{"meta":{"title":"算法小站","subtitle":null,"description":"ICPC和项目开发中常见的算法，主流算法书籍阅读记录，还记录一些有意思的小项目，以及开发日常","author":"Fogsail Chen","url":"https://www.fogsail.net","root":"/"},"pages":[{"title":"关于我","date":"2019-03-06T08:46:36.000Z","updated":"2019-03-06T08:53:55.006Z","comments":true,"path":"about/index.html","permalink":"https://www.fogsail.net/about/index.html","excerpt":"","text":"极客，文艺青年"},{"title":"文章分类","date":"2019-03-06T08:46:36.000Z","updated":"2019-03-06T08:47:43.098Z","comments":true,"path":"categories/index.html","permalink":"https://www.fogsail.net/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-03-06T08:48:34.000Z","updated":"2019-03-06T08:49:10.505Z","comments":true,"path":"tags/index.html","permalink":"https://www.fogsail.net/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"动态规划综合（三）","slug":"20200613","date":"2020-07-09T04:17:20.000Z","updated":"2020-07-11T06:39:41.143Z","comments":true,"path":"2020/07/09/20200613/","link":"","permalink":"https://www.fogsail.net/2020/07/09/20200613/","excerpt":"本文重点讲一下状态压缩类dp和复杂状态下的动态规划问题处理方法","text":"本文重点讲一下状态压缩类dp和复杂状态下的动态规划问题处理方法 状态压缩dp最优配对问题$\\textbf{最优配对问题}$空间里有 $n$ 个点 $P_0, P_1, \\cdots, P_{n-1}$将他们配对成 $\\frac{n}{2}$ 对，使得每个点恰好在一个点对中所有点对中的两点距离之和尽量小 先写出状态转移方程以配对的点作为 $dp$ 的阶段当前已经配对了 $i-1$ 个点，正在配对第 $i$ 个点 可以用状态压缩的方法，当前点在不在集合 $S$ 中，可以用二进制表示 d(i, S) \\xleftarrow{\\min} d(i-1, S-\\{i\\}-\\{j\\})+ |P_iP_j| \\\\ \\ \\\\ d(i, S) = \\min_{j \\in [0, i-1]} \\{|P_iP_j|+d(i-1, S-\\{i\\}-\\{j\\})\\}1234567891011121314void initdp() &#123; memset(d, -inf, sizeof(d)); d[0][0] = 0;&#125;void dp() &#123; for(int i = 0; i &lt; n; i++) &#123; for(int S = 0; S &lt; (1&lt;&lt;n); S++) &#123; for(int j = 0; j &lt; i; j++) if(S &amp; (1&lt;&lt;j)) d[i][S] = max(d[i][S], dist(i, j) + d[i-1][S^(1&lt;&lt;i)^(1&lt;&lt;j)]); &#125; &#125;&#125; 然后可以对代码进行等价变形$i \\textbf{ 是 } S \\textbf{ 中第一个不为 } 0 \\textbf{ 的位}$$\\textbf{也就是说，第一个存在于 } S \\textbf{ 中的元素}$$j \\in [i+1, n)$ 123456789void dp() &#123; for(int S = 0; S &lt; (1&lt;&lt;n); S++) &#123; int i, j; for(i = 0; i &lt; n; i++) if(S &amp; (1&lt;&lt;i)) break; for(j = i + 1; j &lt; n; j++) if(S &amp; (1&lt;&lt;j)) D[S] = max(D[S], dist(i, j) + D[S^(1&lt;&lt;i)^(1&lt;&lt;j)]); &#125;&#125; TSP问题$n$ 个城市，两两有道路相连，给出两个城市 $i, j$ 的道路长度 $L(i, j)$求一条经过每个城市仅一次，最后回到起点的路线，使得经过的道路总长度最短 这个问题仍然可以用一个状态压缩表示集合当前 $dp$ 的阶段是$\\textbf{决策点 } i$已经加入决策的集合，就是已经路过的点构成集合 $S$ d(i, S)=\\min_{j \\in S} \\{d(j, S-\\{i\\}) +dist(i,j)\\} \\textbf{st: for }\\forall i, \\quad d(i, \\{\\})=dist(0, i) \\\\ \\ \\\\ \\textbf{ed: } \\quad d(0, \\{1, 2, \\cdots, n-1\\})图的色数给一个无向图 $G$，把图中的节点染成尽量少的颜色，使得相邻节点的颜色不同 用当前已经在集合 $S$ 中的节点数作为 $dp$ 的阶段$d(S)$ 表示当前节点集 $S$ 最少用了多少种颜色？ $\\exists S’ \\subseteq S, S’$ 是可以染成同一种颜色的节点集根据条件，$S’$ 必然是个独立点集，$S’$ 中的节点没有边相连 color\\{S-S'\\} + color(S') \\\\ \\ \\\\ d(S) = \\min\\{d(S-S') + 1\\}$dp$ 实现的时候可以枚举子集 1234567d[0] = 0;for(int S = 1; S &lt; (1&lt;&lt;n); S++) &#123; d[S] = inf; for(int S0 = S; S0; S0 = (S0-1) &amp; S) &#123; if(no_edges_inside(S0)) d[S] = min(d[S], d[S-S0] + 1); &#125;&#125; 状态压缩dp实践$dp$ 问题很重要的一点是阶段的划分$\\textbf{dp 阶段一般取独立变量，什么意思呢？}$比如有 $n$ 个点，$P_1, P_2, \\cdots, P_n$$\\forall i, j \\in [1, n]，$ 任意两个点 $P_i, P_j$$\\textbf{决策集合互不影响，也就是说}$$\\textbf{决策 } P_i \\textbf{的时候，并不会影响到 } P_j$ 举个例子，上述最优配对问题中，$(P_{i1}, P_{j1})$ 的配对并不会影响 $(P_{i2}, P_{j2})$ 的配对，相对独立 在图的色数问题中，如果用节点作为决策阶段，$P_i$ 的染色情况，会影响到 $P_j$ 染色情况，如果$ (i, j) $ 有边相连二者有约束，不是相对独立的 状态压缩例1UVA10817 $\\text{很显然根据前面的分析，应该用 check 到第 } i \\text{ 个教师作为 dp 阶段}$状态维度1$i \\in [0, m-1], \\text{ 不能辞退}$$i \\in [m, m+n-1] \\text{ 可以辞退，也就是说，存在两种状态，聘用 } \\textbf{or} \\text{ 不聘用}$ 状态维度2$S_1 \\text{ 是 } 0, 1 \\text{ 集合，表示恰好有一个人教的科目的集合}$$S_2 \\text{ 表示至少有 } 2 \\text{ 个人教的科目的集合}$$S_0 \\text{ 表示总状态，可以理解为 没有任何人教的科目的集合}$$st\\rightarrow ed: \\quad S_0: ((1&lt;&lt;n)-1) \\longrightarrow 0$ 状态计算 d(i, S_1, S_2) = \\min\\{d(i+1, S_1, S_2), d(i+1, S_1', S_2')+C[i]\\} \\\\ \\ \\\\ (S_1, S_2) \\xrightarrow{\\textbf{check } ith} (S_1',S_2')注意，只有在 $i \\geqslant m$ 时才出现第二项如果把第 $i$ 个人能够教的科目状态记为 $st[i]$$\\textbf{i) } \\text{从没人教的科目 } S_0 \\text{ 集合中，选出第 } i \\text{ 个人能够教的科目}$$\\quad v1 \\leftarrow S_0 \\textbf{ and } st[i]$$\\textbf{ii) } \\text{已经有 } 1 \\text{ 个人教的科目集合中，第 }i \\text{ 个人还可以教的科目集合 }$$\\quad v2 \\leftarrow S_1 \\textbf{ and } st[i] \\quad \\text{ 为计算 } S_2 \\text{ 做准备}$ $S_0’ = S_0 \\oplus v1$$S_1’ = (S_1 \\oplus v2) \\textbf{ or } v1$$S_2’ = S_2 \\textbf{ or } v2$ dp的起始状态这里是从 $n\\rightarrow 1$ 递推表示安排了几个老师？$start:\\quad dp(0, (1&lt;&lt;s)-1, 0, 0)$$end: \\quad s_2 = (1&lt;&lt;s)-1, dp() = 0$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const int maxs = 8;const int maxn = 100 + 20 + 5;const int inf = 0x3f3f3f3f;int m, n, s;int st[maxn], c[maxn];int d[maxn][(1&lt;&lt;maxs)+1][(1&lt;&lt;maxs)+1];void initdp() &#123; memset(d, -1, sizeof(d));&#125;int dp(int i, int s0, int s1, int s2) &#123; if(i == m + n) return s2 == (1&lt;&lt;s)-1 ? 0 : inf; int&amp; ans = d[i][s1][s2]; if(ans &gt;= 0) return ans &gt;= inf ? inf : ans; ans = inf; if(i &gt;= m) ans = dp(i+1, s0, s1, s2); int v1 = s0 &amp; st[i], v2 = s1 &amp; st[i]; s0 ^= v1; s1 = (s1 ^ v2) | v1; s2 |= v2; ans = min(ans, dp(i+1, s0, s1, s2) + c[i]); return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string line; while (getline(cin, line)) &#123; stringstream ss(line); ss &gt;&gt; s &gt;&gt; m &gt;&gt; n; if(s == 0) break; _for(i, 0, n + m) &#123; getline(cin, line); stringstream ss(line); ss &gt;&gt; c[i]; int x; st[i] = 0; while (ss &gt;&gt; x) &#123; x--; st[i] |= (1&lt;&lt;x); &#125; &#125; // input finished // dp initdp(); int ans = dp(0, (1&lt;&lt;s)-1, 0, 0); printf(\"%d\\n\", ans); &#125;&#125; 状态压缩例2UVALive4643 假设心里想的物品是 $\\textbf{Item}$可以发现，对于特征 $\\forall k \\in [1, m]$ 是相对独立的可以作为 $dp$ 的阶段 每一个特征都有2种状态，表示存在与否，很容易想到用状态压缩 $\\textbf{algorithm 状态表示和状态转移}$假设当前问询特征 $k$，特征 $[1, \\cdots, k-1]$ 构成状态集合 $S$其中集合 $S$ 中$\\text{ Item }$已经确定（已经拥有）的特征集合是 $q$$q\\subseteq S,\\quad d(S, q)$ 表示此时的询问次数 $k$ 这个特征，有两种状态，$\\text{Item }$拥有特征 $\\textbf{or}$ 不拥有特征 d(S,q) = \\max [d(S+\\{k\\}, q+\\{k\\}), d(S+\\{k\\},q)] + 1 \\\\ \\ \\\\ ans = \\min (ans, d(S, q))$\\textbf{algorithm 状态计算，dp边界的确定}$上面的状态转移方程，什么时候可以计算结束了呢？ $\\text{对于某个状态 } (S, q), 什么时候可以终止递归了呢？$ $cnt(S, q) = 1\\text{ 这个状态只包含一个物体}$$cnt(S, q) = 0\\text{ 这个状态不包含任何物体}$这两种状态都不需要再继续做任何问询，$\\textbf{return } 0$ $\\textbf{if } \\text{cnt}(S’, q’) \\leqslant 1$$\\quad d(S’, q’) \\textbf{ return }0$$\\quad d(S, q) = d(S’, q’) + 1$$\\quad \\text{此时只需要问询第 } k \\text{ 个特征 } 1 \\text{ 次即可知道答案}$ $\\textbf{if } \\text{cnt}(S’, q’) = 2$$\\quad d(S’, q’) \\textbf{ return }1$$\\quad d(S, q) = d(S’, q’) + 1$$\\quad \\text{集合中有 2 个元素的话，需要问询 2 次}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int maxs = 11;const int maxn = 128 + 10;const int inf = 0x3f3f3f3f;int n, m;string obj[maxn];int cnt[(1&lt;&lt;maxs)+1][(1&lt;&lt;maxs)+1];void _init() &#123; memset(cnt, 0, sizeof(cnt));&#125;void getdata() &#123; _for(i, 0, n) &#123; int features = 0; _for(k, 0, obj[i].length()) &#123; if(obj[i][k] == '1') features |= (1&lt;&lt;k); &#125; for(int S = 0; S &lt; (1&lt;&lt;m); S++) cnt[S][S &amp; features]++; &#125;&#125;int d[(1&lt;&lt;maxs)+1][(1&lt;&lt;maxs)+1];void initdp() &#123; memset(d, -1, sizeof(d));&#125;int dp(int S, int q) &#123; if(cnt[S][q] &lt;= 1) return 0; if(cnt[S][q] == 2) return 1; int&amp; ans = d[S][q]; if(ans != -1) return ans; ans = m; _for(k, 0, m) &#123; if(S &amp; (1&lt;&lt;k)) continue; int S2 = S | (1&lt;&lt;k), q2 = q | (1&lt;&lt;k); if(cnt[S2][q] &gt;= 1 &amp;&amp; cnt[S2][q2] &gt;= 1) &#123; int val = max(dp(S2, q2), dp(S2, q)) + 1; ans = min(ans, val); &#125; &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;m, &amp;n) == 2 &amp;&amp; n) &#123; _init(); _for(i, 0, n) cin &gt;&gt; obj[i]; // get data getdata(); // dp initdp(); int ans = dp(0, 0); printf(\"%d\\n\", ans); &#125;&#125; 状态压缩例3","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"https://www.fogsail.net/tags/dp/"}]},{"title":"动态规划综合（二）","slug":"20200611","date":"2020-07-04T05:33:34.000Z","updated":"2020-07-09T04:17:02.905Z","comments":true,"path":"2020/07/04/20200611/","link":"","permalink":"https://www.fogsail.net/2020/07/04/20200611/","excerpt":"这篇博文写了一些动态规划的实践问题$\\textbf{树形dp，复杂状态的dp}$","text":"这篇博文写了一些动态规划的实践问题$\\textbf{树形dp，复杂状态的dp}$ 树形dp问题dfs解决树形dpUVALive4472 dp(u) = \\sum_i^{num}dp(v_i) \\\\ num = \\frac{size_u\\cdot T-1}{100} + 1 \\\\ \\ \\\\ ans = dp(0)123456789101112131415161718192021222324252627282930313233343536373839404142const int maxn = 1e5 + 10;const int inf = 0x3f3f3f3f;int N, T;vector&lt;int&gt; son[maxn];int dp(int u) &#123; if(son[u].empty()) return 1; vector&lt;int&gt; vec; for(auto v : son[u]) &#123; vec.push_back(dp(v)); &#125; sort(vec.begin(), vec.end()); int num = (son[u].size() * T - 1) / 100 + 1; int ans = 0; for(int i = 0; i &lt; num; i++) ans += vec[i]; return ans;&#125;void init() &#123; _for(i, 0, maxn) son[i].clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;N, &amp;T) == 2 &amp;&amp; N) &#123; init(); _rep(i, 1, N) &#123; int x; scanf(\"%d\", &amp;x); son[x].push_back(i); &#125; // then dp int ans = dp(0); printf(\"%d\\n\", ans); &#125;&#125; 树的最大独立集问题HDU2412 $\\textbf{本例中加判唯一性}$ \\begin{cases} d(u, 1) = \\sum_{v \\in son(u)} d(v, 0) \\\\ f(u, 1) = \\{\\bigcap_{v \\in son(u)} f(v, 0)==1\\} \\end{cases} \\begin{cases} d(u, 0) = \\max_{v \\in son(u)} \\{d(v, 1), d(v, 0)\\} \\\\ f(u, 0) = 0 && \\forall v\\in son(u), d(v, 0)=d(v,1) \\\\ f(u, 0)= 0 && \\forall v \\in son(u), k \\in \\{0,1\\}, d(v, k)>d(v, k\\oplus 1), f(v, k)=0 \\end{cases}$\\textbf{st}: d(maxn, 2) \\leftarrow 0, f(maxn, 2) \\leftarrow 0$$\\textbf{ed}: \\max(dp(0, 1), dp(0, 0))$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const int maxn = 200 + 10;map&lt;string, int&gt; mp;int tot = 0;int n;vector&lt;int&gt; son[maxn];int ID(const string&amp; str) &#123; if(!mp.count(str)) mp[str] = tot++; return mp[str];&#125;int d[maxn][2];int f[maxn][2];void initdp() &#123; Set(d, 0); Set(f, 0);&#125;int dp(int u, int k) &#123; d[u][k] = k; f[u][k] = 1; for(auto v : son[u]) &#123; if(k == 1) &#123; d[u][k] += dp(v, 0); f[u][k] &amp;= f[v][0]; &#125; else &#123; d[u][k] += max(dp(v, 0), dp(v, 1)); if(d[v][0] == d[v][1]) f[u][k] = 0; else if(d[v][0] &gt; d[v][1] &amp;&amp; f[v][0] == 0) f[u][k] = 0; else if(d[v][1] &gt; d[v][0] &amp;&amp; f[v][1] == 0) f[u][k] = 0; &#125; &#125; return d[u][k];&#125;void init() &#123; mp.clear(); tot = 0; _for(i, 0, maxn) son[i].clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string s, s2; while (cin &gt;&gt; n &gt;&gt; s) &#123; init(); ID(s); _for(i, 1, n) &#123; cin &gt;&gt; s2 &gt;&gt; s; son[ID(s)].push_back(ID(s2)); &#125; // then dp initdp(); int ans = max(dp(0, 1), dp(0, 0)); printf(\"%d \", ans); bool flag = true; if(d[0][0] == d[0][1]) flag = false; else if(d[0][1] &gt; d[0][0] &amp;&amp; f[0][1] == 0) flag = false; else if(d[0][0] &gt; d[0][1] &amp;&amp; f[0][0] == 0) flag = false; flag == 0 ? printf(\"No\\n\") : printf(\"Yes\\n\"); &#125;&#125; 树形dp节点状态LA3685 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const int maxn = 1e5 + 10;const int inf = 0x3f3f3f3f;int n;vector&lt;int&gt; G[maxn];inline void add(int u, int v) &#123; G[u].push_back(v);&#125;// == dp ==int d[maxn][3];void initdp() &#123; memset(d, -1, sizeof(d)); vector&lt;int&gt; ed; _rep(i, 1, n) if(G[i].size() == 0) ed.push_back(i); for(auto x : ed) &#123; d[x][0] = 1; d[x][1] = 0; d[x][2] = inf; &#125;&#125;int dp(int u, int pa, int k) &#123; if(d[u][k] != -1) &#123; return d[u][k]; &#125; d[u][0] = 1; d[u][1] = 0; for(auto v : G[u]) &#123; if(v == pa) continue; d[u][0] += min(dp(v, u, 0), dp(v, u, 1)); d[u][1] += dp(v, u, 2); if (d[u][0] &gt; inf) d[u][0] = inf; if (d[u][1] &gt; inf) d[u][1] = inf; &#125; d[u][2] = inf; for(auto v : G[u]) &#123; if(v == pa) continue; d[u][2] = min(d[u][2], d[u][1] - dp(v, u, 2) + dp(v, u, 0)); &#125; return d[u][k];&#125;// == dp finished ==void init() &#123; _for(i, 0, maxn) G[i].clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) == 1) &#123; init(); // get data _for(i, 0, n - 1) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); add(u, v); add(v, u); &#125; // get data finished initdp(); int ans = min(dp(1, 0, 0), dp(1, 0, 2)); printf(\"%d\\n\", ans); scanf(\"%d\", &amp;n); &#125;&#125; 算法设计策略中位数和差分序列UVA11300 $\\textbf{algorithm}$$\\text{本例子的问题是，一个序列，通过平均分配}$$\\text{使得这个序列最后的值都相等，问 } \\sum(\\Delta) \\text{ 最小值是多少}$ $M = tot / n \\text{ 表示最后的值}$$\\text{原序列是 } A_{i}, \\text{ 无论如何变化，最后的方案都可以看成是}$$\\text{相邻两项 “转手”}$ $A_1 \\leftrightarrow A_2, \\quad A_1 \\text{ 拿出去 } x_1 \\text{ 个元素，从 } A_2 \\text{ 处获得 } x_2 \\text{ 个元素}$ $x_1 = C_0 = 0$$A_1-x_1+x_2 = M \\quad\\Rightarrow x_2-x_1= M-A_1 = C_1$$A_2-x_2+x_3 = M \\quad\\Rightarrow x_3-x_2= M-A_2 = C_2$$\\cdots \\cdots$$x_i - x_{i-1} = M-A_{i-1} = C_{i-1}$ $C_i \\text{ 构成了差分序列，根据差分序列的前缀和等于原序列}$ $x_i= \\sum_{j = 1}^{i-1}C_j$ $\\text{可以根据 }C \\text{ 的前缀和直接得到 }$$[x_1, x_2, \\cdots, x_n]$ $\\textbf{这样问题就转换为}$$\\forall i, j, \\quad i \\neq j, \\quad \\sum|x_i-x_j| \\text{ 最小}$$这个问题可以用中位数模型，排序后，mid=x[n/2]$$ans = \\sum_{i = 1}^{n}|x_i - mid|$ 12345678910111213141516171819202122232425262728293031const int maxn = 1e6 + 10;ll C[maxn], M = 0;ll A[maxn];int n;void init() &#123; memset(C, 0, sizeof(C));&#125;int main() &#123; //freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) == 1) &#123; init(); ll tot = 0; _rep(i, 1, n) &#123; scanf(\"%lld\", &amp;A[i]); tot += A[i]; &#125; M = tot / n; _for(i, 1, n) C[i] = C[i - 1] + 1ll * M - A[i]; sort(C, C + n); ll mid = C[n&gt;&gt;1]; ll ans = 0; _for(i, 0, n) ans += abs(C[i] - mid); printf(\"%lld\\n\", ans); &#125;&#125; 精度运算的一些技巧UVA1388 p_i = \\frac{i}{n}\\cdot 1 = \\frac{i(n+m)}{n(n+m)} \\\\ \\ \\\\ q_i = \\frac{i}{n+m}\\cdot 1 = \\frac{in}{n(n+m)} \\\\ \\ \\\\ \\Delta = |p_i-q_i| = \\frac{|\\frac{i}{n}\\cdot (n+m) - i\\cdot\\frac{n}{n}|}{(n+m)} |\\frac{i}{n}\\cdot (n+m)-i \\cdot \\frac{n}{n}| \\text{ 求的是}\\\\ \\ \\\\ \\frac{i}{n} \\cdot (m) \\text{ 和距离它最近的整数的距离}$\\text{归一化之后，floor}(x+0.5) \\text{ 表示 x 四舍五入之后的值}$$ans = |x - floor(x+0.5)|$ 1234567891011121314const int L = 1e4;int n, m;int main() &#123; //freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;n, &amp;m) == 2) &#123; double ans = 0.0; _for(i, 0, n) &#123; double x = (double)i / n * (m); ans += fabs(x - floor(x+0.5)) / (n + m); &#125; printf(\"%.4lf\\n\", ans * L); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"https://www.fogsail.net/tags/dp/"}]},{"title":"分治算法综合（三）","slug":"20200610","date":"2020-07-01T01:03:36.000Z","updated":"2020-07-04T01:46:29.363Z","comments":true,"path":"2020/07/01/20200610/","link":"","permalink":"https://www.fogsail.net/2020/07/01/20200610/","excerpt":"$\\text{这篇博文概括一下之前的} \\textbf{点分治}$$\\text{此外阐述了树分治中的}\\textbf{点分治，边分治}$$\\textbf{以及动态树分治}$ $\\textbf{CDQ分治}\\text{也做了概括}$","text":"$\\text{这篇博文概括一下之前的} \\textbf{点分治}$$\\text{此外阐述了树分治中的}\\textbf{点分治，边分治}$$\\textbf{以及动态树分治}$ $\\textbf{CDQ分治}\\text{也做了概括}$ 点分治总结$\\textbf{algorithm1}$$\\textbf{i) } \\text{找到树的重心 } root \\text{ 作为初始根节点}$$\\quad \\textbf{solve}(x\\leftarrow root, ans)$ $\\quad \\textbf{特别说明，这里只需要在 solve}(x, ans) \\text{ 中使用 vis}[\\cdots] \\text{ 标记防止栈溢出} $$\\quad \\text{为了防止其余操作在递归时候栈溢出，}\\textbf{避免出现自环}$$\\quad \\text{将父节点 } pa \\text{也作为参数传递，进入递归}$$\\quad \\textbf{getDep}(x, pa), \\textbf{getRoot}(x, pa)$$\\quad \\textbf{if } (y \\in son(x))=pa \\textbf{ or } vis[y], \\textbf{break}$ $\\textbf{ii) } cal(x) \\textbf{ 统计点对的个数}， ans = \\sum cal(x)$$\\quad \\quad \\text{1. } \\text{在 } cal(x) \\text{ 的时候， 得到每个点的 } dep[\\cdots] \\rightarrow vec[\\cdots ]$$\\quad \\quad \\quad \\text{并且将其缓存起来， 这一步可以通过执行 } getDep() \\text{ 完成}$$\\quad \\quad \\text{2. } \\text{根据 } vec[\\cdots], \\text{做相关的统计}$ $\\textbf{iii) 点分治，删除根节点， 将子树 } y \\textbf{ 看成无根树，递归执行}$$\\quad \\quad \\textbf{for } \\forall y \\in son(x)$$\\quad \\quad \\quad \\text{1. 减掉 } y \\text{ 作为孩子节点的统计结果}$$\\quad \\quad \\quad \\quad \\text{此时 } y \\text{ 要作为无根树来统计， 要让 }ans -=cal(y)$$\\quad \\quad \\quad \\quad \\text{而 }y \\text{ 作为孩子节点， 记得 } dep_y = dep_x + w(x, y)$$\\quad \\quad \\quad \\quad \\text{之后再 }ans -= cal(y)$ $\\quad \\quad \\quad \\text{2. 重新求子树 } y \\text{ 作为无根树时候的树的重心}$$\\quad \\quad \\quad \\quad sn= size_y, \\textbf{ 总节点数不再是 n 个了}$ $\\textbf{algorithm2}$$\\textbf{区别就在于 cal}() \\textbf{ 用树状数组统计}$$\\textbf{cal}(x, ans), x\\leftarrow root$ $\\textbf{i) } \\text{将 }dep_x \\rightarrow \\text{fwick}[\\cdots]$$\\quad \\text{fwick}.add(dep_x, 1)$ $\\textbf{ii) for } \\forall y \\in son(x)$$\\quad \\quad \\text{对每一个子树 }y \\text{ 建立一个 vec}[\\cdots], \\textbf{存储子树节点的 }dep[\\cdots ]$$\\quad \\quad \\textbf{getDep}(y, x) \\rightarrow \\text{vec}[\\cdots]$$\\quad \\quad \\textbf{此时不要将 vec}[\\cdots] \\textbf{ 的元素加入树状数组}$$\\quad \\quad \\textbf{这个保证了 }K-vec[\\cdots] \\textbf{ 一定是属于其他子树的点 or 根节点}$$\\quad \\quad ans = \\sum \\text{fwick}.ask(K-vec[\\cdots])$ $\\quad \\quad \\textbf{更新完 }ans \\text{ 之后再将 vec}[\\cdots] \\text{ 放入树状数组中}$$\\quad \\quad \\text{fwick}.add(vec[\\cdots], 1)$ $\\quad \\quad \\text{此外，维护一个队列 que，统计完 } ans \\text{ 之后}$$\\quad \\quad \\text{对树状数组进行还原}$ Luogu2634 这里也是做一个树上统计$cnt = [0, 1, 2 \\mod (3)]$$\\text{统计路径和 sum, } ++cnt[sum \\mod 3]$ cal() = C_{cnt[1]}^1 \\cdot C_{cnt[2]}^1 \\cdot2 + C_{cnt[0]}^1 \\cdot C_{cnt[0]} ^1$\\textbf{套用 algorithm1 的模版，只不过多一步 } cal()$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141const int maxn = 1e5 + 10;const int inf = 0x3f3f3f3f;const int mod = 3;int n;inline ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;class Edge &#123;public: int to, w; Edge* next; Edge() &#123;&#125; Edge(int to, int w) : to(to), w(w) &#123; next = NULL; &#125;&#125; edges[maxn &lt;&lt; 1], *head[maxn];int M = 0;void initG() &#123; M = 0; memset(head, 0, sizeof(head));&#125;void add(int u, int v, int w) &#123; edges[++M] = Edge(v, w); edges[M].next = head[u]; head[u] = &amp;edges[M];&#125;// == gravity ==int root = 0;int sz[maxn];int vis[maxn];int sn = n;void getRoot(int x, int pa, int&amp; res) &#123; sz[x] = 1; int maxpart = 0; for(const Edge* e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; if(vis[y] || y == pa) continue; getRoot(y, x, res); sz[x] += sz[y]; maxpart = max(maxpart, sz[y]); &#125; maxpart = max(maxpart, sn - sz[x]); if(maxpart &lt; res) &#123; res = maxpart; root = x; &#125;&#125;// == gravity finished ==ll cnt[mod + 3];void dfs(int x, int pa, int dep) &#123; ++cnt[dep % mod]; for(const Edge* e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;w; if(vis[y] || y == pa) continue; int dep2 = (dep + w) % mod; dfs(y, x, dep2); &#125;&#125;inline ll cal(int x, int dep) &#123; memset(cnt, 0, sizeof(cnt)); dfs(x, 0, dep); ll ans = 1ll * cnt[0] * cnt[0] + 1ll * 2 * cnt[1] * cnt[2]; return ans;&#125;// == work ==void work(int x, ll&amp; ans) &#123; vis[x] = 1; ans += cal(x, 0); for(const Edge* e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;w; if(vis[y]) continue; ans -= cal(y, w); int res = inf; sn = sz[y]; root = 0; getRoot(y, 0, res); work(root, ans); &#125;&#125;// == work finished ==void init() &#123; memset(sz, 0, sizeof(sz)); memset(vis, 0, sizeof(vis)); sn = n; memset(cnt, 0, sizeof(cnt));&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;n); init(); initG(); _for(i, 0, n - 1) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); add(x, y, z % mod); add(y, x, z % mod); &#125; // then solve int res = inf; getRoot(1, 0, res); ll ans = 0; work(root, ans); ll p = n * n; ll g = gcd(ans, p); ans /= g, p /= g; printf(\"%lld/%lld\\n\", ans, p);&#125; 点分治计数问题计数问题一般使用 $\\textbf{algorithm2}$ Luogu3806 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161const int maxn = 1e5 + 10;const int Maxn = 1e7 + 3;const int inf = 0x3f3f3f3f;int n, m;int ans[maxn];int qry[maxn];class Edge &#123;public: int to, w; Edge* next; Edge() &#123;&#125; Edge(int to, int w) : to(to), w(w) &#123;&#125;&#125; edges[maxn &lt;&lt; 1], *head[maxn];int M = 0;int K;void initG() &#123; M = 0; memset(head, 0, sizeof(head));&#125;void add(int u, int v, int w) &#123; edges[++M] = Edge(v, w); edges[M].next = head[u]; head[u] = &amp;edges[M];&#125;int root = 0;int sz[maxn];int vis[maxn];int sn = n;void getRoot(int x, int pa, int&amp; res) &#123; sz[x] = 1; int maxpart = 0; for(const Edge* e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;w; if(vis[y] || y == pa) continue; getRoot(y, x, res); sz[x] += sz[y]; maxpart = max(maxpart, sz[y]); &#125; maxpart = max(maxpart, sn - sz[x]); if(maxpart &lt; res) &#123; res = maxpart; root = x; &#125;&#125;int dep[maxn];int C[Maxn &lt;&lt; 1];void dfs(int x, int pa, vector&lt;int&gt;&amp; vec) &#123; vec.push_back(dep[x]); for(const Edge* e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;w; if(vis[y] || y == pa) continue; dep[y] = dep[x] + w; dfs(y, x, vec); &#125;&#125;queue&lt;int&gt; buf;inline void cal(int x) &#123; assert(dep[x] == 0); C[dep[x]] = 1; for(const Edge* e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;w; if(vis[y]) continue; dep[y] = dep[x] + w; vector&lt;int&gt; vec; dfs(y, x, vec); for(auto v : vec) _rep(k, 1, m) &#123; //debug(v); if(qry[k] &gt;= v) ans[k] |= C[qry[k] - v]; &#125; for(auto v : vec) &#123; buf.push(v); C[v] = 1; &#125; &#125; while (buf.size()) &#123; int x = buf.front(); buf.pop(); C[x] = 0; &#125; C[dep[x]] = 0;&#125;void solve(int x) &#123; vis[x] = 1; dep[x] = 0; cal(x); for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;w; if(vis[y]) continue; sn = sz[y]; root = 0; int res = inf; getRoot(y, 0, res); solve(root); &#125;&#125;void init() &#123; memset(sz, 0, sizeof(sz)); memset(vis, 0, sizeof(vis)); sn = n; memset(dep, 0, sizeof(dep)); memset(ans, 0, sizeof(ans)); memset(C, 0, sizeof(C));&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;m); init(); initG(); _for(i, 1, n) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; _rep(k, 1, m) scanf(\"%d\", &amp;qry[k]); // then solve int res = inf; getRoot(1, 0, res); solve(root); _rep(k, 1, m) &#123; if(ans[k]) printf(\"AYE\\n\"); else printf(\"NAY\\n\"); &#125;&#125; 点分树和计数问题Luogu2664 $\\textbf{注意，第二次 calculate2() 之前的一大堆操作}$$sum -= size_y, num[color_x]-=size_y$$\\textbf{是为了去重}$$\\textbf{否则的话，在第二次 calculate2() 的时候}$$ans[x] += (\\sum)+tot2\\cdot (sz[x]-sz[y])$$\\textbf{不去重的话，会导致 } (x\\rightarrow y) \\textbf{ 及其子树重复计数统计}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200// ============================================================== //const int maxn = 1e5 + 10;const int inf = 0x3f3f3f3f;int n;int M = 0;int color[maxn];class Edge &#123;public: int to, w; Edge *next; Edge() &#123;&#125; Edge(int to, int w) : to(to), w(w) &#123; next = NULL; &#125;&#125; edges[maxn &lt;&lt; 1], *head[maxn];void initG() &#123; M = 0; memset(head, 0, sizeof(head));&#125;void add(int u, int v, int w) &#123; edges[++M] = Edge(v, w); edges[M].next = head[u]; head[u] = &amp;edges[M];&#125;int sn = n;int sz[maxn];int root = 0;int vis[maxn];ll ans[maxn];void getRoot(int x, int pa, int &amp;res) &#123; sz[x] = 1; int maxpart = 0; for(const Edge* e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;w; if(vis[y] || y == pa) continue; getRoot(y, x, res); sz[x] += sz[y]; maxpart = max(maxpart, sz[y]); &#125; maxpart = max(maxpart, sn - sz[x]); if(maxpart &lt; res) &#123; res = maxpart; root = x; &#125;&#125;ll num[maxn], cnt[maxn];void clear(int x, int pa) &#123; cnt[color[x]] = num[color[x]] = 0; sz[x] = 1; for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;w; if(vis[y] || y == pa) continue; clear(y, x); sz[x] += sz[y]; &#125;&#125;void calculate1(int x, int pa, ll&amp; sum) &#123; if(++cnt[color[x]] == 1) &#123; sum += sz[x]; num[color[x]] += sz[x]; &#125; for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;w; if(y == pa || vis[y]) continue; calculate1(y, x, sum); &#125; --cnt[color[x]];&#125;void change(int x, int pa, int sgn, ll&amp; sum) &#123; if(++cnt[color[x]] == 1) &#123; sum += sgn * sz[x]; num[color[x]] += sgn * sz[x]; &#125; for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;w; if(y == pa || vis[y]) continue; change(y, x, sgn, sum); &#125; --cnt[color[x]];&#125;void calculate2(int x, int pa, int cnt2, int other, ll&amp; sum) &#123; if(++cnt[color[x]] == 1) &#123; cnt2++; sum -= num[color[x]]; &#125; ans[x] += sum + 1ll * other * cnt2; for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;w; if(vis[y] || y == pa) continue; calculate2(y, x, cnt2, other, sum); &#125; if(--cnt[color[x]] == 0) &#123; cnt2--; sum += num[color[x]]; &#125;&#125;void work(int x, ll&amp; sum) &#123; vis[x] = 1; sum = 0; clear(x, -1); calculate1(x, -1, sum); ans[x] += 1ll * sum; for(const Edge* e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;w; if(vis[y]) continue; ++cnt[color[x]]; change(y, x, -1, sum); sum -= sz[y]; num[color[x]] -= sz[y]; calculate2(y, x, 0, sz[x] - sz[y], sum); change(y, x, 1, sum); sum += sz[y]; num[color[x]] += sz[y]; --cnt[color[x]]; &#125; for(const Edge* e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; if(vis[y]) continue; root = -1; sn = sz[y]; int res = inf; getRoot(y, -1, res); work(root, sum); &#125;&#125;void init() &#123; sn = n; memset(sz, 0, sizeof(sz)); memset(vis, 0, sizeof(vis)); memset(ans, 0, sizeof(ans)); memset(num, 0, sizeof(num)); memset(cnt, 0, sizeof(cnt));&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;n); initG(); init(); _rep(i, 1, n) scanf(\"%d\", &amp;color[i]); _for(i, 1, n) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y, 1); add(y, x, 1); &#125; // input data finished root = -1; ll sum = 0; int res = inf; getRoot(1, -1, res); work(root, sum); _rep(i, 1, n) printf(\"%lld\\n\", ans[i]);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"data_structure","slug":"data-structure","permalink":"https://www.fogsail.net/tags/data-structure/"}]},{"title":"分治算法综合（二）","slug":"20200602","date":"2020-06-18T20:21:00.000Z","updated":"2020-07-01T00:58:31.318Z","comments":true,"path":"2020/06/19/20200602/","link":"","permalink":"https://www.fogsail.net/2020/06/19/20200602/","excerpt":"这篇博文重点写了 $\\textbf{CDQ分治，整体分治}$这是针对离线问题的很重要的处理方法","text":"这篇博文重点写了 $\\textbf{CDQ分治，整体分治}$这是针对离线问题的很重要的处理方法 CDQ分治 Acwing254 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#pragma GCC optimize(2)const int maxn = 1e6 + 5;const int inf = 0x3f3f3f3f;int n, m, maxy = -inf;int ans[maxn];class Node &#123;public: int x, y; int tp; Node() &#123;&#125; Node(int x, int y, int tp) : x(x), y(y), tp(tp) &#123;&#125; bool operator&lt; (const Node&amp; rhs) const &#123; return x &lt; rhs.x || (x == rhs.x &amp;&amp; y &lt; rhs.y); &#125;&#125; a[maxn], buf[maxn];// == fenwick definition ==class Fwick &#123;public: int C[maxn]; int n; void _init(int n) &#123; Set(C, -inf); this-&gt;n = n; &#125; void add(int y, int val) &#123; for(; y &lt; n; y += lowbit(y)) C[y] = max(C[y], val); &#125; int ask(int y) &#123; int ret = -inf; for(; y &gt; 0; y -= lowbit(y)) ret = max(ret, C[y]); return ret; &#125; void reset(int y) &#123; for(; y &lt; n; y += lowbit(y)) C[y] = -inf; &#125;&#125; fwick;// == fenwick finished ==// == CDQ ==inline void work(int st, int ed, int w, int dx, int dy) &#123; for(int i = st; i != ed; i += w) &#123; int num = dx * buf[i].x + dy * buf[i].y; int y = dy == -1 ? maxy - buf[i].y : buf[i].y; if(a[buf[i].tp].tp == 1) fwick.add(y, num); else ans[buf[i].tp] = min(ans[buf[i].tp], abs(num - fwick.ask(y))); //debug(ans[buf[i].tp]); &#125; for(int i = st; i != ed; i += w) &#123; int y = dy == -1 ? maxy - buf[i].y : buf[i].y; if(a[buf[i].tp].tp == 1) fwick.reset(y); &#125;&#125;void CDQ(int l, int r) &#123; int mid = (l + r) &gt;&gt; 1; if(l &lt; mid) CDQ(l, mid); if(mid + 1 &lt; r) CDQ(mid + 1, r); int tot = 0; _rep(i, l, r) &#123; if((i &lt;= mid &amp;&amp; a[i].tp == 1) || (i &gt; mid &amp;&amp; a[i].tp == 2)) &#123; buf[++tot] = a[i]; buf[tot].tp = i; &#125; &#125; sort(buf + 1, buf + 1 + tot); work(1, tot + 1, 1, 1, 1); work(1, tot + 1, 1, 1, -1); work(tot, 0, -1, -1, 1); work(tot, 0, -1, -1, -1);&#125;// == CDQ finished ==void init() &#123; Set(ans, inf); fwick._init(maxy);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m; // get data _rep(i, 1, n) &#123; scanf(\"%d%d\", &amp;a[i].x, &amp;a[i].y); a[i].tp = 1; maxy = max(maxy, a[i].y); &#125; _rep(i, 1, m) &#123; scanf(\"%d%d%d\", &amp;a[n+i].tp, &amp;a[n+i].x, &amp;a[n+i].y); maxy = max(maxy, a[n+i].y); &#125; maxy++; //debug(maxy); // get data finished init(); CDQ(1, n + m); _rep(i, 1, n + m) if(a[i].tp == 2) printf(\"%d\\n\", ans[i]);&#125; 值域的整体二分 POJ2104 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127const int maxn = 1e5 + 10;const int inf = 1e9;int N, M;int n = 0, tot = 0;int ans[maxn];// == discrete ==int a[maxn], b[maxn];void discrete() &#123; sort(b + 1, b + 1 + N); n = unique(b + 1, b + 1 + N) - b - 1; _rep(i, 1, N) a[i] = lower_bound(b + 1, b + 1 + n, a[i]) - b;&#125;// original: b[a[i]], a in [1, n]// == discrete finished ==class Qry &#123;public: int x, y, z; int op; Qry() &#123;&#125; Qry(int x, int y, int z) : x(x), y(y), z(z) &#123;&#125; Qry(int x, int y) : x(x), y(y) &#123;&#125;&#125; qry[maxn &lt;&lt; 1], lqry[maxn &lt;&lt; 1], rqry[maxn &lt;&lt; 1];class Fwick &#123;public: int C[maxn]; int n; void _init(int n) &#123; this-&gt;n = n; memset(C, 0, sizeof(C)); &#125; void add(int x, int y) &#123; for(; x &lt;= n; x += lowbit(x)) C[x] += y; &#125; int ask(int x) &#123; int ret = 0; for(; x; x -= lowbit(x)) ret += C[x]; return ret; &#125;&#125; fwick;void solve(int lval, int rval, int st, int ed) &#123; if(st &gt; ed) return; if(lval == rval) &#123; _rep(i, st, ed) &#123; if(qry[i].op &gt; 0) ans[qry[i].op] = b[lval]; &#125; return; &#125; int mid = (lval + rval) &gt;&gt; 1; int lt = 0, rt = 0; _rep(i, st, ed) &#123; if(qry[i].op == 0) &#123; // x -&gt; y if(qry[i].y &lt;= mid) &#123; fwick.add(qry[i].x, 1); lqry[++lt] = qry[i]; &#125; else rqry[++rt] = qry[i]; &#125; else &#123; int cnt = fwick.ask(qry[i].y) - fwick.ask(qry[i].x - 1); if(cnt &gt;= qry[i].z) lqry[++lt] = qry[i]; else &#123; qry[i].z -= cnt; rqry[++rt] = qry[i]; &#125; &#125; &#125; _rep(i, st, ed) &#123; if(qry[i].op == 0 &amp;&amp; qry[i].y &lt;= mid) fwick.add(qry[i].x, -1); &#125; _rep(i, 1, lt) qry[st + i - 1] = lqry[i]; _rep(i, 1, rt) qry[st + lt + i - 1] = rqry[i]; solve(lval, mid, st, st + lt - 1); solve(mid + 1, rval, st + lt, ed);&#125;void init() &#123; n = 0; tot = 0; memset(ans, 0, sizeof(ans));&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; N &gt;&gt; M; init(); // == get data == _rep(i, 1, N) &#123; scanf(\"%d\", &amp;a[i]); b[i] = a[i]; &#125; discrete(); // == get data finished == // == get query == _rep(i, 1, N) &#123; qry[++tot] = Qry(i, a[i]); qry[tot].op = 0; &#125; _rep(i, 1, M) &#123; int l, r, k; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); qry[++tot] = Qry(l, r, k); qry[tot].op = i; &#125; // == query finished == // then solve the problem fwick._init(n + 1); solve(1, n, 1, tot); _rep(i, 1, M) printf(\"%d\\n\", ans[i]);&#125; 带修改的整体二分$\\textbf{algorithm}$$\\textbf{把 } A_x \\text{ 变成 }y$ \\Longrightarrow \\begin{cases} \\text{在 } x \\text{ 位置去掉一个值为 }A_x \\text{ 的数} && op = -1\\\\ \\text{在 } x \\text{ 位置上增加一个值为 } y \\text{ 的数} && op = 0 \\end{cases}$\\text{查询操作 } op = i \\in [1, M]$ $\\textbf{for } \\forall qry_i \\not\\in [\\textbf{query cmd}]$$\\quad \\quad add(qry.x, qry.z)$ \\begin{cases} qry.z=-1 && \\textbf{if } op=-1 \\\\ qry.z=1 && \\textbf{if } op = 0 \\end{cases}其他操作和整体二分大同小异值得注意的是，整体二分中$A[i] \\Rightarrow \\text{fwick.add}(i, 1)$，而不是fwick.add(A[i], 1) 我们要统计的是 $A_i[\\cdots] \\leqslant mid$ 的数的个数用 $A_i \\leqslant mid$ 作为限制条件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136const int maxn = 1e5 + 10;const int inf = 1e9;int N, M;int n = 0, tot = 0, qt = 0;int a[maxn], ans[maxn];class Qry &#123;public: int x, y, z; int op; Qry() &#123;&#125; Qry(int x, int y, int z) : x(x), y(y), z(z) &#123;&#125; Qry(int x, int y) : x(x), y(y) &#123;&#125;&#125; qry[maxn * 3], lqry[maxn * 3], rqry[maxn * 3];class Fwick &#123;public: int C[maxn]; int n; void _init(int n) &#123; this-&gt;n = n; memset(C, 0, sizeof(C)); &#125; void add(int x, int y) &#123; for(; x &lt;= n; x += lowbit(x)) C[x] += y; &#125; int ask(int x) &#123; int ret = 0; for(; x; x -= lowbit(x)) ret += C[x]; return ret; &#125;&#125; fwick;void solve(int lval, int rval, int st, int ed) &#123; if(st &gt; ed) return; if(lval == rval) &#123; _rep(i, st, ed) if(qry[i].op &gt; 0) &#123; ans[qry[i].op] = lval; &#125; return; &#125; int mid = (lval + rval) &gt;&gt; 1; int lt = 0, rt = 0; _rep(i, st, ed) &#123; if(qry[i].op &lt;= 0) &#123; if(qry[i].y &lt;= mid) &#123; fwick.add(qry[i].x, qry[i].z); lqry[++lt] = qry[i]; &#125; else rqry[++rt] = qry[i]; &#125; else &#123; int cnt = fwick.ask(qry[i].y) - fwick.ask(qry[i].x - 1); if(cnt &gt;= qry[i].z) lqry[++lt] = qry[i]; else &#123; qry[i].z -= cnt; rqry[++rt] = qry[i]; &#125; &#125; &#125; _rep(i, st, ed) &#123; if(qry[i].op &lt;= 0 &amp;&amp; qry[i].y &lt;= mid) fwick.add(qry[i].x, -qry[i].z); &#125; _rep(i, 1, lt) qry[st + i - 1] = lqry[i]; _rep(i, 1, rt) qry[st + lt + i - 1] = rqry[i]; solve(lval, mid, st, st + lt - 1); solve(mid + 1, rval, st + lt, ed);&#125;void init() &#123; n = 0; tot = 0; qt = 0; memset(ans, 0, sizeof(ans));&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; cin &gt;&gt; kase; while (kase--) &#123; init(); scanf(\"%d%d\", &amp;N, &amp;M); // get arr[] _rep(i, 1, N) &#123; scanf(\"%d\", &amp;a[i]); &#125; // arr[] finished // -&gt; query[...] _rep(i, 1, N) &#123; qry[++tot] = Qry(i, a[i]); qry[tot].op = 0; qry[tot].z = 1; &#125; _rep(i, 1, M) &#123; char cmd[2]; scanf(\"%s\", cmd); if(cmd[0] == 'Q') &#123; int l, r, k; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); qry[++tot] = Qry(l, r, k); qry[tot].op = ++qt; &#125; else &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); qry[++tot] = Qry(x, a[x]); qry[tot].z = -1; qry[tot].op = -1; qry[++tot] = Qry(x, y); qry[tot].z = 1; qry[tot].op = 0; a[x] = y; &#125; &#125; // then solve fwick._init(maxn + 1); solve(0, inf, 1, tot); _rep(i, 1, qt) printf(\"%d\\n\", ans[i]); &#125;&#125; 整体二分实践Meteors 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132// ============================================================== //const int maxn = 3 * 1e5 + 10;const int inf = 0x3f3f3f3f;int n, m;int K = 0;vector&lt;int&gt; vec[maxn];class BIU &#123;public: int id; ll val; BIU() &#123;&#125; BIU(int id, ll val) : id(id), val(val) &#123;&#125;&#125; P[maxn], pl[maxn], pr[maxn];class Met &#123;public: int l, r; ll a; Met() &#123;&#125; Met(int l, int r, ll a) : l(l), r(r), a(a) &#123;&#125;&#125; A[maxn];class Fwick &#123;public: ll C[maxn]; int n; void _init(int n) &#123; this-&gt;n = n; memset(C, 0, sizeof(C)); &#125; void add(int x, ll d) &#123; for(; x &lt;= m; x += lowbit(x)) C[x] += d; &#125; ll ask(int x) &#123; ll ret = 0; for(; x; x -= lowbit(x)) ret += C[x]; return ret; &#125;&#125; fwick;void get(int k, int sgn) &#123; ll val = sgn * A[k].a; if(A[k].l &lt;= A[k].r) &#123; fwick.add(A[k].l, val); fwick.add(A[k].r + 1, -val); &#125; else &#123; fwick.add(1, val); fwick.add(A[k].l, val); fwick.add(A[k].r + 1, -val); &#125;&#125;ll ans[maxn];void solve(int lval, int rval, int st, int ed) &#123; if(st &gt; ed) return; if(lval == rval) &#123; _rep(i, st, ed) ans[P[i].id] = lval; return; &#125; int mid = (lval + rval) &gt;&gt; 1; int lt = 0, rt = 0; _rep(i, lval, mid) get(i, 1); _rep(i, st, ed) &#123; // P[i].id is cur BIU ll tot = 0; for(auto x : vec[P[i].id]) &#123; tot += fwick.ask(x); if(tot &gt; P[i].val) break; &#125; if(tot &gt;= P[i].val) pl[++lt] = P[i]; else &#123; P[i].val -= tot; pr[++rt] = P[i]; &#125; &#125; _rep(i, lval, mid) get(i, -1); _rep(i, 1, lt) P[st + i - 1] = pl[i]; _rep(i, 1, rt) P[st + lt + i - 1] = pr[i]; solve(lval, mid, st, st + lt - 1); solve(mid + 1, rval, st + lt, ed);&#125;void init() &#123; //&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;m); init(); // get data _rep(i, 1, m) &#123; int o; scanf(\"%d\", &amp;o); vec[o].push_back(i); &#125; _rep(i, 1, n) &#123; P[i].id = i; scanf(\"%lld\", &amp;P[i].val); &#125; scanf(\"%d\", &amp;K); _rep(i, 1, K) &#123; int l, r; ll a; scanf(\"%d%d%lld\", &amp;l, &amp;r, &amp;a); A[i] = Met(l, r, a); &#125; A[++K] = Met(1, m, inf); // then solve the problem fwick._init(maxn); solve(1, K, 1, n); _rep(i, 1, n) ans[i] == K ? puts(\"NIE\") : printf(\"%lld\\n\", ans[i]);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"data_structure","slug":"data-structure","permalink":"https://www.fogsail.net/tags/data-structure/"}]},{"title":"分治算法综合（一）","slug":"20200601","date":"2020-06-11T10:21:57.000Z","updated":"2020-07-01T01:00:26.508Z","comments":true,"path":"2020/06/11/20200601/","link":"","permalink":"https://www.fogsail.net/2020/06/11/20200601/","excerpt":"分治算法中有一些值得探讨的高级专题比如$\\textbf{CDQ分治，树上分治，整体分治}$$\\textbf{其中树上分治又被分为点分治，边分治，动态树分治}$从这篇博文开始陆续对这些内容做一个补充","text":"分治算法中有一些值得探讨的高级专题比如$\\textbf{CDQ分治，树上分治，整体分治}$$\\textbf{其中树上分治又被分为点分治，边分治，动态树分治}$从这篇博文开始陆续对这些内容做一个补充 点分治POJ1741 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139const int maxn = 1e5 + 10;const int inf = 0x3f3f3f3f;int n, k;// == Graph definition ==int M = 0;class Edge &#123;public: int to, weight; Edge *next; Edge() &#123;&#125; Edge(int to, int w) : to(to), weight(w) &#123; next = NULL; &#125;&#125; edges[maxn &lt;&lt; 1], *head[maxn];void initG() &#123; M = 0; memset(head, 0, sizeof(head));&#125;void add(int u, int v, int w) &#123; edges[++M] = Edge(v, w); edges[M].next = head[u]; head[u] = &amp;edges[M];&#125;// == Graph finished ==// == find gravity and get root ==int sz[maxn];int sn = n;int vis[maxn];int root = 0;void getRoot(int x, int pa, int&amp; res) &#123; sz[x] = 1; int maxpart = 0; for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;weight; if(vis[y] || y == pa) continue; getRoot(y, x, res); sz[x] += sz[y]; maxpart = max(maxpart, sz[y]); &#125; maxpart = max(maxpart, sn - sz[x]); if(maxpart &lt; res) &#123; res = maxpart; root = x; &#125;&#125;// == get root finished ==// == getDep ==int dep[maxn];void getDep(int x, int pa, vector&lt;int&gt;&amp; vec) &#123; vec.push_back(dep[x]); for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;weight; if(y == pa || vis[y]) continue; dep[y] = dep[x] + w; getDep(y, x, vec); &#125;&#125;// == getDep finished ==// == cal(p) ==inline int cal(int x) &#123; vector&lt;int&gt; vec; getDep(x, 0, vec); sort(vec.begin(), vec.end()); int sum = 0, i = 0, j = vec.size() - 1; while (i &lt; j) &#123; if(vec[i] + vec[j] &lt;= k) sum += j - i, i++; else j--; &#125; return sum;&#125;// == cal(p) finished ==// == work ==void work(int x, int&amp; ans) &#123; dep[x] = 0; vis[x] = 1; ans += cal(x); for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;weight; if(vis[y]) continue; dep[y] = dep[x] + w; ans -= cal(y); sn = sz[y]; root = 0; int res = inf; getRoot(y, 0, res); work(root, ans); &#125;&#125;// == work finished ==void init() &#123; // Set(sz, 0); Set(vis, 0); sn = n; root = 0;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;n, &amp;k) == 2 &amp;&amp; n) &#123; initG(); init(); // input data _for(i, 1, n) &#123; int x, y, w; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;w); add(x, y, w); add(y, x, w); &#125; // input finished int res = inf; getRoot(1, 0, res); int ans = 0; work(root, ans); printf(\"%d\\n\", ans); &#125;&#125; 点分治树状数组统计$root \\leftarrow getRoot(x)$$\\text{find }\\textbf{gravity}$ $\\textbf{algorithm: } solve(x\\leftarrow \\text{gravity})$$\\textbf{i) } x \\text{ is the root, let } dep(x) = 0$$\\textbf{ii) } getDep(x \\ \\cup \\ subTree)$$\\quad \\quad \\rightarrow \\textbf{cal}(x)$$\\textbf{iii) for } \\forall (x, y) \\in [s_1, s_2, \\cdots, s_k], s_i \\text{ is subTree}$$\\quad \\quad \\quad sn = \\text{size}(y)$$\\quad \\quad \\quad root \\leftarrow getRoot(y), solve(root)$ $\\textbf{algorithm: cal}(x)$ $\\text{fwick}.add(dep(x), 1)$ $\\textbf{for } \\forall e(x, y) \\in [S_i]$$\\quad \\quad dep(y)=dep(x)+w(x, y)$$\\quad \\quad getDep(y \\ \\cup \\ S_i) \\xrightarrow{dep} vec[\\cdots]$ $\\quad \\quad \\textbf{for }\\forall(d:vec)$$\\quad \\quad \\textbf{i) } \\text{fwick}.ask(K-d) \\text{ count how many: } $$\\quad \\quad \\quad(S_j | S_j \\neq S_i)+(d \\in S_i) \\leqslant K$$\\quad \\quad \\textbf{ii) then }\\text{fwick}.add(d \\in S_i, 1)$ $\\text{reset fenwick}$$\\textbf{for }\\forall (d:vec)$$\\quad \\quad \\text{fwick}.add(d, -1)$$\\text{fwick}.add(dep(x), -1)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197const int maxn = 1e5 + 10;const int MAXN = maxn &lt;&lt; 5;const int inf = 0x3f3f3f3f;int N, K;// == Fenwick ==class Fwick &#123;public: vector&lt;int&gt; C; int n; void resize(int n) &#123; this-&gt;n = n; C.resize(n); &#125; void clear() &#123; fill(C.begin(), C.end(), 0); &#125; int ask(int x) &#123; x++; int ans = 0; for(; x &gt; 0; x -= lowbit(x)) ans += C[x]; return ans; &#125; void add(int x, int d) &#123; x++; for(; x &lt;= K + 10; x += lowbit(x)) C[x] += d; &#125; int find(int l, int r, int val) &#123; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(ask(mid) &lt; val) l = mid + 1; else r = mid; &#125; return l; &#125;&#125; fwick;// == Fenwick finished ==// == Graph definition ==int m = 0;class Edge &#123;public: int to, weight; Edge *next; Edge() &#123;&#125; Edge(int to, int w) : to(to), weight(w) &#123; next = NULL; &#125;&#125; edges[maxn &lt;&lt; 1], *head[maxn];void add(int u, int v, int w) &#123; edges[++m] = Edge(v, w); edges[m].next = head[u]; head[u] = &amp;edges[m];&#125;void initG() &#123; m = 0; memset(head, 0, sizeof(head));&#125;// == Graph finished ==int sz[maxn];int dep[maxn];int vis[maxn];int sn = N;int root = 0;// == get gravity as root ==void getRoot(int x, int pa, int &amp;res) &#123; sz[x] = 1; int maxpart = 0; for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; if(vis[y] || y == pa) continue; getRoot(y, x, res); sz[x] += sz[y]; maxpart = max(maxpart, sz[y]); &#125; maxpart = max(maxpart, sn - sz[x]); if(maxpart &lt; res) &#123; res = maxpart; root = x; &#125;&#125;// == get root finished ==// == get dep and calculate ==void getDep(int x, int pa, vector&lt;int&gt; &amp;vec) &#123; vec.push_back(dep[x]); for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;weight; if(vis[y] || y == pa) continue; dep[y] = dep[x] + w; if(dep[y] &lt;= K) getDep(y, x, vec); &#125;&#125;queue&lt;int&gt; buf;inline void cal(int x, int &amp;ans) &#123; fwick.add(dep[x], 1); for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;weight; if(vis[y]) continue; dep[y] = dep[x] + w; vector&lt;int&gt; vec; getDep(y, x, vec); _for(i, 0, vec.size()) if(K &gt;= vec[i]) &#123; ans += fwick.ask(K - vec[i]); &#125; _for(i, 0, vec.size()) &#123; fwick.add(vec[i], 1); buf.push(vec[i]); &#125; &#125; while (buf.size()) &#123; fwick.add(buf.front(), -1); buf.pop(); &#125; fwick.add(dep[x], -1);&#125;// == get dep finsihed ==// == solve ==void solve(int x, int &amp;ans) &#123; dep[x] = 0; vis[x] = 1; cal(x, ans); for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;weight; if(vis[y]) continue; sn = sz[y]; root = 0; int res = inf; getRoot(y, -1, res); solve(root, ans); &#125;&#125;// == solve finished ==void init() &#123; Set(sz, 0); Set(dep, 0); Set(vis, 0); sn = N; root = 0; fwick.resize(MAXN); fwick.clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;N, &amp;K) == 2 &amp;&amp; N) &#123; init(); initG(); // get data _for(i, 1, N) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; // data finished int res = inf; getRoot(1, -1, res); int ans = 0; solve(root, ans); printf(\"%d\\n\", ans); &#125;&#125; 点分治例子Acwing264 $\\textbf{algorithm}$$\\textbf{i) solve}(x, \\text{ans})$$\\quad \\quad \\text{dep}(x) = 0, \\text{vis}(x) = 1$$\\quad \\quad \\textbf{cal}(x, ans)$$\\quad \\quad \\textbf{for } \\forall y \\in son(x)$$\\quad \\quad \\quad root \\leftarrow getRoot(), \\textbf{solve}(root, ans)$ $\\textbf{ii) cal}(x, y), \\text{难点在于cal的计算}$ $\\textbf{用 vec1}[\\cdots] \\textbf{ 维护 D}[\\cdots], \\textbf{vec2}[\\cdots] \\textbf{ 维护 dep}[\\cdots]$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164const int maxn = 1e6 + 10;const int inf = 0x3f3f3f3f;int N, K;// == Graph definition ==int m = 0;class Edge &#123;public: int to, weight; Edge *next; Edge() &#123;&#125; Edge(int to, int w) : to(to), weight(w) &#123; next = NULL; &#125;&#125; edges[maxn &lt;&lt; 1], *head[maxn];void initG() &#123; m = 0; memset(head, 0, sizeof(head));&#125;void add(int u, int v, int w) &#123; edges[++m] = Edge(v, w); edges[m].next = head[u]; head[u] = &amp;edges[m];&#125;// == Graph finished ==// == get root ==int root = 0;int sn = N;int sz[maxn];int vis[maxn];void getRoot(int x, int pa, int &amp;res) &#123; sz[x] = 1; int maxpart = 0; for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; if(vis[y] || y == pa) continue; getRoot(y, x, res); sz[x] += sz[y]; maxpart = max(maxpart, sz[y]); &#125; maxpart = max(maxpart, sn - sz[x]); if(maxpart &lt; res) &#123; res = maxpart; root = x; &#125;&#125;// == get root finished ==// == solve ==int dep[maxn];int D[maxn];int dp[maxn];void dfs(int x, int pa, vector&lt;int&gt; &amp;vec1, vector&lt;int&gt; &amp;vec2) &#123; vec1.push_back(D[x]); vec2.push_back(dep[x]); for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;weight; if(vis[y] || y == pa) continue; dep[y] = dep[x] + 1; D[y] = D[x] + w; if(D[y] &lt;= 1e6) dfs(y, x, vec1, vec2); &#125;&#125;queue&lt;int&gt; que;void cal(int x, int &amp;ans) &#123; for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;weight; if(vis[y]) continue; vector&lt;int&gt; vec1, vec2; dep[y] = dep[x] + 1; D[y] = D[x] + w; dfs(y, x, vec1, vec2); _for(i, 0, vec1.size()) &#123; if(K &gt;= vec1[i]) ans = min(ans, dp[K - vec1[i]] + vec2[i]); &#125; _for(i, 0, vec1.size()) &#123; que.push(vec1[i]); dp[vec1[i]] = min(dp[vec1[i]], vec2[i]); &#125; &#125; while (que.size()) &#123; dp[que.front()] = inf; que.pop(); &#125;&#125;void solve(int x, int &amp;ans) &#123; vis[x] = 1; dep[x] = 0; D[x] = 0; dp[0] = 0; cal(x, ans); for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;weight; if(vis[y]) continue; sn = sz[y]; root = 0; int res = inf; getRoot(y, x, res); solve(root, ans); &#125;&#125;// == solve finished ==void init() &#123; root = 0; sn = N; Set(sz, 0); Set(vis, 0); Set(dep, 0); Set(D, 0); Set(dp, inf);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;K); initG(); init(); _for(i, 1, N) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); u++; v++; add(u, v, w); add(v, u, w); &#125; // then solve the problem int res = inf; getRoot(1, -1, res); int ans = inf; solve(root, ans); if(ans == inf) printf(\"-1\\n\"); else printf(\"%d\\n\", ans);&#125; 一些算法技巧$\\textbf{algorithm 差分}$ $A[…]=A_1,A_2,A_3, \\cdots ,A_n$$B_i = A_i - A_{i-1}, \\ B_1 = A_1$$B就是A的差分序列$ $\\textbf{性质1}$ A_i = \\sum_{j = 1}^{i} B_j$\\textbf{性质2}$$A[l, r] \\xleftarrow{+C}$$给区间 A[l, r] 的元素都加上 C$ $\\Leftrightarrow B_{r+1} - C, B_{l} + C$ Acwing100 $\\textbf{algorithm, solve }(B_i, B_j) , i &lt; j$$\\text{目标是把 } B_2, B_3\\cdots, B_n 全部变成0$ $\\textbf{i) } 2\\leqslant i &lt; j \\leqslant n, \\text{ 能够处理 } B[2\\cdots n] \\text{ 中的 } 2 \\text{ 个数 } B_i, B_j$$\\quad \\text{改变的是区间 } A[i, \\cdots, j-1]$$\\quad \\text{在一正一负的时候尽可能用这种操作}$ $\\textbf{ii) } i = 1, 2 \\leqslant j \\leqslant n$$\\quad \\text{改变的是} A[\\cdots] 的前缀$ $\\textbf{iii) } 2 \\leqslant i \\leqslant n, j = n + 1$$\\quad \\text{改变的是} A[\\cdots] 的后缀$ $\\textbf{iv) } i = 1, j = n + 1$$\\quad \\text{改变了整个 }A 序列，无意义$ $\\textbf{algorithm}$$\\textbf{i) do } \\text{type i) , when } B_i \\cdot B_j &lt;0$$\\textbf{ii) } \\text{other, do type ii) or iii)}$$\\quad \\text{ example, remain }\\textbf{r unpaired}$$\\quad \\rightarrow [\\text{ii)}, \\text{iii)}] = (0, r), (1, r), \\cdots, (r, 0)$$\\quad \\rightarrow tot =r+1$ 123456789101112131415161718192021222324252627282930const int maxn = 1e5 + 10;int A[maxn], B[maxn];int n;void init() &#123; Set(B, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;n); init(); _rep(i, 1, n) scanf(\"%d\", &amp;A[i]); B[1] = 1; _rep(i, 2, n) B[i] = A[i] - A[i - 1]; ll s1 = 0, s2 = 0; _rep(i, 2, n) &#123; if(B[i] &gt; 0) s1 += B[i]; else s2 -= B[i]; &#125; ll ans = min(s1, s2) + abs(s1 - s2); cout &lt;&lt; ans &lt;&lt; endl; ll ans2 = abs(s1 - s2) + 1; cout &lt;&lt; ans2 &lt;&lt; endl;&#125; 树状数组维护差分序列POJ3468 $[l, r] \\xleftarrow{+d}$$B_i = A_i - A_{i - 1}$ A_i = \\sum_{j = 1}^{i} B_j \\\\ \\ \\\\ S_{\\text{prefix}}(x) = \\sum_{i = 1}^{x} A_i = \\sum_{i = 1}^{x}\\sum_{j = 1}^{i} B_j \\\\ \\ \\\\ = \\sum_{i = 1}^{x}(x-i+1)B_i = (x+1)\\sum_{i = 1}^{x}B_i - \\sum_{i = 1}^{x}i \\cdot B_i$\\textbf{algorithm}$$\\textbf{i) } \\text{fwick[0]} \\leftarrow \\sum_{i = 1}^{x} B_i, \\quad \\text{fwick[1]} \\leftarrow \\sum_{i = 1}^{x} i B_i$$\\textbf{ii) change: } [l, r]$$\\quad \\quad \\text{fwick[0]}.add(r+1, -d), \\quad \\text{fwick[0]}.add(l, d)$$\\quad \\quad \\text{fwick[1]}.add(r+1, -(r+1)d), \\quad \\text{fwick[1]}.add(l, ld)$$\\textbf{ii) ask: } [l, r]$$\\quad \\quad S(r) = (\\text{fwick}[0].ask(r)) \\times (r+1) - \\text{fwick[1]}(r)$$\\quad \\quad S(l -1) = (\\text{fwick}[0].ask(l - 1)) \\times (l) - \\text{fwick[1]}(l - 1)$$\\quad \\quad \\textbf{ans} = S(r) - S(l - 1)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const int maxn = 100000 + 10;int n, m;ll A[maxn];// == fenwick definition ==class Fwick &#123;public: vector&lt;ll&gt; C[2]; int n; void resize(int n) &#123; this-&gt;n = n; _for(i, 0, 2) C[i].resize(n + 1); &#125; void clear() &#123; _for(i, 0, 2) fill(C[i].begin(), C[i].end(), 0ll); &#125; void add(int k, int x, ll d) &#123; int i = x; for(; i &lt;= n; i += lowbit(i)) C[k][i] += 1ll * d; &#125; ll ask(int k, int x) &#123; ll ans = 0; for(int i = x; i; i -= lowbit(i)) ans += C[k][i]; return ans; &#125;&#125; fwick;// == fenwick finsihed ==ll prefix(int x) &#123; return fwick.ask(0, x) * (x + 1) - fwick.ask(1, x);&#125;void init() &#123; fwick.resize(maxn); fwick.clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;m); init(); _rep(i, 1, n) &#123; scanf(\"%lld\", &amp;A[i]); fwick.add(0, i, A[i] - A[i - 1]); fwick.add(1, i, i * (A[i] - A[i - 1])); &#125; // then solve while (m--) &#123; char cmd[2]; scanf(\"%s\", cmd); if(cmd[0] == 'C') &#123; int l, r, d; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;d); fwick.add(0, r + 1, -1ll * d); fwick.add(0, l, 1ll * d); fwick.add(1, r + 1, -1ll * d * (r + 1)); fwick.add(1, l, 1ll * d * l); &#125; else &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); ll ans = prefix(r) - prefix(l - 1); printf(\"%lld\\n\", ans); &#125; &#125;&#125; 树状数组求逆序对$\\textbf{algorithm: A}[\\cdots]$$\\textbf{for } \\forall i \\in [1, n]$$\\quad \\textbf{check } [1, 2, \\cdots, i] \\rightarrow \\textbf{fwick}[\\cdots]$$\\quad \\textbf{fwick}.add(A[i], 1)$ $\\quad \\textbf{fwick}.sum(A[i]) \\rightarrow (\\text{how many} \\leqslant A[i]) \\in [1, \\cdots, i]$ \\text{ans} = \\sum (i - \\text{fwick}.sum(A[i]))12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: int inversePairs(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); #define lowbit(x) (x &amp; (-x)) typedef long long ll; int b[n + 1], a[n + 1]; class Fwick &#123; public: vector&lt;ll&gt; C; int n; void resize(int n) &#123; this-&gt;n = n; C.resize(n + 1); &#125; void clear() &#123; fill(C.begin(), C.end(), 0); &#125; int sum(int x) &#123; int ans = 0; for(; x &gt; 0; x -= lowbit(x)) ans += C[x]; return ans; &#125; int add(int x, int d) &#123; for(; x &lt;= n; x += lowbit(x)) C[x] += d; &#125; &#125; fwick; for(int i = 1; i &lt;= (int)nums.size(); i++) &#123; a[i] = b[i] = nums[i - 1]; &#125; sort(b + 1, b + 1 + n); int tot = unique(b + 1, b + 1 + n) - b - 1; for(int i = 1; i &lt;= n; i++) a[i] = lower_bound(b + 1, b + 1 + tot, a[i]) - b; fwick.resize(tot + 1); fwick.clear(); int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; fwick.add(a[i], 1); ans += i - fwick.sum(a[i]); &#125; return ans; &#125;&#125;;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"data_structure","slug":"data-structure","permalink":"https://www.fogsail.net/tags/data-structure/"}]},{"title":"图算法和图模型(八)","slug":"20200524","date":"2020-06-05T13:14:31.000Z","updated":"2020-06-13T20:55:24.107Z","comments":true,"path":"2020/06/05/20200524/","link":"","permalink":"https://www.fogsail.net/2020/06/05/20200524/","excerpt":"这篇博文主要讲述一下状态图，隐式图建图的技巧补充了一些最短路的拓展$spfa()$ 求最长路算法等等","text":"这篇博文主要讲述一下状态图，隐式图建图的技巧补充了一些最短路的拓展$spfa()$ 求最长路算法等等 spfa求最长路UVALive3310 $\\textbf{algorithm}$$\\textbf{i) run }\\quad \\text{strongConnected?} \\leftarrow \\text{tarjan()}$$\\quad \\quad \\textbf{ if circle, } \\text{ return } \\infty$ $\\textbf{ii) run } \\text{spfa()}$$\\quad \\quad \\textbf{ relax }(x, y), \\quad d(y) &lt; d(x) + w(x, y)$$\\quad \\quad \\text{ get longest path}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325const int maxn = 100000+5;const int inf = 1e9;int n, tot;int ans;// == Graph definition ==int m = 0;class Edge &#123;public: int to, weight, s, t; bool loop; Edge *next; Edge() &#123;&#125; Edge(int v, int w, int s, int t, bool loop) : to(v), weight(w), s(s), t(t), loop(loop) &#123; next = NULL; &#125;&#125; edges[maxn &lt;&lt; 1], *head[maxn];void add(int x, int y, int w, int s, int t, bool loop) &#123; edges[++m] = Edge(y, w, s, t, loop); edges[m].next = head[x]; head[x] = &amp;edges[m];&#125;int dfn[maxn], low[maxn];int belong[maxn], ccnum[maxn];int cc = 0;int ins[maxn];stack&lt;int&gt; stk;int clk = 0;void initG() &#123; memset(head, 0, sizeof(head)); m = clk = 0; memset(dfn, 0, sizeof(dfn)); memset(low, 0, sizeof(low)); memset(ins, 0, sizeof(ins)); while (stk.size()) stk.pop(); memset(ccnum, 0, sizeof(ccnum)); cc = 0; memset(belong, 0, sizeof(belong));&#125;void tarjan(int u) &#123; low[u] = dfn[u] = ++clk; stk.push(u); ins[u] = 1; for(const Edge *e = head[u]; e; e = e-&gt;next) &#123; int v = e-&gt;to; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(ins[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if(dfn[u] == low[u]) &#123; cc++; while (true) &#123; int x = stk.top(); stk.pop(); ins[x] = false; belong[x] = cc; if(x == u) break; &#125; &#125;&#125;// == Graph finished ==// == build graph, important ==const int maxl = 82;char buf[maxl];char Cmd[maxn][maxl];ll nxt[maxn], len[maxn];bool Die[maxn], vis[maxn];int ID[maxn], pos[maxn];void initbuild() &#123; memset(ID, -1, sizeof(ID)); memset(pos, -1, sizeof(pos)); memset(Die, 0, sizeof(Die)); memset(nxt, -1, sizeof(nxt)); memset(len, 0, sizeof(len));&#125;bool judge(const int u, int &amp;v, int &amp;w) &#123; memset(vis, 0, sizeof(vis)); vis[u] = 1; bool loop = false; while (ID[v] == -1) &#123; vis[v] = 1; w += len[v]; v = nxt[v]; if(vis[v]) &#123; loop = true; break; &#125; &#125; return loop;&#125;void build() &#123; initbuild(); ID[0] = ++tot; pos[tot] = 0; _for(i, 0, n) &#123; if(Cmd[i][0] == 'l') &#123; int s = -1, t = -1; sscanf(Cmd[i], \"%*s%d%d\", &amp;s, &amp;t); s--; if(ID[s] == -1) &#123; ID[s] = ++tot; pos[tot] = s; &#125; if(ID[i] == -1) &#123; ID[i] = ++tot; pos[tot] = i; &#125; nxt[i] = i; &#125; else if(Cmd[i][0] == 'i' || Cmd[i][0] == 'j') &#123; int v; sscanf(Cmd[i], \"%*s%d\", &amp;v); v--; if(Cmd[i][0] == 'i' &amp;&amp; ID[i] == -1) &#123; ID[i] = ++tot; pos[tot] = i; &#125; nxt[i] = v; &#125; else if(Cmd[i][0] == 'd') &#123; if(ID[i] == -1) &#123; ID[i] = ++tot; pos[tot] = i; &#125; Die[ID[i]] = true; nxt[i] = i; &#125; else &#123; nxt[i] = (i + 1) % n; &#125; len[i] = nxt[i] == i ? 0 : 1; &#125; _forDown(i, tot, 1) &#123; if(Die[i]) continue; int u = pos[i]; int v = nxt[u]; int w = len[u]; bool lp = judge(u, v, w); if(lp) &#123; add(ID[u], ID[u], inf, -1, -1, false); continue; &#125; len[u] = w; nxt[u] = v; if(v != u) &#123; add(ID[u], ID[v], w, -1, -1, false); &#125; if(Cmd[u][0] == 'j') continue; // then deal with pass, loop, ifgo // just one step v = (u + 1) % n; w = 1; lp = judge(u, v, w); if(lp) &#123; add(ID[u], ID[u], inf, -1, -1, false); continue; &#125; int s = -1, t = -1; if(Cmd[u][0] == 'l') &#123; sscanf(Cmd[u], \"%*s%d%d\", &amp;s, &amp;t); s--; &#125; add(ID[u], ID[v], w, ID[s], t, Cmd[u][0] == 'l'); &#125;&#125;// == build finished ==// == spfa get longest path ==ll cnt[maxn], D[maxn];int inq[maxn];void initspfa() &#123; memset(cnt, 0, sizeof(cnt)); memset(inq, 0, sizeof(inq)); memset(D, 0, sizeof(D));&#125;void spfa() &#123; initspfa(); queue&lt;int&gt; que; int st = ID[0]; inq[st] = 1; D[st] = 1; que.push(st); while (que.size()) &#123; int x = que.front(); que.pop(); inq[x] = false; if(Die[x] &amp;&amp; ans &lt; D[x]) ans = D[x]; for(const Edge *e = head[x]; e; e = e-&gt;next) &#123; int y = e-&gt;to; int w = e-&gt;weight; if(e-&gt;loop) w += (D[x] - D[e-&gt;s] + 1) * (e-&gt;t - 1); if(D[y] &lt; D[x] + w) &#123; D[y] = D[x] + w; if(!inq[y]) &#123; inq[y] = true; que.push(y); if(++cnt[y] &gt; tot) &#123; printf(\"infinity\\n\"); return; &#125; &#125; &#125; &#125; &#125; if(ans &gt; inf) printf(\"infinity\\n\"); else cout &lt;&lt; ans &lt;&lt; endl;&#125;// == spfa finished ==// == get cmd ==void getCmd() &#123; _for(i, 0, strlen(buf)) buf[i] = tolower(buf[i]); char *p = strtok(buf, \" \"); while (p) &#123; strcat(Cmd[n], p); strcat(Cmd[n], \" \"); p = strtok(NULL, \" \"); &#125; n++;&#125;bool cmdModify() &#123; bool die = false; _for(i, 0, n) &#123; if(Cmd[i][0] == 'd') die = true; if(Cmd[i][0] == 'i' || Cmd[i][0] == 'j') &#123; int v; sscanf(Cmd[i], \"%*s%d\", &amp;v); v--; if(v == (i + 1) % n) Cmd[i][0] = 'p'; if(i == v &amp;&amp; !die) return false; &#125; &#125; return die;&#125;// == get cmd finished ==void init() &#123; memset(Cmd, 0, sizeof(Cmd)); n = tot = 0;&#125;void test() &#123; _for(i, 0, n) debug(Cmd[i]);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (fgets(buf, sizeof(buf) / sizeof(buf[0]), stdin)) &#123; if(buf[0] == '\\n') break; init(); getCmd(); while (fgets(buf, sizeof(buf) / sizeof(buf[0]), stdin)) &#123; if(buf[0] == '\\n') break; _for(i, 0, strlen(buf)) if(isspace(buf[i])) buf[i] = ' '; getCmd(); &#125; // one test case finished //test(); if(!cmdModify()) &#123; printf(\"infinity\\n\"); continue; &#125; // then build graph initG(); build(); bool circle = false; tarjan(1); _rep(i, 1, tot) ccnum[belong[i]]++; _rep(i, 1, cc) if(ccnum[i] &gt; 1) &#123; circle = true; break; &#125; if(circle) &#123; printf(\"infinity\\n\"); continue; &#125; ans = -1; spfa(); &#125;&#125; 有向无环图最长路径$\\textbf{dp + topoSort} \\text{可解决有向无环图最长路径问题}$ 2017Urmuqi 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const int maxn = 100000 + 10;int ans = 0;// == Graph definition ==vector&lt;int&gt; G[maxn];class Edge &#123;public: int to, weight; Edge() &#123;&#125; Edge(int v, int w) : to(v), weight(w) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;int deg[maxn];void initG() &#123; Set(deg, 0); _for(i, 0, maxn) G[i].clear(); edges.clear();&#125;void addEdge(int u, int v, int w) &#123; edges.push_back(Edge(v, w)); G[u].push_back(edges.size() - 1); deg[v]++;&#125;int n, m;// == Graph finished ==int D[maxn];void initdp() &#123; ans = 0; Set(D, 0);&#125;void dp() &#123; queue&lt;int&gt; que; _rep(i, 1, n) if(deg[i] == 0) que.push(i); while (que.size()) &#123; int x = que.front(); que.pop(); if(G[x].size() == 0) ans = max(ans, D[x]); _for(i, 0, G[x].size()) &#123; const Edge&amp; e = edges[G[x][i]]; int y = e.to; if(D[y] &lt; D[x] + e.weight) D[y] = D[x] + e.weight; if(--deg[y] == 0) que.push(y); &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; initG(); scanf(\"%d%d\", &amp;n, &amp;m); _rep(i, 1, m) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); &#125; initdp(); dp(); printf(\"%d\\n\", ans); &#125;&#125; 二分图初步codeforces 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const int maxn = 1e5 + 10;int n, m, k;// == Graph ==vector&lt;int&gt; G[maxn];class Edge &#123;public: int to, weight; Edge() &#123;&#125; Edge(int v, int w) : to(v), weight(w) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;void initG() &#123; _for(i, 0, maxn) G[i].clear(); edges.clear();&#125;void addEdge(int u, int v, int w) &#123; edges.push_back(Edge(v, w)); G[u].push_back(edges.size() - 1);&#125;// == Graph finished ==// == solve ==int D[maxn];int pre[maxn];int vis[maxn];int bin[maxn];void dfs(int u, int pa) &#123; vis[u] = 1; _for(i, 0, G[u].size()) &#123; const Edge&amp; e = edges[G[u][i]]; int v = e.to; if(vis[v] &amp;&amp; v != pa) &#123; vector&lt;int&gt; path; int cu = u; while (cu != v) &#123; path.push_back(cu); cu = pre[cu]; &#125; path.push_back(v); cout &lt;&lt; 2 &lt;&lt; \"\\n\"; printf(\"%d\\n\", (int)path.size()); for(auto x : path) printf(\"%d \", x); exit(0); &#125; else if(!vis[v]) &#123; bin[v] = bin[u] ^ 1; pre[v] = u; dfs(v, u); &#125; &#125;&#125;// == solve finished ==void init() &#123; Set(D, 0); Set(pre, 0); Set(vis, 0); Set(bin, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); initG(); init(); scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); n = k; _for(i, 0, m) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if(u &gt; n || v &gt; n) continue; addEdge(u, v, 1); addEdge(v, u, 1); &#125; // solve _rep(i, 1, n) if(!vis[i]) &#123; dfs(i, -1); &#125; vector&lt;int&gt; ans[2]; _rep(i, 1, n) &#123; ans[bin[i]].push_back(i); &#125; if(ans[0].size() &lt; ans[1].size()) swap(ans[0], ans[1]); ans[0].resize((k + 1) / 2); cout &lt;&lt; 1 &lt;&lt; \"\\n\"; for(auto x : ans[0]) printf(\"%d \", x);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"Graph","slug":"Graph","permalink":"https://www.fogsail.net/tags/Graph/"}]},{"title":"图算法和图模型(七)","slug":"20200523","date":"2020-05-30T07:13:48.000Z","updated":"2020-06-02T14:48:09.592Z","comments":true,"path":"2020/05/30/20200523/","link":"","permalink":"https://www.fogsail.net/2020/05/30/20200523/","excerpt":"这篇文章继续对最短路问题做相关阐述主要讲一下负权边的处理以及状态图建图的技巧和方法","text":"这篇文章继续对最短路问题做相关阐述主要讲一下负权边的处理以及状态图建图的技巧和方法 多阶段 DijkstraUVALive3561 看一下这个例子的建图过程 $\\textbf{algorithm}$$\\textbf{i) } \\text{build graph}$$\\quad \\textbf{ for } \\forall \\text{trip} \\in [1, \\text{NI}]$$\\quad \\quad \\text{ get trip List} \\rightarrow ([\\textbf{toList}], len)$$\\quad \\quad \\text{ chooseTicket}([\\textbf{toList}, len])$ $\\quad \\text{ chooseTicket}(\\textbf{toList}, len):$$\\quad \\quad \\textbf{ for } \\forall i \\in [0, \\text{NT}), \\textbf{ for } \\forall k \\in [1, tot]$$\\quad \\quad \\quad \\textbf{ st}=(k,\\text{tickets[i,0]})$$\\quad \\quad \\quad \\textbf{ for } \\forall j \\in [1, \\text{tickets}(i).\\text{size)}$$\\quad \\quad \\quad \\quad \\textbf{ if } \\textbf{ toList}[k]=\\text{tickets}[i,j], \\textbf{Edge}(\\textbf{st}, (k+1, \\text{tickets[i, j]}), \\text{cost})$$\\quad \\quad \\quad \\quad \\textbf{ else } \\textbf{Edge}(\\textbf{st}, (k, \\text{tickets}[i, j], \\text{cost})$$\\quad \\quad \\quad \\quad \\text{ cost}:=(\\text{price}[ith\\text{-Tickets}], \\text{ticketID})$ $\\textbf{ii) } \\text{run } Dijkstra()$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186const int maxN = 4000 + 10;const int inf = 0x3f3f3f3f;int nCities = 0;const int maxn = 100;vector&lt;int&gt; tickets[maxn];int cost[maxn];int NT, NI;// == Graph ==vector&lt;int&gt; G[maxN];class Edge &#123;public: int from, to, weight, val; Edge() &#123;&#125; Edge(int u, int v, int w, int val) : from(u), to(v), weight(w), val(val) &#123;&#125;&#125;;class Node &#123;public: int u, dist; Node() &#123;&#125; Node(int u, int dist) : u(u), dist(dist) &#123;&#125; bool operator&lt; (const Node&amp; rhs) const &#123; return dist &gt; rhs.dist; &#125;&#125;;vector&lt;Edge&gt; edges;void initG() &#123; _for(i, 0, maxN) G[i].clear(); edges.clear();&#125;void addEdge(int u, int v, int w, int val) &#123; edges.push_back(Edge(u, v, w, val)); G[u].push_back(edges.size() - 1);&#125;// == Graph finsihed ==// == dijkstra ==int D[maxN], vis[maxN];int pid[maxN];void initDij(int st) &#123; _for(i, 0, maxN) D[i] = inf; D[st] = 0; Set(vis, 0); Set(pid, 0);&#125;void dijsktra(int st) &#123; initDij(st); priority_queue&lt;Node&gt; que; que.push(Node(st, 0)); while (!que.empty()) &#123; int x = que.top().u; que.pop(); if(vis[x]) continue; vis[x] = 1; _for(i, 0, G[x].size()) &#123; const Edge&amp; e = edges[G[x][i]]; int y = e.to; if(D[y] &gt; D[x] + e.weight) &#123; D[y] = D[x] + e.weight; pid[y] = G[x][i]; que.push(Node(y, D[y])); &#125; &#125; &#125;&#125;vector&lt;int&gt; getPath(int ed, const int st) &#123; vector&lt;int&gt; path; while (ed != st) &#123; path.push_back(edges[pid[ed]].val); ed = edges[pid[ed]].from; &#125; reverse(path.begin(), path.end()); return path;&#125;// == dijkstra finsihed ==// == get all tickets ==map&lt;int, int&gt; cityID;inline int ID(int x) &#123; if(cityID.count(x)) return cityID[x]; cityID[x] = ++nCities; return nCities;&#125;inline int ID(int i, int j) &#123; return (i - 1) * nCities + j;&#125;void getTickets(const int NT) &#123; _for(i, 0, NT) &#123; tickets[i].clear(); int len; scanf(\"%d%d\", &amp;cost[i], &amp;len); while (len--) &#123; int x; scanf(\"%d\", &amp;x); tickets[i].push_back(ID(x)); &#125; &#125;&#125;// == get tickets finished ==// == get trip data ==vector&lt;int&gt; toList;int getTrip(const int trip) &#123; toList.clear(); int tot = 0; scanf(\"%d\", &amp;tot); _for(i, 0, tot) &#123; int x; scanf(\"%d\", &amp;x); toList.push_back(ID(x)); &#125; return tot;&#125;// == trip finished ==// == chooseTicket for trip ==void chooseTicket(const vector&lt;int&gt;&amp; toList, const int tot) &#123; _for(i, 0, NT) _rep(k, 1, tot) &#123; int cur = tickets[i][0]; int k2 = k; _for(j, 1, tickets[i].size()) &#123; int A = tickets[i][j]; if(A == toList[k2]) k2++; if(k2 &gt; tot) break; addEdge(ID(k, cur), ID(k2, A), cost[i], i + 1); if(k2 == tot) break; &#125; &#125;&#125;// == chooseTicket finished ==void init() &#123; nCities = 0; cityID.clear(); _for(i, 0, maxn) tickets[i].clear(); Set(cost, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while (scanf(\"%d\", &amp;NT) == 1 &amp;&amp; NT) &#123; init(); // get tickets getTickets(NT); scanf(\"%d\", &amp;NI); kase++; _rep(trip, 1, NI) &#123; int tot = getTrip(trip); assert(toList.size() != 0); initG(); chooseTicket(toList, tot); int src = ID(1, toList[0]), ed = ID(tot, toList[tot-1]); dijsktra(src); printf(\"Case %d, Trip %d: Cost = %d\\n\", kase, trip, D[ed]); printf(\" Tickets used:\"); vector&lt;int&gt; res = getPath(ed, src); _for(i, 0, res.size()) printf(\" %d\", res[i]); printf(\"\\n\"); &#125; &#125;&#125; 状态建图UVALive3661 $\\textbf{algorithm}$$\\textbf{build graph}$$\\textbf{i) } \\text{get vector}$ \\quad \\{\\textbf{ top, bottom }\\} \\{\\textbf{ left, right }\\} \\{ \\textbf{slash} \\} = (i, j, dir[0, 2)) \\\\ \\ \\\\ \\xrightarrow{\\text{vector}} \\textbf{[edges]}$\\textbf{ii) } u=\\textbf{ID(edges)}=\\textbf{ID}(\\textbf{top}(i,j,dir), \\cdots)$$\\quad \\ \\ v=\\textbf{ID}(\\textbf{edges}) = \\textbf{ID}(\\textbf{slash}(i, j, dir))$$\\quad \\ \\ add(u, v, cost(\\textbf{slash}(i, j, dir)))$ $\\textbf{dijkstra}$$\\textbf{i) st} = 0, \\ add(\\textbf{0}, \\textbf{leftBorder})$$\\quad add(\\textbf{0, bottomBorder})$ $\\quad \\textbf{ed right}= $$\\quad \\quad \\textbf{for } \\forall i \\in [0, n)$$\\quad \\quad \\quad \\textbf{ID}(i, m-1, dir=1)$ $\\quad \\textbf{ed top}=$$\\quad \\quad \\textbf{for } \\forall i \\in [0, m)$$\\quad \\quad \\quad \\textbf{ID}(0, i, dir = 0)$ $\\textbf{ii) } \\text{run } dijkstra()$$\\quad \\textbf{ ans} = \\min (\\textbf{D[ed right], D[ed top]})$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150const int inf = 0x3f3f3f3f;const int maxn = 1000 + 10;const int maxN = 4000000;int cost[maxn][maxn][3];int n, m;// == Graph definition ==vector&lt;int&gt; G[maxN];class Edge &#123;public: int to, weight; Edge() &#123;&#125; Edge(int to, int w) : to(to), weight(w) &#123;&#125;&#125;;class Node &#123;public: int u, dist; Node() &#123;&#125; Node(int u, int d) : u(u), dist(d) &#123;&#125; bool operator&lt; (const Node&amp; rhs) const &#123; return dist &gt; rhs.dist; &#125;&#125;;vector&lt;Edge&gt; edges;void initG() &#123; _for(i, 0, maxN) G[i].clear(); edges.clear();&#125;void addEdge(int u, int v, int w) &#123; edges.push_back(Edge(v, w)); G[u].push_back(edges.size() - 1);&#125;// == Graph finished ==// == dijkstra ==int D[maxN], vis[maxN];void initDij(int st) &#123; Set(D, inf); D[st] = 0; Set(vis, 0);&#125;void dijkstra(int st) &#123; initDij(st); priority_queue&lt;Node&gt; que; que.push(Node(st, 0)); while (!que.empty()) &#123; int x = que.top().u; que.pop(); if(vis[x]) continue; vis[x] = 1; _for(i, 0, G[x].size()) &#123; const Edge&amp; e = edges[G[x][i]]; int y = e.to; if(D[y] &gt; D[x] + e.weight) &#123; D[y] = D[x] + e.weight; que.push(Node(y, D[y])); &#125; &#125; &#125;&#125;// == dijkstra finsihed ==inline int ID(int i, int j, int dir) &#123; return i*m+j+1 + dir*n*m;&#125;inline int read() &#123; int x; scanf(\"%d\", &amp;x); return x;&#125;// == build graph ==void getEdge(int *e1, int *e2, int *e3) &#123; int *edges[3] = &#123;e1, e2, e3&#125;; // edges[i]:= (i, j, dir) _for(i, 0, 3) _for(j, 0, 3) if(i != j) &#123; int u = ID(edges[i][0], edges[i][1], edges[i][2]); int v = ID(edges[j][0], edges[j][1], edges[j][2]); int w = cost[edges[j][0]][edges[j][1]][edges[j][2]]; addEdge(u, v, w); &#125;&#125;void build() &#123; _for(i, 0, n - 1) _for(j, 0, m - 1) &#123; int top[] = &#123;i, j, 0&#125;; int bottom[] = &#123;i + 1, j, 0&#125;; int left[] = &#123;i, j, 1&#125;; int right[] = &#123;i, j + 1, 1&#125;; int slash[] = &#123;i, j, 2&#125;; getEdge(top, right, slash); getEdge(bottom, left, slash); &#125; _for(i, 0, n - 1) &#123; int u = ID(i, 0, 1); int w = cost[i][0][1]; addEdge(0, u, w); &#125; _for(i, 0, m - 1) &#123; int u = ID(n - 1, i, 0); int w = cost[n - 1][i][0]; addEdge(0, u, w); &#125;&#125;// == build finsiehd ==void init() &#123; Set(cost, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; init(); initG(); // get data _for(i, 0, n) _for(j, 0, m-1) cost[i][j][0] = read(); _for(i, 0, n - 1) _for(j, 0, m) cost[i][j][1] = read(); _for(i, 0, n - 1) _for(j, 0, m - 1) cost[i][j][2] = read(); // build graph build(); // dijkstra dijkstra(0); // get ans int ans = inf; _for(i, 0, n - 1) ans = min(ans, D[ID(i, m - 1, 1)]); _for(i, 0, m - 1) ans = min(ans, D[ID(0, i, 0)]); //debug(ans); printf(\"Case %d: Minimum = %d\\n\", ++kase, ans); &#125;&#125; 最短路和dpZOJ1232 $\\textbf{i) run } floyd()$$\\quad f(i,j) \\leftarrow f(i, k) + f(k, j)$$\\quad \\quad \\textbf{if } k \\in [1,A], D[i,j] \\leqslant L$$\\quad \\quad \\quad (\\text{st} \\rightarrow k) \\text{ can use magic boot} \\textbf{, valid}(i, j) = 1$ $\\textbf{ii) }$ dp(i,k)=\\min\\left\\{\\begin{array}{ll} \\forall j","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"Graph","slug":"Graph","permalink":"https://www.fogsail.net/tags/Graph/"}]},{"title":"图算法和图模型(六)","slug":"20200521","date":"2020-05-25T10:22:21.000Z","updated":"2020-05-29T14:32:38.523Z","comments":true,"path":"2020/05/25/20200521/","link":"","permalink":"https://www.fogsail.net/2020/05/25/20200521/","excerpt":"spfa判负环，差分约束系统状态图，隐式图等等图论最短路算法中一些比较精彩的应用","text":"spfa判负环，差分约束系统状态图，隐式图等等图论最短路算法中一些比较精彩的应用 差分约束$\\textbf{algorithm: system of diffrence constraints}$$\\textbf{i)} \\quad \\forall i, j , \\quad x_j - x_i \\leqslant b_k$$\\quad \\quad \\Longrightarrow w(i, j) = b_k$$\\quad \\quad \\textbf{let src, } \\forall u \\in V(G), w(src, u) = 0$$\\textbf{ii)}\\quad \\text{run } \\textbf{spfa}()$$\\quad \\quad \\textbf{if negative cycle exists, } \\text{solution}=\\emptyset$$\\quad \\quad \\textbf{if no nega-cycle, } \\text{solution = } [\\cdots]$ $\\textbf{proof}$$\\quad \\forall e(u, v), \\quad l(v) &gt; l(u) + w(u, v)$$\\quad \\sum l(v) &gt; \\sum l(u) + \\sum w(u, v) , \\quad \\sum w(u, v) &lt; 0 $$\\quad \\Rightarrow \\sum l(v) = \\sum l(u)$ $\\quad \\forall u \\in V(G), \\text{bellman-Ford never stop, no solution}$ $\\textbf{problem}$$\\text{以 } v \\text{ 为终点的边权值减小 } k, \\text{ 以 } v \\text{ 为起点的边权值增加 }k$$\\text{变化后所有边的权值非负，并且尽量大}$ \\forall e(a, b), \\quad w(a, b) + \\sum_{k \\rightarrow a}(k)(a)- \\sum_{k \\rightarrow b} (k)(b) \\geqslant x \\\\ \\ \\\\ \\text{target:=} x_{\\max} \\\\ \\ \\\\ \\textbf{i) consider } x \\text{ value range, } x \\text{ is non-negative} \\\\ x \\geqslant 1 \\\\ \\ \\\\ \\textbf{ii) system of difference constraints} \\\\ \\ \\\\ \\sum_{k\\rightarrow b} (k)(b) - \\sum_{k \\rightarrow a}(k)(a) \\leqslant w(a, b) - x \\\\ \\ \\\\ w(a, b) - x_{\\max} \\leqslant w(a, b) - x \\leqslant w(a, b) - x_{\\min} \\\\ \\ \\\\ \\lim_{lhs} (\\textbf{not satisfy}) \\longleftrightarrow \\lim_{rhs} (\\textbf{satisfy}) \\\\ \\ \\\\ \\text{不等式右边比左边，更趋向于满足差分约束系统} \\\\ \\ \\\\ x \\in [1, \\max\\{w(a, b)\\}]$\\textbf{algorithm: binary-search}$$\\text{satisfy system, spfa() return true}$$\\text{not satisfy system, spfa() return false}$$\\textbf{if and only if no} \\text{ nega-Cycle, satisfy}$ $\\quad \\textbf{ if spfa}(x_{\\max} + 1)=\\textbf{true, solution} = \\infty$$\\quad \\textbf{ if spfa}(x_{\\min}) = \\textbf{false, solution} = \\emptyset$$\\quad \\text{ check mid}(x_{\\min}, x_{\\max}) \\Leftrightarrow \\text{mid}(L, R)$$\\quad \\quad \\textbf{ if mid } \\text{satisfy }, L = \\text{mid}, \\textbf{mid } \\uparrow$$\\quad \\quad \\textbf{ else } R = \\text{mid}, \\textbf{ mid } \\downarrow$ 思路还是常见的二分，如果中间值满足就尝试增加中间值，让它尽可能往 $\\textbf{not satisfy}$ 方向靠直到不满足为止 否则，就减小中间值，让它更容易 $\\textbf{satisfy}$ UVA11478 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117const int maxn = 500 + 10;const int inf = 0x3f3f3f3f;int n, m;// == Graph definition ==vector&lt;int&gt; G[maxn];class Edge &#123;public: int to, weight; Edge() &#123;&#125; Edge(int t, int w) : to(t), weight(w) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;void initG() &#123; edges.clear(); _for(i, 0, maxn) G[i].clear();&#125;void addEdge(int u, int v, int w) &#123; edges.push_back(Edge(v, w)); G[u].push_back(edges.size() - 1);&#125;// == Graph finished ==int cnt[maxn], inq[maxn];int D[maxn];void initSPFA() &#123; Set(cnt, 0); Set(inq, 0); Set(D, inf);&#125;// true: nega-cycle// false: non-negaCycleint spfa() &#123; initSPFA(); queue&lt;int&gt; que; _rep(i, 1, n) &#123; D[i] = 0; que.push(i); inq[i] = true; &#125; while (!que.empty()) &#123; int x = que.front(); que.pop(); inq[x] = 0; _for(i, 0, G[x].size()) &#123; const Edge&amp; e = edges[G[x][i]]; int y = e.to; if(D[y] &gt; D[x] + e.weight) &#123; D[y] = D[x] + e.weight; if(!inq[y]) &#123; que.push(y); inq[y] = true; if(++cnt[y] &gt; n) return true; &#125; &#125; &#125; &#125; return false;&#125;bool check(int x) &#123; _for(i, 0, edges.size()) &#123; edges[i].weight -= x; &#125; bool ret = spfa(); _for(i, 0, edges.size()) &#123; edges[i].weight += x; &#125; return !ret;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;n, &amp;m) == 2) &#123; initG(); // build graph int ud = 0; _for(i, 0, m) &#123; int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); addEdge(u, v, d); ud = max(ud, d); &#125; // build finished // x in [1, ud] //debug(ud); if(check(ud + 1)) printf(\"Infinite\\n\"); else if(!check(1)) printf(\"No Solution\\n\"); else &#123; int ans = 1; int L = 2, R = ud; while (L &lt;= R) &#123; int mid = (L + R) &gt;&gt; 1; //debug(mid); if(check(mid)) &#123; ans = mid; L = mid + 1; &#125; else R = mid - 1; &#125; printf(\"%d\\n\", ans); &#125; &#125;&#125; 状态图编码问题以 $\\textbf{colored cubes} 为例$ 群运算观点下的图形变换POJ2741 $\\text{change posture of cubes}$改变 $\\textbf{cubes}$ 的 $\\textbf{posture}$本质是一个$\\textbf{置换(permutation)}$ 由 $\\Omega \\rightarrow \\Omega$ 的变换组成的集合称为置换$S_n = S(\\Omega)$ $\\textbf{i) } S_n \\text{ 的单位元定义: } \\forall \\pi \\in S_n, \\ \\pi e = \\pi = e\\pi$$\\quad e:= \\textbf{for } \\forall i \\in [1, n]$$\\quad \\quad \\quad A(i) = i$ $\\textbf{ii) } \\pi: i \\mapsto \\pi(i), i = 1, 2, \\cdots, n$ \\pi:\\left(\\begin{array}{ccc} 1 & 2 & \\ldots & n \\\\ i_{1} & i_{2} & \\ldots & i_{n} \\end{array}\\right) \\\\ \\ \\\\ i_k \\in \\{1, 2, \\cdots, n\\}其本质是构成了一个$\\textbf{全排列映射}$ \\pi:\\left(\\begin{array}{ccc} 1 & 2 & \\ldots & n \\\\ \\downarrow & \\downarrow & \\ & \\downarrow \\\\ i_{1} & i_{2} & \\ldots & i_{n} \\end{array}\\right)$\\textbf{iii) } S_n \\text{上的乘法运算其实是置换的合成}$$\\quad \\text{ 构成了} \\textbf{ n 元对称群}$ $\\textbf{example}$ $\\textbf{algorithm1}$$\\textbf{permutation groups}$$\\textbf{i) for } \\forall i \\in [1, n], e:\\Rightarrow A(i) = i$$\\textbf{ii) }$ \\pi_{\\textbf{left}} A= D \\Rightarrow \\\\ \\ \\\\ \\textbf{trans} = \\pi_{\\textbf{left}}, \\quad \\textbf{rot(trans, A):}$\\quad \\textbf{for } \\forall i \\in [1, n], \\textbf{let } e = [A(i)]$$\\quad \\quad \\text{eg: }\\quad \\pi_{\\textbf{left}}(i) = p$$\\quad \\quad D=\\pi^{k} = (\\pi_k\\pi_{k-1}\\cdots \\pi_2\\pi_1) e$$\\quad \\quad D(i) = \\textbf{trans(A(i))}, \\text{ return } D$ $\\textbf{algorithm2 逆运算}$ (\\pi_1 \\pi_2 \\cdots \\pi_k) A = D \\Longrightarrow \\\\ \\ \\\\ A = (\\pi_k^{-1})(\\pi_{k-1}^{-1}) \\cdots (\\pi_1^{-1})D$\\textbf{permutation inversion}$$\\quad \\textbf{for } \\forall x \\in [1, n]$$\\quad \\quad \\ \\pi(x) = p$$\\quad \\quad \\ \\textbf{do } A(p) \\gets A(x)$ $\\textbf{main algorithm}$ $\\textbf{check()}$$\\text{get inversion: } ori(i) \\gets cube(i)$ $\\textbf{for } \\forall k \\in \\textbf{faces}[0, 1, \\cdots, 5], \\textbf{tot} = 0$$\\quad \\text{ get }\\textbf{ Max-color}$$\\quad \\textbf{ for } \\forall i \\in \\textbf{ori}[1, \\cdots, n]$$\\quad \\quad \\textbf{ Max-color=} \\max(\\textbf{Max-color}, \\textbf{ cnt}(ori(i, k)))$$\\quad \\textbf{ tot} = \\sum (n - \\textbf{colored-Max-face})$$\\textbf{ans = } \\min(\\textbf{ans, tot})$ $\\textbf{dfs}(d)$$\\quad \\ \\textbf{for } \\forall i \\in [0, 23)$$\\quad \\quad \\ \\text{cube(d) shapes as } \\textbf{posture } R(d) = i$$\\quad \\quad \\ \\textbf{dfs}(d + 1)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185// == enumerate permutation ==/*int LEFT[] = &#123;4, 0, 2, 3, 5, 1&#125;;int UP[] = &#123;2, 1, 5, 0, 4, 3&#125;;void rot(int *trans, int *A) &#123; int q[6]; memcpy(q, A, sizeof(q)); _for(i, 0, 6) A[i] = trans[q[i]];&#125;void enumerate() &#123; int E[6] = &#123;0, 1, 2, 3, 4, 5&#125;; _for(i, 0, 6) &#123; int A[6]; memcpy(A, E, sizeof(E)); if(i == 0) rot(UP, A); if(i == 1) &#123; rot(LEFT, A); rot(UP, A); &#125; if(i == 3) &#123; rot(UP, A); rot(UP, A); &#125; if(i == 4) &#123; rot(LEFT, A); rot(LEFT, A); rot(LEFT, A); rot(UP, A); &#125; if(i == 5) &#123; rot(LEFT, A); rot(LEFT, A); rot(UP, A); &#125; _for(k, 0, 4) &#123; printf(\"&#123;%d, %d, %d, %d, %d, %d&#125;,\\n\", A[0], A[1], A[2], A[3], A[4], A[5]); rot(LEFT, A); &#125; &#125;&#125;// == enumerate finsihed ==int main() &#123; freopen(\"out.txt\", \"w\", stdout); enumerate();&#125;*//*&#123;2, 1, 5, 0, 4, 3&#125;,&#123;2, 0, 1, 4, 5, 3&#125;,&#123;2, 4, 0, 5, 1, 3&#125;,&#123;2, 5, 4, 1, 0, 3&#125;,&#123;4, 2, 5, 0, 3, 1&#125;,&#123;5, 2, 1, 4, 3, 0&#125;,&#123;1, 2, 0, 5, 3, 4&#125;,&#123;0, 2, 4, 1, 3, 5&#125;,&#123;0, 1, 2, 3, 4, 5&#125;,&#123;4, 0, 2, 3, 5, 1&#125;,&#123;5, 4, 2, 3, 1, 0&#125;,&#123;1, 5, 2, 3, 0, 4&#125;,&#123;5, 1, 3, 2, 4, 0&#125;,&#123;1, 0, 3, 2, 5, 4&#125;,&#123;0, 4, 3, 2, 1, 5&#125;,&#123;4, 5, 3, 2, 0, 1&#125;,&#123;1, 3, 5, 0, 2, 4&#125;,&#123;0, 3, 1, 4, 2, 5&#125;,&#123;4, 3, 0, 5, 2, 1&#125;,&#123;5, 3, 4, 1, 2, 0&#125;,&#123;3, 4, 5, 0, 1, 2&#125;,&#123;3, 5, 1, 4, 0, 2&#125;,&#123;3, 1, 0, 5, 4, 2&#125;,&#123;3, 0, 4, 1, 5, 2&#125;,*/const int D[24][6] = &#123; &#123;2, 1, 5, 0, 4, 3&#125;, &#123;2, 0, 1, 4, 5, 3&#125;, &#123;2, 4, 0, 5, 1, 3&#125;, &#123;2, 5, 4, 1, 0, 3&#125;, &#123;4, 2, 5, 0, 3, 1&#125;, &#123;5, 2, 1, 4, 3, 0&#125;, &#123;1, 2, 0, 5, 3, 4&#125;, &#123;0, 2, 4, 1, 3, 5&#125;, &#123;0, 1, 2, 3, 4, 5&#125;, &#123;4, 0, 2, 3, 5, 1&#125;, &#123;5, 4, 2, 3, 1, 0&#125;, &#123;1, 5, 2, 3, 0, 4&#125;, &#123;5, 1, 3, 2, 4, 0&#125;, &#123;1, 0, 3, 2, 5, 4&#125;, &#123;0, 4, 3, 2, 1, 5&#125;, &#123;4, 5, 3, 2, 0, 1&#125;, &#123;1, 3, 5, 0, 2, 4&#125;, &#123;0, 3, 1, 4, 2, 5&#125;, &#123;4, 3, 0, 5, 2, 1&#125;, &#123;5, 3, 4, 1, 2, 0&#125;, &#123;3, 4, 5, 0, 1, 2&#125;, &#123;3, 5, 1, 4, 0, 2&#125;, &#123;3, 1, 0, 5, 4, 2&#125;, &#123;3, 0, 4, 1, 5, 2&#125;&#125;;// D[r[i]] get posture of ith cubeint n;const int maxn = 4;int ori[maxn][6];int cube[maxn][6];int r[maxn];int ans;vector&lt;string&gt; data;void init() &#123; ans = n * 6; data.clear(); Set(r, 0);&#125;inline int getID(const char *name) &#123; string str(name); _for(i, 0, data.size()) &#123; if(data[i] == str) return i; &#125; data.push_back(str); return data.size() - 1;&#125;// == check ==void inv(int ori[][6], const int cube[][6]) &#123; _for(i, 0, n) _for(j, 0, 6) &#123; int p = D[r[i]][j]; ori[i][p] = cube[i][j]; &#125;&#125;void check() &#123; inv(ori, cube); int tot = 0; _for(k, 0, 6) &#123; int Max = 0; int cnt[maxn * 6]; Set(cnt, 0); _for(i, 0, n) Max = max(Max, ++cnt[ori[i][k]]); tot += n - Max; &#125; ans = min(ans, tot);&#125;// == check finished ==// == dfs ==void dfs(int d) &#123; if(d == n) check(); else &#123; _for(i, 0, 24) &#123; r[d] = i; dfs(d + 1); &#125; &#125;&#125;// == dfs finished ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; init(); // get data of cubes _for(i, 0, n) _for(j, 0, 6) &#123; char name[30]; scanf(\"%s\", name); cube[i][j] = getID(name); &#125; dfs(1); printf(\"%d\\n\", ans); &#125;&#125; 状态空间建图UVALive4128 $\\textbf{i) state transition equation}$ $\\textbf{ii) start and end state}$ $\\textbf{algorithm}$$\\textbf{i) hash-coding for every state}$$\\quad \\textbf{for } \\forall dir, \\quad \\text{add(0, }\\textbf{Hash}(r_1, c_1, dir, 1), cost)$$\\quad \\textbf{for } \\forall \\textbf{r, c}, \\text{ according to equation}$$\\quad \\quad \\textbf{ u}(r,c), \\textbf{v}(nr, nc)$$\\quad \\quad \\textbf{ add}(\\textbf{Hash}(\\textbf{u}, dir, doubled), \\textbf{Hash}(\\textbf{v}, nDir, nDoubled), cost)$ $\\textbf{ii) run } Dijkstra()$$\\quad \\quad \\textbf{for } \\forall dir \\in[0, 4), \\forall doubled \\in [0,2)$$\\quad \\quad \\quad \\text{ get } \\min\\textbf{D}(\\text{Hash}(\\text{end},dir, double))$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180const int dr[] = &#123;-1, 0, 1, 0&#125;;const int dc[] = &#123;0, -1, 0, 1&#125;;const int UP = 0, LEFT = 1, DOWN = 2, RIGHT = 3;const int inv[] = &#123;2, 3, 0, 1&#125;;const int maxn = 100 + 5;int R, C, r1, c1, r2, c2;int cost[maxn][maxn][4];int N;const int maxN = maxn * maxn * 8 + 5;const int inf = 0x3f3f3f3f;inline int read() &#123; int x; scanf(\"%d\", &amp;x); return x;&#125;// == Graph defintion ==vector&lt;int&gt; G[maxN];class Edge &#123;public: int from, to, weight; Edge() &#123;&#125; Edge(int f, int t, int w) : from(f), to(t), weight(w) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;class Node &#123;public: int u, dist; bool operator&lt; (const Node&amp; rhs) const &#123; return dist &gt; rhs.dist; &#125; Node() &#123;&#125; Node(int u, int d) : u(u), dist(d) &#123;&#125;&#125;;void initG() &#123; edges.clear(); _for(i, 0, maxN) G[i].clear();&#125;void addEdge(int u, int v, int w) &#123; edges.push_back(Edge(u, v, w)); G[u].push_back(edges.size() - 1);&#125;// == Graph finsihed ==// == build data ==int id[maxn][maxn][4][2];int tot = 0;inline int ID(int r, int c, int dir, int doubled) &#123; int&amp; x = id[r][c][dir][doubled]; if(x != 0) return x; x = ++tot; return x;&#125;void init() &#123; tot = 0; Set(id, 0);&#125;// [1, R], [1, C]inline bool valid(int r, int c, int dir) &#123; if(r &lt;= 0 || r &gt; R || c &lt;= 0 || c &gt; C) return false; return cost[r][c][dir] &gt; 0;&#125;// == data finished ==// == build graph ==void build() &#123; _for(dir, 0, 4) if(valid(r1, c1, dir)) &#123; int u = ID(r1+dr[dir], c1+dc[dir], dir, 1); assert(u &gt;= 1); int w = cost[r1][c1][dir] * 2; addEdge(0, u, w); &#125; _rep(r, 1, R) _rep(c, 1, C) _for(dir, 0, 4) if(valid(r, c, inv[dir])) &#123; _for(nDir, 0, 4) if(valid(r, c, nDir)) &#123; _for(doubled, 0, 2) &#123; int nr = r + dr[nDir]; int nc = c + dc[nDir]; int w = cost[r][c][nDir]; int nDoubled = 0; if(nDir != dir) &#123; nDoubled = 1; if(!doubled) w += cost[r][c][inv[dir]]; w += cost[r][c][nDir]; &#125; addEdge(ID(r, c, dir, doubled), ID(nr, nc, nDir, nDoubled), w); &#125; &#125; &#125;&#125;// == build finsihed ==// == dijkstra ==int D[maxN], vis[maxN];void initDij(int st) &#123; Set(D, inf); D[st] = 0; Set(vis, 0);&#125;void dijkstra(int st) &#123; initDij(st); priority_queue&lt;Node&gt; que; que.push(Node(st, 0)); while (!que.empty()) &#123; int x = que.top().u; que.pop(); if(vis[x]) continue; vis[x] = 1; _for(i, 0, G[x].size()) &#123; const Edge&amp; e = edges[G[x][i]]; int y = e.to; if(D[y] &gt; D[x] + e.weight) &#123; D[y] = D[x] + e.weight; que.push(Node(y, D[y])); &#125; &#125; &#125;&#125;// == dijkstra finsihed ==// == solve ==void solve(int&amp; ans) &#123; _for(dir, 0, 4) _for(doubled, 0, 2) &#123; int ed = ID(r2, c2, dir, doubled); int res = D[ed]; if(!doubled) res += cost[r2][c2][inv[dir]]; ans = min(ans, res); &#125;&#125;// == solve finsihed ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while (scanf(\"%d%d%d%d%d%d\", &amp;R, &amp;C, &amp;r1, &amp;c1, &amp;r2, &amp;c2) == 6 &amp;&amp; R) &#123; init(); initG(); // input grid data _rep(r, 1, R) &#123; _rep(c, 1, C - 1) cost[r][c][RIGHT] = cost[r][c+1][LEFT] = read(); if(r != R) &#123; _rep(c, 1, C) cost[r][c][DOWN] = cost[r+1][c][UP] = read(); &#125; &#125; N = R*C*8 + 1; // build graph build(); // run dijkstra dijkstra(0); // solve int ans = inf; solve(ans); printf(\"Case %d: \", ++kase); if(ans == inf) printf(\"Impossible\\n\"); else printf(\"%d\\n\", ans); &#125;&#125; 差分dp差分约束可以解决一系列有条件约束的dp问题0/1 背包，完全背包等等 Problem Scores $\\text{比如说从一类物品中，每次选一个物品}, \\textbf{可以重复}$$\\text{问有多少种选择方法}$$在此基础上，加入约束条件，就是差分约束dp$ $\\textbf{algorithm1: dp()}$ $\\textbf{0-1 背包}$ f(i, j)=\\max \\left\\{\\begin{array}{l} f(i-1, j) && \\text{do not use ith item} \\\\ f\\left(i-1, j-V_{i}\\right)+w_{i} \\quad n>j \\geqslant V_{i} && \\text{use ith item} \\end{array}\\right.$(i-1) \\xrightarrow{update()} (i)$$\\textbf{for } \\forall j = n \\textbf{ downto } V_i$ $\\textbf{完全背包}$ f(i, j)=\\max \\left\\{\\begin{array}{l} f(i-1, j) && \\text{do not use ith} \\\\ f\\left(i, j-V_{i}\\right)+w_{i} \\quad V_i \\leqslant j < n && \\text{use ith} \\end{array}\\right.$(i) \\xrightarrow{update()} (i\\textbf{th itself})$$\\textbf{for } \\forall j = V_i \\textbf{ to } n$ 一个是用以前的阶段更新现在阶段一个是用当前阶段更新当前所以循环的顺序是不一样的 $\\textbf{algorithm2}$$1 \\leqslant a_i \\leqslant n, \\forall k, 1 \\leqslant k &lt; n $都有对任意大小为 $k$ 的子集 $S$ 和大小为 $k+1$ 的子集 $T$ \\sum_{x \\in S} a_x < \\sum_{x \\in T} a_x这样的集合有多少个？ $\\textbf{i) }$ \\textbf{if }\\quad k = \\lfloor \\frac{n}{2} \\rfloor \\text{ meet the conditions } \\\\ \\ \\\\ \\sum_{i = 1}^{k+1}a_i \\geqslant \\sum_{i = n-k+1}^{n} a_i, \\quad (n-k+1= k+1 \\Rightarrow k = \\lfloor \\frac{n}{2}\\rfloor) \\text{根据序列的单调性，} k < \\lfloor \\frac{n}{2}\\rfloor \\\\ \\ \\\\ 相当于 (\\sum_{i = 1}^{k+1}a_i)-\\sum a_p \\geqslant?? ( \\sum_{i = n-k+1}^{n} a_i) + \\sum a_q, \\\\ \\quad (\\sum a_p < \\sum a_q, \\ p < q), \\text{ 不等式仍然成立}$\\textbf{所以只要有 } k = \\lfloor \\frac{n}{2} \\rfloor \\textbf{ 成立，所有情况都成立}$ $\\textbf{ii) 差分数组的构造}$ \\Delta a_i = a_i - a_{i-1} \\\\ \\ \\\\ \\Rightarrow \\sum_{i = 1}^{\\lfloor \\frac{n}{2} \\rfloor + 1} \\sum_{j=1}^{i} \\Delta a_j \\geqslant \\sum_{i = n - \\lfloor \\frac{n}{2} \\rfloor +1}^{n} \\sum_{j=1}^{i} \\Delta a_j$\\textbf{if } n = \\textbf{odd number}, \\lfloor \\frac{n}{2} \\rfloor = \\frac{n-1}{2}$ \\sum_{i = 1}^{\\frac{n+1}{2}} \\sum_{j=1}^{i} \\Delta a_j \\geqslant \\sum_{i = \\frac{n+1}{2}+1}^{n} \\sum_{j=1}^{i} \\Delta a_j \\\\ \\ \\\\ \\xrightarrow{\\textbf{两边+}} \\sum_{i = 1}^{\\frac{n+1}{2}}\\sum_{j = 1}^{i} \\Delta a_j \\Rightarrow 2\\sum_{i = 1}^{\\frac{n+1}{2}} \\sum_{j=1}^{i} \\Delta a_j \\geqslant \\sum_{i = 1}^{n} \\sum_{j=1}^{i} \\Delta a_j \\\\ \\ \\\\ 2\\sum_{i=1}^{\\frac{n+1}{2}}(\\frac{n+1}{2}-i+1)\\Delta a_i \\geqslant \\sum_{i=1}^{n} (n-i+1) \\Delta a_i \\\\ \\ \\\\ (\\sum_{i = 1}^{n}(n-i+1) - 2\\sum_{i = 1}^{\\frac{n+1}{2}}(\\frac{n+1}{2}-i+1)) \\Delta a_i \\leqslant 0 \\\\ \\ \\\\ \\sum_{i = 1}^{n} C_i \\Delta a_i \\leqslant 0 \\\\ \\ \\\\ C_{i}=\\left\\{\\begin{array}{ll} n-i+1 && i>\\frac{n+1}{2} \\\\ (n-i+1)-2\\left(\\frac{n+1}{2}-i+1\\right)= i-2&& i \\leqslant \\frac{n+1}{2} \\end{array}\\right.$\\textbf{if } n = \\textbf{even number}, \\lfloor \\frac{n}{2} \\rfloor = \\frac{n}{2}$ \\sum_{i=1}^{\\frac{n}{2}+1} \\sum_{j=1}^{i} \\Delta a_{j} \\geqslant \\sum_{i=\\frac{n}{2}+1}^{n} \\sum_{j=1}^{i} \\Delta a_{j} \\xrightarrow{\\text{减掉}i = n/2+1 \\text{这一项}} \\\\ \\ \\\\ \\sum_{i=1}^{\\frac{n}{2}} \\sum_{j=1}^{i} \\Delta a_{j} \\geqslant \\sum_{i=\\frac{n}{2}+2}^{n} \\sum_{j=1}^{i} \\Delta a_{j} \\\\ \\ \\\\ 2\\sum_{i=1}^{\\frac{n}{2}} \\sum_{j=1}^{i} \\Delta a_{j} \\geqslant \\sum_{i=1}^{n} \\sum_{j=1}^{i} \\Delta a_{j} - \\sum_{i=1}^{\\frac{n}{2}+1} \\Delta a_{i} \\\\ \\ \\\\ 2 \\sum_{i=1}^{\\frac{n}{2}}\\left(\\frac{n}{2}-i+1\\right)\\Delta a_{i} \\geqslant \\sum_{i=1}^{n}(n-i+1) \\Delta a_{i}-\\sum_{i=1}^{\\frac{n}{2}+1} \\Delta a_{i} \\\\ \\ \\\\ \\sum_{i = 1}^{n} C_i \\Delta a_i \\leqslant 0 \\\\ \\ \\\\ C_{i}=\\left\\{\\begin{array}{ll} n-i+1 && i>\\frac{n}{2} +1\\\\ i-2&& i \\leqslant \\frac{n}{2} \\\\ n-i && i = \\frac{n}{2}+1 \\end{array}\\right. i = \\frac{n}{2} + 1 \\Rightarrow C_i = \\frac{n}{2}-1 \\Rightarrow C_i = i - 2 \\\\ \\ \\\\ C_{i}=\\left\\{\\begin{array}{ll} n-i+1 && i>\\frac{n}{2} +1\\\\ i-2&& i \\leqslant \\frac{n}{2}+1 \\end{array}\\right.$\\textbf{iii)}$综上所述 C_{i}=\\left\\{\\begin{array}{ll} n-i+1 && i>\\lfloor \\frac{n}{2} \\rfloor +1\\\\ i-2&& i \\leqslant \\lfloor \\frac{n}{2}\\rfloor + 1 \\end{array}\\right. \\\\ \\ \\\\ \\sum_{i = 1}^{n} C_i \\Delta a_i \\leqslant 0$i = 1, C_1 = -1 &lt;0$$\\sum \\Delta a_i + 1 \\leqslant n$ \\left\\{\\begin{array}{l} a_{1} \\leqslant n-1-\\sum_{i=2}^{n} a_{i} \\\\ a_{1} \\geqslant \\sum_{i=2}^{n} a_{i} \\end{array}\\right.由此原问题转换为求满足条件 $a_1$ 的个数 \\textbf{cnt} = ( n-1-\\sum_{i=2}^{n} a_{i} ) - (\\sum_{i = 2}^{n} C_ia_i) +1 \\\\ \\ \\\\ = n-\\sum_{i=2}^{n} (C_i+1)a_{i}$\\textbf{iv) algorithm} $ f(i) :=\\Rightarrow \\sum_{i=2}^{n} (C_i+1)a_{i}=i \\\\ \\ \\\\ \\text{方案数} \\\\ \\ \\\\ \\max\\{0, n-\\sum_{i=2}^{n} (C_i+1)a_{i}\\}, \\quad i \\in [0, n-1] \\\\ \\ \\\\ \\textbf{ans = } \\sum_{i = 0}^{n-1} (n-i) \\cdot f(i)$\\quad \\textbf{ calculate } f(i), \\textbf{使用完全背包}$$\\quad \\text{ 此时从 } \\forall i \\in[2, n] \\text{ 的物品中选 }$$\\quad \\text{ 第 } i \\text{ 个物品重量为 } B_i = C_i + 1$$\\quad \\text{ 可以重复选, 每种物品可以选 } a_i \\text{次}$$\\quad \\text{ 其中背包总重量不超过 }n-1, \\text{ 求方案数}$ 1234567891011121314151617181920212223242526272829303132333435const int maxn = 5000 + 10;int n, m;int f[maxn], C[maxn];void initDP() &#123; Set(f, 0); f[0] = 1; int mid = n &gt;&gt; 1; _rep(i, 2, mid + 1) C[i] = i - 1; _rep(i, mid + 2, n) C[i] = n - i + 2;&#125;int dp() &#123; initDP(); _rep(i, 2, n) _rep(j, C[i], n - 1) &#123; f[j] = (f[j] + f[j - C[i]]) % m; &#125; ll ans = 0; _rep(i, 0, n - 1) &#123; ans = ans + 1ll * (n - i) * f[i] % m; ans %= m; &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;m); int res = dp(); cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"Graph","slug":"Graph","permalink":"https://www.fogsail.net/tags/Graph/"}]},{"title":"图算法和图模型(五)","slug":"20200520","date":"2020-05-23T09:38:49.000Z","updated":"2020-05-25T09:42:16.298Z","comments":true,"path":"2020/05/23/20200520/","link":"","permalink":"https://www.fogsail.net/2020/05/23/20200520/","excerpt":"这篇博文重点讲状态依赖的最短路问题以spfa，负环判断为主另外还讲了一些最短路算法在实践中的应用","text":"这篇博文重点讲状态依赖的最短路问题以spfa，负环判断为主另外还讲了一些最短路算法在实践中的应用 状态依赖的SPFA算法电梯调度问题 $(x, j) \\ \\text{表示电梯当前在 } x \\text{ 层，手柄位置为 } j$$\\text{spfa queue statues}$$:= vis(x, j)$ $\\textbf{for } \\forall i \\in [1, m] \\leftrightarrow \\text{next position}$$\\quad \\quad w=|i-j|+2|C(i)|$ d(x+C[i], i) = \\min\\{d(x+C[i],i), d(x,j)+w\\} \\\\ \\ \\\\ \\text{run spfa()}spfa算法注意点在计算下一个状态的时候$\\textbf{判断!inq[next]}$123456if(D[next] &gt; D[cur] + w) &#123; if(!inq[next]) &#123; que.push(next); inq[next] = 1; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#define MPR(a, b) make_pair(a, b)const int maxn = 1000 + 5;const int maxm = 20 + 5;const int inf = 0x3f3f3f3f;int n, m;int D[maxn][maxm], inq[maxn][maxm];typedef pair&lt;int, int&gt; PII;int C[maxn];// == run spfa ==void initSpfa() &#123; Set(inq, 0); Set(D, inf);&#125;void spfa(int st_x, int st_j) &#123; queue&lt;PII&gt; que; que.push(MPR(st_x, st_j)); D[st_x][st_j] = 0; inq[st_x][st_j] = 1; while (!que.empty()) &#123; int x = que.front().first; int j = que.front().second; que.pop(); inq[x][j] = 0; _rep(i, 1, m) &#123; int nx = x + C[i]; int w = abs(i - j) + 2 * abs(C[i]); if(nx &lt; 1 || nx &gt; n) continue; if(D[nx][i] &gt; D[x][j] + w) &#123; D[nx][i] = D[x][j] + w; if(!inq[nx][i]) &#123; que.push(MPR(nx, i)); inq[nx][i] = 1; &#125; &#125; &#125; &#125;&#125;// == spfa finsihed ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;m); int pos = 0; _rep(i, 1, m) &#123; scanf(\"%d\", &amp;C[i]); if(C[i] == 0) pos = i; &#125; // then spfa initSpfa(); spfa(1, pos); int ans = inf; _rep(i, 1, m) ans = min(ans, D[n][i]); if(ans == inf) puts(\"-1\"); else printf(\"%d\\n\", ans);&#125; floyd路径统计algorithm $c(i, j) \\text{用来记录 } i \\rightarrow j \\text{ 最短路的条数}$$\\textbf{i) } \\quad \\textbf{for } \\forall e(u, v) \\in E(G)$$\\ \\ \\ \\quad \\quad \\quad init: \\ c(u, v) = 1$$\\textbf{ii)} \\quad \\textbf{if} \\quad d(u,v) &gt; d(u, k) + d(k, v)$$\\quad \\quad \\quad \\quad c(u, v) = c(u, k) \\cdot c(k, v)$$\\quad \\quad \\textbf{if} \\quad d(u, v) = d(u, k) + d(k, v)$$\\quad \\quad \\quad \\quad c(u, v) += c(u, k) \\cdot c(k, v)$$\\textbf{iii)}$ \\text{经过 } k \\text{ 的最短路，满足 floyd 方程} \\\\ \\forall (i, j), i \\neq j, \\quad d(i,j) = d(i,k)+d(k, j)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int maxn = 100 + 10;const int inf = 0x3f3f3f3f;int n, m;int d[maxn][maxn];ll c[maxn][maxn];double ans[maxn];void initFloyd() &#123; Set(d, inf); _rep(i, 0, n) d[i][i] = 0; Set(c, 0); Set(ans, 0.0);&#125;void floyd() &#123; _rep(k, 1, n) _rep(i, 1, n) _rep(j, 1, n) &#123; if(i != j &amp;&amp; k != i &amp;&amp; k != j) &#123; if(d[i][j] &gt; d[i][k] + d[k][j]) &#123; d[i][j] = d[i][k] + d[k][j]; c[i][j] = 1ll * c[i][k] * c[k][j]; &#125; else if(d[i][j] == d[i][k] + d[k][j]) &#123; c[i][j] += 1ll * c[i][k] * c[k][j]; &#125; &#125; &#125;&#125;void solve() &#123; _rep(k, 1, n) _rep(i, 1, n) _rep(j, 1, n) &#123; if(i != j &amp;&amp; k != i &amp;&amp; k != j) &#123; if(d[i][j] == d[i][k] + d[k][j]) &#123; ans[k] += (double) c[i][k] * c[k][j] / c[i][j]; &#125; &#125; &#125; _rep(i, 1, n) printf(\"%.3lf\\n\", ans[i]);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;m); initFloyd(); _for(i, 0, m) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); d[x][y] = d[y][x] = z; c[x][y] = c[y][x] = 1ll; &#125; floyd(); solve();&#125; Dijkstra和DAG上的dp$\\textbf{algorithm}$$\\textbf{i) } \\text{ run dijkstra()}$$\\quad \\quad \\textbf{we get } \\forall u, \\textbf{D(u)}$$\\textbf{ii) dp}(st\\leftarrow ed) , \\textbf{ begin: consider ed}$$\\quad \\quad \\quad f(ed) = 1, f(v/ed) = 0$$\\quad \\quad \\quad \\textbf{sort according to } D[u]\\rightarrow ord[\\cdots], \\ ord_0 = ed$$\\quad \\quad \\quad \\textbf{now } D(ord_0)=0, D(ord_1), D(ord_2) \\uparrow \\cdots $$\\quad \\quad \\quad \\textbf{for } \\forall x = ord_i \\textbf{ for } \\forall e(x, y)$$\\quad \\quad \\quad \\quad \\textbf{ if } D(y) &gt; D(x), f(y) += f(x)$$\\quad \\quad \\quad \\text{ans is } f(st)$ $\\text{in this case, run dp() in } \\textbf{every node}$ $\\textbf{iii) dp}(st\\rightarrow ed), \\textbf{begin: consider dp(st, ed)}$$\\quad \\quad \\quad \\textbf{init set } f[\\cdots] \\leftarrow -1$$\\quad \\quad \\quad \\textbf{dp}(x, ed)$$\\quad \\quad \\quad \\quad \\textbf{ if } x = ed, \\text{return } 1$$\\quad \\quad \\quad \\quad \\textbf{ if } f(x) \\geqslant 0, \\text{found ans, return } f(x)$$\\quad \\quad \\quad \\quad \\textbf{ let } f(x) = 0, \\textbf{for } \\forall e(x, y)$$\\quad \\quad \\quad \\quad \\quad \\textbf{ if } D(y) &lt; D(x), f(x) +=dp(y, ed)$$\\quad \\quad \\quad \\quad \\text{ return } f(x)$ $\\text{run dp() recursive }$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134const int maxn = 1000 + 10;const int inf = 0x3f3f3f3f;int n, m;// == Graph definition ==vector&lt;int&gt; G[maxn];class Edge &#123;public: int to, weight; Edge() &#123;&#125; Edge(int t, int w) : to(t), weight(w) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;void initG() &#123; _for(i, 0, maxn) G[i].clear(); edges.clear();&#125;void addEdge(int u, int v, int w) &#123; edges.push_back(Edge(v, w)); G[u].push_back(edges.size() - 1);&#125;class Node &#123;public: int u, dist; bool operator&lt; (const Node&amp; rhs) const &#123; return dist &gt; rhs.dist; &#125; Node() &#123;&#125; Node(int u, int d) : u(u), dist(d) &#123;&#125;&#125;;// == Graph finished ==// == dijkstra ==int D[maxn], vis[maxn];void initDij(int st) &#123; Set(D, inf); D[st] = 0; Set(vis, 0);&#125;void dijkstra(int st) &#123; initDij(st); priority_queue&lt;Node&gt; que; que.push(Node(st, 0)); while (!que.empty()) &#123; int x = que.top().u; que.pop(); if(vis[x]) continue; vis[x] = 1; _for(i, 0, G[x].size()) &#123; const Edge&amp; e = edges[G[x][i]]; int y = e.to; if(D[y] &gt; D[x] + e.weight) &#123; D[y] = D[x] + e.weight; que.push(Node(y, D[y])); &#125; &#125; &#125;&#125;// == dijkstra finished ==// == dp ==inline bool cmp(int a, int b) &#123; return D[a] &lt; D[b];&#125;int ord[maxn];int f[maxn];void initDP(const int ed) &#123; _rep(i, 1, n) ord[i] = i; sort(ord + 1, ord + 1 + n, cmp); //assert(ed == ord[1]); Set(f, 0); f[ed] = 1;&#125;void dp(const int st) &#123; _rep(i, 1, n) &#123; int x = ord[i]; _for(j, 0, G[x].size()) &#123; int y = edges[G[x][j]].to; if(D[y] &gt; D[x]) f[y] += f[x]; &#125; &#125; printf(\"%d\\n\", f[st]);&#125;void initDP() &#123; Set(f, -1);&#125;int dp(int x, const int ed) &#123; if(x == ed) return 1; if(f[x] &gt;= 0) return f[x]; f[x] = 0; _for(i, 0, G[x].size()) &#123; int y = edges[G[x][i]].to; if(D[y] &lt; D[x]) f[x] += dp(y, ed); &#125; return f[x];&#125;// == dp finsiehd ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; initG(); _for(i, 0, m) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); addEdge(x, y, z); addEdge(y, x, z); &#125; // run dijkstra dijkstra(2); // then dp initDP(2); dp(1); //initDP(); //printf(\"%d\\n\", dp(1, 2)); &#125;&#125; 最短路树$\\textbf{algorithm: } e(x, u):=p(u) \\textbf{ is the forward arc(前向弧)}$$\\textbf{run } dijkstra() \\text{ and record } p()$ \\textbf{Dijkstra-Tree := } \\bigcup\\limits_{p(u) \\in path}e(p(u))$\\textbf{i) init: } W(u, v) = \\bigcup\\limits_{weights}w(u, v)$$\\quad \\text{multiple edges, } idx(u, v) := \\text{edge number}$$\\quad used(src, u, v):= \\text{ run dijkstra}(src), e(u, v)\\text{ is Tree-edge or not}$ $\\textbf{ii) for } \\forall src \\in V(G)$$\\quad \\quad \\textbf{run Dijkstra}(src) \\rightarrow \\text{ mark } p(\\cdots)$$\\quad \\quad \\textbf{for } \\forall u \\in V(G), \\forall e(u, v) \\in \\textbf{Dijkstra-Tree}(G)$$\\quad \\quad \\quad \\quad C(src) = \\sum_u D(u), \\text{ mark } used(src, u, v)$$\\quad \\textbf{ ans} = \\sum C(src)$ $\\textbf{iii) consider delete operation }$$\\quad \\quad \\textbf{del}(u, v)\\Rightarrow w(u, v) = 0 \\textbf{ or } w(u, v) = W(u, v)[2, 3, \\cdots]$$\\quad \\quad \\textbf{for }\\forall src \\in V(G)$$\\quad \\quad \\quad \\textbf{ if } used(src, u, v)=0, \\textbf{ ans }= \\sum C(src)$$\\quad \\quad \\quad \\textbf{ else } \\text{rebuild Dijkstra-Tree}$$\\quad \\quad \\quad \\quad \\text{ run Dijkstra}(src)$$\\quad \\quad \\quad \\quad \\textbf{ for } \\forall u \\in V(G)$$\\quad \\quad \\quad \\quad \\quad \\textbf{ ans} = \\sum D(u)$ $\\quad \\quad \\textbf{reset } w(u, v) = W(u, v)[0]$ UVA1416 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164const int maxn = 100 + 10;const int inf = 0x3f3f3f3f;int n, m, L;vector&lt;int&gt; W[maxn][maxn];int used[maxn][maxn][maxn];int idx[maxn][maxn];// == Graph definition ==vector&lt;int&gt; G[maxn];class Edge &#123;public: int from, to, weight; Edge() &#123;&#125; Edge(int f, int t, int w) : from(f), to(t), weight(w) &#123;&#125;&#125;;class Node &#123;public: int u, dist; Node() &#123;&#125; Node(int u, int d) : u(u), dist(d) &#123;&#125; bool operator&lt; (const Node&amp; rhs) const &#123; return dist &gt; rhs.dist; &#125;&#125;;vector&lt;Edge&gt; edges;void initG() &#123; _for(i, 0, maxn) G[i].clear(); edges.clear();&#125;void addEdge(int u, int v, int w) &#123; edges.push_back(Edge(u, v, w)); G[u].push_back(edges.size() - 1); idx[u][v] = edges.size() - 1;&#125;// == Graph finished ==// == Dijkstra ==int p[maxn];int D[maxn], vis[maxn];void initDij(int st) &#123; Set(p, 0); Set(vis, 0); Set(D, inf); D[st] = 0;&#125;void dijkstra(int st) &#123; initDij(st); priority_queue&lt;Node&gt; que; que.push(Node(st, 0)); while (!que.empty()) &#123; int x = que.top().u; que.pop(); if(vis[x]) continue; vis[x] = 1; _for(i, 0, G[x].size()) &#123; const Edge&amp; e = edges[G[x][i]]; int y = e.to; if(e.weight &gt; 0 &amp;&amp; D[y] &gt; D[x] + e.weight) &#123; D[y] = D[x] + e.weight; p[y] = G[x][i]; que.push(Node(y, D[y])); &#125; &#125; &#125;&#125;// == Dijkstra finished ==// == solver ==int C[maxn];void initCal() &#123; Set(C, 0);&#125;int cal() &#123; initCal(); int ans = 0; _rep(st, 1, n) &#123; dijkstra(st); _rep(v, 1, n) &#123; if(v != st) &#123; int u = edges[p[v]].from; used[st][u][v] = used[st][v][u] = 1; &#125; C[st] += (D[v] == inf ? L : D[v]); &#125; ans += C[st]; &#125; return ans;&#125;int del(int u, int v) &#123; Edge&amp; e1 = edges[idx[u][v]]; Edge&amp; e2 = edges[idx[v][u]];; if(W[u][v].size() == 1) e1.weight = e2.weight = 0; else if(W[u][v].size() &gt; 1) e1.weight = e2.weight = W[u][v][1]; int ans = 0; _rep(st, 1, n) &#123; if(used[st][u][v] == 0) ans += C[st]; else &#123; dijkstra(st); _rep(i, 1, n) ans += (D[i] == inf ? L : D[i]); &#125; &#125; e1.weight = e2.weight = W[u][v][0]; return ans;&#125;// == solver finsihed ==void init() &#123; _for(i, 0, maxn) _for(j, 0, maxn) W[i][j].clear(); Set(used, 0); Set(idx, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;L) == 3) &#123; init(); initG(); // build graph _for(i, 0, m) &#123; int u, v, s; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;s); W[u][v].push_back(s); W[v][u].push_back(s); &#125; _rep(i, 1, n) _rep(j, i + 1, n) &#123; if(W[i][j].size()) &#123; sort(W[i][j].begin(), W[i][j].end()); addEdge(i, j, W[i][j][0]); addEdge(j, i, W[i][j][0]); &#125; &#125; // build finished // solve the problem int c1 = cal(); int c2 = -1; _rep(i, 1, n) _rep(j, i + 1, n) if(W[i][j].size()) &#123; c2 = max(c2, del(i, j)); &#125; printf(\"%d %d\\n\", c1, c2); &#125;&#125; Dijkstra杂题，路径输出$\\textbf{ceil}(x) := \\geqslant x \\textbf{(离x最近的整数)}$常常用来处理以下问题，比如每 $k$ 个单位要缴纳 $1$ 单位不足 $1$ 单位按 $1$ 单位来算 D(u) \\xrightarrow{x=\\frac{D(u)+x}{K}} D(u)+x (K-1)x = D(u) \\Leftrightarrow x = \\frac{D(u)}{K-1} \\\\ \\ \\\\ \\text{rhs} = D(u) + x = \\textbf{ceil}(\\frac{D(u)}{K-1} \\cdot K)$\\textbf{i) } \\text{ run dijkstra}(), \\textbf{ get } D_{to}$$\\quad \\textbf{ for } \\forall e(x, y)$$\\quad \\quad \\textbf{ if } D(y) &gt; D_{to}, D(y)=D_{to}, p(y) = e(x, y)$$\\quad \\quad \\textbf{ if } D(y) = D_{to}, \\ ([x_1, x_2], y), \\ x_2 &lt; x_1$$\\quad \\quad \\quad \\quad (x_1, y) \\rightarrow (x_2, y), \\quad p(y) = e(x_2, y)$ $\\textbf{ii) } \\text{ output path}$$\\quad \\quad \\text{ run dijkstra}(ed\\rightarrow st)$$\\quad \\quad \\text{ out}(ed \\leftarrow st)$$\\quad \\quad \\text{ out}(u, V(p(u)), V(p(p(u))), \\cdots)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136const int maxn = 100 + 5;const ll inf = 0x3f3f3f3f3f3f3f3f;int n, P, st, ed;// == Graph definition ==vector&lt;int&gt; G[maxn];class Edge &#123;public: int from, to, isUp; Edge() &#123;&#125; Edge(int f, int t, int w) : from(f), to(t), isUp(w) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;class Node &#123;public: int u; ll dist; Node() &#123;&#125; Node(int u, ll d) : u(u), dist(d) &#123;&#125; bool operator&lt; (const Node&amp; rhs) const &#123; return dist &gt; rhs.dist; &#125;&#125;;void initG() &#123; edges.clear(); _for(i, 0, maxn) G[i].clear();&#125;void addEdge(int u, int v, int isUp) &#123; edges.push_back(Edge(u, v, isUp)); G[u].push_back(edges.size() - 1);&#125;// == Graph finsihed ==inline int read() &#123; char ch[9]; scanf(\"%s\", ch); if(isupper(ch[0])) return ch[0] - 'A'; else return ch[0] - 'a' + 26;&#125;inline char format(int u) &#123; return u &lt; 26 ? 'A' + u : 'a' + (u - 26);&#125;inline bool isUp(int u) &#123; return u &lt; 26 ? 1 : 0;&#125;// == dijkstra ==ll D[maxn];int vis[maxn];int pid[maxn];void initDij(ll P, int st) &#123; _for(i, 0, maxn) D[i] = inf; D[st] = P; Set(vis, 0); Set(pid, 0); pid[st] = -1;&#125;void dijkstra(ll P, int st) &#123; initDij(P, st); priority_queue&lt;Node&gt; que; que.push(Node(st, P)); while (!que.empty()) &#123; int x = que.top().u; que.pop(); //debug(D[x]); if(vis[x]) continue; vis[x] = 1; _for(i, 0, G[x].size()) &#123; const Edge&amp; e = edges[G[x][i]]; int y = e.to; ll d_to; if(e.isUp) d_to = (ll)ceil(D[x] * 1.0 / 19 * 20); else d_to = D[x] + 1; //debug(d_to); if(D[y] &gt; d_to || (D[y] == d_to &amp;&amp; format(x) &lt; format(edges[pid[y]].from))) &#123; D[y] = d_to; pid[y] = G[x][i]; que.push(Node(y, D[y])); &#125; &#125; &#125;&#125;void print(int u) &#123; if(pid[u] == -1) &#123; printf(\"%c\\n\", format(u)); return; &#125; printf(\"%c-\", format(u)); print(edges[pid[u]].from);&#125;// == dijkstra finsihed ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n &gt;= 0) &#123; initG(); printf(\"Case %d:\\n\", ++kase); // build graph _for(i, 0, n) &#123; int u = read(); int v = read(); if(u != v) &#123; addEdge(u, v, isUp(u)); addEdge(v, u, isUp(v)); &#125; &#125; // graph finished // then dijkstra scanf(\"%d\", &amp;P); st = read(); ed = read(); //debug(ed); dijkstra(P, ed); printf(\"%lld\\n\", D[st]); print(st); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"Graph","slug":"Graph","permalink":"https://www.fogsail.net/tags/Graph/"}]},{"title":"图算法和图模型(四)","slug":"20200519","date":"2020-05-20T14:00:48.000Z","updated":"2020-05-23T09:38:38.224Z","comments":true,"path":"2020/05/20/20200519/","link":"","permalink":"https://www.fogsail.net/2020/05/20/20200519/","excerpt":"这篇博文主要讲述了最短路算法中可能会用得到的建图技巧","text":"这篇博文主要讲述了最短路算法中可能会用得到的建图技巧 隐式图Dijkstra$\\text{隐式图 Dijkstra 的核心在于，一边 Dijkstra 一边建图}$$\\forall u \\in V(G), u \\text{ 一般情况表示状态编码 }$ $\\textbf{algorithm}$$\\textbf{u(state, dist)}$$\\textbf{i)} \\quad \\text{get start status}$$\\ \\ \\ \\quad que \\leftarrow\\text{st(stateCode, 0)}$$\\textbf{ii)} \\ \\ \\textbf{while(que.size())}$$\\quad \\quad \\quad \\text{get u = que.front(), que.pop()}$$\\quad \\quad \\quad \\text{if u = endState, return } \\textbf{D(u)}$ $\\quad \\quad \\quad \\textbf{for } \\forall i \\in \\text{candidates}$$\\quad \\quad \\quad \\quad \\text{check}(edges(i)) \\text{ is available?}$$\\quad \\quad \\quad \\quad \\text{if(check == false and not available) } continue$$\\quad \\quad \\quad \\quad \\text{get } \\textbf{v(newState, u.dist + e(u, v))}$$\\quad \\quad \\quad \\quad \\text{sometimes change v.state}$$\\quad \\quad \\quad \\quad D(v) = \\min(D(v), v.dist)$$\\quad \\quad \\quad \\quad \\quad \\text{ if changed, que.push}(v)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const int maxn = 20;const int maxm = 100 + 5;const int inf = 0x3f3f3f3f;int T[maxm];int n, m;// == node definition ==class Node &#123;public: int state, dist; bool operator&lt; (const Node&amp; rhs) const &#123; return dist &gt; rhs.dist; &#125; Node() &#123;&#125; Node(int s, int d) : state(s), dist(d) &#123;&#125;&#125;;int D[1&lt;&lt;maxn], vis[1&lt;&lt;maxn];char before[maxm][maxn], after[maxm][maxn];void initG() &#123; Set(D, inf); Set(vis, 0);&#125;// == node finished ==// == Dijkstra ==bool valid(const Node&amp; u, const int k) &#123; // check before patches k _for(i, 0, n) &#123; if(before[k][i] == '-' &amp;&amp; ((1&lt;&lt;i) &amp; u.state)) return false; if(before[k][i] == '+' &amp;&amp; !((1&lt;&lt;i) &amp; u.state)) return false; &#125; return true;&#125;int dijkstra() &#123; priority_queue&lt;Node&gt; que; Node st((1&lt;&lt;n)-1, 0); que.push(st); D[st.state] = 0; while (!que.empty()) &#123; Node x = que.top(); que.pop(); if(x.state == 0) return D[x.state]; if(vis[x.state]) continue; vis[x.state] = 1; // get next y _rep(i, 1, m) &#123; bool patchable = valid(x, i); if(!patchable) continue; // use patches i Node y(x.state, x.dist + T[i]); _for(j, 0, n) &#123; if(after[i][j] == '+') y.state |= (1&lt;&lt;j); if(after[i][j] == '-') y.state &amp;= ~(1&lt;&lt;j); &#125; if(D[y.state] &gt; y.dist) &#123; D[y.state] = y.dist; que.push(y); &#125; &#125; &#125; return -1;&#125;// == Dijkstra finsihed ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; initG(); _rep(i, 1, m) scanf(\"%d%s%s\", &amp;T[i], before[i], after[i]); printf(\"Product %d\\n\", ++kase); // then solve the problem int ans = dijkstra(); if(ans &lt; 0) printf(\"Bugs cannot be fixed.\\n\\n\"); else printf(\"Fastest sequence takes %d seconds.\\n\\n\", ans); &#125;&#125; 状态依赖的Dijkstra$如果边加入一个时间维度，规定在某个时间段内可以走$$\\forall e \\in E(G)$$\\quad [0, a]:= \\text{pass}$$\\quad [a+1, a+b]:= \\text{can not pass}$ $\\textbf{algorithm}$$\\textbf{u(id, dist)}, D(V)=\\infty$$\\textbf{i)} \\quad \\text{get st}$$\\ \\ \\ \\quad que \\leftarrow\\text{st(s, 0), D(s) = 0}$$\\textbf{ii)} \\ \\ \\textbf{while(que.size())}$$\\quad \\quad \\quad \\text{get u = que.front(), que.pop()}$$\\quad \\quad \\quad \\text{check } \\forall e(u, v) \\in E(G)$$\\quad \\quad \\quad \\text{if } e.t &gt; e.a, \\text{could not pass, } continue$ $\\quad \\quad \\quad \\textbf{for }\\forall e(u, v)$$\\quad \\quad \\quad \\quad \\textbf{check } D(u) \\stackrel{?}\\longleftrightarrow [0,e.a] \\cup [e.a+1, e.a+e.b]$$\\quad \\quad \\quad \\quad D(u) \\equiv r \\pmod{e.a+e.b}$ $\\quad \\quad \\quad \\quad r + e.t \\in [0, e.a], \\quad w(u, v):= e.t$$\\quad \\quad \\quad \\quad r+e.t &gt; e.a, \\quad w(u, v):= (e.a+e.b-r) + e.t$$\\quad \\quad \\quad \\quad D(v) = \\min(D(v), D(u) + w)$$\\quad \\quad \\quad \\quad \\quad \\text{if changed, que} \\leftarrow v$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const int maxn = 300 + 10;const int inf = 0x3f3f3f3f;int n, m, s, t;int D[maxn], vis[maxn];// == Graph definition ==vector&lt;int&gt; G[maxn];class Edge &#123;public: int from, to, a, b, t; Edge(int from, int to, int a, int b, int t) : from(from), to(to), a(a), b(b), t(t) &#123;&#125; Edge() &#123;&#125;&#125;;vector&lt;Edge&gt; edges;void addEdge(int u, int v, int a, int b, int t) &#123; edges.push_back(Edge(u, v, a, b, t)); G[u].push_back(edges.size() - 1);&#125;void initG(int s) &#123; Set(D, inf); D[s] = 0; Set(vis, 0);&#125;// == Graph finished ==// == Dijkstra ==struct Node &#123; int u, dist; Node(int u, int d) : u(u), dist(d) &#123;&#125; Node() &#123;&#125; bool operator&lt; (const Node&amp; rhs) const &#123; return dist &gt; rhs.dist; &#125;&#125;;void dijkstra(int s) &#123; priority_queue&lt;Node&gt; que; que.push(Node(s, 0)); while (!que.empty()) &#123; int x = que.top().u; que.pop(); if(vis[x]) continue; vis[x] = true; _for(i, 0, G[x].size()) &#123; const Edge&amp; e = edges[G[x][i]]; int y = e.to; if(e.t &gt; e.a) continue; int w, r = D[x] % (e.a + e.b); if(r + e.t &lt;= e.a) w = e.t; else w = e.a + e.b - r + e.t; if(D[y] &gt; D[x] + w) &#123; D[y] = D[x] + w; que.push(Node(y, D[y])); &#125; &#125; &#125;&#125;// == Dijkstra finished ==void init() &#123; _rep(i, 0, n) G[i].clear(); edges.clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while (~scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;s, &amp;t)) &#123; init(); printf(\"Case %d: \", ++kase); // get data _for(i, 0, m) &#123; int u, v, a, b, t; scanf(\"%d%d%d%d%d\", &amp;u, &amp;v, &amp;a, &amp;b, &amp;t); addEdge(u, v, a, b, t); &#125; // then dijkstra initG(s); dijkstra(s); printf(\"%d\\n\", D[t]); &#125;&#125; 动态规划统计最短路条数$\\textbf{algorithm}$$\\textbf{i)} \\quad \\text{run} \\textbf{ Dijkstra() } \\text{and calculate } \\forall u \\in V(G) \\rightarrow D(u)$$\\textbf{ii)} \\quad f(k, u) \\text{表示以 }D(u)+k \\text{ 作为最短路的路径条数 }$$\\quad \\quad \\quad [D(u), k] \\text{ 表示此时的 } u \\text{ 点的长度为 } D(u) + k$$\\quad \\quad \\quad \\forall e(u, v) :=$ [D(u),k]\\Rightarrow\\left\\{\\begin{array}{lc} \\{f(1, v)+=f(0, u)\\} \\cup \\{f(k, v)+=f(k, u)\\}, \\quad k=0 \\\\ \\{f(k, v)+=f(k, u)\\} , \\quad k = 1 \\end{array}\\right. D(v) = D(u) + w(u, v) \\quad \\rightarrow f(k, v) += f(k, u) \\\\ D(v)+1 = D(u) + w(u, v) \\quad \\rightarrow f(1, v) += f(0, u) f(0, s) = 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124const int maxn = 1e3 + 10;const ll inf = 0x3f3f3f3f3f3f3f3f;int n, m, st, ed;// == Graph definition ==vector&lt;int&gt; G[maxn];int vis[maxn];ll D[maxn];class Edge &#123;public: int to, w; Edge(int t, int w) : to(t), w(w) &#123;&#125; Edge() &#123;&#125;&#125;;vector&lt;Edge&gt; edges;void addEdge(int u, int v, int w) &#123; edges.push_back(Edge(v, w)); G[u].push_back(edges.size() - 1);&#125;void initG(int st) &#123; _for(i, 0, maxn) D[i] = inf; D[st] = 0; Set(vis, 0);&#125;// == Graph finished ==// == Dijkstra ==struct Node &#123; int u; ll dist; Node() &#123;&#125; Node(int u, ll d) : u(u), dist(d) &#123;&#125; bool operator&lt; (const Node&amp; rhs) const &#123; return dist &gt; rhs.dist; &#125;&#125;;void dijkstra(int st) &#123; priority_queue&lt;Node&gt; que; que.push(Node(st, 0)); while (!que.empty()) &#123; int x = que.top().u; que.pop(); if(vis[x]) continue; vis[x] = true; _for(i, 0, G[x].size()) &#123; const Edge&amp; e = edges[G[x][i]]; int y = e.to; if(D[y] &gt; D[x] + 1ll * e.w) &#123; D[y] = D[x] + 1ll * e.w; que.push(Node(y, D[y])); &#125; &#125; &#125;&#125;// == Dijkstra finished ==// == dp ==ll f[2][maxn];bool cmp(int a, int b) &#123; return D[a] &lt; D[b];&#125;int ord[maxn];void initDp() &#123; Set(f, 0); f[0][st] = 1ll; _rep(i, 1, n) ord[i] = i; sort(ord + 1, ord + 1 + n, cmp);&#125;void dp() &#123; _for(k, 0, 2) _rep(i, 1, n) &#123; int x = ord[i]; _for(j, 0, G[x].size()) &#123; const Edge&amp; e = edges[G[x][j]]; int y = e.to; if(D[y] == D[x] + e.w) f[k][y] += f[k][x]; if(k == 0 &amp;&amp; D[y] + 1 == D[x] + e.w) f[1][y] += f[0][x]; &#125; &#125;&#125;// == dp finsiehd ==void init() &#123; _for(i, 0, maxn) G[i].clear(); edges.clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; init(); scanf(\"%d%d\", &amp;n, &amp;m); // input data _for(i, 0, m) &#123; int u, v, l; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;l); addEdge(u, v, l); &#125; scanf(\"%d%d\", &amp;st, &amp;ed); // dijkstra initG(st); dijkstra(st); // then dp initDp(); dp(); printf(\"%lld\\n\", f[0][ed] + f[1][ed]); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"Graph","slug":"Graph","permalink":"https://www.fogsail.net/tags/Graph/"}]},{"title":"图算法和图模型(三)","slug":"20200514","date":"2020-05-16T14:05:48.000Z","updated":"2020-05-20T13:42:43.563Z","comments":true,"path":"2020/05/16/20200514/","link":"","permalink":"https://www.fogsail.net/2020/05/16/20200514/","excerpt":"这部分内容对最短路做一个补充包括 $floyd$ 算法和传递闭包","text":"这部分内容对最短路做一个补充包括 $floyd$ 算法和传递闭包 floyd 算法 123456789101112131415161718192021222324int dist[maxn][maxn];void initG() &#123; Set(dist, inf); _rep(i, 1, N) dist[i][i] = 0;&#125;void floyd() &#123; _rep(k, 1, N) &#123; _rep(i, 1, N) _rep(j, 1, N) &#123; dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); &#125; &#125;&#125;int main() &#123; initG(); _rep(i, 1, m) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); d[x][y] = min(d[x][y], z); &#125; floyd();&#125; $\\textbf{二元关系传递闭包}$$d(i, j) \\text{是 0，1 矩阵，表示二元关系}$$d(i, j) = 1 \\Leftrightarrow i, j \\text{ 有关系}$$d(i, j) = 0 \\Leftrightarrow i, j \\text{ 没有关系}$ 1234567891011121314151617181920212223bool d[maxn][maxn];void initG() &#123; Set(d, 0);&#125;void floyd() &#123; _rep(k, 1, n) &#123; _rep(i, 1, n) _rep(j, 1, n) &#123; d[i][j] |= (d[i][k] &amp; d[k][j]); &#125; &#125;&#125;int main() &#123; _rep(i, 1, n) d[i][i] = 1; _rep(i, 1, m) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); d[x][y] = d[y][x] = 1; &#125; floyd();&#125; 有向图传递闭包$d(i,j)=1 \\text{ 表示 } (i, j) 之间有约束关系$关系的传递性可以用有向图传递闭包的方式来解决 POJ10941234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const int maxn = 30;int f[maxn][maxn], G[maxn][maxn];int deg[maxn];int n, m;char str[5];void init() &#123; Set(f, 0); Set(G, 0); Set(deg, 0);&#125;// == floyd algorithm ==void floyd() &#123; _for(k, 0, n) _for(i, 0, n) _for(j, 0, n) &#123; f[i][j] |= (f[i][k] &amp; f[k][j]); &#125;&#125;// == floyd finsihed ==// == topo sort ==void topo(const int t) &#123; queue&lt;int&gt; que; _for(i, 0, n) if(deg[i] == 0) que.push(i); printf(\"Sorted sequence determined after %d relations: \", t); while (!que.empty()) &#123; int x = que.front(); que.pop(); printf(\"%c\", (char)('A' + x)); _for(y, 0, n) &#123; if(G[x][y]) if(--deg[y] == 0) que.push(y); &#125; &#125; printf(\".\\n\");&#125;// == topo finsihed ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;n, &amp;m) &amp;&amp; n) &#123; init(); bool found = false, fail = false; int t = 0; _rep(i, 1, m) &#123; scanf(\"%s\", str); if(found || fail) continue; int u = str[0] - 'A'; int v = str[2] - 'A'; G[u][v] = f[u][v] = 1; deg[v]++; floyd(); found = true; _for(u, 0, n) &#123; if(f[u][u]) &#123; fail = true; break; &#125; _for(v, 0, n) &#123; if(v != u &amp;&amp; (f[u][v] ^ f[v][u]) == 0) found = false; &#125; &#125; t = i; &#125; if(fail) printf(\"Inconsistency found after %d relations.\\n\", t); else if(found) topo(t); else printf(\"Sorted sequence cannot be determined.\\n\"); &#125;&#125; 无向图最小环POJ1734 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const int maxn = 200 + 10;const int inf = 0x3f3f3f3f;int n, m;// == Graph definition ==int c[maxn][maxn], d[maxn][maxn];int pos[maxn][maxn];int ans = inf;vector&lt;int&gt; path;void init() &#123; Set(c, inf); _rep(i, 1, n) c[i][i] = 0; Set(pos, 0); ans = inf; path.clear();&#125;// == Graph finished ==// == floyd algorithm ==void initFloyd() &#123; Cpy(d, c);&#125;inline void getPath(int x, int y, vector&lt;int&gt;&amp; path) &#123; if(pos[x][y] == 0) return; getPath(x, pos[x][y], path); path.push_back(pos[x][y]); getPath(pos[x][y], y, path);&#125;void floyd() &#123; initFloyd(); _rep(k, 1, n) &#123; _for(i, 1, k) _for(j, i + 1, k) &#123; if((ll)d[i][j] + c[j][k] + c[k][i] &lt; ans) &#123; ans = d[i][j] + c[j][k] + c[k][i]; //debug(ans); path.clear(); path.push_back(i); getPath(i, j, path); path.push_back(j); path.push_back(k); &#125; &#125; _rep(i, 1, n) _rep(j, 1, n) &#123; if(d[i][j] &gt; d[i][k] + d[k][j]) &#123; d[i][j] = d[i][k] + d[k][j]; pos[i][j] = k; &#125; &#125; &#125;&#125;// == floyd finsihed ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m; // build graph init(); _rep(i, 1, m) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); c[x][y] = c[y][x] = min(c[x][y], z); &#125; // floyd floyd(); if(ans == inf) &#123; puts(\"No solution.\"); return 0; &#125; _for(i, 0, path.size()) printf(\"%d \", path[i]); printf(\"\\n\");&#125; 矩阵乘法在最短路问题上的应用矩阵乘法的定义 C_{i j}=\\sum_{k=1}^{m} A_{i k} \\cdot B_{k j}特殊情形，$F(1\\times n), A(n \\times n) \\Rightarrow F^{\\prime}(1\\times n) = F \\cdot A$省略 $F$ 的第一维 \\forall j \\in [1, n], \\ F^{\\prime}_j = \\sum_{k=1}^{n} F_k \\cdot A_{kj}$\\text{Fibonacci数列的矩阵形式}$ Fib_{n+1} = Fib_{n} + Fib_{n-1} \\\\ \\ \\\\ F(n) = (Fib_{n}, \\ Fib_{n+1}) \\\\ F(n-1) = (Fib_{n-1}, \\ Fib_{n}) \\left(Fib_{n-1}, Fib_{n} \\right)\\left(\\begin{array}{cc} 0 & 1 \\\\ 1 & 1 \\end{array}\\right)=\\left(Fib_{n}, Fib_{n+1}\\right) =\\left(Fib_{n}, Fib_{n-1}+Fib_{n}\\right) F(n) = F(n-1)\\cdot A^1 = \\cdots = F(0)\\cdot A^n \\\\ \\ \\\\ F(0) = \\{0, 1\\}快速幂计算 a^{n}=\\left\\{\\begin{array}{cc} a^{n-1} \\cdot a & n \\text { is odd } \\\\ a^{n / 2} & n \\text { is even } \\\\ 1 & n=0 \\end{array}\\right.非递归的方法计算快速幂比如需要计算 $7^{(1010)_2}$，可以做拆分$7^{(1000)_2} \\cdot 7^{(10)_2}$ 对于 $a^n$， 如果有 a &amp; 1 == 1，那么这一位就要计入， ans = a如果有 a &amp; 1 == 0，那么只要把 a = a , 不断底数平方就可以 $7^{(100\\cdots)_2} = 7^1, 7^2, 7^4, \\cdots $ 12345678int qpow(int a, int n) &#123; int ans = 1; for(; n; n &gt;&gt;= 1) &#123; if(n &amp; 1) ans *= a; a *= a; &#125; return ans;&#125; Fibonacci计算POJ3070 123456789101112131415161718192021222324252627282930313233343536const int mod = 10000;int n;const int K = 2;void mul(int f[K], int A[K][K]) &#123; int c[K]; Set(c, 0); _for(j, 0, K) _for(k, 0, K) &#123; c[j] = (c[j] + (ll)f[k] * A[k][j]) % mod; &#125; Cpy(f, c);&#125;void mulself(int A[K][K]) &#123; int c[K][K]; Set(c, 0); _for(i, 0, K) _for(j, 0, K) _for(k, 0, K) &#123; c[i][j] = (c[i][j] + (ll)(A[i][k]) * A[k][j]) % mod; &#125; Cpy(A, c);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (cin &gt;&gt; n &amp;&amp; n != -1) &#123; int f[2] = &#123;0, 1&#125;; int A[2][2] = &#123;&#123;0, 1&#125;, &#123;1, 1&#125;&#125;; for(; n; n &gt;&gt;= 1) &#123; if(n &amp; 1) mul(f, A); mulself(A); &#125; cout &lt;&lt; f[0] &lt;&lt; endl; &#125;&#125; 状态转移矩阵的构建 Acwing206 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104const int maxn = 10 + 5;const int inf = 0x3f3f3f3f;int n, m, t, act, N;// == board definition ==char str[maxn], op[maxn][maxn];int bd[maxn][maxn], ptr[maxn][maxn];// == board definition finished ==// == get hash ==inline int _hash(int i, int j) &#123; return (i - 1) * m + j;&#125;vector&lt;vector&lt;ll&gt; &gt; A[60 + 5];vector&lt;vector&lt;ll&gt; &gt; F;void initHash() &#123; N = n * m + 1; _rep(i, 1, 60) A[i].resize(N, vector&lt;ll&gt;(N)); F.resize(1, vector&lt;ll&gt;(N)); F[0][0] = 1; _rep(i, 1, 60) A[i][0][0] = 1;&#125;// == hash finished ==// == build matrix ==void build() &#123; _rep(k, 1, 60) &#123; _rep(i, 1, n) _rep(j, 1, m) &#123; int x = bd[i][j], y = ptr[i][j]; if(isdigit(op[x][y])) &#123; A[k][0][_hash(i, j)] = op[x][y] - '0'; A[k][_hash(i, j)][_hash(i, j)] = 1; &#125; else if(op[x][y] == 'N' &amp;&amp; i &gt; 1) A[k][_hash(i, j)][_hash(i-1, j)] = 1; else if(op[x][y] == 'S' &amp;&amp; i &lt; n) A[k][_hash(i, j)][_hash(i+1, j)] = 1; else if(op[x][y] == 'W' &amp;&amp; j &gt; 1) A[k][_hash(i, j)][_hash(i, j-1)] = 1; else if(op[x][y] == 'E' &amp;&amp; j &lt; m) A[k][_hash(i, j)][_hash(i, j+1)] = 1; ptr[i][j] = (ptr[i][j] + 1) % strlen(op[x]); &#125; &#125;&#125;// == build matrix finished ==// == calculate ==inline void mul(vector&lt;vector&lt;ll&gt; &gt; &amp;A, const vector&lt;vector&lt;ll&gt; &gt; &amp;B) &#123; vector&lt;vector&lt;ll&gt; &gt; ans; ans.resize(A.size(), vector&lt;ll&gt;(B[0].size())); _for(i, 0, A.size()) _for(j, 0, B[0].size()) &#123; _for(k, 0, B.size()) ans[i][j] = ans[i][j] + A[i][k] * B[k][j]; &#125; A = ans;&#125;void solve() &#123; vector&lt;vector&lt;ll&gt; &gt; C = A[1]; _rep(i, 2, 60) mul(C, A[i]); ll ans = 0; int q = t / 60; for(; q; q &gt;&gt;= 1) &#123; if(q &amp; 1) mul(F, C); mul(C, C); &#125; int r = t % 60; _rep(i, 1, r) mul(F, A[i]); _for(i, 0, N) ans = max(ans, F[0][i]); cout &lt;&lt; ans &lt;&lt; endl;&#125;// == calculate finsihed ==void init() &#123; Set(ptr, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m &gt;&gt; t &gt;&gt; act; init(); // get input board _rep(i, 1, n) &#123; scanf(\"%s\", str + 1); _rep(j, 1, m) bd[i][j] = str[j] - '0'; &#125; // get command _for(i, 0, act) scanf(\"%s\", op[i]); // == input finished == // init Hash and build matrix initHash(); build(); // calculate solve();&#125; floyd和矩阵乘法 POJ3613 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int maxn = 200 + 10;const int inf = 0x3f3f3f3f;int n, t, s, e, tot = 0;map&lt;int, int&gt; mp;// == status definition ==struct Mat &#123; int A[maxn][maxn]; void _init() &#123; _for(i, 1, maxn) _for(j, 1, maxn) &#123; A[i][j] = inf; &#125; &#125;&#125; st, ed;// == status finished ==inline Mat mul(Mat a, Mat b) &#123; Mat c; c._init(); _rep(i, 1, tot) _rep(j, 1, tot) _rep(k, 1, tot) &#123; c.A[i][j] = min(c.A[i][j], a.A[i][k] + b.A[k][j]); &#125; return c;&#125;void init() &#123; tot = 0; mp.clear(); st._init(); ed._init();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; t &gt;&gt; s &gt;&gt; e; init(); // build Graph while (t--) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;z, &amp;x, &amp;y); x = mp[x] ? mp[x] : (mp[x] = ++tot); y = mp[y] ? mp[y] : (mp[y] = ++tot); st.A[x][y] = st.A[y][x] = z; &#125; Cpy(ed.A, st.A); // Matrix change n--; for(; n; n &gt;&gt;= 1) &#123; if(n &amp; 1) ed = mul(ed, st); st = mul(st, st); &#125; cout &lt;&lt; ed.A[mp[s]][mp[e]] &lt;&lt; endl;&#125; 群运算观点下的floyd方程 d(i, j) = \\min_{k \\in [1, n]}(d(i, j), d(i, k)+d(k, j))其实可以做进一步的扩展，因为加法运算有群封闭性和结合律同样，$\\min, \\ \\max$ 运算也具有结合律 那么诸如路径最大值尽可能小的问题，也可以写出 floyd 方程 d(i, j) = \\min_{k \\in [1, n]} \\{d(i, j), \\max\\{d(i, k), d(k, j)\\}\\}UVA10048 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int inf = 0x3f3f3f3f;const int maxn = 100 + 10;int n, m, q;int d[maxn][maxn];void init() &#123; Set(d, 0); _rep(i, 1, n) _rep(j, 1, n) d[i][j] = inf; _rep(i, 1, n) d[i][i] = 0;&#125;void floyd() &#123; _rep(k, 1, n) _rep(i, 1, n) _rep(j, 1, n) &#123; if(d[i][k] &lt; inf &amp;&amp; d[k][j] &lt; inf) &#123; d[i][j] = min(d[i][j], max(d[i][k], d[k][j])); &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while (scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q) == 3 &amp;&amp; n) &#123; init(); while (m--) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); d[x][y] = d[y][x] = min(d[x][y], z); &#125; // run floyd() floyd(); if(kase &gt; 0) printf(\"\\n\"); printf(\"Case #%d\\n\", ++kase); // query while (q--) &#123; int q1, q2; scanf(\"%d%d\", &amp;q1, &amp;q2); if(d[q1][q2] == inf) printf(\"no path\\n\"); else printf(\"%d\\n\", d[q1][q2]); &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"Graph","slug":"Graph","permalink":"https://www.fogsail.net/tags/Graph/"}]},{"title":"图算法和图模型(二)","slug":"20200513","date":"2020-05-14T06:32:42.000Z","updated":"2020-05-16T13:46:54.804Z","comments":true,"path":"2020/05/14/20200513/","link":"","permalink":"https://www.fogsail.net/2020/05/14/20200513/","excerpt":"这部分我重点写了最短路问题","text":"这部分我重点写了最短路问题 最短路Dijkstra POJ1511 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990const int inf = 0x3f3f3f3f;const int maxn = 1e6 + 5;// == Graph definition ==vector&lt;int&gt; G[maxn];class Edge &#123;public: int to, weight; Edge() &#123;&#125; Edge(int to, int w) : to(to), weight(w) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;void initG() &#123; _for(i, 0, maxn) G[i].clear(); edges.clear();&#125;void addEdge(int u, int v, int w) &#123; edges.push_back(Edge(v, w)); G[u].push_back(edges.size() - 1);&#125;// == Graph finished ==int st[maxn], ed[maxn], w[maxn];typedef pair&lt;int, int&gt; PII;int n, m;// == Dijkstra ==int vis[maxn], dist[maxn];void initDij() &#123; Set(dist, inf); Set(vis, 0); dist[1] = 0;&#125;void dijkstra() &#123; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; que; que.push(MPR(0, 1)); while (!que.empty()) &#123; int x = que.top().second; que.pop(); if(vis[x]) continue; vis[x] = 1; _for(i, 0, G[x].size()) &#123; int y = edges[G[x][i]].to; int z = edges[G[x][i]].weight; if(dist[y] &gt; dist[x] + z) &#123; dist[y] = dist[x] + z; que.push(MPR(dist[y], y)); &#125; &#125; &#125;&#125;// == Dijkstra finished ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); initG(); _rep(i, 1, m) &#123; scanf(\"%d%d%d\", &amp;st[i], &amp;ed[i], &amp;w[i]); addEdge(st[i], ed[i], w[i]); &#125; initDij(); dijkstra(); ll sum = 0; _rep(i, 1, n) sum += dist[i]; initG(); _rep(i, 1, m) addEdge(ed[i], st[i], w[i]); initDij(); dijkstra(); _rep(i, 1, n) sum += dist[i]; printf(\"%lld\\n\", sum); &#125;&#125; Moore-Bellman-Ford $\\text{bellman-ford 方程的应用，求平均权值最小}$$对于某个权值 \\ c , \\ c \\in [0, maxv]$$二分猜想最小平均权值为 \\ mid$ w_1+w_2+\\cdots w_k < k \\cdot mid \\\\ \\Leftrightarrow (w_1-mid)+(w_2-mid)+\\cdots +(w_k-mid)","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"Graph","slug":"Graph","permalink":"https://www.fogsail.net/tags/Graph/"}]},{"title":"分析学基本理论（二）","slug":"20200422","date":"2020-05-02T11:59:20.000Z","updated":"2020-05-06T02:22:42.756Z","comments":true,"path":"2020/05/02/20200422/","link":"","permalink":"https://www.fogsail.net/2020/05/02/20200422/","excerpt":"这篇博文对连分数理论和逼近算法做进一步研究","text":"这篇博文对连分数理论和逼近算法做进一步研究 连分数逼近算法连分数与渐进分数的差 x=\\frac{a_{n+1}^{\\prime} p_{n}+p_{n-1}}{a_{n+1}^{\\prime} q_{n}+q_{n-1}} \\\\ \\ \\\\ x-\\frac{p_{n}}{q_{n}}=\\frac{(-1)^{n}}{q_ n\\left(a_{n+1}^{\\prime} q_{n}+q_{n-1}\\right)} \\quad x-\\frac{p_{0}}{q_{0}}=x-a_{0}=\\frac{1}{a_{1}^{\\prime}} \\\\ \\ \\\\ 根据前面的引理， q_{1}^{\\prime}=a_{1}^{\\prime}, \\quad q_{n}^{\\prime}=a_{n}^{\\prime} q_{n-1}+q_{n-2} \\ (1 < n \\leqslant N) \\\\ \\ \\\\ \\textbf{special} \\quad a_{N}=a_{N}^{\\prime} \\quad q_{N}^{\\prime}=q_{N} \\text{if} \\ \\ 1 \\leqslant n \\leqslant N - 1, \\text{then} \\\\ \\ \\\\ x-\\frac{p_{n}}{q_{n}}=\\frac{(-1)^{n}}{q_{n} q_{n+1}^{\\prime}} a_{N}=1, \\quad a_{N-1}^{\\prime}=a_{N-1}+\\frac{1}{a_{N}}=a_{N-1}+1$\\textbf{i)}$ 研究 \\ \\left|\\frac{p_{n}-q_{n} x}{q_{n}}\\right|=\\frac{1}{q_{n} q_{n+1}^{\\prime}} \\Leftrightarrow\\left|p_{n}-q_{n} x\\right|=\\frac{1}{q_{n+1}^{\\prime}} \\\\ \\ \\\\ 注意 \\ q_{n+1}^{\\prime} \\ 的性质就可以了$\\textbf{ii)}$ q_{0}=1, \\quad q_{1}=a_{1}, \\quad q_{2}=a_{2} q_{1}+q_{0}=a_{1} a_{2}+1 \\\\ q_{1}=a_{1}","categories":[{"name":"math","slug":"math","permalink":"https://www.fogsail.net/categories/math/"}],"tags":[{"name":"math","slug":"math","permalink":"https://www.fogsail.net/tags/math/"}]},{"title":"基础代数（一）代数的起源","slug":"20200421","date":"2020-04-28T12:25:06.000Z","updated":"2020-04-29T09:58:56.393Z","comments":true,"path":"2020/04/28/20200421/","link":"","permalink":"https://www.fogsail.net/2020/04/28/20200421/","excerpt":"科斯特利金的代数学书写的挺不错的有一些现代的问题也值得研究","text":"科斯特利金的代数学书写的挺不错的有一些现代的问题也值得研究 数学归纳法原理$从美国数学月刊的一个征解问题说起$$美国数学月刊，1977，\\text{V.84, No.6}$$给定圆周上任意n个点，确定$$\\left(\\begin{array}{l}n \\2\\end{array}\\right) 条弦划分圆内的区域数 R_n，任意三条弦在圆内不相交$ R_n = 1+\\left(\\begin{array}{l} n \\\\ 2 \\end{array}\\right)+\\left(\\begin{array}{l} n \\\\ 4 \\end{array}\\right)$根据数学归纳法，n = 1显然成立，如果 n = k时成立，那么只要证明$ R_{n+1}-R_{n}=n+\\left(\\begin{array}{l} n \\\\ 3 \\end{array}\\right)$而这个式子是成立的，证明如下$$\\textbf{i) } 加入的新点 q，与 原来 \\forall n 构成弦$$这个弦将原来的区域划分出了一块新的区域 S$$如阴影部分所示, {S \\in D_1} \\cup {S \\in D_2} \\cup \\cdots $$这样的 S 有\\left(\\begin{array}{l}n \\1\\end{array}\\right) 个，所以划分区域增加$ \\Delta_1=\\left(\\begin{array}{l} n \\\\ 1 \\end{array}\\right)$\\textbf{ii) } 加入新点q，构成相交弦，在圆内产生交点$$从 n 中任取3个点, {a_1, a_2, a_3}, 不失一般性$$假设(q, a_3) 与 (a_1, a_2) 相交，交点位于圆内$$增加的区域如下$ \\Delta_{2}=\\left(\\begin{array}{l} n \\\\ 3 \\end{array}\\right) $证毕$ $\\textbf{practice1}$ S(n)+\\sin(n+1) \\varphi=\\frac{\\sin \\frac{n \\varphi}{2} \\sin \\frac{(n+1) \\varphi}{2}}{\\sin \\frac{\\varphi}{2}}+\\frac{\\sin (n+1) \\varphi \\sin \\frac{\\varphi}{2}}{\\sin \\frac{\\varphi}{2}} \\\\ \\ \\\\ \\Rightarrow 2 \\sin \\frac{(n+1) \\varphi}{2} \\cos \\frac{(n+1) \\varphi}{2} \\sin \\frac{\\varphi}{2}+\\sin \\frac{n \\varphi}{2} \\sin \\frac{(n+1) \\varphi}{2} \\\\ \\ \\\\ \\Rightarrow \\sin \\frac{(n+1) \\varphi}{2}\\left(2 \\cos \\frac{(n+1) \\varphi}{2} \\sin \\frac{\\varphi}{2}+\\frac{\\sin n \\varphi}{2}\\right) \\\\ \\ \\\\ \\Rightarrow \\cos \\frac{n \\varphi}{2} \\sin \\varphi-2 \\sin \\frac{n \\varphi}{2} \\sin ^{2} \\frac{\\varphi}{2}+\\frac{\\sin n \\varphi}{2} \\\\ \\ \\\\ =\\sin \\left(\\frac{n \\varphi}{2}+\\varphi\\right)$\\textbf{practice2}$ \\sin \\frac{n \\varphi}{2} \\cos \\frac{(n+1) \\varphi}{2}+\\cos (n+1) \\varphi \\sin \\frac{\\varphi}{2} \\\\ \\ \\\\ \\Rightarrow 2 \\cos ^{2} \\frac{(n+1) \\varphi}{2} \\sin \\frac{\\varphi}{2}-\\sin \\frac{\\varphi}{2}+\\sin \\frac{n \\varphi}{2} \\cos \\frac{(n+1) \\varphi}{2} \\\\ \\ \\\\ \\Rightarrow \\cos \\frac{(n+1) \\varphi}{2}\\left(2 \\cos \\frac{(n+1) \\varphi}{2} \\sin \\frac{\\varphi}{2}+\\sin \\frac{n \\varphi}{2}\\right)-\\sin \\frac{\\varphi}{2} \\\\ \\ \\\\ \\text{bracket} \\Rightarrow 2\\left(\\cos \\frac{n \\varphi}{2} \\cos \\frac{\\varphi}{2}-\\sin \\frac{n \\varphi}{2} \\sin \\frac{\\varphi}{2}\\right) \\sin \\frac{\\varphi}{2}+\\sin \\frac{n \\varphi}{2} \\\\ \\ \\\\ =\\sin \\left(\\frac{n \\varphi}{2}+\\varphi\\right) \\\\ \\ \\\\ \\ \\\\ \\Rightarrow \\sin \\left(\\frac{(n+1) \\varphi}{2}+\\frac{\\varphi}{2}\\right) \\cos \\frac{(n+1) \\varphi}{2}-\\sin \\frac{\\varphi}{2} \\\\ \\ \\\\ \\Rightarrow 2 \\sin \\frac{(n+1) \\varphi}{2} \\cos \\frac{(n+1) \\varphi}{2} \\cos \\frac{\\varphi}{2}+2 \\cos ^{2} \\frac{(n+1) \\varphi}{2} \\sin \\frac{\\varphi}{2}-2 \\sin \\frac{\\varphi}{2} \\\\ \\ \\\\ \\Rightarrow \\frac{\\sin (n+1) \\varphi \\cos \\frac{\\varphi}{2}+\\sin \\frac{\\varphi}{2} \\cos (n+1) \\varphi-\\sin \\frac{\\varphi}{2}}{2 \\sin \\varphi / 2} \\\\ \\ \\\\ \\Rightarrow \\frac{\\sin \\left((n+1) \\varphi+\\frac{\\varphi}{2}\\right)-\\sin \\frac{\\varphi}{2}}{2 \\sin \\frac{\\varphi}{2}}=\\frac{\\sin \\frac{(n+1) \\varphi}{2} \\cos \\frac{(n+2) \\varphi}{2}}{\\sin \\frac{\\varphi}{2}}置换$\\Omega={1,2, \\ldots, n}, 通过不相交的类分解，可以有$$\\Omega=\\Omega_{1} \\cup \\Omega_{2} \\ldots \\cup \\Omega_{p} 称为轨道$ \\Omega_{k}=\\left\\{i, \\pi(i), \\pi^{2}(i), \\ldots \\pi^{l_{k}-1}(i)\\right\\} l_{k} \\leqslant q=\\operatorname{Card}\\langle\\pi\\rangle, \\quad \\pi^{l_{k}}(i)=i \\\\ \\ \\\\ \\pi_{k}=\\left(i, \\pi_{(i)}, \\pi^{2}(i), \\ldots, \\pi^{l_{k}-1}(i)\\right)=\\left(\\begin{array}{cccc} i & \\pi(i) & \\cdots & \\left.\\pi^{k-2} (i)\\right. \\\\ \\pi ( i) & \\pi^{2}(i) & \\cdots & \\left.\\pi^{k-1}(i)\\right. \\end{array}\\right) \\\\ \\ \\\\ \\forall j \\in \\Omega_{k}, \\quad \\pi(j)=\\pi_{k}(j)$\\textbf{置换的唯一分解}$$\\pi=\\pi_{1} \\pi_{2} \\ldots \\pi_{m}, \\quad l_{k}&gt;1, \\quad 1 \\leqslant k \\leqslant m$$存在另一种分解，不妨设为\\pi=\\alpha_{1} \\alpha_{2} \\ldots \\alpha_{r}$ \\exists \\pi_{s}, \\alpha_{t}, \\quad \\pi_{s}(i) \\neq i, \\quad \\alpha_{t}(i) \\neq i \\pi_{s}(i)=\\pi(i)=\\alpha_{t}(i), \\text{ if we have} \\\\ \\ \\\\ \\pi_{s}^{k}(i)=\\pi^{k}(i)=\\alpha_{t}^{k}(i) \\\\ \\ \\\\ \\Rightarrow \\pi \\pi_{S}^{k}(i)=\\pi^{k+1}(i)=\\pi \\alpha_{t}^{k}(i), 根据交换性 \\Rightarrow \\pi_{s}^{k} \\pi(i)=\\pi^{k+1}(i)=\\alpha_{t}^{k} \\pi(i) \\\\ \\ \\\\ \\pi_{s}^{k+1}(i)=\\pi^{k+1}(i)=\\alpha_{t}^{k+1}(i), \\quad \\forall k=\\{0,1,2 \\dots\\} \\\\ \\ \\\\ \\text{let } k = 0, \\pi_{s}=\\alpha_{t}$\\textbf{置换的符号是唯一的}$$证明的结论等价于置换的两个分解$ \\begin{aligned} &\\pi=\\tau_{1} \\tau_{2} \\ldots \\tau_{k}\\\\ &\\pi=\\tau_{1}^{\\prime} \\tau_{2}^{\\prime}\\ldots \\tau_{k'}^{\\prime} \\end{aligned} \\\\ k + k'是一个偶数$\\textbf{i)}$ \\left(\\tau_{s}^{\\prime}\\right)^{2}=e, \\quad \\tau_{1} \\tau_{2} \\ldots \\tau_{k} \\tau_{k^{\\prime} \\cdots \\cdots}^{\\prime} \\tau_{2}^{\\prime} \\tau_{1}^{\\prime}=e \\\\ \\ \\\\ \\text{let} \\quad e=\\sigma_{1} \\sigma_{2} \\cdots \\sigma_{m-1} \\sigma_{m}, m>0 \\\\ \\ \\\\ 只要证明，将 m 个因子消减成 m-2 个$\\textbf{ii)}$ e=\\sigma_{1} \\sigma_{2} \\ldots \\sigma_{p-1} \\sigma_{p} \\sigma_{p+1} \\ldots \\sigma_{m} \\\\ \\ \\\\ \\sigma_{p}=(s, t), \\quad s \\notin\\left\\{\\sigma_{p+1}, \\ldots \\sigma_{m}\\right\\} \\\\ \\ \\\\ \\textbf{1)} \\quad \\sigma_{p-1}=(s\\quad t) ,\\quad \\sigma_{p-1} \\sigma_{p}=(s \\quad t)(s \\quad t)=e \\Rightarrow \\\\ \\ \\\\ m-2 \\ 对换分解 \\\\ \\ \\\\ \\textbf{2)} \\quad \\sigma_{p-1}=(s, r), r \\neq s, t \\\\ \\ \\\\ \\Rightarrow \\sigma_{p-1} \\sigma_{p}=(s, r)(s, t)=(s, t)(r, t) \\\\ \\ \\\\ \\textbf{3)} \\quad \\sigma_{p-1}=(t, r), r \\neq s, t \\\\ \\ \\\\ \\Rightarrow \\sigma_{p-1} \\sigma_{p}=(t, r)(s, t)=(s, t)(t, r) \\\\ \\ \\\\ \\textbf{4)} \\quad \\sigma_{p-1}=(q, r), \\quad\\{q, r\\} \\cap\\{s, t\\}=\\phi \\\\ \\ \\\\ \\sigma_{p-1} \\sigma_{p}=(q, r)(s, t)=(s, t)(q, r)$\\textbf{iii)}$ 可以使用这样的操作，把 (s,t) 不断提前 \\\\ \\ \\\\ e=\\sigma_{1}^{\\prime} \\sigma_{2}^{\\prime} \\ldots \\sigma_{m}^{\\prime}, \\sigma_{1}^{\\prime}=\\left(s, t^{\\prime}\\right), \\quad s \\notin\\left\\{\\sigma_{2}^{\\prime}, \\sigma_{3}^{\\prime},\\ldots \\sigma_{m}^{\\prime}\\right\\} \\\\ \\ \\\\ k>1, \\quad \\sigma_{k}^{\\prime}(s)=s, \\quad s=e(s)=\\sigma_{1}^{\\prime}(s)=t^{\\prime} \\neq s","categories":[{"name":"math","slug":"math","permalink":"https://www.fogsail.net/categories/math/"}],"tags":[{"name":"math","slug":"math","permalink":"https://www.fogsail.net/tags/math/"}]},{"title":"分析学基本理论（一）","slug":"20200420","date":"2020-04-23T06:31:25.000Z","updated":"2020-05-02T11:58:44.422Z","comments":true,"path":"2020/04/23/20200420/","link":"","permalink":"https://www.fogsail.net/2020/04/23/20200420/","excerpt":"$这里对分析学基础理论，极限和无穷级数部分做一个 \\textbf{review}$$在 \\text{knuth} 的具体数学中，很多理论都是建立在分析学基础上的$","text":"$这里对分析学基础理论，极限和无穷级数部分做一个 \\textbf{review}$$在 \\text{knuth} 的具体数学中，很多理论都是建立在分析学基础上的$ 数列极限的补充问题$从每一个实数列中都可以选出一个收敛的或者是趋于无穷的子列$$\\textbf{proof} \\quad 其中，收敛很好证明$ $无穷性的证明，\\forall k \\in \\mathbb{N}, \\text{choose} \\ n_k \\in \\mathbb{N}$$|x_{n_k}| &gt; k \\ and \\ n_k &lt; n_{k+1}, {x_{n_k}} 构成无穷子列$ $\\textbf{example1}$ \\mathop{\\underline{\\lim}}\\limits_{k \\rightarrow \\infty} \\frac{(-1)^{k}}{k}=\\lim _{n \\rightarrow \\infty} \\inf _{k \\geqslant n} \\frac{(-1)^{k}}{k}=\\left\\{\\begin{array}{l} \\frac{(-1)^{2m +1}}{(2 m+1)}=-\\frac{1}{n} \\quad n=2 m+1 \\\\ \\ \\\\ \\frac{(-1)^{2 m} \\cdot(-1)}{2 m+1}=\\frac{-1}{n+1} \\quad n=2m \\end{array} \\right\\} =0 \\mathop{\\overline{\\lim}}\\limits _{k \\rightarrow \\infty} \\frac{(-1)^{k}}{k}=\\lim _{n \\rightarrow \\infty} \\sup _{k \\geqslant n} \\frac{(-1)^{k}}{k}=\\left\\{\\begin{array}{ll} \\frac{(-1)^{2m}}{2 m}=\\frac{1}{n} & n=2 m \\\\ \\ \\\\ \\frac{(-1)^{2 m+2}}{2 m+2}=\\frac{1}{n+1} & n=2 m+1 \\end{array}\\right\\} = 0$下极限证明语言$$\\forall \\varepsilon&gt;0, \\quad i-\\varepsilon&lt;i_n=\\inf\\limits_{k \\geqslant n} x_{k} \\leqslant x_{k}$$因为 \\ \\varepsilon \\ 是任意的，所以对于{x_k}$$任何部分极限都不能小于 \\ i - \\varepsilon，也就是不能小于 \\ i$ 补充阅读：《不等式的秘密》$阅读这部分内容，主要是为了提升数感，让自己的代数变形能力有进一步的提升$ AM-GM不等式$\\textbf{problem1}$$a, b, c&gt;0, abc = 1，证明$ (a+b)(b+c)(c+a) \\geqslant (a+1)(b+1)(c+1) \\\\ \\Longrightarrow ab(a+b)+bc(b+c)+ca(c+a) \\geqslant a+b+c+ab+bc+ca$重点在于轮换对称的构造$ L H S_{c y c}=\\left\\{\\begin{array}{l} a^{2} b+a^{2} c \\\\ b^{2} a+b^{2} c \\\\ c^2a+c^{2} b \\end{array}\\right\\} \\quad \\left\\{\\begin{array}{l} a^{2} b+a b^{2} \\\\ b^{2} c+b c^{2} \\\\ c^{2} a+c a^{2} \\end{array}\\right\\} 2 L H S+\\sum_{c y c} a b=\\sum_{c y c}\\left(a^{2} b+a^{2} b+a^{2} c+a^{2} c+b c\\right) \\geqslant 5 \\sum_{c y c}a \\\\ 2 L H S+\\sum_{c y c} a=\\sum_{c y c}\\left(a^{2} b+a^{2} b+a b^{2}+a b^{2}+c\\right) \\geqslant 5 \\sum_{c y c} a b 综上，L H S \\geqslant \\sum_{c y c} a+\\sum_{c yc} a b$\\textbf{problem2} \\ 4n+3是数论中非常常见的数，因此构造\\ \\frac{3}{4} \\ 也是很常见的$$x,y,z&gt;0，且\\ xyz=1$ \\frac{x^{3}}{(1+y)(1+z)}+\\frac{y^{3}}{(1+z)(1+x)}+\\frac{z^{3}}{(1+x)(1+y)} \\geq \\frac{3}{4} \\frac{x^{3}}{(1+y)(1+z)}+\\frac{1+y}{8}+\\frac{1+z}{8} \\geqslant \\frac{3}{4} x ，写成轮换对称 \\sum_{c y c} \\frac{x^{3}}{(1+y)(1+z)}+\\frac{1}{4} \\sum_{c y c}(1+x) \\geqslant \\sum_{c y c} \\frac{3 x}{4} \\\\ \\Rightarrow \\sum_{c y c} \\frac{x^{3}}{(1+y)(1+z)} \\geq \\frac{1}{4} \\sum_{c y c}(2 x-1)=\\frac{1}{4}(x+x+y+y+\\ldots)-\\frac{3}{4} \\\\ \\geqslant \\frac{6}{4}-\\frac{3}{4}=\\frac{3}{4}$\\textbf{problem3 轮换恒等变形}$ \\left(a^{2}+b^{2}+c^{2}\\right)(a b+b c+c a)=a b\\left(a^{2}+b^{2}\\right)+b c\\left(b^{2}+c^{2}\\right)+c a\\left(a^{2}+c^{2}\\right)+a b c(a+b+c) \\\\ \\text{if} \\ a , b, c \\geqslant 0, a+b+c =2 \\\\ \\left(a^{2}+b^{2}+c^{2}\\right)(a b+b c+c a) \\geqslant a b\\left(a^{2}+b^{2}\\right)+b c\\left(b^{2}+c^{2}\\right)+c a\\left(a^{2}+c^{2}\\right) \\\\ \\geqslant 2\\left(a^{2} b^{2}+b^2 c^{2}+a^{2} c^{2}\\right) a^{2}+b^{2}+c^{2}+2(a b+b c+c a)=(a+b+c)^{2}=4 \\\\ 2\\left(a^{2}+b^{2}+c^{2}\\right)(a b+b c+c a) \\leqslant\\left(\\frac{a^{2}+b^{2}+c^{2}+2(a b+b c+c a)}{2}\\right)^{2}=4 \\\\ \\begin{array}{l} \\left(a^{2}+b^{2}+c^{2}\\right)(a b+b c+c a) \\leqslant 2 \\\\ \\Rightarrow a^{2} b^{2}+b^{2} c^{2}+a^{2} c^{2} \\leqslant 1 \\end{array}$\\textbf{problem4 不等式中的域分组}$$a,b,c,d&gt;0$ \\frac{1}{a^{2}+a b}+\\frac{1}{b^{2}+b c}+\\frac{1}{c^{2}+c d}+\\frac{1}{d^{2}+d a} \\geqslant \\frac{4}{a c+b d} \\frac{a c+b d}{a^{2}+a b}=\\frac{a^{2}+a b+a c+b d}{a^{2}+a b}-1=\\frac{a+c}{a+b}+\\frac{b(d+a)}{a(a+b)}-1 \\\\ L H S=\\sum_{c y c} \\frac{a+c}{a+b}+\\sum_{c y c} \\frac{b(d+a)}{a(a+b)}-4 \\left\\{\\frac{a+c}{a+b}, \\frac{b(d+a)}{a(a+b)}\\right\\}, \\quad \\left\\{\\frac{b+d}{b+c}, \\frac{c(a+b)}{b(b+c)} \\right\\} \\\\ \\left\\{\\frac{c+a}{c+d}, \\frac{d(c+b)}{c(c+d)}\\right\\}, \\quad \\left\\{\\frac{d+b}{d+a}, \\frac{a(d+c)}{d(d+a)}\\right\\} \\\\ \\ \\\\ 用AM-GM不等式消去第二个项，得到 \\\\ \\ \\\\ LH S \\geqslant \\sum_{c y c} \\frac{a+c}{a+b} \\sum_{c y c} \\frac{a+c}{a+b}=(a+c)\\left(\\frac{1}{a+b}+\\frac{1}{c+d}\\right)+(b+d)\\left(\\frac{1}{b+c}+\\frac{1}{d+a}\\right) \\\\ \\text{Schwarz 不等式} \\\\ \\ \\\\ \\frac{1}{a+b}+\\frac{1}{c+d} \\geqslant \\frac{(1+1)^{2}}{a+b+c+d}=\\frac{4}{a+b+c+d} \\\\ \\ \\\\ L H S \\geqslant \\frac{4(a+c)}{a+b+c+d}+\\frac{4(b+d)}{a+b+c+d}=4$\\textbf{problem5}$$a,b,c,d,e \\geqslant 0, a+b+c+d+e = 5, \\text{proof}$$abc+bcd+cde+dea+eab \\leqslant 5$$\\textbf{proof}$ a b c+b c d+c d e+d e a+e a b=e(a+c)(b+d)+b c(a+d-e) \\\\ \\leqslant e\\left(\\frac{a+b+c+d}{2}\\right)^{2}+\\left(\\frac{b+c+a+d-e}{3}\\right)^{3} \\\\ \\ \\\\ =\\frac{e(5-e)^{2}}{4}+\\frac{(5-2 e)^{2}}{27} f(x)=\\frac{x(5-x)^{2}}{4}+\\frac{(5-2 x)^{2}}{27} \\\\ \\frac{d f(x)}{d x}=-\\frac{5}{36}\\left(x^{2}+4 x-5\\right) \\Rightarrow x=1, \\frac{d f(x)}{d x}=0 \\\\ \\ \\\\ \\text{let } e = \\min\\{a,b,c,d,e\\}, \\Rightarrow e \\leqslant 1 \\\\ \\ \\\\ f(x) \\leqslant f(1)=2 \\leqslant 5$\\textbf{problem5}$$a,b,c,d&gt;0, \\text{proof}$ \\left(\\frac{1}{a}+\\frac{1}{b}+\\frac{1}{c}+\\frac{1}{d}\\right)^{2} \\geqslant \\frac{1}{a^{2}}+\\frac{4}{a^{2}+b^{2}}+\\frac{9}{a^{2}+b^{2}+c^{2}}+\\frac{16}{a^{2}+b^{2}+c^{2}+d^{2}} \\Leftrightarrow \\frac{1}{b^{2}}+\\frac{1}{c^{2}}+\\frac{1}{d^{2}}+\\sum_{s y m} \\frac{2}{a b} \\geqslant \\frac{4}{a^{2}+b^{2}}+\\frac{9}{a^{2}+b^{2}+c^{2}}+\\frac{16}{a^{2}+b^{2}+c^{2}+d^{2}} AM-GM不等式，有 \\\\ \\ \\\\ \\frac{2}{a b} \\geqslant \\frac{4}{a^{2}+b^{2}} \\\\ \\ \\\\ \\frac{2}{a c}+\\frac{2}{b c} \\geqslant \\frac{(2 \\sqrt{2})^{2}}{a c+b c} \\geqslant \\frac{8}{\\frac{a^{2}+b^{2}}{2}+c^{2}}>\\frac{8}{a^{2}+b^{2}+c^{2}} \\ \\text{(Cauchy-Schwarz)}\\\\ \\ \\\\ \\frac{1}{b^{2}}+\\frac{1}{c^{2}} \\geqslant \\frac{4}{b^{2}+c^{2}} \\geqslant \\frac{1}{b^{2}+c^{2}+a^{2}} \\\\ \\ \\\\ d=\\min \\{a, b, c, d\\} \\\\ \\ \\\\ \\frac{2}{a d}+\\frac{2}{b d}+\\frac{2}{c d} \\geqslant \\frac{(3 \\sqrt{2})^{2}}{a d+b d+c d} \\\\ \\ \\\\ \\geqslant \\frac{18}{a d+b d+c d+d^{2}} \\geqslant \\frac{18}{a^{2}+b^{2}+c^{2}+d^{2}}>\\frac{16}{a^{2}+b^{2}+c^{2}+d^{2}}$\\textbf{problem6 } \\text{ask} \\min {M}$ \\left|a b\\left(a^{2}-b^{2}\\right)+b c\\left(b^{2}-c^{2}\\right)+c a\\left(c^{2}-a^{2}\\right)\\right| \\leqslant M\\left(a^{2}+b^{2}+c^{2}\\right)^{2} L H S=a b\\left(a^{2}-b^{2}+c^{2}-c^{2}\\right)+b c\\left(b^{2}-c^{2}\\right)+c a\\left(c^{2}-a^{2}\\right) \\\\ \\ \\\\ =b\\left(b^{2}-c^{2}\\right)(c-a)+a(c-a)(c+a)(c-b) \\\\ \\ \\\\ =-(a-b)(b-c)(c-a)(a+b+c) \\\\ \\ \\\\ \\text{let } x=a-b, y = b-c, z=c-a, s=a+b+c \\Leftrightarrow 9|sxyz| \\leqslant M\\left(s^{2}+x^{2}+y^{2}+z^{2}\\right)^{2}, \\quad x +y+z =0 \\\\ \\ \\\\$\\textbf{i)}$ x^{2}+y^{2}+z^{2}=x^{2}+y^{2}+(x+y)^{2}=2\\left((x+y)^{2}-x y\\right) \\\\ \\ \\\\ \\geqslant 2\\left((x+y)^{2}-\\frac{(x+y)^{2}}{4}\\right)=\\frac{3}{2}(x+y)^{2} \\\\ \\ \\\\ |s x y z|=|s x y(x+y)| \\leqslant |s| \\frac{(x+y)^{3}}{4}$\\textbf{ii)}$ \\text{let } t = x+y \\\\ \\ \\\\ \\Leftrightarrow \\text{ask} \\quad |s| t^{3} \\leqslant ?\\left(s^{2}+\\frac{3}{2} t^{2}\\right)^{2} \\\\ \\ \\\\ \\Leftrightarrow \\text{ask} \\quad s^{2} t^{6} \\leqslant \\ ? \\frac{\\left(2 s^{2}+3 t^{2}\\right)^{4}}{4} \\\\ \\ \\\\ \\text{we have} \\quad 2 s^{2} t^{6}=2 s^{2} \\cdot t^{2} \\cdot t^{2} \\cdot t^{2} \\leqslant\\left(\\frac{2 s^{2}+3 t^{2}}{4}\\right)^{4} \\\\ \\ \\\\ 4 \\cdot \\sqrt{2}|s| t^{3} \\leqslant \\frac{\\left(2 s^{2}+3 t^{2}\\right)^{2}}{4} \\\\ \\ \\\\ |s x y z| \\leqslant \\frac{1}{16 \\sqrt{2}}\\left(s^{2}+x^{2}+y^{2}+z^{2}\\right)^{2}, M=\\frac{9}{16 \\sqrt{2}} \\\\ \\ \\\\ \\left\\{\\begin{array}{l} \\sqrt{2}(a+b+c)=c-a \\\\ a+b+c=3 \\\\ c-a=3 \\sqrt{2} \\\\ a-b=b-c \\end{array}\\right. \\Rightarrow \\left\\{\\begin{array}{l} b=1 \\\\ c-a=3 \\sqrt{2} \\\\ a+c=2 \\end{array}\\right. \\\\ \\ \\\\ (a, b, c)=\\left(1-\\frac{3}{\\sqrt{2}}, 1,1+\\frac{3}{\\sqrt{2}}\\right)Cauchy求反技术$已知 a+b+c+d = 4，证明$ \\frac{a}{1+b^{2} c}+\\frac{b}{1+c^{2} d}+\\frac{c}{1+d^{2} a}+\\frac{d}{1+a^{2} b} \\geq 2 \\frac{a}{1+b^{2} c}=a-\\frac{a b^{2} c}{1+b^{2} c} \\geqslant a-\\frac{2 b^{2} c}{2 b \\sqrt{c}} \\geqslant a-\\frac{b(a+a c)}{4}\\\\ \\ \\\\ 2 \\sum_{c y c} a b=\\left(\\sum_{c y c} a\\right)^{2}-\\sum_{c y c}\\left(a^{2}\\right) \\Rightarrow \\\\ \\ \\\\ \\Rightarrow \\quad\\left(\\sum_{cyc} a\\right)^{2}=2 \\sum_{c y c} a b+\\sum_{c y c} a^{2} \\geqslant 4 \\sum_{cyc}ab \\\\ \\ \\\\ \\Rightarrow \\sum_{c y c} a b \\leqslant \\frac{1}{4}\\left(\\sum_{c y c} a\\right)^{2} \\\\ \\ \\\\ \\left(\\sum_{c yc4} a\\right)^{3}=4 \\sum_{c y c 4} a^{3}+\\left(\\begin{array}{l} 3 \\\\ 1 \\end{array}\\right)\\left(\\begin{array}{l} 4 \\\\ 1 \\end{array}\\right) \\sum_{c y c 4} a b c \\\\ \\ \\\\ 16 \\sum_{c y c} a b c \\leqslant(\\sum_{cyc} a)^{3}$\\textbf{AM-BM and Chebyshev}$$\\textbf{Chebyshev}$ a_{1} b_{1}+a_{2} b_{1}+\\ldots+a_{n} b_{n} \\geqslant \\frac{1}{n}\\left(a_{1}+a_{2}+\\dots+a_{n}\\right)\\left(b_{1}+b_{2}+\\ldots+b_{n}\\right)$a+b+c=3, \\quad \\text{proof}$ \\sum_{c y c}(a b)^{\\frac{2}{3}} \\leqslant 3 \\\\ \\ \\\\ (a+b+c)^{2} \\geqslant \\frac{1}{9}(a+b+c)(1+1+1)=\\frac{1}{3}(a+b+c) \\\\ \\ \\\\ (a+b+c)^{2}=\\sum_{c y c} a^{2}+2 \\sum_{c y c} a b \\geqslant 3 \\sum_{c y c} a b \\\\ \\ \\\\ \\Rightarrow \\left(\\sum_{c yc} a\\right)^{2}=\\frac{2}{3}\\left(\\sum_{c y c} a\\right)^{2}+\\frac{1}{3}\\left(\\sum_{c y c} a\\right)^{2} \\geqslant 2 \\sum_{c yc} a+\\sum_{c y c} a b \\\\ \\ \\\\ =\\sum_{c y c}(a+a+a b)=\\sum_{c y c}(a+b+a b) \\geqslant 3 \\sum_{c y c}(a b)^{2 / 3}$\\textbf{Rearrangement inequality}$ a+b+c =3, \\quad \\sum_{c y c} a \\geqslant \\sum_{c y c} a b \\\\ \\ \\\\ \\sum_{c y c} a=\\frac{1}{3} \\cdot\\left(\\sum_{c y c} a\\right)\\left(\\sum_{c y c} a\\right)=\\frac{1}{3}\\left(\\sum_{c y c} a\\right)^{2} \\\\ \\ \\\\ \\begin{aligned} &a^{2}+b^{2}+c^{2} \\geqslant a b+b c+c a\\\\ &\\sum_{c y c} a^{2} \\geqslant \\sum_{c y c} a b \\end{aligned} \\\\ \\sum_{c y c} a \\geqslant \\frac{1}{3} \\cdot 3 \\sum_{c y c} a b=\\sum_{c y c} a b$\\textbf{problem}$$a+b+c+d=4, \\ \\text{proof}$ \\sum_{c y c} a b-\\sum_{c y c} a b^{2} c \\\\ \\ \\\\ \\Leftrightarrow a b+b c+c d+d a \\leqslant a b^{2} c+b c^{2} d+c d^{2} a+d a^{2} b \\\\ \\ \\\\ L H S=\\frac{1}{4}(b+c+d+a)(a b+b c+c d+d a) \\\\ \\ \\\\ \\leqslant a b^{2}+b c^{2}+c d^{2}+d a^{2}=\\frac{1}{4}(c+d+a+b)\\left(a b^{2}+b c^{2}+c d^{2}+d a^{2}\\right) \\\\ \\ \\\\ \\leqslant a b^{2} c+b c^{2} d+c d^{2} a+d a^{2} b$\\textbf{Cauchy求反技术的技巧}$ a, b, c>0, \\quad a^{2}+b^{2}+c^{2}=3 \\ \\text{proof} \\\\ \\ \\\\ \\frac{1}{a^{3}+2}+\\frac{1}{b^{3}+2}+\\frac{1}{c^{3}+2} \\geqslant 1 \\\\ \\ \\\\ \\frac{1}{a^{3}+2}=\\frac{1}{2}-\\frac{a^{3}}{2\\left(a^{3}+2\\right)}连分数连分数相关定义$\\textbf{表示}$ \\left[a_{0}, a_{1}\\right]=a_{0}+\\frac{1}{a_{1}} \\\\ \\ \\\\ \\left[a_{0}, a_{1}, \\ldots, a_{n-1}, a_{n}\\right]=\\left[a_{0}, a_{1}, \\ldots, a_{n-2}, a_{n-1}+\\frac{1}{a_{n}}\\right] p_{0}=a_{0}, \\quad p_{1}=a_{1} a_{0}+1, \\quad p_{n}=a_{n} p_{n-1}+p_{n-2} \\quad(2 \\leqslant n \\leqslant N) \\\\ q_{0}=1, \\quad q_{1}=a_{1}, \\quad q_{n}=a_{n} q_{n-1}+q_{n-2} \\quad \\quad \\quad(2 \\leqslant n \\leqslant N) \\\\ \\ \\\\ \\left[a_{0}, a_{1}, \\ldots . ., a_{n}\\right]=\\frac{p_{n}}{q_{n}}$\\textbf{proof}$ \\left[a_{0}, a_{1}, \\ldots, a_{m-1}, a_{m}\\right]=\\frac{p_{m}}{q_{m}}=\\frac{a_{m} p_{m-1}+p_{m-2}}{a_{m} q_{m-1}+q_{m-2}} \\\\ \\ \\\\ \\left[a_{0}, a_{1}, \\ldots, a_{m-1}, a_{m}, a_{m+1}\\right]=\\left[a_{0}, a_{1}, \\ldots ., a_{m-1}, a_{m}+\\frac{1}{a_{m+1}}\\right] \\\\ \\ \\\\ =\\frac{\\left(a_{m}+\\frac{1}{a_{m+1}}\\right) p_{m-1}+p_{m-2}}{\\left(a_{m}+\\frac{1}{a_{m+1}}\\right) q_{m-1}+q_{m-2}}=\\frac{a_{m+1}\\left(a_{m} p_{m-1}+p_{m-2}\\right)+p_{m-1}}{a_{m+1}\\left(a_{m} q_{m-1}+q_{m-2}\\right)+q_{m-1}} \\\\ \\ \\\\ = \\frac{p_{m+1}}{q_{m+1}}$\\textbf{lemma1}$ \\frac{p_{n}}{q_{n}}=\\frac{a_{n} p_{n-1}+p_{n-2}}{a_{n} q_{n-1}+q_{n-2}}$构造递推式如下$ p_{n} q_{n-1}-p_{n-1} q_{n}=\\left(a_{n} p_{n-1}+p_{n-2}\\right) q_{n-1}-p_{n-1}\\left(a_{n} q_{n-1}+q_{n-2}\\right) \\\\ \\ \\\\ =(-1)^{1}\\left(p_{n-1} q_{n-2}-p_{n-2} q_{n-1}\\right)=(-1)^{n-1}\\left(p_1q_{0}-p_{0} q_{1}\\right)=(-1)^{n-1}$还有$ p_{n} q_{n-2}-p_{n-2} q_{n}=\\left(a_{n} p_{n-1}+p_{n-2}\\right) q_{n-2}-p_{n-2}\\left(a_{n} q_{n-1}+q_{n-2}\\right) \\\\ \\ \\\\ =a_{n}\\left(p_{n-1} q_{n-2}-p_{n-2} q_{n-1}\\right)=(-1)^{n-2} \\cdot a_{n}=(-1)^{n} a_{n} p_{n} q_{n-1}-p_{n-1} q_{n}=(-1)^{n-1} \\\\ \\left.p_{n} q_{n-2}-p_{n-2} q_{n}=(-1\\right)^{n} a_{n} \\\\ \\ \\\\ \\frac{p_{n}}{q_{n}}-\\frac{p_{n-1}}{q_{n-1}}=\\frac{(-1)^{n-1}}{q_{n-1} q_{n}} \\\\ \\ \\\\ \\frac{p_{n}}{q_{n}}-\\frac{p_{n-2}}{q_{n-2}}=\\frac{(-1)^{n} a_{n}}{q_{n-2} q_{n}}$由此可以知道分奇偶项，得到的单调性$ $\\textbf{lemma2}$$\\text{if} \\quad n &gt; 3, \\quad q_n \\geqslant n$ q_{0}=1, \\quad q_{1}=a_{1} \\geqslant 1 \\\\ q_{n}=a_{n} q_{n-1}+q_{n-2} \\geqslant q_{n-1}+1=n-1+1=n \\\\ \\ \\\\ 根据数学归纳法，证毕$\\textbf{theorem1}$$x\\ 可以用一个奇数个渐进分数的连分数表示出来$$那么也一定能用偶数个渐进分数的连分数表示$ \\left[a_{0}, a_{1}, \\dots a_{n}\\right]=\\left[a_{0}, a_{1}, \\dots a_{n}-1,1\\right], \\quad a_n \\geqslant 2 \\\\ \\ \\\\ \\text{if} \\quad a_n = 1, \\left[a_{0}, a_{1}, \\ldots, a_{n-1}, 1\\right]=\\left[a_{0}, a_{1}, \\ldots, a_{n-2}, a_{n-1}+1\\right]$\\textbf{theorem2}$$连分数的第 \\ n \\ 个完全商$$a_{n}^{\\prime}=\\left[a_{n}, a_{n+1}, \\ldots, a_{N}\\right] \\quad(0 \\leqslant n \\leqslant N)$ x=a_{0}^{\\prime}, \\quad x=a_{0}+\\frac{1}{a_{1}^{\\prime}}=\\frac{a_{0} a_{1}^{\\prime}+1}{a_{1}^{\\prime}} \\\\ \\ \\\\ \\left[a_{n}, a_{1}, \\ldots, a_{N}\\right]=\\left[a_{0}, a_{1}, \\ldots a_{n-1},\\left[a_{n}, a_{n+1}, \\dots, a_{N}\\right]\\right] \\\\ \\ \\\\ =\\frac{\\left[a_{n}, a_{n+1} \\ldots, a_{n}\\right] p_{n-1}+p_{n-2}}{\\left[a_{n}, a_{n+1} \\dots, a_{n}\\right] q_{n-1}+q_{n-2}} \\\\ \\ \\\\ x=\\frac{a_{n}' p_{n-1}+p_{n-2}}{a_{n}' q_{n-1}+q_{n-2}}$\\textbf{theorem3}$$除了 \\ a_N = 1，有 a_{N-1} = [a_{N-1}’]-1$$其他情况，a_n = [a_n’]$ 注意到，a_{n}^{\\prime}=a_{n}+\\frac{1}{a_{n+1}'} \\quad(0 \\leqslant n \\leqslant N-1) \\textbf{i)}\\quad N = 0, a_0 = a_0'=[a_0'] \\\\ \\ \\\\ \\textbf{ii)}\\quad N > 0，\\ n = N-1, a_{n+1}^{\\prime}=1, a_{N}=1，我们有 \\\\ \\ \\\\ a_{N-1}^{\\prime}=a_{N-1}+\\frac{1}{a_{N}^{\\prime}}=a_{N-1}+1>1 \\\\ \\ \\\\ \\text{from } \\ n + 1 \\ \\text{down to} \\ n，a_{n+1}^{\\prime}>1 \\quad(0 \\leqslant n \\leqslant N-1) \\\\ \\ \\\\ a_{n}0, \\ldots\\\\ &x=a_{0}+\\xi_{0} \\quad\\left(0 \\leqslant \\xi_{0}","categories":[{"name":"math","slug":"math","permalink":"https://www.fogsail.net/categories/math/"}],"tags":[{"name":"math","slug":"math","permalink":"https://www.fogsail.net/tags/math/"}]},{"title":"一些通用的数学概念和记号","slug":"20200419","date":"2020-04-20T03:22:27.000Z","updated":"2020-04-23T17:19:04.459Z","comments":true,"path":"2020/04/20/20200419/","link":"","permalink":"https://www.fogsail.net/2020/04/20/20200419/","excerpt":"最近想着有空的时候把数学捡起来这篇博文写了分析学中的集合论先从分析学开始吧","text":"最近想着有空的时候把数学捡起来这篇博文写了分析学中的集合论先从分析学开始吧 集合论一些结论的证明$\\textbf{solution1}$$X \\times Y = \\emptyset \\iff (X=\\emptyset) \\vee (Y =\\emptyset)$ $\\textbf{proof}$ \\emptyset = (x \\in X) \\wedge (x \\in C_MX) \\\\ \\begin{cases} (x \\in X) \\wedge (y \\in Y) = (x \\in X) \\wedge (x \\in C_MX) & \\\\ (x \\in X) \\wedge (y \\in Y) = (y \\in Y) \\wedge (y \\in C_MY) & \\end{cases} \\Rightarrow (x \\in X) \\wedge (y \\in Y) = (x \\in C_MX) \\wedge (y \\in C_MY) \\\\ \\begin{cases} X = C_MX \\\\ Y=C_MY\\end{cases} \\Rightarrow (x=\\emptyset) \\vee (y = \\emptyset)另一方面 (X = \\emptyset) \\vee (Y=\\emptyset) \\Rightarrow \\forall(x,y), \\ (x\\in C_MX) \\vee (y \\in C_MY) \\Rightarrow \\forall (x,y), \\ x \\in C_M(X\\times Y) \\\\ \\Rightarrow \\forall (x,y), \\ x \\notin X\\times Y$X, Y$ 任意，所以 $X \\times Y = \\emptyset$ $\\textbf{solution2}$$(A\\times B)\\subset (X \\times Y) \\iff (A \\subset X) \\wedge (B \\subset Y)$ $\\textbf{proof}$ Let \\ \\textbf{P}=(x \\in A) \\wedge (y \\in B), \\ \\textbf{Q}=(x\\in X) \\wedge (y \\in Y) \\\\ P \\Rightarrow Q \\iff (\\lnot p \\vee Q)$1)$ (\\lnot p) \\vee ((x \\in X) \\wedge (y \\in Y)) \\iff (\\lnot p \\vee (x\\in X)) \\wedge (\\lnot p \\vee (y \\in Y)) \\\\ \\iff (p \\Rightarrow (x \\in X)) \\wedge (p \\Rightarrow (y \\in Y)) x \\in A \\Rightarrow x\\in X \\iff (A \\subset X) \\\\ y \\in B \\Rightarrow y\\in Y \\iff (B \\subset Y)$2)$根据命题等价性，右边推左边也同理 $\\textbf{ solution3 }$$(X \\times Y) \\cup (Z \\times Y) = (X \\cup Z) \\times Y$ \\forall x \\in X, \\forall y \\in Y, \\forall z\\in Z, \\\\ (x \\in X) \\vee (y \\in Y) \\vee (z \\in Z) \\vee (y \\in Y) \\\\ \\iff \\{(x, z) | (x \\in X) \\vee (z \\in Z)\\} \\cup Y \\iff (X \\cup Z) \\times Y$\\textbf{ solution4 }$$(X \\times Y) \\cap (X’ \\times Y’) = (X \\cap X’) \\times (Y \\cap Y’)$ 不妨假设$u \\in (X \\cap X’), \\ v \\in (Y \\cap Y’)$ \\{(u, v) | (u \\in (X \\cap X')) \\wedge (v \\in (Y \\cap Y'))\\} \\\\ \\iff \\{(u, v) | (u \\in X) \\wedge (u \\in X') \\wedge (v \\in Y) \\wedge (v \\in Y')\\} \\\\ \\iff \\{(u, v) | [(u \\in x) \\wedge (v \\in Y)] \\ \\wedge \\ [(u \\in X') \\wedge (v \\in Y')]\\}令 $A = X \\times Y, \\ B = X’ \\times Y’$ \\{(u, v) | (u \\in X) \\wedge (v \\in Y)\\} \\Rightarrow \\{p | p \\in A\\} \\\\ \\{(u, v) | (u \\in X') \\wedge (v \\in Y')\\} \\Rightarrow \\{p | p \\in B\\} \\\\ \\iff \\{p | (p \\in A) \\wedge (p \\in B)\\} \\iff A \\cap B \\iff (X \\times Y) \\cap (X' \\times Y')$\\textbf{solution5} \\ 反对称性$ S \\Delta T=(S \\backslash T) \\cup(T \\backslash S) \\\\ S \\backslash T=S \\cup(\\neg T), \\quad T \\backslash S=T \\cup(\\neg S) \\\\ (S \\cup T) \\cup\\left(\\neg T \\cup \\neg S\\right)=(S \\cup T) \\cup(\\neg(S \\cap T)) \\\\ =(S \\cup T) \\backslash(S \\cap T)函数的表示$\\textbf{ solution1 }$$(A \\subset B) \\Rightarrow (f(A) \\subset f(B))$ $1) (A \\subset B) \\Rightarrow \\quad f(A) \\subset f(B)$ f(A) := \\{y \\in Y | \\exists x, (x \\in A) \\wedge (y \\in f(x))\\} \\\\ A \\subset B \\iff (x \\in A \\Rightarrow x \\in B) \\\\ \\Rightarrow \\{y \\in Y | \\exists x, (x \\in B) \\wedge (y \\in f(x))\\} = f(B)$2) \\ (f(A) \\subset f(B)) \\not \\Rightarrow (A \\subset B)$ \\{y \\in Y | \\exists x, (x \\in A)\\} \\Rightarrow \\{y \\in Y | \\exists x, x \\in B\\} \\\\ \\exists x, (x \\in A) \\Longrightarrow \\exists x, (x \\in B) \\\\ \\iff \\exists x, \\ (x \\in A) \\wedge (x \\not \\in B)$\\textbf{ solution2 }$$A \\neq \\emptyset \\Rightarrow f(A) \\neq \\emptyset$ \\exists x, x \\in A \\\\ Let \\ x_1 \\in A \\Rightarrow f(x_1) = y_1 \\Leftrightarrow \\exists y_1 \\in Y \\\\ \\iff \\{\\exists x | x \\in A \\} \\Rightarrow \\{\\exists y | f(x) = y\\}$\\textbf{ solution3 }$$f(A \\cap B) \\subset (f(A) \\cap f(B))$ f(A):=\\{y \\in Y | \\exists x \\ (x \\in (A \\cap B)) \\wedge (y \\in f(x))\\} \\\\ \\{\\exists x, x \\in (A \\cap B) \\wedge y \\in f(x)\\} \\Rightarrow \\{\\exists x | (x \\in A) \\wedge (y \\in f(x)) \\wedge (x \\in B) \\wedge (y \\in f(x)\\} \\\\ \\Rightarrow f(A) \\cap f(B)$\\textbf{ solution4 }$$f(A \\cap B) = f(A) \\cap f(B)$ f(A \\cap B):= \\{y \\in Y | \\exists x, (x \\in (A \\cap B) \\wedge (y \\in f(x)))\\} \\\\ \\{\\exists x,y | ((x \\in A) \\vee (x \\in B)) \\wedge (y \\in f(x))\\} \\\\ \\iff \\{\\exists x,y | (x \\in A \\wedge y \\in f(x)) \\vee (x \\in B \\wedge y \\in f(x))\\} \\\\ \\iff f(A) \\cup f(B)$\\textbf{ solution5 }$$A^{\\prime} \\subset B^{\\prime} \\Rightarrow f^{-1}\\left(A^{\\prime}\\right) \\subset f^{-1}\\left(B^{\\prime}\\right)$需要用到定义$f^{-1}(B)={x \\in X | f(x) \\in B}$ A^{\\prime} \\subset B^{\\prime} \\iff f(x) \\in A^{\\prime} \\Rightarrow f(x) \\in B^{\\prime} \\iff \\left\\{x \\in X | f(x) \\in A^{\\prime}\\right\\} \\Rightarrow\\left\\{x \\in X | f(x) \\in B^{\\prime}\\right\\} \\\\ f^{-1}(A) \\subset f^{-1}(B)$\\textbf{ solution6 }$$f^{-1}\\left(A^{\\prime} \\cap B^{\\prime}\\right)=f^{-1}\\left(A^{\\prime}\\right) \\cap f^{-1}\\left(B^{\\prime}\\right)$ \\left\\{x \\in X |\\left(f(x) \\in A^{\\prime}\\right) \\wedge\\left(f(x) \\in B^{\\prime}\\right)\\right\\} \\\\ \\Leftrightarrow\\left\\{x \\in X\\left|f(x) \\in A^{\\prime}\\right\\} \\cap\\left\\{x \\in X | f(x) \\in B^{\\prime}\\right\\}\\right.\\\\ \\iff f^{-1}\\left(A^{\\prime}\\right) \\cap f^{-1}\\left(B^{\\prime}\\right)$\\textbf{ solution7 }$$f^{-1}\\left(A^{\\prime} \\cup B^{\\prime}\\right)=f^{-1}\\left(A^{\\prime}\\right) \\cup f^{-1}\\left(B^{\\prime}\\right)$同理可证 $\\textbf{solution8 }$$f^{-1}(A / B)=f^{-1}(A) / f^{-1}(B)$ \\{x \\in X |(f(x) \\in A) \\wedge(f(x) \\notin B)\\} \\iff \\left\\{x \\in X\\left|f(x) \\in A\\} \\cap\\left\\{x \\in X | f^{\\prime}(x) \\notin B\\right\\}\\right.\\right. \\\\ \\Leftrightarrow f^{-1}(A) / f^{-1}(B)$\\textbf{ solution9 }$$f^{-1}\\left(C_{Y} A\\right)=C_{X} f^{-1}(A)$ C_{X} f^{-1}(A)=X-\\{x \\in X |f(x) \\in A\\} \\\\ =\\{x \\in X | f(x) \\notin A\\}=\\left\\{x \\in X | f(x) \\in C_{Y} A\\right\\} = f^{-1}\\left(C_{Y} A\\right)$\\textbf{ solution10 }$$\\begin{aligned}&amp;\\forall A, \\ A \\subset X\\&amp;\\forall B , \\ B \\subset Y\\end{aligned}$有 $f^{-1}(f(A)) \\supset A$ 需要用到的很重要的结论是 f(A)=\\{y \\in Y | \\exists x, \\quad(x \\in A) \\wedge(y \\in f(x))\\} \\text { i) } \\quad x \\in A \\Rightarrow f(x) \\in f(A) \\\\ \\text {ii)} \\quad A \\subset X \\Rightarrow x \\in A, x \\in X \\\\ \\Rightarrow \\{x \\in X | f(x) \\in f(A)\\}=f^{-1}(f(x)) \\\\ let \\ \\textbf{M} = \\{x \\in X | f(x) \\in f(A)\\} \\iff \\{x \\in A \\Rightarrow x \\in \\textbf{M} \\} \\Rightarrow A \\subset M \\iff f^{-1}(f(A)) \\supset A$\\textbf{ solution11 }$$f\\left(f^{-1}(B)\\right) \\subset B$ M=f^{-1}(B)=\\{x \\in X | f(x) \\in B\\} \\\\ f(M)=\\{y \\in Y, \\exists x|(x \\in M) \\wedge(y \\in f(x))\\} \\\\ \\Rightarrow f(M)=\\{y \\in Y, \\exists x \\in X \\ | \\ (f(x) \\in B) \\wedge(y \\in f(x))\\}所以存在这样的一个 $x$ \\exists x_i, f(x_i) \\in B \\\\ \\Leftrightarrow\\{y \\in Y |(f(x) \\in B) \\wedge(y \\in f(x))\\} \\subset B \\\\ \\iff f(f^{-1}(B)) \\subset B函数的其他命题（一）$\\textbf{ solution1 }$$\\mathcal{R}_1 \\subset X \\times Y, \\quad \\mathcal{R}_2 \\subset Y \\times X$ 满足$\\left(\\mathcal{R}_{1} \\circ \\mathcal{R}_{2}=\\Delta_{x}\\right) \\wedge\\left(\\mathcal{R}_{2} \\circ \\mathcal{R}_{1}=\\Delta_{Y}\\right)$它们都是函数关系 \\left\\{\\begin{array}{l} \\mathcal{R}_{1} \\subset X \\times Y \\\\ \\mathcal{R}_{2} \\subset Y \\times X \\end{array}\\right. \\Rightarrow \\mathcal{R}_{2} \\circ \\mathcal{R}_{1}= \\left\\{\\exists y,(x \\mathcal{R}_1 y) \\wedge\\left(y \\mathcal{R}_{2} x\\right)\\right\\} = \\Delta_y不妨设 $\\mathcal{R} = \\mathcal{R}_2 \\circ \\mathcal{R}_1$ \\left\\{\\begin{array}{l} \\left.x \\mathcal{R} y_{1}=\\{\\exists y_{1},\\quad\\left(x \\mathcal{R}_1 y_{1}\\right) \\wedge\\left(y_{1}\\mathcal{R}_{2} x\\right)\\right\\}=\\Delta_{Y} \\\\ x \\mathcal{R} y_{2}=\\left\\{\\exists y_{2}, \\quad\\left(x \\mathcal{R}_1y_{2}\\right) \\wedge\\left(y_{2} \\mathcal{R}_{2} x\\right)\\right\\}=\\Delta_{Y} \\end{array}\\right. \\iff y_1=y_2同理可证，$\\mathcal{R}_2 \\circ \\mathcal{R}_1$为函数关系 $\\textbf{ solution2 }$$\\mathcal{R} \\subset X^{2}$，传递性等价于$\\mathcal{R} \\circ \\mathcal{R} \\subset \\mathcal{R}$ $\\text{i)}$， 根据传递性 $(a \\mathcal{R} b) \\wedge (b \\mathcal{R} c) \\Rightarrow (a \\mathcal{R} c)$$\\exists a \\in X, \\exists b \\in X$， 因为 $\\mathcal{R}$ 是建立在 $X \\times X$ 上的关系所以有 $c \\in X$ $\\text{ii)}$，有 \\mathcal{R} \\circ \\mathcal{R}=\\{\\exists x,(x \\mathcal{R} x) \\wedge(x \\mathcal{R} x)\\} \\subset\\{\\forall x | x \\in X \\times X\\} \\subset \\mathcal{R} \\\\ \\iff \\mathcal{R} \\circ \\mathcal{R} \\subset \\mathcal{R}$\\textbf{ solution3 }$$\\mathcal{R}’ \\subset Y \\times X \\ \\text{和} \\ \\mathcal{R} \\subset X \\times Y \\ \\text{满足} \\ (y \\mathcal{R}’ x) \\Leftrightarrow (x \\mathcal{R} y), \\text{则} \\ \\mathcal{R}’ \\text{是} \\ \\mathcal{R} \\text{的转置关系}$$\\mathcal{R} \\subset X^2 \\text{的反对称性等价于} \\ \\mathcal{R} \\cap \\mathcal{R}’ \\subset \\Delta_X$ \\exists a \\in X, \\exists b \\in X, \\quad(a \\mathcal{R} b) \\wedge(b \\mathcal{R} a) \\Rightarrow a=b \\text{因为} (b \\mathcal{R} a) \\Leftrightarrow (a \\mathcal{R}' b) \\iff (a \\mathcal{R} b) \\wedge (a \\mathcal{R}' b) \\Rightarrow a = b \\iff (\\mathcal{R} \\cap \\mathcal{R}') X = X \\\\ \\text{所以有} \\mathcal{R} \\cap \\mathcal{R}' \\subset \\Delta_X$\\textbf{ solution4 }$$\\text{当且仅当} \\mathcal{R} \\cup \\mathcal{R}’ = X^2 \\text{时，集合} X \\text{中的任意两个元素由} \\mathcal{R} \\subset X^2 \\text{相联系}$ \\text{因为} \\mathcal{R} \\subset X^2, \\quad \\forall a, b \\in X, \\quad a \\mathcal{R} b \\in X \\Leftrightarrow b \\mathcal{R}' a \\in X \\\\ \\text{所以} (a \\mathcal{R} b) \\cup (b \\mathcal{R}' a) \\in X^2 \\\\ \\iff \\mathcal{R} \\cup \\mathcal{R}' = X^2 \\text{另一方面}, \\mathcal{R} \\cup \\mathcal{R}'，\\text{显然} \\mathcal{R} \\subset X^2, \\ \\mathcal{R}' \\subset X^2函数的其他命题（二）$f:X \\to Y\\text{是映射}， y \\in Y的原像f^{-1}(y) \\subset X 称为 y上的层$ $\\textbf{ solution1 }$$x_1 \\in X, x_2 \\in X, \\text{如果} f(x_1)=f(x_2)，\\text{认为} x_1, x_2 \\text{由关系} \\mathcal{R} \\subset X^2 \\text{相联系，并记作} x_1 \\mathcal{R} x_2, \\mathcal{R}\\text{是等价关系}$ \\text{i)， 很显然} x_1 \\mathcal{R} x_2 = x_2 \\mathcal{R} x_1 \\\\ \\text{ii)} \\ x_1 \\mathcal{R} a := f(x_1)=f(a), \\quad a \\mathcal{R} x_2:=f(a)=f(x_2) \\\\ (x_1 \\mathcal{R} a) \\wedge (a \\mathcal{R} x_2) \\Rightarrow f(x_1)=f(a)=f(x_2) \\Rightarrow f(x_1)=f(x_2) \\\\ \\text{是等价关系}$\\textbf { solution2 }$$\\text{i)} \\quad f: X\\to Y \\text{的层互不相交，而所有层的并集是整个集合} X$ \\text{如果} X \\to Y \\text{的层相交}, f^{-1}(y_1) = f^{-1}(y_2) = x_1 \\\\ f(x_1) = y_1 \\quad f(x_1) = y_2, \\text{与映射定义矛盾}$\\text{ii)} \\quad f^{-1}(y_1) \\cup f^{-1}(y_2) \\cup \\cdots f^{-1}(y_n) = x_1 \\cup x_2 \\cup \\cdots \\cup x_n = X$ 映射的性质$\\textbf{solution1}$$\\textbf{映射} f:X \\to Y \\text{是满射, 当且仅当} \\forall B \\subset Y, f(f^{-1}(B))= B$ \\text{a)} \\quad \\forall x \\in f^{-1}(B), f(x) \\in B \\subset Y \\\\ \\forall x \\in X, f(x) = \\bigcup_{i=1} B_{i} = Y \\iff f(X) = Y \\text{b)} \\quad \\forall B \\subset Y, f(f^{-1}(B)) = B, \\text{保证了} f \\text{是满射} \\text{，下面证明} f \\text{为单射} \\\\ \\iff f(x_1)=f(x_2) \\Rightarrow x_1=x_2 \\\\ \\text{不妨设} f(x_1) = f(x_2) = p \\in Y \\\\ f^{-1}(f(x_1)) = f^{-1}(p) = \\{x\\in A | f(x)=p\\} = M_1 \\subset A \\\\ f^{-1}(f(x_2)) = f^{-1}(p) = M_2 \\subset A \\\\ f^{-1}(p) = M_1 = M_2, \\text{即它的层是唯一的} \\\\ f(x_1)=f(x_2) \\Rightarrow x_1=x_2$\\textbf{solution2}$$如果\\ f:X \\to Y 与\\ g: Y\\to X 满足\\ g\\circ f=e_X, e_X 为中性元，$$则\\ g \\ 称为 \\ f \\ 的左逆映射，\\ f \\ 称为 \\ g \\ 的右逆映射，可能存在多个单侧逆映射$ \\left(x_{1}, x_{2}, \\ldots \\ldots, x_{n} \\ldots\\right) \\stackrel{f_{a}}{\\rightarrow}\\left(a, x_{1}, x_{n} \\ldots x_{n}\\right) \\\\ 注意到 a 的取值可以是任意的$\\textbf{solution3}$ $f: X \\to Y \\quad g: Y\\to Z 是双射，映射 \\ g \\circ f : X \\to Z 是双射，并且 (g\\circ f)^{-1} = f^{-1} \\circ g^{-1}$ \\text{i)} \\quad 先证满射性，X \\stackrel{f}{\\rightarrow} Y\\stackrel{g} \\rightarrow Z \\\\ (g \\circ f) X = Z \\\\ g \\circ f 为满射 \\text{ii)} \\quad 再证单射性，(g \\circ f)(x_1)=(g\\circ f)(x_2) \\Rightarrow g(f(x_1))=g(f(x_2)) \\\\ g 为单射，f(x_1)=f(x_2) \\\\ f 为单射，x_1=x_2 \\text{iii)} \\quad (f^{-1} \\circ g^{-1}) \\circ (g \\circ f) = f^{-1} \\circ (g^{-1}\\circ g) \\circ f= f^{-1} \\circ e_Y \\circ f \\\\ = f^{-1} \\circ f = e_X$\\textbf{solution4}$$对于任何映射 \\ f : X\\to Y, 由 x \\stackrel {F} \\longmapsto (x, f(x)) 定义的映射$$F: X \\to X \\times Y 是单射$ f(x_1) = f(x_2) \\Rightarrow x_1 = x_2 \\\\ \\forall x_1 \\neq x_2, f(x_1) \\neq f(x_2) \\Rightarrow (x_1, f(x_1)) \\neq (x_2, f(x_2)) \\\\ F(x_1)=F(x_2) \\Rightarrow x_1 = x_2极限理论基础$极限为A，A的邻域之外，有有限个点，在数学上要注意表示形式$$比如，证明极限的唯一性的时候，要想证明邻域重合$ \\forall n > N_1, x_1 \\in V(A_1) \\\\ \\forall n > N_2, x_2 \\in V(A_2) \\\\ 不妨设 \\ A_1 < A_2，N_1 < N_2 \\\\ 此时，使得 \\ A_1 + \\epsilon = A_2 - \\epsilon \\\\ \\epsilon = \\frac{A_1-A_2}{2}，更一般地，让 \\ \\epsilon = \\frac{|A_1 - A_2|}{2}$\\textbf{solution1}$ \\left|A \\cdot B-x_{n} y_{n}\\right| \\leqslant \\left|x_{n}\\right|\\left(\\Delta y_{n}\\right)+\\left|y_{n}\\right|\\left(\\Delta x_{n}\\right)+\\Delta x_{n} \\Delta y_{n} \\\\ \\ \\\\ 构造 \\frac{\\epsilon}{3} \\begin{aligned} &\\left\\{\\begin{array}{l} \\Delta x_{n}","categories":[{"name":"math","slug":"math","permalink":"https://www.fogsail.net/categories/math/"}],"tags":[{"name":"math","slug":"math","permalink":"https://www.fogsail.net/tags/math/"}]},{"title":"高级数据结构（二）","slug":"20200411","date":"2020-04-11T10:32:26.000Z","updated":"2020-05-14T05:35:44.105Z","comments":true,"path":"2020/04/11/20200411/","link":"","permalink":"https://www.fogsail.net/2020/04/11/20200411/","excerpt":"这部分重点介绍一下KDTree，CDQ分治等等","text":"这部分重点介绍一下KDTree，CDQ分治等等 KDTree介绍 KDTree模版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122const int maxn = 1e6 + 5;const int NIL = -1;// == Point definition ==class Point &#123;public: int id, x, y; Point() &#123;&#125; Point(int _id, int _x, int _y) : id(_id), x(_x), y(_y) &#123;&#125; bool operator&lt; (const Point&amp; rhs) const &#123; return id &lt; rhs.id; &#125; void print() &#123; printf(\"%d\\n\", id); &#125;&#125;;Point pt[maxn];bool cmpx(const Point&amp; p1, const Point&amp; p2) &#123; return p1.x &lt; p2.x;&#125;bool cmpy(const Point&amp; p1, const Point&amp; p2) &#123; return p1.y &lt; p2.y;&#125;// == Point finished ==// == KDTree structure ==class Node &#123;public: int loc; int cld[2];&#125;;inline int sgn(int d) &#123; return d % 2;&#125;Node T[maxn];int tot = 0, root;void init() &#123; tot = 0; _for(i, 0, maxn) T[i].cld[0] = T[i].cld[1] = NIL;&#125;int buildKD(int l, int r, int d) &#123; if(l &gt;= r) return NIL; int mid = (l + r) &gt;&gt; 1; int t = ++tot; if(sgn(d) == 0) sort(pt + l, pt + r, cmpx); else sort(pt + l, pt + r, cmpy); T[t].loc = mid; T[t].cld[0] = buildKD(l, mid, d + 1); T[t].cld[1] = buildKD(mid + 1, r, d + 1); return t;&#125;// == KDTree finished ==// == query ==void query(int u, int sx, int tx, int sy, int ty, int d, vector&lt;Point&gt;&amp; ans) &#123; int x = pt[T[u].loc].x; int y = pt[T[u].loc].y; if(sx &lt;= x &amp;&amp; x &lt;= tx &amp;&amp; sy &lt;= y &amp;&amp; y &lt;= ty) ans.push_back(pt[T[u].loc]); if(sgn(d) == 0) &#123; if(T[u].cld[0] != NIL) &#123; if(sx &lt;= x) query(T[u].cld[0], sx, tx, sy, ty, d + 1, ans); &#125; if(T[u].cld[1] != NIL) &#123; if(x &lt;= tx) query(T[u].cld[1], sx, tx, sy, ty, d + 1, ans); &#125; &#125; else &#123; if(T[u].cld[0] != NIL) &#123; if(sy &lt;= y) query(T[u].cld[0], sx, tx, sy, ty, d + 1, ans); &#125; if(T[u].cld[1] != NIL) &#123; if(y &lt;= ty) query(T[u].cld[1], sx, tx, sy, ty, d + 1, ans); &#125; &#125;&#125;// == query finsihed ==int N = 0;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int x, y; scanf(\"%d\", &amp;N); _for(i, 0, N) &#123; scanf(\"%d%d\", &amp;x, &amp;y); pt[i] = Point(i, x, y); &#125; init(); root = buildKD(0, N, 0); int q; scanf(\"%d\", &amp;q); int sx, tx, sy, ty; vector&lt;Point&gt; ans; _for(i, 0, q) &#123; scanf(\"%d%d%d%d\", &amp;sx, &amp;tx, &amp;sy, &amp;ty); ans.clear(); query(root, sx, tx, sy, ty, 0, ans); sort(ans.begin(), ans.end()); _for(k, 0, ans.size()) ans[k].print(); puts(\"\"); &#125;&#125; KDTree插入和删除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148const int K = 2;const int inf = 0x3f3f3f3f;// == tree definition ==class Node &#123;public: int point[K]; Node *cld[2];&#125;;typedef Node* T;T create(const int arr[]) &#123; T cur = new Node(); _for(i, 0, K) cur-&gt;point[i] = arr[i]; cur-&gt;cld[0] = cur-&gt;cld[1] = NULL; return cur;&#125;// == tree finished ==// == insert function ==T insertRec(T u, const int point[], int dep) &#123; if(u == NULL) return create(point); int cd = dep % K; if(point[cd] &lt; u-&gt;point[cd]) u-&gt;cld[0] = insertRec(u-&gt;cld[0], point, dep + 1); else u-&gt;cld[1] = insertRec(u-&gt;cld[1], point, dep + 1); return u;&#125;T insert(T u, const int point[]) &#123; return insertRec(u, point, 0);&#125;// == insert finished ==// == search rectangle ==bool equalPoint(const int point1[], const int point2[]) &#123; _for(i, 0, K) if(point1[i] != point2[i]) return false; return true;&#125;bool searchRec(T u, const int point[], int dep) &#123; if(u == NULL) return false; if(equalPoint(u-&gt;point, point)) return true; int cd = dep % K; if(point[cd] &lt; u-&gt;point[cd]) return searchRec(u-&gt;cld[0], point, dep + 1); return searchRec(u-&gt;cld[1], point, dep + 1);&#125;bool search(T u, const int point[]) &#123; return searchRec(u, point, 0);&#125;// == search finished ==// == find min rec ==T findMinRec(T u, int _cd, int dep) &#123; if(u == NULL) return NULL; int cd = dep % K; if(cd == _cd) &#123; if(u-&gt;cld[0] == NULL) return u; return findMinRec(u-&gt;cld[0], _cd, dep + 1); &#125; T left = findMinRec(u-&gt;cld[0], _cd, dep + 1); T right = findMinRec(u-&gt;cld[1], _cd, dep + 1); T cur = left-&gt;point[_cd] &lt; right-&gt;point[_cd] ? left : right; return cur-&gt;point[_cd] &lt; u-&gt;point[_cd] ? cur : u;&#125;T findMin(T u, int _cd) &#123; return findMinRec(u, _cd, 0);&#125;// == find finished ==// == delete node ==void copyPoint(int to[], const int point[]) &#123; _for(i, 0, K) to[i] = point[i];&#125;T delRec(T u, const int point[], int dep) &#123; if(u == NULL) return NULL; int cd = dep % K; // it is the point to be deleted if(equalPoint(u-&gt;point, point)) &#123; if(u-&gt;cld[1]) &#123; T _min = findMin(u-&gt;cld[1], cd); copyPoint(u-&gt;point, _min-&gt;point); u-&gt;cld[1] = delRec(u-&gt;cld[1], _min-&gt;point, dep + 1); &#125; else if(u-&gt;cld[0]) &#123; T _min = findMin(u-&gt;cld[0], cd); copyPoint(u-&gt;point, _min-&gt;point); u-&gt;cld[1] = delRec(u-&gt;cld[0], _min-&gt;point, dep + 1); &#125; else &#123; // is leaf node delete u; return NULL; &#125; return u; &#125; if(point[cd] &lt; u-&gt;point[cd]) u-&gt;cld[0] = delRec(u-&gt;cld[0], point, dep + 1); else u-&gt;cld[1] = delRec(u-&gt;cld[1], point, dep + 1); return u;&#125;T del(T u, const int point[]) &#123; return delRec(u, point, 0);&#125;// == delete finished ==int n;int main() &#123; T root = NULL; int points[][K] = &#123; &#123;3,6&#125;, &#123;17, 15&#125;, &#123;13, 15&#125;, &#123;6, 12&#125;, &#123;9, 1&#125;, &#123;2, 7&#125;, &#123;10, 19&#125; &#125;; n = sizeof(points) / sizeof(points[0]); _for(i, 0, n) root = insert(root, points[i]); int p1[] = &#123;10, 19&#125;; search(root, p1) ? printf(\"Found\\n\") : printf(\"Not found\\n\"); int p2[] = &#123;12, 19&#125;; search(root, p2) ? printf(\"Found\\n\") : printf(\"Not found\\n\"); int p3[] = &#123;10, 19&#125;; int p4[] = &#123;9, 1&#125;; del(root, p3); search(root, p3) ? printf(\"Found\\n\") : printf(\"Not found\\n\"); search(root, p4) ? printf(\"Found\\n\") : printf(\"Not found\\n\");&#125; KDTree寻找K近邻HDU4347 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135const int maxn = (5e4 + 10) * 2;const int NIL = 0;const int inf = 0x3f3f3f3f;// == KDTree Node definition ==int cd, K;class Node &#123;public: int x[6], cld[2]; ll _max[6], _min[6]; bool operator&lt; (const Node&amp; rhs) const &#123; if(x[cd] != rhs.x[cd]) return x[cd] &lt; rhs.x[cd]; _rep(i, cd + 1, K) if(x[i] != rhs.x[i]) return x[i] &lt; rhs.x[i]; _for(i, 1, cd) if(x[i] != rhs.x[i]) return x[i] &lt; rhs.x[i]; return x[cd] &lt; rhs.x[cd]; &#125;&#125;;Node T[maxn];inline void pushup(int x, int y) &#123; _rep(i, 1, K) &#123; T[x]._max[i] = max(T[x]._max[i], T[y]._max[i]); T[x]._min[i] = min(T[x]._min[i], T[y]._min[i]); &#125;&#125;int build(int l, int r, int dep) &#123; if(l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; cd = dep % K; nth_element(T + l, T + mid, T + r + 1); _rep(i, 1, K) T[mid]._min[i] = T[mid]._max[i] = T[mid].x[i]; T[mid].cld[0] = T[mid].cld[1] = NIL; if(l &lt; mid) &#123; T[mid].cld[0] = build(l, mid - 1, dep + 1); pushup(mid, T[mid].cld[0]); &#125; if(r &gt; mid) &#123; T[mid].cld[1] = build(mid + 1, r, dep + 1); pushup(mid, T[mid].cld[1]); &#125; return mid;&#125;int rt;// == KDTree finished ==int n, m, q;// == temp node for update ==typedef pair&lt;ll, Node&gt; PLN;priority_queue&lt;PLN&gt; que;ll euclid(const Node&amp; a, const Node&amp; b) &#123; ll ans = 0; _rep(i, 1, K) ans += 1ll * (a.x[i] - b.x[i]) * (a.x[i] - b.x[i]); return ans;&#125;// == temp node finsihed ==// == k closest query ==Node goal;void query(int u, int dep) &#123; if(!u) return; ll res = euclid(T[u], goal); if(res &lt; que.top().first) &#123; que.pop(); PLN cur(res, T[u]); que.push(cur); &#125; int cd = dep % K; ll cut = T[u].x[cd] - goal.x[cd]; if(cut &gt; 0) &#123; query(T[u].cld[0], dep + 1); if(cut*cut &lt; que.top().first) query(T[u].cld[1], dep + 1); &#125; else &#123; query(T[u].cld[1], dep + 1); if(cut*cut &lt; que.top().first) query(T[u].cld[0], dep + 1); &#125;&#125;// == k closest query finsiehd ==void init() &#123; _rep(i, 1, K) T[0]._max[i] = -inf, T[0]._min[i] = inf;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (~scanf(\"%d%d\", &amp;n, &amp;K)) &#123; init(); _rep(i, 1, n) _rep(j, 1, K) scanf(\"%d\", &amp;T[i].x[j]); // build KDTree and use KDTree rt = build(1, n, 1); // finished scanf(\"%d\", &amp;q); while (q--) &#123; _rep(i, 1, K) scanf(\"%d\", &amp;goal.x[i]); scanf(\"%d\", &amp;m); PLN _NIL(inf, Node()); _rep(i, 1, m) que.push(_NIL); // query closest m points query(rt, 1); stack&lt;PLN&gt; stk; while (!que.empty()) &#123; stk.push(que.top()); que.pop(); &#125; printf(\"the closest %d points are:\\n\", m); while (!stk.empty()) &#123; PLN ans = stk.top(); stk.pop(); _rep(i, 1, K) &#123; printf(\"%d\", ans.second.x[i]); i != K ? printf(\" \") : printf(\"\\n\"); &#125; &#125; &#125; &#125;&#125; HDU5992 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122const int maxn = (200000 + 5) * 2;const ll inf = 0x3f3f3f3f3f3f3f3f;const int NIL = 0;// == KDTree definition ==int cd, K = 2;class Node &#123;public: int x[2], cld[2]; int cost, id; bool operator&lt; (const Node&amp; rhs) const &#123; return x[cd] &lt; rhs.x[cd]; &#125;&#125; T[maxn];int rt;// usage, build(1, n, 0)int build(int l, int r, int dep) &#123; if(l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; cd = dep % K; nth_element(T+l, T+mid, T+r+1); T[mid].cld[0] = T[mid].cld[1] = NIL; if(l &lt; mid) T[mid].cld[0] = build(l, mid - 1, dep + 1); if(r &gt; mid) T[mid].cld[1] = build(mid + 1, r, dep + 1); return mid;&#125;// == KDTree definition finsished ==// == ans used for update ==ll euclid(const Node&amp; a, const Node&amp; b) &#123; ll ans = 0; _for(i, 0, K) ans += 1ll * (a.x[i] - b.x[i]) * (a.x[i] - b.x[i]); return ans;&#125;bool valid(const Node&amp; cur, const Node&amp; goal) &#123; return cur.cost &lt;= goal.cost;&#125;typedef pair&lt;ll, Node&gt; PLN;PLN ans;// == ans finsihed ==// == query ==void query(int u, const Node&amp; goal, int dep) &#123; if(!u) return; ll res = euclid(T[u], goal); if(res == ans.first &amp;&amp; T[u].id &lt; ans.second.id &amp;&amp; valid(T[u], goal)) &#123; PLN cur(res, T[u]); ans = cur; &#125; if(res &lt; ans.first &amp;&amp; valid(T[u], goal)) &#123; PLN cur(res, T[u]); ans = cur; &#125; int cd = dep % K; ll cut = T[u].x[cd] - goal.x[cd]; if(cut &gt; 0) &#123; query(T[u].cld[0], goal, dep + 1); if(cut*cut &lt; ans.first) query(T[u].cld[1], goal, dep + 1); &#125; else &#123; query(T[u].cld[1], goal, dep + 1); if(cut*cut &lt; ans.first) query(T[u].cld[0], goal, dep + 1); &#125;&#125;// == query finsihed ==int n, m;void init() &#123; K = 2;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; init(); // == input data == scanf(\"%d%d\", &amp;n, &amp;m); _rep(i, 1, n) &#123; _for(j, 0, 2) scanf(\"%d\", &amp;T[i].x[j]); scanf(\"%d\", &amp;T[i].cost); T[i].id = i; &#125; // == input finsihed == // == build kdtree == rt = build(1, n, 0); // == build finsihed == for(; m; m--) &#123; Node goal; _for(j, 0, 2) scanf(\"%d\", &amp;goal.x[j]); scanf(\"%d\", &amp;goal.cost); PLN _NIL(inf, Node()); ans = _NIL; // == query for closest point == query(rt, goal, 0); // == query finsihed == _for(i, 0, K) printf(\"%d \", ans.second.x[i]); printf(\"%d\\n\", ans.second.cost); &#125; &#125;&#125; KDTree统计区间点数UVA12939 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181const int maxn = 200000 + 10;const int NIL = 0;int n, d, m;// == Point definition ==class Point &#123;public: int x, y;&#125; PO[maxn];// == Point finsihed ==// == Node definition ==int ID[maxn]; /* used for mapping ID */int K = 2, cd;class KDTree &#123;public: int xy[2], xymin[2], xymax[2]; int cld[2]; int sum, fa, num; bool operator&lt; (const KDTree&amp; rhs) const &#123; return xy[cd] &lt; rhs.xy[cd]; &#125; inline void update(); inline void _init(int i);&#125; T[maxn];inline void KDTree::_init(int i) &#123; ID[fa] = i; _for(j, 0, K) xymax[j] = xymin[j] = xy[j]; num = sum = 0; cld[0] = cld[1] = NIL;&#125;inline void KDTree::update() &#123; _for(i, 0, K) if(cld[i]) _for(j, 0, K) &#123; xymin[j] = min(xymin[j], T[cld[i]].xymin[j]); xymax[j] = max(xymax[j], T[cld[i]].xymax[j]); &#125;&#125;int build(int l, int r, int dep, int _fa) &#123; if(l &gt; r) return NIL; int mid = (l + r) &gt;&gt; 1; cd = dep % K; nth_element(T + l, T + mid, T + r + 1); KDTree&amp; cur = T[mid]; //assert(cur.fa != 0); cur._init(mid); assert(ID[cur.fa] == mid); cur.fa = _fa; if(l &lt; mid) cur.cld[0] = build(l, mid - 1, dep + 1, mid); if(r &gt; mid) cur.cld[1] = build(mid + 1, r, dep + 1, mid); cur.update(); return mid;&#125;int root;// == Node definition finished ==// == KDTree query ==ll ANS[maxn];inline bool inRange(int x, int l, int r) &#123; return l &lt;= x &amp;&amp; x &lt;= r;&#125;int query(int u, int x1, int x2, int y1, int y2) &#123; int res = 0; const KDTree&amp; cur = T[u]; if(cur.xymin[0] &gt; x2 || cur.xymax[0] &lt; x1 || cur.xymin[1] &gt; y2 || cur.xymax[1] &lt; y1 || cur.sum == 0) &#123; return 0; &#125; if(x1 &lt;= cur.xymin[0] &amp;&amp; cur.xymax[0] &lt;= x2 &amp;&amp; y1 &lt;= cur.xymin[1] &amp;&amp; cur.xymax[1] &lt;= y2) &#123; return cur.sum; &#125; if(inRange(cur.xy[0], x1, x2) &amp;&amp; inRange(cur.xy[1], y1, y2)) res += cur.num; _for(i, 0, K) if(cur.cld[i]) &#123; res += query(cur.cld[i], x1, x2, y1, y2); &#125; return res;&#125;// == KDTree query finished ==// == Mo algo ==int belong[maxn];int sz, t;class Qry &#123;public: int l, r, id;&#125; qry[maxn];void block() &#123; sz = sqrt(n); t = n / sz; _rep(i, 1, t) _rep(k, (i - 1) * sz + 1, i * sz) belong[k] = i; if(t * sz &lt; n) &#123; t++; _rep(k, (t - 1) * sz + 1, n) belong[k] = t; &#125;&#125;bool cmp(const Qry&amp; a, const Qry&amp; b) &#123; if(belong[a.l] ^ belong[b.l]) return belong[a.l] &lt; belong[b.l]; return a.r &lt; b.r;&#125;void add(int pos, ll&amp; ans) &#123; ans += query(root, PO[pos].x - d, PO[pos].x + d, PO[pos].y - d, PO[pos].y + d); int ti = ID[pos]; T[ti].num = 1; while (ti) T[ti].sum++, ti = T[ti].fa;&#125;void del(int pos, ll&amp; ans) &#123; int ti = ID[pos]; T[ti].num = 0; while (ti) T[ti].sum--, ti = T[ti].fa; ans -= query(root, PO[pos].x - d, PO[pos].x + d, PO[pos].y - d, PO[pos].y + d);&#125;// == Mo algo finished ==void init() &#123; Set(ID, 0); Set(belong, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); for(int t = 1, x, y; scanf(\"%d%d%d\", &amp;n, &amp;d, &amp;m) == 3; t++) &#123; init(); printf(\"Case %d:\\n\", t); // input point data _rep(i, 1, n) &#123; KDTree&amp; cur = T[i]; scanf(\"%d%d\", &amp;x, &amp;y); cur.xy[0] = PO[i].x = x + y; cur.xy[1] = PO[i].y = x - y; cur.fa = i; &#125; // build tree root = build(1, n, 0, 0); // block for Mo algorithm // remember sort query then Mo algorithm _rep(i, 1, m) &#123; scanf(\"%d%d\", &amp;qry[i].l, &amp;qry[i].r); qry[i].id = i; &#125; block(); sort(qry + 1, qry + 1 + m, cmp); // use Mo algo and KDTree query int l = 1, r = 0; ll ans = 0; _rep(i, 1, m) &#123; int ql = qry[i].l, qr = qry[i].r; while (r &lt; qr) add(++r, ans); while (r &gt; qr) del(r--, ans); while (l &lt; ql) del(l++, ans); while (l &gt; ql) add(--l, ans); ANS[qry[i].id] = ans; &#125; _rep(i, 1, m) printf(\"%lld\\n\", ANS[i]); &#125;&#125; KDTree和并查集HDU5809 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184const int maxn = (1e5 + 5) * 2;const ll inf = 0x3f3f3f3f3f3f3f3f;const int NIL = 0;int n, q;int ID[maxn];// == KDTree definition ==int cd, K = 2;class Node &#123;public: ll x[2]; int cld[2]; ll xymax[2], xymin[2]; int id; bool operator&lt; (const Node&amp; rhs) const &#123; if(x[0] != rhs.x[0]) return x[0] &lt; rhs.x[0]; return x[1] &lt; rhs.x[1]; &#125; void _init(int i) &#123; ID[id] = i; _for(j, 0, K) xymin[j] = xymax[j] = x[j]; cld[0] = cld[1] = NIL; &#125; inline void update();&#125; Tree[maxn];inline void Node::update() &#123; _for(i, 0, K) if(cld[i]) _for(j, 0, K) &#123; xymin[j] = min(xymin[j], Tree[cld[i]].xymin[j]); xymax[j] = max(xymax[j], Tree[cld[i]].xymax[j]); &#125;&#125;bool cmp(const Node&amp; a, const Node&amp; b) &#123; return a.x[cd] &lt; b.x[cd];&#125;// Point cur = pt[Tree[u].id]int root;// == KDTree finished ==// == build tree ==int build(int l, int r, int dep) &#123; if(l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; cd = dep % K; nth_element(Tree + l, Tree + mid, Tree + r + 1, cmp); Tree[mid]._init(mid); if(l &lt; mid) Tree[mid].cld[0] = build(l, mid - 1, dep + 1); if(mid &lt; r) Tree[mid].cld[1] = build(mid + 1, r, dep + 1); Tree[mid].update(); return mid;&#125;// == build fisniehd ==// == used to solve ==struct A &#123; ll dist; Node nd; A() &#123;&#125;; A(ll d, Node nd) : dist(d), nd(nd) &#123;&#125;&#125; res;// dist init to infinline ll euclid(const Node&amp; a, const Node&amp; b) &#123; ll ans = 0; _for(i, 0, K) ans += 1ll * (a.x[i] - b.x[i]) * (a.x[i] - b.x[i]); return ans;&#125;inline ll manhatten(int u, const Node&amp; goal) &#123; ll ans = 0; const Node&amp; cur = Tree[u]; _for(i, 0, K) &#123; ans += (max(cur.xymin[i] - goal.x[i], 0LL) + max(goal.x[i] - cur.xymax[i], 0LL)) * (max(cur.xymin[i] - goal.x[i], 0LL) + max(goal.x[i] - cur.xymax[i], 0LL)); &#125; return ans;&#125;void querymin(int u, const Node&amp; goal) &#123; if(!u) return; if(goal.id != Tree[u].id) &#123; ll dist = euclid(goal, Tree[u]); if(dist == res.dist &amp;&amp; Tree[u] &lt; res.nd) &#123; res.nd = Tree[u]; &#125; if(dist &lt; res.dist) &#123; res.dist = dist; res.nd = Tree[u]; &#125; &#125; ll dl = Tree[u].cld[0] ? manhatten(Tree[u].cld[0], goal) : inf; ll dr = Tree[u].cld[1] ? manhatten(Tree[u].cld[1], goal) : inf; if(dl &lt; dr) &#123; if(dl &lt;= res.dist) querymin(Tree[u].cld[0], goal); if(dr &lt;= res.dist) querymin(Tree[u].cld[1], goal); &#125; else &#123; if(dr &lt;= res.dist) querymin(Tree[u].cld[1], goal); if(dl &lt;= res.dist) querymin(Tree[u].cld[0], goal); &#125;&#125;// == finsihed ==// == findset definition ==int pa[maxn];int findset(int x) &#123; return pa[x] == x ? x : pa[x] = findset(pa[x]);&#125;// == findset finsihed ==// == solve the problem ==void fi(int i) &#123; res = A(inf, Node()); querymin(root, Tree[ID[i]]); int to = res.nd.id; int u = findset(i); int v = findset(to); //printf(\"#: %d, %d, %d, %d\\n\", i, to, u, v); if(u != v) pa[u] = v;&#125;// == solve finished ==void init() &#123; // K = 2; res = A(inf, Node()); Set(ID, 0); _for(i, 0, maxn) pa[i] = i;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); for(int _ = 1; _ &lt;= kase; _++) &#123; printf(\"Case #%d:\\n\", _); init(); scanf(\"%d%d\", &amp;n, &amp;q); _rep(i, 1, n) &#123; scanf(\"%lld%lld\", &amp;Tree[i].x[0], &amp;Tree[i].x[1]); Tree[i].id = i; &#125; // build KDTree root = build(1, n, 0); //_rep(i, 1, n) debug(ID[i]); // query min dist _rep(i, 1, n) fi(i); // debug _rep(i, 1, q) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); findset(x) == findset(y) ? puts(\"YES\") : puts(\"NO\"); &#125; &#125;&#125; KDTree剪枝优化LA7825 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164const int inf = 0x3f3f3f3f;const int maxn = 1e5 + 5;const int maxm = 100 + 5;int n;// == KDTree definition ==int cd = 0;const int K = 2;struct Base &#123; int x[2]; int tp;&#125; sta[maxn];class Node &#123;public: Node *cld[2]; int xy[2]; int tp; int tot; int sum[maxm]; int x1, x2, y1, y2; void border(int L, int R, int&amp; _x1, int&amp; _x2, int&amp; _y1, int&amp; _y2) &#123; _rep(i, L, R) &#123; Base&amp; cur = sta[i]; _x1 = min(_x1, cur.x[0]); _x2 = max(_x2, cur.x[0]); _y1 = min(_y1, cur.x[1]); _y2 = max(_y2, cur.x[1]); &#125; &#125; inline void _init(int _tp = 0, int _x1 = 0, int _x2 = 0, int _y1 = 0, int _y2 = 0) &#123; tot = 0; Set(sum, 0); cld[0] = cld[1] = NULL; x1 = _x1; x2 = _x2; y1 = _y1; y2 = _y2; tp = _tp; &#125; inline void getData(int tid) &#123; const Base&amp; _cur = sta[tid]; _for(i, 0, K) xy[i] = _cur.x[i]; sum[_cur.tp]++; tot = 1; &#125; void update();&#125; memory[maxn * 2];typedef Node* T;Node *mem = memory;Node *root;void Node::update() &#123; _for(i, 0, K) if(cld[i]) &#123; _for(j, 0, maxm) sum[j] += cld[i]-&gt;sum[j]; tot += cld[i]-&gt;tot; &#125;&#125;// == KDTree finished ==// == build KDTree ==inline bool cmp(const Base&amp; a, const Base&amp; b) &#123; return a.x[cd] &lt; b.x[cd];&#125;void build(T&amp; cur, int l, int r, int dep) &#123; if(l &gt; r) return; cur = ++mem; int _x1, _x2, _y1, _y2; _x1 = _y1 = inf; _x2 = _y2 = 0; cur-&gt;border(l, r, _x1, _x2, _y1, _y2); //assert(dbg(cur) != 0); //debug(dbg(cur)); cd = dep % K; int mid = (l + r) &gt;&gt; 1; nth_element(sta + l, sta + mid, sta + r + 1, cmp); cur-&gt;_init(sta[mid].tp, _x1, _x2, _y1, _y2); cur-&gt;getData(mid); build(cur-&gt;cld[0], l, mid - 1, dep + 1); build(cur-&gt;cld[1], mid + 1, r, dep + 1); cur-&gt;update();&#125;// == build KDTree finished ==// == used for calculate ==inline int sqr(int x) &#123; return x * x;&#125;inline int maxdist(T cur, const Base&amp; goal) &#123; if(!cur) return 0; int ans = sqr(cur-&gt;x1 - goal.x[0]) + sqr(cur-&gt;y1 - goal.x[1]); ans = max(ans, sqr(cur-&gt;x1 - goal.x[0]) + sqr(cur-&gt;y2 - goal.x[1])); ans = max(ans, sqr(cur-&gt;x2 - goal.x[0]) + sqr(cur-&gt;y1 - goal.x[1])); ans = max(ans, sqr(cur-&gt;x2 - goal.x[0]) + sqr(cur-&gt;y2 - goal.x[1])); return ans;&#125;inline int euclid(T cur, const Base&amp; goal) &#123; return sqr(cur-&gt;xy[0] - goal.x[0]) + sqr(cur-&gt;xy[1] - goal.x[1]);&#125;void query(const T &amp;cur, const Base&amp; goal, int&amp; res) &#123; if(!cur) return; if(cur-&gt;tot == cur-&gt;sum[goal.tp]) return; if(maxdist(cur, goal) &lt;= res) return; if(cur-&gt;tp != goal.tp) &#123; res = max(res, euclid(cur, goal)); &#125; int d[2], flag = 1; d[0] = maxdist(cur-&gt;cld[0], goal); d[1] = maxdist(cur-&gt;cld[1], goal); if(d[0] &gt; d[1]) flag ^= 1; if(d[flag] &gt; res) query(cur-&gt;cld[flag], goal, res); if(d[flag^1] &gt; res) query(cur-&gt;cld[flag^1], goal, res);&#125;void solve() &#123; int ans = 0; _rep(i, 1, n) query(root, sta[i], ans); printf(\"%d\\n\", ans);&#125;// == calculate finsihed ==void init() &#123; _for(i, 0, maxn) (memory + i)-&gt;_init(); mem = memory; root = NULL;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; // input sta data _rep(i, 1, n) &#123; Base&amp; cur = sta[i]; scanf(\"%d%d%d\", &amp;cur.x[0], &amp;cur.x[1], &amp;cur.tp); &#125; init(); // build KDTree build(root, 1, n, 0); // solve solve(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"高级数据结构（一）","slug":"20200327","date":"2020-03-27T11:19:44.000Z","updated":"2020-04-07T13:33:40.389Z","comments":true,"path":"2020/03/27/20200327/","link":"","permalink":"https://www.fogsail.net/2020/03/27/20200327/","excerpt":"这里给出一些字符串算法的实现，和一些高级数据结构主要有后缀数组，trie树，splay树等等","text":"这里给出一些字符串算法的实现，和一些高级数据结构主要有后缀数组，trie树，splay树等等 后缀数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445class suffixArray &#123;public: int str[maxn], sa[maxn]; int c[maxn], t1[maxn], t2[maxn]; int n; void build(int R) &#123; *x = t1, *y = t2; // radix sort according to 1stKey _for(i, 0, R) c[i] = 0; _for(i, 0, n) c[x[i] = str[i]]++; _for(i, 1, R) c[i] += c[i - 1]; _forDown(i, n - 1, 0) sa[--c[x[i]]] = i; // manber-myers loop for(int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; // construct y[], use sa[] to construct 2ndKey int p = 0; _for(i, n-k, n) y[p++] = i; _for(i, 0, n) if(sa[i] &gt;= k) y[p++] = sa[i] - k; // radix sort y[], according to (1st, 2nd) key _for(i, 0, R) c[i] = 0; _for(i, 0, n) c[x[y[i]]]++; _for(i, 1, R) c[i] += c[i - 1]; _forDown(i, n - 1, 0) sa[--c[x[y[i]]]] = y[i]; &#125; // update x[] and loop swap(x, y); x[sa[0]] = 0; p = 1; _for(i, 1, n) &#123; bool flag = (x[sa[i]] == x[sa[i - 1]] &amp;&amp; x[sa[i]+k] == x[sa[i-1]+k]); x[sa[i]] = (flag ? p - 1 : p++); &#125; // update p and R if(p &gt;= n) break; R = p; &#125;&#125;; splay树复习，用二叉树遍历debug 二叉树遍历debug，其中根据前序和中序来推导层序，是很常见的12345678910111213T build(int pl, int pr, int il, int ir) &#123; if(pl &gt; pr || il &gt; ir) return NULL; int rt = post[pr]; Node *cur = new Node(rt); int mid = search(in, il, ir, rt); int num = mid - il; cur-&gt;cld[0] = build(pl, pl + num - 1, il, mid - 1); cur-&gt;cld[1] = build(pl + num, pr - 1, mid + 1, ir); return cur;&#125; 记得根据左子树的点个数，来完成递归 splay的基本操作 BZOJ1588 指针版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238const int maxn = 1e6 + 8;const int mod = 1000000;const int inf = 0x3f3f3f3f;int n;// == tree structure ==class Node &#123;public: static Node *root;#define root Node::root Node* pa; Node* cld[2]; int val, cnt; Node() &#123;&#125; Node(int v, Node* pa) : val(v), pa(pa) &#123; cld[0] = cld[1] = NULL; cnt = 1; &#125; int sgn() &#123; return pa-&gt;cld[1] == this; &#125; void setc(int d, Node* x) &#123; cld[d] = x; if(x) x-&gt;pa = this; &#125; void rot(int d) &#123; Node *y = pa, *z = y-&gt;pa; if(z) z-&gt;setc(y-&gt;sgn(), this); if(y) y-&gt;setc(d, cld[d^1]); setc(d^1, y); &#125; void rot() &#123; rot(sgn()); &#125; Node* splay(const Node* to) &#123; if(this == to) return this; while (pa != to) &#123; if(pa == NULL) &#123; root = this; break; &#125; if(pa-&gt;pa == to) &#123; rot(); break; &#125; else &#123; int a = sgn(), b = pa-&gt;sgn(); (a^b ? this : pa)-&gt;rot(a); rot(b); &#125; &#125; return this; &#125;&#125; *root;typedef Node* T;void build() &#123; root = new Node(-inf, NULL); root-&gt;cld[1] = new Node(inf, root);&#125;// == tree structure finished ==// == debug ==void dbg(const T&amp; rt) &#123; T p = rt; if(p-&gt;cld[0]) dbg(p-&gt;cld[0]); printf(\"\\n\"); debug(p-&gt;val); if(p-&gt;pa) debug(p-&gt;pa-&gt;val); if(p-&gt;cld[1]) dbg(p-&gt;cld[1]);&#125;// == debug finsihed ==// == void insert operation ==void insert(const T&amp; p, int x) &#123; T u = p; T pa = NULL; while (u &amp;&amp; u-&gt;val != x) &#123; pa = u; u = u-&gt;cld[x &gt; u-&gt;val]; &#125; if(u != NULL) u-&gt;cnt++; else &#123; if(pa != NULL) &#123; u = new Node(x, pa); pa-&gt;cld[x &gt; pa-&gt;val] = u; &#125; else &#123; u = new Node(x, NULL); root = u; &#125; &#125; u-&gt;splay(root);&#125;// == insert finsihed ==// == delete data ==T find(int x) &#123; T u = root; while (true) &#123; if(x == u-&gt;val) return u; if(u-&gt;cld[x &gt; u-&gt;val] == NULL) return NULL; u = u-&gt;cld[x &gt; u-&gt;val]; &#125;&#125;void del(int x) &#123; T u = find(x); if(u == NULL) return; u-&gt;splay(root); if(u-&gt;cnt &gt; 1) &#123; u-&gt;cnt--; return; &#125; if(u-&gt;cld[0] == NULL) &#123; int d = u-&gt;sgn(); u-&gt;pa-&gt;setc(d, u-&gt;cld[1]); delete u; u = NULL; &#125; else &#123; int d = u-&gt;sgn(); T pre = u-&gt;cld[0]; while (pre-&gt;cld[1]) pre = pre-&gt;cld[1]; pre-&gt;splay(u); pre-&gt;setc(1, u-&gt;cld[1]); u-&gt;pa-&gt;setc(d, pre); delete u; u = NULL; &#125;&#125;void rmvTree(T&amp; p) &#123; if(p-&gt;cld[0]) rmvTree(p-&gt;cld[0]); if(p-&gt;cld[1]) rmvTree(p-&gt;cld[1]); delete p; p = NULL;&#125;// == delete finsihed ==// == precursor and successor ==int getNxt(const T&amp; rt, int val) &#123; int ans = inf; T p = rt; while (p) &#123; if(val == p-&gt;val) &#123; if(p-&gt;cnt &gt;= 1) &#123; ans = p-&gt;val; return ans; &#125; if(p-&gt;cld[1]) &#123; p = p-&gt;cld[1]; while (p-&gt;cld[0]) p = p-&gt;cld[0]; ans = p-&gt;val; &#125; break; &#125; if(p-&gt;val &gt; val &amp;&amp; p-&gt;val &lt; ans) ans = p-&gt;val; p = val &lt; p-&gt;val ? p-&gt;cld[0] : p-&gt;cld[1]; &#125; return ans;&#125;int getPre(const T&amp; rt, int val) &#123; int ans = -inf; T p = rt; while (p) &#123; if(val == p-&gt;val) &#123; if(p-&gt;cnt &gt;= 1) &#123; ans = p-&gt;val; return ans; &#125; if(p-&gt;cld[0]) &#123; p = p-&gt;cld[0]; while (p-&gt;cld[1]) p = p-&gt;cld[1]; ans = p-&gt;val; &#125; break; &#125; if(p-&gt;val &lt; val &amp;&amp; p-&gt;val &gt; ans) ans = p-&gt;val; p = val &lt; p-&gt;val ? p-&gt;cld[0] : p-&gt;cld[1]; &#125; return ans;&#125;// == precursor finished ==int ans = 0;void init() &#123; ans = 0;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); build(); init(); scanf(\"%d\", &amp;n); scanf(\"%d\", &amp;ans); n--; insert(root, ans); while (n--) &#123; int x; scanf(\"%d\", &amp;x); int pre = getPre(root, x); int nxt = getNxt(root, x); ans += min(abs(pre - x), abs(nxt - x)); insert(root, x); &#125; printf(\"%d\", ans); rmvTree(root);&#125; 数组版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235const int maxn = 1e6 + 10;const int mod = 1000000;const int inf = 0x3f3f3f3f;const int NIL = 0;int n;// == define tree ==class Node &#123;public: int pa; int cld[2]; int val, cnt;&#125; node[maxn];inline int sgn(int x) &#123; return node[node[x].pa].cld[1] == x;&#125;int tot = 0;int root;int New(int val, int pa) &#123; node[++tot].val = val; node[tot].pa = pa; node[tot].cnt = 1; return tot;&#125;void build() &#123; root = New(-inf, NIL); node[root].cld[1] = New(inf, root);&#125;void dbg(int p) &#123; if(node[p].cld[0]) dbg(node[p].cld[0]); printf(\"\\n\"); debug(node[p].val); debug(node[node[p].pa].val); if(node[p].cld[1]) dbg(node[p].cld[1]);&#125;// == tree finished ==// == rotate ==void setc(int q, int d, int p) &#123; if(p) node[p].pa = q; if(q) node[q].cld[d] = p; if(q == NIL) root = p;&#125;inline void rot(int x, int d) &#123; int y = node[x].pa, z = node[y].pa; if(z) setc(z, sgn(y), x); if(y) setc(y, d, node[x].cld[d^1]); setc(x, d^1, y);&#125;inline void rot(int x) &#123; rot(x, sgn(x));&#125;// == rotate finished ==// == void splay ==int splay(int p, const int to) &#123; if(p == to) return p; while (node[p].pa != to) &#123; if(node[p].pa == NIL) &#123; root = p; break; &#125; if(node[node[p].pa].pa == to) &#123; rot(p); break; &#125; else &#123; int a = sgn(p), b = sgn(node[p].pa); rot((a^b ? p : node[p].pa), a); rot(p, b); &#125; &#125; return p;&#125;// == splay finished ==// == insert element ==void insert(const int p, int x) &#123; int u = p; int pa = NIL; while (u &amp;&amp; node[u].val != x) &#123; pa = u; u = node[u].cld[x &gt; node[u].val]; &#125; if(u) node[u].cnt++; else &#123; if(pa) &#123; u = New(x, pa); node[pa].cld[x &gt; node[pa].val] = u; &#125; else &#123; u = New(x, NIL); root = u; &#125; &#125; splay(u, root);&#125;// == insert finished ==// == delete element ==int find(int x) &#123; int u = root; while (true) &#123; if(node[u].val == x) return u; if(node[u].cld[x &gt; node[u].val] == 0) return NIL; u = node[u].cld[x &gt; node[u].val]; &#125;&#125;void _del(int x) &#123; node[x].cld[0] = node[x].cld[1] = 0; node[x].pa = 0; node[x].val = node[x].cnt = 0; if(x == tot) tot--;&#125;void del(int x) &#123; int u = find(x); if(u == NIL) return; splay(u, root); if(node[u].cnt &gt; 1) &#123; node[u].cnt--; return; &#125; if(node[u].cld[0] == 0) &#123; int d = sgn(u); setc(node[u].pa, d, node[u].cld[1]); _del(u); &#125; else &#123; int d = sgn(u); int pre = node[u].cld[0]; while (node[pre].cld[1]) pre = node[pre].cld[1]; splay(pre, u); setc(pre, 1, node[u].cld[1]); setc(node[u].pa, d, pre); _del(u); &#125;&#125;// == delete finsihed ==// == pre and next ==int getPre(const int rt, int val) &#123; int ans = -inf; int p = rt; while (p) &#123; if(node[p].val == val) &#123; if(node[p].cnt &gt;= 1) &#123; ans = node[p].val; return ans; &#125; if(node[p].cld[0]) &#123; p = node[p].cld[0]; while (node[p].cld[1]) p = node[p].cld[1]; ans = node[p].val; &#125; break; &#125; if(node[p].val &lt; val &amp;&amp; node[p].val &gt; ans) ans = node[p].val; p = val &lt; node[p].val ? node[p].cld[0] : node[p].cld[1]; &#125; return ans;&#125;int getNxt(const int rt, int val) &#123; int ans = inf; int p = rt; while (p) &#123; if(node[p].val == val) &#123; if(node[p].cnt &gt;= 1) &#123; ans = node[p].val; return ans; &#125; if(node[p].cld[1]) &#123; p = node[p].cld[1]; while (node[p].cld[0]) p = node[p].cld[0]; ans = node[p].val; &#125; break; &#125; if(node[p].val &gt; val &amp;&amp; node[p].val &lt; ans) ans = node[p].val; p = val &lt; node[p].val ? node[p].cld[0] : node[p].cld[1]; &#125; return ans;&#125;// == pre and next finsihed ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;n); build(); int ans; scanf(\"%d\", &amp;ans); insert(root, ans); n--; while (n--) &#123; int x; scanf(\"%d\", &amp;x); int pre = getPre(root, x); int nxt = getNxt(root, x); ans += min(abs(pre - x), abs(nxt - x)); insert(root, x); &#125; printf(\"%d\", ans);&#125; splay树的插入和删除 BZOJ1208 指针版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295const int maxn = 1e6 + 8;const int mod = 1000000;const int inf = 0x3f3f3f3f;int n;// == tree structure ==class Node &#123;public: static Node *root;#define root Node::root Node* pa; Node* cld[2]; int val, cnt; Node() &#123;&#125; Node(int v, Node* pa) : val(v), pa(pa) &#123; cld[0] = cld[1] = NULL; cnt = 1; &#125; int sgn() &#123; return pa-&gt;cld[1] == this; &#125; void setc(int d, Node *x) &#123; cld[d] = x; if(x) x-&gt;pa = this; &#125; void rot(int d) &#123; Node *y = pa, *z = y-&gt;pa; if(z) z-&gt;setc(y-&gt;sgn(), this); if(y) y-&gt;setc(d, cld[d^1]); setc(d^1, y); &#125; void rot() &#123; rot(sgn()); &#125; Node *splay(const Node *to) &#123; if(this == to) return this; while (pa != to) &#123; if(pa == NULL) &#123; root = this; break; &#125; if(pa-&gt;pa == to) &#123; rot(); break; &#125; else &#123; int a = sgn(), b = pa-&gt;sgn(); (a^b ? this : pa)-&gt;rot(a); rot(b); &#125; &#125; return this; &#125;&#125; *root;typedef Node* T;void build() &#123; root = new Node(-inf, NULL); root-&gt;cld[1] = new Node(inf, root);&#125;// == tree structure finished ==// == debug ==void dbg(const T&amp; rt) &#123; T p = rt; if(p-&gt;cld[0]) dbg(p-&gt;cld[0]); printf(\"\\n\"); debug(p-&gt;val); if(p-&gt;pa) debug(p-&gt;pa-&gt;val); if(p-&gt;cld[1]) dbg(p-&gt;cld[1]);&#125;// == debug finished ==// == insert operation ==void insert(const T&amp; p, int x) &#123; T u = p; T pa = NULL; while (u &amp;&amp; u-&gt;val != x) &#123; pa = u; u = u-&gt;cld[x &gt; u-&gt;val]; &#125; if(u != NULL) u-&gt;cnt++; else &#123; if(pa != NULL) &#123; u = new Node(x, pa); pa-&gt;cld[x &gt; pa-&gt;val] = u; &#125; else &#123; u = new Node(x, NULL); root = u; &#125; &#125; u-&gt;splay(root);&#125;// == insert finsihed ==// == remove tree ==T find(int x) &#123; T u = root; while (true) &#123; if(u-&gt;val == x) return u; if(u-&gt;cld[x &gt; u-&gt;val] == NULL) return NULL; u = u-&gt;cld[x &gt; u-&gt;val]; &#125;&#125;void del(int x) &#123; T u = find(x); if(u == NULL) return; u-&gt;splay(root); if(u != root) assert(u-&gt;pa == root); if(u-&gt;cnt &gt; 1) &#123; u-&gt;cnt--; return; &#125; if(u-&gt;cld[0] == NULL) &#123; int d = u-&gt;sgn(); u-&gt;pa-&gt;setc(d, u-&gt;cld[1]); delete u; u = NULL; &#125; else &#123; int d = u-&gt;sgn(); T pre = u-&gt;cld[0]; while (pre-&gt;cld[1]) pre = pre-&gt;cld[1]; pre-&gt;splay(u); assert(u-&gt;cld[0] == pre); pre-&gt;setc(1, u-&gt;cld[1]); u-&gt;pa-&gt;setc(d, pre); delete u; u = NULL; &#125;&#125;void rmvTree(T&amp; p) &#123; if(p-&gt;cld[0]) rmvTree(p-&gt;cld[0]); if(p-&gt;cld[1]) rmvTree(p-&gt;cld[1]); delete p; p = NULL;&#125;// == remove finished ==// == previous and successor ==int getNxt(const T&amp; rt, int val) &#123; int ans = inf; T p = rt; while (p) &#123; if(val == p-&gt;val) &#123; if(p-&gt;cnt &gt;= 1) &#123; ans = p-&gt;val; return ans; &#125; if(p-&gt;cld[1]) &#123; p = p-&gt;cld[1]; while (p-&gt;cld[0]) p = p-&gt;cld[0]; ans = p-&gt;val; &#125; break; &#125; if(p-&gt;val &gt; val &amp;&amp; p-&gt;val &lt; ans) ans = p-&gt;val; p = val &lt; p-&gt;val ? p-&gt;cld[0] : p-&gt;cld[1]; &#125; return ans;&#125;int getPre(const T&amp; rt, int val) &#123; int ans = -inf; T p = rt; while (p) &#123; if(val == p-&gt;val) &#123; if(p-&gt;cnt &gt;= 1) &#123; ans = p-&gt;val; return ans; &#125; if(p-&gt;cld[0]) &#123; p = p-&gt;cld[0]; while (p-&gt;cld[1]) p = p-&gt;cld[1]; ans = p-&gt;val; &#125; break; &#125; if(p-&gt;val &lt; val &amp;&amp; p-&gt;val &gt; ans) ans = p-&gt;val; p = val &lt; p-&gt;val ? p-&gt;cld[0] : p-&gt;cld[1]; &#125; return ans;&#125;// == pre and successor finished ==int petnum = 0, ans = 0;void init() &#123; petnum = 0; ans = 0;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); scanf(\"%d\", &amp;n); build(); while (n--) &#123; int opt; scanf(\"%d\", &amp;opt); int x; scanf(\"%d\", &amp;x); if(petnum == 0) &#123; insert(root, x); if(opt == 0) petnum++; else petnum--; &#125; else if(petnum &gt; 0) &#123; // all pet if(opt == 0) &#123; insert(root, x); petnum++; &#125; else &#123; int pre = getPre(root, x); int nxt = getNxt(root, x); if(abs(pre - x) &lt;= abs(nxt - x)) &#123; del(pre); ans = (ans + abs(pre - x)) % mod; //debug(x); &#125; else &#123; del(nxt); ans = (ans + abs(nxt - x)) % mod; //debug(x); &#125; petnum--; &#125; &#125; else &#123; // all people assert(petnum &lt; 0); if(opt == 1) &#123; insert(root, x); petnum--; &#125; else &#123; int pre = getPre(root, x); int nxt = getNxt(root, x); if(abs(pre - x) &lt; abs(nxt - x)) &#123; del(pre); ans = (ans + abs(pre - x)) % mod; //debug(x); &#125; else &#123; del(nxt); ans = (ans + abs(nxt - x)) % mod; //debug(x); &#125; petnum++; &#125; &#125; &#125; //dbg(root); printf(\"%d\", ans); rmvTree(root);&#125; 数组版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288const int maxn = 1e6 + 8;const int mod = 1000000;const int inf = 0x3f3f3f3f;const int NIL = 0;int n;// == define tree ==class Node &#123;public: int pa; int cld[2]; int val, cnt;&#125; node[maxn];inline int sgn(int u) &#123; return node[node[u].pa].cld[1] == u;&#125;int tot = 0;int root;int New(int val, int pa) &#123; node[++tot].val = val; node[tot].pa = pa; node[tot].cnt = 1; return tot;&#125;void build() &#123; root = New(-inf, NIL); node[root].cld[1] = New(inf, root);&#125;void dbg(int p) &#123; if(node[p].cld[0]) dbg(node[p].cld[0]); printf(\"\\n\"); debug(node[p].val); debug(node[node[p].pa].val); if(node[p].cld[1]) dbg(node[p].cld[1]);&#125;// == define tree finished ==// == rotate ==inline void setc(int q, int d, int p) &#123; if(p) node[p].pa = q; if(q) node[q].cld[d] = p; if(q == NIL) root = p;&#125;inline void rot(int x, int d) &#123; int y = node[x].pa, z = node[y].pa; if(z) setc(z, sgn(y), x); if(y) setc(y, d, node[x].cld[d^1]); setc(x, d^1, y);&#125;inline void rot(int x) &#123; return rot(x, sgn(x));&#125;// == rotate finished ==// == splay function ==int splay(int p, const int to) &#123; if(p == to) return p; while (node[p].pa != to) &#123; if(node[p].pa == NIL) &#123; root = p; break; &#125; if(node[node[p].pa].pa == to) &#123; rot(p); break; &#125; else &#123; int a = sgn(p), b = sgn(node[p].pa); rot((a^b ? p : node[p].pa), a); rot(p, b); &#125; &#125; return p;&#125;// == splay finished ==// == insert ==void insert(const int p, int x) &#123; int u = p; int pa = NIL; while (u &amp;&amp; node[u].val != x) &#123; pa = u; u = node[u].cld[x &gt; node[u].val]; &#125; if(u) node[u].cnt++; else &#123; if(pa) &#123; u = New(x, pa); node[pa].cld[x &gt; node[pa].val] = u; &#125; else &#123; u = New(x, NIL); root = u; &#125; &#125; splay(u, root);&#125;// == insert finished ==// == remove node ==int Find(int x) &#123; int u = root; while (true) &#123; if(node[u].val == x) return u; if(node[u].cld[x &gt; node[u].val] == 0) return NIL; u = node[u].cld[x &gt; node[u].val]; &#125;&#125;void _del(int x) &#123; node[x].cld[0] = node[x].cld[1] = 0; node[x].pa = 0; node[x].val = node[x].cnt = 0; if(x == tot) tot--;&#125;void del(int x) &#123; int u = Find(x); if(u == NIL) return; splay(u, root); if(u != root) assert(node[u].pa == root); if(node[u].cnt &gt; 1) &#123; node[u].cnt--; return; &#125; if(node[u].cld[0] == 0) &#123; int d = sgn(u); setc(node[u].pa, d, node[u].cld[1]); _del(u); &#125; else &#123; int d = sgn(u); int pre = node[u].cld[0]; while (node[pre].cld[1]) pre = node[pre].cld[1]; splay(pre, u); assert(node[u].cld[0] == pre); setc(pre, 1, node[u].cld[1]); setc(node[u].pa, d, pre); _del(u); &#125;&#125;// == remove finished ==// == precursor and successor ==int getNxt(const int rt, int val) &#123; int ans = inf; int p = rt; while (p) &#123; if(val == node[p].val) &#123; if(node[p].cnt &gt;= 1) &#123; ans = node[p].val; return ans; &#125; if(node[p].cld[1]) &#123; p = node[p].cld[1]; while (node[p].cld[0]) p = node[p].cld[0]; ans = node[p].val; &#125; break; &#125; if(node[p].val &gt; val &amp;&amp; node[p].val &lt; ans) ans = node[p].val; p = val &lt; node[p].val ? node[p].cld[0] : node[p].cld[1]; &#125; return ans;&#125;int getPre(const int rt, int val) &#123; int ans = -inf; int p = rt; while (p) &#123; if(val == node[p].val) &#123; if(node[p].cnt &gt;= 1) &#123; ans = node[p].val; return ans; &#125; if(node[p].cld[0]) &#123; p = node[p].cld[0]; while (node[p].cld[1]) p = node[p].cld[1]; ans = node[p].val; &#125; break; &#125; if(node[p].val &lt; val &amp;&amp; node[p].val &gt; ans) ans = node[p].val; p = val &lt; node[p].val ? node[p].cld[0] : node[p].cld[1]; &#125; return ans;&#125;// == precursor and successor finished ==int petnum = 0, ans = 0;void init() &#123; tot = 0; petnum = 0; ans = 0;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); scanf(\"%d\", &amp;n); build(); while (n--) &#123; int opt; scanf(\"%d\", &amp;opt); int x; scanf(\"%d\", &amp;x); if(petnum == 0) &#123; insert(root, x); if(opt == 0) petnum++; else petnum--; &#125; else if(petnum &gt; 0) &#123; // all pet if(opt == 0) &#123; insert(root, x); petnum++; &#125; else &#123; // adopt pet int pre = getPre(root, x); int nxt = getNxt(root, x); if(abs(pre - x) &lt;= abs(nxt - x)) &#123; del(pre); ans = (ans + abs(pre - x)) % mod; &#125; else &#123; del(nxt); ans = (ans + abs(nxt - x)) % mod; &#125; petnum--; &#125; &#125; else &#123; // all people if(opt == 1) &#123; insert(root, x); petnum--; &#125; else &#123; int pre = getPre(root, x); int nxt = getNxt(root, x); if(abs(pre - x) &lt; abs(nxt - x)) &#123; del(pre); ans = (ans + abs(pre - x)) % mod; &#125; else &#123; del(nxt); ans = (ans + abs(nxt - x)) % mod; &#125; petnum++; &#125; &#125; &#125; printf(\"%d\", ans);&#125; splay树解决区间问题BZOJ1251 数组版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233const int inf = 0x3f3f3f3f;const int maxn = 1e6 + 10;const int mod = 1e9 + 7;// == tree structure ==const int NIL = 0;class Node &#123;public: int pa; int cld[2]; int big, val, tag; int sz; bool rev; void create(int _val, int _pa) &#123; pa = _pa; big = val = _val; sz = 1; cld[0] = cld[1] = 0; tag = rev = 0; &#125;&#125; T[maxn];int root;inline int sgn(int u) &#123; return T[T[u].pa].cld[1] == u;&#125;void pushup(int u) &#123; T[u].big = T[u].val; T[u].sz = 1; if(T[u].cld[0]) &#123; T[u].big = max(T[u].big, T[T[u].cld[0]].big); T[u].sz += T[T[u].cld[0]].sz; &#125; if(T[u].cld[1]) &#123; T[u].big = max(T[u].big, T[T[u].cld[1]].big); T[u].sz += T[T[u].cld[1]].sz; &#125;&#125;void pushdown(int u) &#123; if(u == NIL) return; if(T[u].tag) &#123; _for(k, 0, 2) if(T[u].cld[k]) &#123; T[T[u].cld[k]].val += T[u].tag; T[T[u].cld[k]].tag += T[u].tag; T[T[u].cld[k]].big += T[u].tag; &#125; T[u].tag = 0; &#125; if(T[u].rev) &#123; _for(k, 0, 2) &#123; if(T[u].cld[k]) T[T[u].cld[k]].rev ^= 1; &#125; swap(T[u].cld[0], T[u].cld[1]); T[u].rev = 0; &#125;&#125;int build(int l, int r) &#123; if(l &gt; r) return NIL; if(l == r) return l; int mid = (l + r) &gt;&gt; 1; int lson, rson; lson = T[mid].cld[0] = build(l, mid - 1); rson = T[mid].cld[1] = build(mid + 1, r); T[lson].pa = T[rson].pa = mid; pushup(mid); return mid;&#125;void buildTree(int n) &#123; T[1].create(-inf, NIL), T[n + 2].create(-inf, NIL); _rep(i, 2, n + 1) T[i].create(0, NIL); root = build(1, n + 2); T[root].pa = NIL; T[NIL].cld[1] = root; T[NIL].pa = 0; T[NIL].sz = 0; //assert(T[1].pa != NIL);&#125;// == tree structure finsihed ==// == void rotate and splay ==inline void setc(int q, int d, int p) &#123; if(p) T[p].pa = q; if(q) T[q].cld[d] = p; if(q == NIL) root = p;&#125;inline void rot(int x, int d) &#123; int y = T[x].pa, z = T[y].pa; setc(z, sgn(y), x); setc(y, d, T[x].cld[d^1]); setc(x, d^1, y); pushup(y);&#125;inline void rot(int x) &#123; return rot(x, sgn(x));&#125;int splay(int p, const int to) &#123; if(p == to) return p; while (T[p].pa != to) &#123; int y = T[p].pa, z = T[y].pa; if(T[p].pa == NIL) &#123; root = p; break; &#125; if(T[T[p].pa].pa == to) &#123; rot(p); break; &#125; else &#123; int a = sgn(p), b = sgn(T[p].pa); rot((a^b ? p : T[p].pa), a); rot(p, b); &#125; &#125; pushup(p); return p;&#125;// == rotate and splay finished ==// == select kth, return (k+1)th ==int select(const int rt, int k) &#123; int u = rt; pushdown(u); while (u &amp;&amp; T[T[u].cld[0]].sz != k) &#123; if(k &lt; T[T[u].cld[0]].sz) u = T[u].cld[0]; else &#123; k -= T[T[u].cld[0]].sz + 1; u = T[u].cld[1]; &#125; pushdown(u); &#125; return u;&#125;// == select finsihed ==// == void change ==void change(int l, int r, int val) &#123; int x = select(root, l - 1); int y = select(root, r + 1); splay(x, NIL); splay(y, x); T[T[y].cld[0]].val += val; T[T[y].cld[0]].tag += val; T[T[y].cld[0]].big += val;&#125;// == change finsihed ==void turn(int l, int r) &#123; int x = select(root, l - 1); int y = select(root, r + 1); splay(x, NIL); splay(y, x); T[T[y].cld[0]].rev ^= 1;&#125;int query(int l, int r) &#123; int x = select(root, l - 1); int y = select(root, r + 1); splay(x, NIL); splay(y, x); return T[T[y].cld[0]].big;&#125;// == void debug ==void dbg(const int rt) &#123; int u = rt; if(T[u].cld[0]) dbg(T[u].cld[0]); puts(\"\"); debug(T[u].sz); debug(T[u].val); debug(T[u].cld[0]); debug(T[u].cld[1]); if(T[u].cld[1]) dbg(T[u].cld[1]);&#125;// == dbgint main() &#123; freopen(\"input.txt\", \"r\", stdin); int n, m; scanf(\"%d%d\", &amp;n, &amp;m); buildTree(n); _for(i, 0, m) &#123; int a, b, c, d; scanf(\"%d\", &amp;a); //dbg(NIL); //puts(\"\\n\\n\\n\"); if(a == 1) &#123; scanf(\"%d%d%d\", &amp;b, &amp;c, &amp;d); change(b, c, d); &#125; else if(a == 2) &#123; scanf(\"%d%d\", &amp;b, &amp;c); turn(b, c); &#125; else &#123; scanf(\"%d%d\", &amp;b, &amp;c); printf(\"%d\\n\", query(b, c)); &#125; &#125;&#125; 指针版特别注意，因为有哨兵节点null的存在，所以 pushup() 的时候要小心注意忽略 null 节点编程技巧，使用static来定义哨兵节点 cld != null，才 pushup() 更新节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235const int maxn = 1e6 + 10;const int inf = 0x3f3f3f3f;// == tree structure ==class Node &#123;public: static Node *null;#define null Node::null Node *pa; Node *cld[2]; int big, val, tag; int sz; bool rev; inline void pushdown() &#123; if(tag) &#123; _for(k, 0, 2) if(cld[k]) &#123; cld[k]-&gt;tag += tag; cld[k]-&gt;val += tag; cld[k]-&gt;big += tag; &#125; tag = 0; &#125; if(rev) &#123; _for(k, 0, 2) if(cld[k]) cld[k]-&gt;rev ^= 1; rev = 0; swap(cld[0], cld[1]); &#125; &#125; inline void pushup() &#123; big = val; sz = 1; if(cld[0] != null) &#123; big = max(big, cld[0]-&gt;big); sz += cld[0]-&gt;sz; &#125; if(cld[1] != null) &#123; big = max(big, cld[1]-&gt;big); sz += cld[1]-&gt;sz; &#125; &#125; inline int sgn() &#123; return pa-&gt;cld[1] == this; &#125; void setc(int d, Node *x) &#123; cld[d] = x; x-&gt;pa = this; &#125; void rot(int d) &#123; Node *y = pa, *z = y-&gt;pa; z-&gt;setc(y-&gt;sgn(), this); y-&gt;setc(d, cld[d^1]); setc(d^1, y); y-&gt;pushup(); &#125; void rot() &#123; rot(sgn()); &#125; Node *splay(const Node *to) &#123; while (pa != to) &#123; if(pa-&gt;pa == to) &#123; rot(); break; &#125; else &#123; int a = sgn(), b = pa-&gt;sgn(); (a^b ? this : pa)-&gt;rot(a); rot(b); &#125; &#125; pushup(); return this; &#125;&#125; A[maxn];Node *null = new Node();typedef Node* T;T NIL = new Node();T root = &amp;A[0];T build(int l, int r) &#123; if(l &gt; r) return null; int mid = (l + r) &gt;&gt; 1; T p = &amp;A[mid]; p-&gt;cld[0] = build(l, mid - 1); p-&gt;cld[1] = build(mid + 1, r); p-&gt;val = p-&gt;rev = 0; if(p-&gt;cld[0]) p-&gt;cld[0]-&gt;pa = p; if(p-&gt;cld[1]) p-&gt;cld[1]-&gt;pa = p; p-&gt;pushup(); return p;&#125;void buildTree(int n) &#123; root = build(1, n + 2); root-&gt;pa = NIL; NIL-&gt;pa = NULL; NIL-&gt;cld[0] = NULL; NIL-&gt;cld[1] = root; null-&gt;sz = 0; null-&gt;pa = NULL; null-&gt;val = -inf;&#125;void levedbg(T rt) &#123; queue&lt;T&gt; que; que.push(rt); int cnt = 1, nxtcnt = 0; int level = 1; while (!que.empty()) &#123; T x = que.front(); que.pop(); if(x != null &amp;&amp; x != NIL &amp;&amp; x) printf(\"%d(%d) \", x-&gt;val, x-&gt;sgn()); cnt--; if(x == NULL) continue; if(x-&gt;cld[0] != null) que.push(x-&gt;cld[0]), nxtcnt++; if(x-&gt;cld[1] != null) que.push(x-&gt;cld[1]), nxtcnt++; if(cnt == 0) &#123; printf(\"\\n\"); cnt = nxtcnt; nxtcnt = 0; &#125; &#125;&#125;// == tree finished ==// == void dbg ==void dbg(const T rt) &#123; T u = rt; //u-&gt;pushdown(); if(u-&gt;cld[0] != null &amp;&amp; u-&gt;cld[0]) dbg(u-&gt;cld[0]); if(u != NIL &amp;&amp; u != null &amp;&amp; u) &#123; printf(\"%d \", u-&gt;val); &#125; if(u-&gt;cld[1] != null &amp;&amp; u-&gt;cld[1]) dbg(u-&gt;cld[1]);&#125;// == dbg finished ==// == select kth ==T select(const T rt, int k) &#123; T u = rt; while (u != null) &#123; if(u-&gt;cld[0]-&gt;sz == k - 1) return u; if(u-&gt;cld[0]-&gt;sz &gt;= k) u = u-&gt;cld[0]; else &#123; k -= u-&gt;cld[0]-&gt;sz + 1; u = u-&gt;cld[1]; &#125; u-&gt;pushdown(); &#125; return u;&#125;void change(int l, int r, int val) &#123; T x1 = select(root, l - 1); T x2 = select(root, r + 1); //debug(x1-&gt;sz), debug(x2-&gt;sz); puts(\"\"); x1-&gt;splay(NIL), root = x1; //dbg(x1); puts(\"\"); x2-&gt;splay(x1); x2-&gt;cld[0]-&gt;val += val; x2-&gt;cld[0]-&gt;tag += val; x2-&gt;cld[0]-&gt;big += val; //dbg(x2-&gt;cld[0]); puts(\"\");&#125;void turn(int l, int r) &#123; T x1 = select(root, l - 1); T x2 = select(root, r + 1); x1-&gt;splay(NIL), root = x1; x2-&gt;splay(x1); x2-&gt;cld[0]-&gt;rev ^= 1;&#125;int query(int l, int r) &#123; T x1 = select(root, l - 1); T x2 = select(root, r + 1); x1-&gt;splay(NIL), root = x1; x2-&gt;splay(x1); return x2-&gt;cld[0]-&gt;big;&#125;// == select finished ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); int n, m; scanf(\"%d%d\", &amp;n, &amp;m); buildTree(n); //levedbg(root); _for(i, 0, m) &#123; int a, b, c, d; scanf(\"%d\", &amp;a); if(a == 1) &#123; scanf(\"%d%d%d\", &amp;b, &amp;c, &amp;d); b++, c++; change(b, c, d); // dbg(root); puts(\"\"); &#125; else if(a == 2) &#123; scanf(\"%d%d\", &amp;b, &amp;c); b++, c++; turn(b, c); &#125; else &#123; scanf(\"%d%d\", &amp;b, &amp;c); b++, c++; printf(\"%d\\n\", query(b, c)); &#125; &#125;&#125; 反转序列如果仅仅需要反转序列，在中序遍历的时候，记得下传延迟标记即可BZOJ3223 其他代码同上例，只需要增加一个dfs即可 12345678void dfs(const int root) &#123; int u = root; pushdown(u); if(T[u].cld[0]) dfs(T[u].cld[0]); if(T[u].val != -inf) printf(\"%d \", T[u].val); if(T[u].cld[1]) dfs(T[u].cld[1]);&#125; 另外注意设置哨兵的特殊值，避免输出哨兵 123456789101112void buildTree(int n) &#123; root = build(1, n + 2); root-&gt;pa = NIL; NIL-&gt;cld[0] = NULL; NIL-&gt;cld[1] = root; null-&gt;sz = 0; null-&gt;pa = NULL; A[1].val = -inf; A[n+2].val = -inf;&#125; 分裂和合并UVA11922 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204const int maxn = 1e6 + 10;const int inf = 0x3f3f3f3f;// == tree structure ==class Node &#123;public: static Node *null;#define null Node::null Node* pa; Node* cld[2]; int val, sz; bool rev; inline void pushdown() &#123; if(rev) &#123; _for(k, 0, 2) if(cld[k]) cld[k]-&gt;rev ^= 1; swap(cld[0], cld[1]); rev = false; &#125; &#125; inline void pushup() &#123; sz = 1; _for(k, 0, 2) if(cld[k] != null) sz += cld[k]-&gt;sz; &#125; inline int sgn() &#123; return pa-&gt;cld[1] == this; &#125; void setc(int d, Node* x) &#123; cld[d] = x; x-&gt;pa = this; &#125; void rot(int d) &#123; Node *y = pa, *z = y-&gt;pa; z-&gt;setc(y-&gt;sgn(), this); y-&gt;setc(d, cld[d^1]); setc(d^1, y); y-&gt;pushup(); &#125; void rot() &#123; rot(sgn()); &#125; Node* splay(const Node* to) &#123; while (pa != to) &#123; if(pa-&gt;pa == to) &#123; rot(); break; &#125; else &#123; int a = sgn(), b = pa-&gt;sgn(); (a^b ? this : pa)-&gt;rot(a); rot(b); &#125; &#125; pushup(); return this; &#125;&#125; A[maxn];Node *null = new Node();typedef Node* T;T NIL = new Node();T root = &amp;A[0];T build(int l, int r) &#123; if(l &gt; r) return null; int mid = (l + r) &gt;&gt; 1; T p = &amp;A[mid]; p-&gt;cld[0] = build(l, mid - 1); p-&gt;cld[1] = build(mid + 1, r); p-&gt;val = mid; if(p-&gt;cld[0]) p-&gt;cld[0]-&gt;pa = p; if(p-&gt;cld[1]) p-&gt;cld[1]-&gt;pa = p; p-&gt;pushup(); return p;&#125;void buildTree(int n) &#123; root = build(1, n + 2); root-&gt;pa = NIL; NIL-&gt;pa = NULL; NIL-&gt;cld[1] = root; NIL-&gt;cld[0] = NULL; null-&gt;sz = 0; null-&gt;pa = NULL;&#125;// == tree structure finished ==// == debug ==void dbg(T rt) &#123; T u = rt; if(u-&gt;cld[0]) dbg(u-&gt;cld[0]); if(u != null) printf(\"cur: %d\\n\", u-&gt;val); if(u-&gt;cld[1]) dbg(u-&gt;cld[1]);&#125;void leveldbg(T rt) &#123; queue&lt;T&gt; que; que.push(rt); int cnt = 1, nxtcnt = 0; int level = 1; while (!que.empty()) &#123; T x = que.front(); que.pop(); if(x != null &amp;&amp; x != NIL &amp;&amp; x) printf(\"%d(%d) \", x-&gt;val, x-&gt;sgn()); cnt--; if(x == NULL) continue; if(x-&gt;cld[0] != null) que.push(x-&gt;cld[0]), nxtcnt++; if(x-&gt;cld[1] != null) que.push(x-&gt;cld[1]), nxtcnt++; if(cnt == 0) &#123; //printf(\"level: %d\\n\", level++); puts(\"\"); cnt = nxtcnt; nxtcnt = 0; &#125; &#125;&#125;// == debug finished ==// == select kth ==T select(const T rt, int k) &#123; T u = rt; while (u != null) &#123; if(u-&gt;cld[0]-&gt;sz == k - 1) return u; if(u-&gt;cld[0]-&gt;sz &gt;= k) u = u-&gt;cld[0]; else &#123; k -= u-&gt;cld[0]-&gt;sz + 1; u = u-&gt;cld[1]; &#125; u-&gt;pushdown(); &#125; return u;&#125;// == select finsihed ==void test() &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); T u = select(root, a); debug(u-&gt;val); if(u != null) u-&gt;splay(NIL); root = u; leveldbg(root);&#125;// == reverse ==inline void turn(int x1, int x2) &#123; T L = select(root, x1 - 1), R = select(root, x2 + 1); L-&gt;splay(NIL), root = L; R-&gt;splay(root); T goal = R-&gt;cld[0]; goal-&gt;rev ^= 1; R-&gt;cld[0] = null; R-&gt;pushup(); root-&gt;pushup(); T t1 = select(root, root-&gt;sz); T t2 = select(root, root-&gt;sz-1); t2-&gt;splay(NIL), root = t2; t1-&gt;splay(root); t1-&gt;cld[0] = goal; goal-&gt;pa = t1; t1-&gt;pushup(); root-&gt;pushup();&#125;// == reverse finsihed ==vector&lt;int&gt; ans;void dfs(T r, int n) &#123; r-&gt;pushdown(); if(r-&gt;cld[0] != null) dfs(r-&gt;cld[0], n); if(r-&gt;val != 1 &amp;&amp; r-&gt;val != n + 2) printf(\"%d\\n\", r-&gt;val - 1); if(r-&gt;cld[1] != null) dfs(r-&gt;cld[1], n);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int n, m; scanf(\"%d%d\", &amp;n, &amp;m); buildTree(n); //leveldbg(root); while (m--) &#123; int x1, x2; scanf(\"%d%d\", &amp;x1, &amp;x2); x1++, x2++; turn(x1, x2); &#125; dfs(root, n);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"实用数据结构(六)","slug":"20200305","date":"2020-03-04T17:34:50.000Z","updated":"2020-03-29T07:30:22.193Z","comments":true,"path":"2020/03/05/20200305/","link":"","permalink":"https://www.fogsail.net/2020/03/05/20200305/","excerpt":"这部分给出一些数据结构的模版，和处理技巧","text":"这部分给出一些数据结构的模版，和处理技巧 线段树单点修改模版UVA12299 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109const int inf = 0x3f3f3f3f;const int maxnode = 1&lt;&lt;18;const int maxn = 100000 + 10;int A[maxn];int n, q;// == struct segment tree ==class segTree &#123;public: int l, r; int dat;&#125;;segTree tree[maxnode];#define l(x) tree[x].l#define r(x) tree[x].r#define dat(x) tree[x].dat// == struct finished ==void build(int p, int l, int r) &#123; l(p) = l, r(p) = r; //debug(p), debug(l(p)),debug(r(p)); //cout &lt;&lt; endl; if(l == r) &#123; dat(p) = A[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r); dat(p) = min(dat(p &lt;&lt; 1), dat(p &lt;&lt; 1 | 1));&#125;void change(int p, int x, int v) &#123; // change A[x] = v, segment API is change(1, x, v) if(l(p) == r(p)) &#123; dat(p) = v; return; &#125; int mid = (l(p) + r(p)) &gt;&gt; 1; if(x &lt;= mid) change(p &lt;&lt; 1, x, v); else change(p &lt;&lt; 1 | 1, x, v); dat(p) = min(dat(p &lt;&lt; 1), dat(p &lt;&lt; 1 | 1));&#125;int ask(int p, int ql, int qr) &#123; if(ql &lt;= l(p) &amp;&amp; r(p) &lt;= qr) return dat(p); int mid = (l(p) + r(p)) &gt;&gt; 1; //debug(p); //debug(l(p)), debug(r(p)); int val = inf; if(ql &lt;= mid) val = min(val, ask(p &lt;&lt; 1, ql, qr)); if(qr &gt; mid) val = min(val, ask(p &lt;&lt; 1 | 1, ql, qr)); return val;&#125;const int maxl = 30 + 2;void solve(const char* cmd) &#123; int args[maxl], buf[maxl]; int len = strlen(cmd); int k = 0; args[k] = 0; _for(i, 6, len) &#123; if(isdigit(cmd[i])) args[k] = args[k] * 10 + cmd[i] - '0'; else &#123; k++; args[k] = 0; &#125; &#125; // debug args if(cmd[0] == 'q') &#123; int ql = args[0]; int qr = args[1]; //debug(ql); //debug(qr); //cout &lt;&lt; endl; printf(\"%d\\n\", ask(1, ql, qr)); &#125; else &#123; // shift rmq _for(i, 0, k) buf[i] = A[args[i]]; _for(i, 0, k) &#123; int p = args[i]; A[p] = buf[(i + 1) % k]; int v = A[p]; change(1, p, v); &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); cin &gt;&gt; n &gt;&gt; q; _rep(i, 1, n) scanf(\"%d\", &amp;A[i]); build(1, 1, n); while (q--) &#123; char cmd[maxl]; scanf(\"%s\", cmd); //debug(cmd); solve(cmd); &#125;&#125; 延迟标记模版有一类延迟标记问题是描述区间中 $minv, maxv$ 的问题这类问题注意两点就可以 第一，某个区间的值修改成 $tag$，那么它的所有子区间，也就是代表这个区间的点的所有子节点，$maxv, minv$ 都会同步变化同时变成 $tag$ 第二，这种问题常常用贡献值来计算比如修改后的值 $val \\leq minv$，比区间最小值都小，那么这个值无贡献，诸如此类 UVA1232 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394const int maxn = 100000 + 10;class segTree &#123;public: int l, r; int maxv, minv, tag;&#125; tree[maxn &lt;&lt; 2];#define l(x) tree[x].l#define r(x) tree[x].r#define maxv(x) tree[x].maxv#define minv(x) tree[x].minv#define tag(x) tree[x].tagvoid pushup(int p) &#123; maxv(p) = max(maxv(p&lt;&lt;1), maxv(p&lt;&lt;1 | 1)); minv(p) = min(minv(p&lt;&lt;1), minv(p&lt;&lt;1 | 1));&#125;void pushdown(int p) &#123; if(tag(p) &amp;&amp; l(p) != r(p)) &#123; tag(p&lt;&lt;1) = tag(p); maxv(p&lt;&lt;1) = minv(p&lt;&lt;1) = tag(p); tag(p&lt;&lt;1 | 1)= tag(p); maxv(p&lt;&lt;1 | 1) = minv(p&lt;&lt;1 | 1) = tag(p); tag(p) = 0; &#125;&#125;void build(int p, int l, int r) &#123; l(p) = l, r(p) = r; tag(p) = 0; minv(p) = maxv(p) = 0; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r);&#125;int change(int p, int l, int r, int val) &#123; if(l(p) == l &amp;&amp; r(p) == r &amp;&amp; minv(p) &gt; val) return 0; if(l(p) == l &amp;&amp; r(p) == r &amp;&amp; maxv(p) &lt;= val) &#123; // update segment node if(maxv(p) &lt; val) &#123; tag(p) = val; maxv(p) = minv(p) = val; &#125; //debug(r - l + 1); return r - l + 1; &#125; pushdown(p); int ans = 0; int mid = (l(p) + r(p)) &gt;&gt; 1; if(r &lt;= mid) ans = change(p &lt;&lt; 1, l, r, val); else if(l &gt; mid) ans = change(p &lt;&lt; 1 | 1, l, r, val); else ans = change(p &lt;&lt; 1, l, mid, val) + change(p &lt;&lt; 1 | 1, mid + 1, r, val); pushup(p); return ans;&#125;int n, li, ri, h;void solve() &#123; int ans = 0; build(1, 1, maxn); scanf(\"%d\", &amp;n); _for(i, 0, n) &#123; scanf(\"%d%d%d\", &amp;li, &amp;ri, &amp;h); ans += change(1, li, ri - 1, h); &#125; printf(\"%d\\n\", ans);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; while (true) &#123; scanf(\"%d\", &amp;kase); if(kase == 0) break; while (kase--) &#123; solve(); &#125; &#125;&#125; 延迟标记思想的应用UVA1455 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179const int maxn = 1000000 + 10;const int maxm = maxn * 2;int n, m;struct _A &#123; int x, y;&#125; A[maxn];int pa[maxn], miny[maxn], maxy[maxn], cnt[maxn];int top = 0;int findset(int x) &#123; return x == pa[x] ? x : pa[x] = findset(pa[x]);&#125;void init() &#123; _rep(i, 0, n) pa[i] = i; Set(miny, 0); Set(maxy, 0); Set(cnt, 0); top = 0;&#125;// == seg Tree ==class segTree &#123;public: int l, r; int num, city; int tag1, tag2;&#125; tree[maxm &lt;&lt; 2];#define l(x) tree[x].l#define r(x) tree[x].r#define num(x) tree[x].num#define city(x) tree[x].city#define tag1(x) tree[x].tag1#define tag2(x) tree[x].tag2void build(int p, int l, int r) &#123; l(p) = l, r(p) = r; num(p) = city(p) = 0; tag1(p) = tag2(p) = 0; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(p&lt;&lt;1, l, mid); build(p&lt;&lt;1|1, mid + 1, r);&#125;void pushdown(int p) &#123; if(tag1(p) &amp;&amp; l(p) != r(p)) &#123; // deal with tag1, num tag1(p&lt;&lt;1) += tag1(p); num(p&lt;&lt;1) += (r(p&lt;&lt;1) - l(p&lt;&lt;1) + 1) * tag1(p); tag1(p&lt;&lt;1|1) += tag1(p); num(p&lt;&lt;1|1) += (r(p&lt;&lt;1|1) - l(p&lt;&lt;1|1) + 1) * tag1(p); tag1(p) = 0; &#125; if(tag2(p) &amp;&amp; l(p) != r(p)) &#123; // deal with tag2, city tag2(p&lt;&lt;1) += tag2(p); city(p&lt;&lt;1) += (r(p&lt;&lt;1) - l(p&lt;&lt;1) + 1) * tag2(p); tag2(p&lt;&lt;1|1) += tag2(p); city(p&lt;&lt;1|1) += (r(p&lt;&lt;1|1) - l(p&lt;&lt;1|1) + 1) * tag2(p); tag2(p) = 0; &#125;&#125;void pushup(int p) &#123; num(p) = num(p&lt;&lt;1) + num(p&lt;&lt;1|1); city(p) = city(p&lt;&lt;1) + city(p&lt;&lt;1|1);&#125;void change(int p, int l, int r, int a, int b) &#123; if(l(p) == l &amp;&amp; r(p) == r) &#123; tag1(p) += a; num(p) += (r(p) - l(p) + 1) * a; tag2(p) += b; city(p) += (r(p) - l(p) + 1) * b; return; &#125; pushdown(p); int mid = (l(p) + r(p)) &gt;&gt; 1; if(r &lt;= mid) change(p&lt;&lt;1, l, r, a, b); else if(l &gt; mid) change(p&lt;&lt;1|1, l, r, a, b); else &#123; change(p&lt;&lt;1, l, mid, a, b); change(p&lt;&lt;1|1, mid + 1, r, a, b); &#125; pushup(p);&#125;int query(int p, int C) &#123; if(l(p) == r(p)) return p; pushdown(p); int mid = (l(p) + r(p)) &gt;&gt; 1; if(C &lt;= mid) return query(p&lt;&lt;1, C); else return query(p&lt;&lt;1|1, C);&#125;// == seg Tree finished ==void inp() &#123; scanf(\"%d\", &amp;n); init(); _for(i, 0, n) &#123; scanf(\"%d%d\", &amp;A[i].x, &amp;A[i].y); A[i].y &lt;&lt;= 1; top = max(top, A[i].y); maxy[i] = miny[i] = A[i].y; cnt[i] = 1; &#125; build(1, 0, top); _for(i, 0, n) change(1, A[i].y, A[i].y, 1, 1);&#125;void solve() &#123; scanf(\"%d\", &amp;m); while (m--) &#123; char cmd[10]; scanf(\"%s\", cmd); if(cmd[0] == 'r') &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); a = findset(a); b = findset(b); if(a == b) continue; change(1, miny[a], maxy[a], -1, -cnt[a]); change(1, miny[b], maxy[b], -1, -cnt[b]); pa[b] = a; cnt[a] += cnt[b]; miny[a] = min(miny[a], miny[b]); maxy[a] = max(maxy[a], maxy[b]); change(1, miny[a], maxy[a], 1, cnt[a]); &#125; else &#123; double c; scanf(\"%lf\", &amp;c); int C = c * 2 + 0.5; if(C &gt; top) puts(\"0 0\"); else &#123; int ans = query(1, C); printf(\"%d %d\\n\", num(ans), city(ans)); &#125; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; inp(); solve(); &#125;&#125; 扫描线算法HDU4052 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163const int maxn = 100000 + 10;const int inf = 0x3f3f3f3f;class Node &#123;public: int x; int y1, y2; int k; Node() &#123;&#125; Node(int x, int y1, int y2, int k) : x(x), y1(y1), y2(y2), k(k) &#123;&#125; bool operator&lt; (const Node&amp; rhs) const &#123; return x &lt; rhs.x; &#125;&#125; node[maxn];struct Rec &#123; int x1, y1, x2, y2; void read() &#123; scanf(\"%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); if(x1 &gt; x2) swap(x1, x2); if(y1 &gt; y2) swap(y1, y2); &#125;&#125; rec[maxn];map&lt;int, int&gt; ny;int raw[maxn];void init() &#123; ny.clear(); Set(raw, 0);&#125;// == seg Tree ==class segTree &#123;public: int l, r, cover; int len;&#125; tree[maxn &lt;&lt; 2];#define l(x) tree[x].l#define r(x) tree[x].r#define cover(x) tree[x].cover#define len(x) tree[x].lenvoid build(int p, int l, int r) &#123; cover(p) = len(p) = 0; l(p) = l, r(p) = r; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(p&lt;&lt;1, l, mid); build(p&lt;&lt;1|1, mid + 1, r);&#125;inline void pushup(int p) &#123; if(cover(p)) len(p) = (raw[r(p)] - raw[l(p) - 1]); else if (l(p) == r(p)) len(p) = 0; else len(p) = len(p&lt;&lt;1) + len(p&lt;&lt;1|1);&#125;void change(int p, int l, int r, int d) &#123; if(l &lt;= l(p) &amp;&amp; r(p) &lt;= r) &#123; cover(p) += d; pushup(p); return; &#125; int mid = (l(p) + r(p)) &gt;&gt; 1; //debug(l(1)), debug(r(1)); //debug(mid); if(l &lt;= mid) change(p&lt;&lt;1, l, r, d); if(r &gt; mid) change(p&lt;&lt;1|1, l, r, d); pushup(p);&#125;// == seg Tree finished ==// == solve the problem ==int w, h, m;int N, n;void discrete(int _n) &#123; sort(raw + 1, raw + 1 + _n); sort(node + 1, node + 1 + _n); N = unique(raw + 1, raw + 1 + _n) - raw - 1; _rep(i, 1, N) ny[raw[i]] = i;&#125;ll solve(int _n) &#123; if(m &gt; h) return 0; ny.clear(); int L, R; _rep(i, 1, _n) &#123; int k = i &lt;&lt; 1; L = raw[k - 1] = rec[i].y1; R = raw[k] = min(h, rec[i].y2 + m - 1) + 1; node[k - 1] = Node(rec[i].x1, L, R, 1); node[k] = Node(rec[i].x2 + 1, L, R, -1); &#125; _n &lt;&lt;= 1; L = 1, R = 1 + min(h, m - 1); node[_n + 1] = Node(1, L, R, 1); raw[_n + 1] = L; node[_n + 2] = Node(1 + w, L, R, -1); raw[_n + 2] = R; _n += 2; discrete(_n); ll ans = 0; // == main solve() == if(N) build(1, 1, N); _rep(i, 1, _n - 1) &#123; int L = ny[node[i].y1] + 1, R = ny[node[i].y2]; assert(L != 0 &amp;&amp; R != 0); //debug(node[i].y1), debug(node[i].y2), debug(node[i].x), debug(node[i].k); //cout &lt;&lt; endl; if(L &lt;= R) change(1, L, R, node[i].k); ans += (ll) len(1) * (node[i + 1].x - node[i].x); &#125; ans = (ll) w * h - ans; return ans; // == finished ==&#125;// == solve finsihed ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (~scanf(\"%d%d%d%d\", &amp;w, &amp;h, &amp;n, &amp;m)) &#123; init(); int n2 = n; _rep(i, 1, n) &#123; rec[i].read(); &#125; ll ans = solve(n); _rep(i, 1, n2) &#123; swap(rec[i].y1, rec[i].x1); swap(rec[i].y2, rec[i].x2); &#125; swap(w, h); ans += solve(n2); if(m == 1) ans /= 2; printf(\"%lld\\n\", ans); &#125;&#125; 动态开点与线段树合并NEERC2011F 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312const int maxn = 50000 + 10;const int maxm = 8000000;const double eps = 1e-10;int n, m;int mx = 0;class Parabola &#123;public: int x, y, p; double a, b, c; inline double cal(double x) &#123; return a*x*x + b*x + c; &#125; void read(int&amp; mx) &#123; scanf(\"%d%d%d\", &amp;p, &amp;x, &amp;y); a = (double)y * 1.0 / (1ll * (x - p) * (p - x) * 1.0); b = -2 * a * x; c = -a*p*p - b*p; mx = max(mx, 2*x-p); &#125;&#125; para[maxn];// == seg Tree nested seg Tree ==int tot = 0;int rt[maxn &lt;&lt; 2];double X[maxn &lt;&lt; 2], _X[maxn &lt;&lt; 2];void init() &#123; tot = 0; Set(rt, 0); Set(X, 0); Set(_X, 0);&#125;class segTree &#123;public: int l, r;&#125; tree[maxn &lt;&lt; 2];#define l(x) tree[x].l#define r(x) tree[x].rclass nestTree &#123;public: int ls, rs; double maxh;&#125; ntree[maxm];#define ls(x) ntree[x].ls#define rs(x) ntree[x].rs#define maxh(x) ntree[x].maxhvoid spread1(int&amp; o, int l, int r, int x, int y) &#123; if(!o) o = ++tot; maxh(o) = y; if(l == r) return; int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) spread1(ls(o), l, mid, x, y); else spread1(rs(o), mid + 1, r, x, y);&#125;int merge1(int p, int q, int l, int r) &#123; if(!p || !q) return p + q; if(l == r) return maxh(p) &gt; maxh(q) ? p : q; int u = ++tot; int mid = (l + r) &gt;&gt; 1; ls(u) = merge1(ls(p), ls(q), l, mid); rs(u) = merge1(rs(p), rs(q), mid + 1, r); maxh(u) = max(maxh(ls(u)), maxh(rs(u))); return u;&#125;// usage, build1(1, 1, n)void build1(int p, int l, int r) &#123; // leaf node means lth parabola // spread 2D-segTree l(p) = l, r(p) = r; if(l == r) &#123; spread1(rt[p], 0, mx, para[l].x, para[l].y); return; &#125; int mid = (l + r) &gt;&gt; 1; build1(p&lt;&lt;1, l, mid); build1(p&lt;&lt;1|1, mid + 1, r); rt[p] = merge1(rt[p&lt;&lt;1], rt[p&lt;&lt;1|1], 0, mx);&#125;// query 2D, usage, query2(rt[p], 0, mx, x1, x2)// query interval [x1, x2]// query2(p), query2(ls(p), ..), query2(rs(p), ...)double query2(int p, int l, int r, int ql, int qr) &#123; if(!p || ql &gt; r || qr &lt; l) return 0; if(ql &lt;= l &amp;&amp; r &lt;= qr) return maxh(p); int mid = (l + r) &gt;&gt; 1; return max(query2(ls(p), l, mid, ql, qr), query2(rs(p), mid + 1, r, ql, qr));&#125;// usage, query1(1, t1, t2, x1, x2)double query1(int p, int tl, int tr, int xl, int xr) &#123; if(r(p) &lt; tl || l(p) &gt; tr) return 0; if(tl &lt;= l(p) &amp;&amp; r(p) &lt;= tr) return query2(rt[p], 0, mx, xl, xr); return max(query1(p&lt;&lt;1, tl, tr, xl, xr), query1(p&lt;&lt;1|1, tl, tr, xl, xr));&#125;// == seg Tree nested finished ==// == outline seg Tree, build by parabola id, solve interval endpoint ==struct Line &#123; double xl, xr; int id; Line(double _xl = 0.0, double _xr = 0.0, int _id = 0) : xl(_xl), xr(_xr), id(_id) &#123;&#125; bool operator&lt; (const Line&amp; rhs) const &#123; return xr &lt; rhs.xr; &#125;&#125;;class outlineTree &#123;public: int _l, _r; vector&lt;Line&gt; lines;&#125; lineTree[maxn &lt;&lt; 2];#define _l(x) lineTree[x]._l#define _r(x) lineTree[x]._r#define lines(x) lineTree[x].linesinline double intersection(int i, int j, double l, double r) &#123; // find intersction of two parabola in seg [l, r] const Parabola&amp; u = para[i]; const Parabola&amp; v = para[j]; double A = u.a - v.a; double B = u.b - v.b; double C = u.c - v.c; if(fabs(A) &lt; eps) &#123; // A = 0, find solution // B = 0, no solution, return xr if(fabs(B) &lt; eps) return r; double ans = -C / B; if(l + eps &lt; ans &amp;&amp; ans &lt; r - eps) return ans; return r; &#125; double D = B*B - 4*A*C; if(D &lt; -eps) return r; D = sqrt(D); double ans = r; double x1 = (-B - D) / A / 2; if(l + eps &lt; x1 &amp;&amp; x1 &lt; r - eps) ans = x1; double x2 = (-B + D) / A / 2; if(l + eps &lt; x2 &amp;&amp; x2 &lt; r - eps) ans = min(ans, x2); return ans;&#125;vector&lt;Line&gt; tmp;inline void combine(vector&lt;Line&gt;&amp; A, vector&lt;Line&gt;&amp; B, vector&lt;Line&gt;&amp; C) &#123; sort(A.begin(), A.end()); sort(B.begin(), B.end()); if(A.size() == 0) &#123; C = B; return; &#125; if(B.size() == 0) &#123; C = A; return; &#125; // solve all (x, 0) to a new array _X, then unique to X tmp.clear(); int tot = 0; _for(i, 0, A.size()) &#123; _X[++tot] = A[i].xl; _X[++tot] = A[i].xr; &#125; _for(i, 0, B.size()) &#123; _X[++tot] = B[i].xl; _X[++tot] = B[i].xr; &#125; sort(_X + 1, _X + 1 + tot); int sz = 0; for(int i = 1; i &lt;= tot; ) &#123; int j = i; for(; j &lt; tot &amp;&amp; fabs(_X[j + 1] - _X[j]) &lt; eps; j++); X[++sz] = _X[j]; i = j + 1; &#125; // X[1,..,sz] is the sub segment // &#123;l, r, paraID&#125; construct outline int p1 = 0, p2 = 0; _for(i, 1, sz) &#123; double l = X[i], r = X[i + 1]; while (p1 &lt; A.size() &amp;&amp; A[p1].xr + eps &lt; r) p1++; while (p2 &lt; B.size() &amp;&amp; B[p2].xr + eps &lt; r) p2++; if(((p1 == A.size()) || (A[p1].xl &gt; l + eps)) &amp;&amp; ((p2 == B.size()) || (B[p2].xl &gt; l + eps))) continue; if((p1 == A.size()) || (A[p1].xl &gt; l + eps)) &#123; tmp.push_back(Line(l, r, B[p2].id)); continue; &#125; if((p2 == B.size()) || (B[p2].xl &gt; l + eps)) &#123; tmp.push_back(Line(l, r, A[p1].id)); continue; &#125; // intersction [l, x1, x2, ..., r], get point while (l + eps &lt; r) &#123; double x = intersection(A[p1].id, B[p2].id, l, r); double phi = (l + x) / 2; if(para[A[p1].id].cal(phi) &gt; para[B[p2].id].cal(phi)) &#123; if(para[A[p1].id].cal(phi) &gt;= 0) tmp.push_back(Line(l, x, A[p1].id)); &#125; else &#123; if(para[B[p2].id].cal(phi) &gt;= 0) tmp.push_back(Line(l, x, B[p2].id)); &#125; l = x; &#125; &#125; C.clear(); for(int i = 0; i &lt; tmp.size(); ) &#123; int j = i; for(; j &lt; tmp.size()-1 &amp;&amp; tmp[j + 1].id == tmp[i].id; j++); C.push_back(Line(tmp[i].xl, tmp[j].xr, tmp[i].id)); i = j + 1; &#125;&#125;void build2(int p, int l, int r) &#123; _l(p) = l, _r(p) = r; if(l == r) &#123; const Parabola&amp; cur = para[l]; lines(p).push_back(Line(cur.p, 2*cur.x-cur.p, l)); return; &#125; int mid = (l + r) &gt;&gt; 1; build2(p&lt;&lt;1, l, mid); build2(p&lt;&lt;1|1, mid + 1, r); combine(lines(p&lt;&lt;1), lines(p&lt;&lt;1|1), lines(p));&#125;// == outline seg Tree finished ==// == solve the problem ==inline double work(int p, double x) &#123; int l = 0, r = lines(p).size()-1; int ans = r; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if(lines(p)[mid].xr &gt;= x + eps) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; return para[lines(p)[ans].id].cal(x);&#125;void solve(int p, int tl, int tr, int x1, int x2, double&amp; ans) &#123; if(tl &gt; _r(p) || tr &lt; _l(p)) return; if(tl &lt;= _l(p) &amp;&amp; _r(p) &lt;= tr) &#123; ans = max(ans, work(p, x1)); ans = max(ans, work(p, x2)); return; &#125; solve(p&lt;&lt;1, tl, tr, x1, x2, ans); solve(p&lt;&lt;1|1, tl, tr, x1, x2, ans);&#125;// == solve finished ==int main() &#123; freopen(\"flights.in\", \"r\", stdin); freopen(\"flights.out\", \"w\", stdout); scanf(\"%d\", &amp;n); _rep(i, 1, n) &#123; para[i].read(mx); &#125; build1(1, 1, n); build2(1, 1, n); scanf(\"%d\", &amp;m); _rep(i, 1, m) &#123; int t1, t2, x1, x2; scanf(\"%d%d%d%d\", &amp;t1, &amp;t2, &amp;x1, &amp;x2); double ans = 0.0; ans = query1(1, t1, t2, x1, x2); solve(1, t1, t2, x1, x2, ans); cout &lt;&lt; ans &lt;&lt; endl; &#125; // debug(para[1].cal(11)); // debug(mx);&#125; 并查集处理几何问题的思路 树状数组解决数位统计问题HDU3670 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const int maxn = 100000 + 5;const int mod = (int)(1&lt;&lt;16);const int maxm = mod + 10;int n, m;int cas = 0;class Fwick &#123;public: int C[16][maxm]; void init() &#123; Set(C, 0); &#125; void update(int k, int x, int val) &#123; x++; while (x &lt; maxm) &#123; C[k][x] += val; x += lowbit(x); &#125; &#125; int sum(int k, int x) &#123; x++; int ret = 0; while (x) &#123; ret += C[k][x]; x -= lowbit(x); &#125; return ret; &#125;&#125; fwick;void solve() &#123; ll add = 0, ans = 0; char cmd[10]; while (scanf(\"%s\", cmd) == 1) &#123; if(cmd[0] == 'E') break; if(cmd[0] == 'C') &#123; int x; scanf(\"%d\", &amp;x); add += x; if(add &gt;= mod) add %= mod; &#125; else &#123; int t; scanf(\"%d\", &amp;t); int tail = add % (1&lt;&lt;t); if(add &amp; (1&lt;&lt;t)) &#123; ans += fwick.sum(t, (1&lt;&lt;t) - 1 - tail); ans += fwick.sum(t, (1&lt;&lt;(t+1)) - 1) - fwick.sum(t, (1&lt;&lt;(t+1)) - 1 - tail); &#125; else &#123; ans += fwick.sum(t, (1&lt;&lt;(t+1)) - 1 - tail) - fwick.sum(t, (1&lt;&lt;t) - 1 - tail); &#125; &#125; &#125; printf(\"Case %d: %lld\\n\", ++cas, ans);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); char cmd[10]; while (scanf(\"%d\", &amp;n) == 1) &#123; if(n == -1) break; fwick.init(); _for(i, 0, n) &#123; int x; scanf(\"%d\", &amp;x); _for(k, 0, 16) fwick.update(k, (x % (1&lt;&lt;(k+1))), 1); &#125; solve(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"动态规划综合(一)","slug":"20200212","date":"2020-02-12T00:25:22.000Z","updated":"2020-05-28T18:15:59.538Z","comments":true,"path":"2020/02/12/20200212/","link":"","permalink":"https://www.fogsail.net/2020/02/12/20200212/","excerpt":"这部分内容主要讲述动态规划的综合包括大整数与计数问题，计数dp，数位统计dp 计数dp补充大整数类与计数dp这里特别注意大整数类的封装","text":"这部分内容主要讲述动态规划的综合包括大整数与计数问题，计数dp，数位统计dp 计数dp补充大整数类与计数dp这里特别注意大整数类的封装 POJ1737 $base$取$1e4$，很常见 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166// == Big Integer class ==const int SZ = 200 + 5;inline void write(ll x) &#123; if(x &lt; 0) &#123; putchar('-'); x = -x; &#125; if(x &lt; 10) &#123; putchar(x + '0'); return; &#125; write(x / 10); putchar((x % 10) + '0');&#125;const int base = 1e4;class Int &#123;public: int a[SZ], len; Int() &#123; Set(a, 0); len = 0; &#125; Int(int x) &#123; Set(a, 0); len = 0; while (x) &#123; a[++len] = x % base; x /= base; &#125; &#125; inline void print() &#123; write(a[len]); for(int i = len - 1; i; i--) &#123; if(a[i] &lt; 1000) putchar('0'); if(a[i] &lt; 100) putchar('0'); if(a[i] &lt; 10) putchar('0'); write(a[i]); &#125; &#125;&#125;;inline Int operator+ (Int a, Int b) &#123; Int ans; ans = a; ans.len = max(a.len, b.len); _rep(i, 1, ans.len) &#123; ans.a[i] += b.a[i]; ans.a[i + 1] += ans.a[i] / base; ans.a[i] %= base; &#125; while (ans.a[ans.len + 1]) ans.len++; return ans;&#125;inline Int operator / (Int a, int b) &#123; Int ans; assert(ans.len == 0); int num = 0; for(int i = a.len; i; i--) &#123; num = num * base + a.a[i]; ans.a[i] = num / b; num %= b; if(ans.len == 0 &amp;&amp; ans.a[i]) ans.len = i; &#125; return ans;&#125;inline Int operator* (Int a, int b) &#123; Int ans = a; _rep(i, 1, ans.len) ans.a[i] *= b; _rep(i, 1, ans.len) &#123; ans.a[i + 1] += ans.a[i] / base; ans.a[i] %= base; &#125; while (ans.a[ans.len + 1]) &#123; ans.len++; ans.a[ans.len + 1] += ans.a[ans.len] / base; ans.a[ans.len] %= base; &#125; return ans;&#125;inline Int operator* (Int a, Int b) &#123; Int ans; assert(ans.a[1] == 0); ans.len = a.len + b.len; _rep(i, 1, a.len) _rep(j, 1, b.len) &#123; ans.a[i+j-1] += a.a[i] * b.a[j]; ans.a[i+j] += ans.a[i+j-1] / base; ans.a[i+j-1] %= base; &#125; while (ans.a[ans.len] == 0) ans.len--; return ans;&#125;inline Int operator- (Int a, Int b) &#123; Int ans = a; _rep(i, 1, b.len) &#123; ans.a[i] -= b.a[i]; if(ans.a[i] &lt; 0) &#123; ans.a[i + 1]--; ans.a[i] += base; &#125; &#125; while (ans.a[ans.len] == 0) ans.len--; return ans;&#125;// == Big Integer class finished ==// == init ==const int Max = 1500;Int bin[Max * 2];void initbin() &#123; bin[0] = Int(1); _rep(i, 1, Max) bin[i] = bin[i - 1] * 2;&#125;const int maxn = 50;Int c[maxn + 5][maxn + 5];void initc() &#123; c[0][0] = Int(1); _rep(i, 1, maxn) &#123; c[i][0] = Int(1); _rep(j, 1, i) c[i][j] = c[i - 1][j - 1] + c[i - 1][j]; &#125;&#125;// == init finished ==// == initbin() initc(), then dp() ==Int f[maxn + 5];void dp() &#123; f[1] = Int(1); _rep(i, 2, maxn) &#123; f[i] = bin[i*(i-1) / 2]; _for(j, 1, i) &#123; f[i] = f[i] - (f[j] * c[i-1][j-1] * bin[(i-j)*(i-j-1) / 2]); &#125; &#125;&#125;// == dp finished ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); initbin(); initc(); dp(); int n; while (cin &gt;&gt; n &amp;&amp; n) f[n].print(), puts(\"\");&#125; 计数dp综合他们中的多少个这是无向连通图的计数问题，注意节点有标号。 具体的思路如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338// == Big Integer class ==const int SZ = 200 + 5;inline void write(ll x) &#123; if(x &lt; 0) &#123; putchar('-'); x = -x; &#125; if(x &lt; 10) &#123; putchar(x + '0'); return; &#125; write(x / 10); putchar((x % 10) + '0');&#125;const int base = 1e4;class Int &#123;public: int a[SZ], len; Int() &#123; Set(a, 0); len = 0; &#125; Int(int x) &#123; Set(a, 0); len = 0; while (x) &#123; a[++len] = x % base; x /= base; &#125; &#125; inline void print() &#123; write(a[len]); for(int i = len - 1; i; i--) &#123; if(a[i] &lt; 1000) putchar('0'); if(a[i] &lt; 100) putchar('0'); if(a[i] &lt; 10) putchar('0'); write(a[i]); &#125; &#125;&#125;;inline Int operator+ (Int a, Int b) &#123; Int ans; ans = a; ans.len = max(a.len, b.len); _rep(i, 1, ans.len) &#123; ans.a[i] += b.a[i]; ans.a[i + 1] += ans.a[i] / base; ans.a[i] %= base; &#125; while (ans.a[ans.len + 1]) ans.len++; return ans;&#125;inline Int operator / (Int a, int b) &#123; Int ans; assert(ans.len == 0); int num = 0; for(int i = a.len; i; i--) &#123; num = num * base + a.a[i]; ans.a[i] = num / b; num %= b; if(ans.len == 0 &amp;&amp; ans.a[i]) ans.len = i; &#125; return ans;&#125;inline ll operator % (Int a, int b) &#123; ll num = 0; for(int i = a.len; i; i--) &#123; num = ((num * base) % b + a.a[i]) % b; &#125; return num;&#125;inline Int operator* (Int a, int b) &#123; Int ans = a; _rep(i, 1, ans.len) ans.a[i] *= b; _rep(i, 1, ans.len) &#123; ans.a[i + 1] += ans.a[i] / base; ans.a[i] %= base; &#125; while (ans.a[ans.len + 1]) &#123; ans.len++; ans.a[ans.len + 1] += ans.a[ans.len] / base; ans.a[ans.len] %= base; &#125; return ans;&#125;inline Int operator* (Int a, Int b) &#123; Int ans; assert(ans.a[1] == 0); ans.len = a.len + b.len; _rep(i, 1, a.len) _rep(j, 1, b.len) &#123; ans.a[i+j-1] += a.a[i] * b.a[j]; ans.a[i+j] += ans.a[i+j-1] / base; ans.a[i+j-1] %= base; &#125; while (ans.a[ans.len] == 0) ans.len--; return ans;&#125;inline Int operator- (Int a, Int b) &#123; Int ans = a; _rep(i, 1, b.len) &#123; ans.a[i] -= b.a[i]; if(ans.a[i] &lt; 0) &#123; ans.a[i + 1]--; ans.a[i] += base; &#125; &#125; while (ans.a[ans.len] == 0) ans.len--; return ans;&#125;const int maxn = 50 + 2;Int _c[maxn][maxn];const int mod = 1e9 + 7;ll H[maxn + 1];// == table() and list H[] ==const int Max = 1500;Int bin[Max*2];void initbin() &#123; bin[0] = Int(1); _rep(i, 1, Max) bin[i] = bin[i - 1] * 2;&#125;Int tb[maxn + 5];void getH() &#123; initbin(); tb[1] = Int(1); _rep(i, 2, maxn) &#123; tb[i] = bin[i*(i-1) / 2]; _for(j, 1, i) &#123; tb[i] = tb[i] - (tb[j] * _c[i-1][j-1] * bin[(i-j)*(i-j-1) / 2]); &#125; &#125;&#125;void table() &#123; getH(); _rep(i, 1, maxn) H[i] = tb[i] % mod;&#125;// == table() finsihed ==const int maxm = 1250;// == calculate C() ==void initC() &#123; _c[0][0] = Int(1); _rep(i, 1, maxn) &#123; _c[i][0] = Int(1); _rep(j, 1, i) _c[i][j] = _c[i-1][j-1] + _c[i-1][j]; &#125;&#125;inline ll C(int n, int m) &#123; return _c[n][m] % mod;&#125;ll power(ll a, int b) &#123; ll ans = 1; for(; b; b &gt;&gt;= 1) &#123; if(b &amp; 1) ans = ans * a % mod; a = a * a % mod; &#125; return ans;&#125;// == C() finsihed, usage initC() and C(x, y) ==// == first part, init f(i,j) ==ll f[maxn][maxm];ll sum[maxn][maxm];void initf() &#123; Set(f, -1); Set(sum, 0); f[0][0] = 0; f[1][0] = 1; f[1][1] = 0; f[2][0] = 0; f[2][1] = 1; f[2][2] = 0; _for(i, 3, maxn) f[i][0] = 0;&#125;// == f(i, j) finished ==// == second part, init g(i,j,k) ==ll g[maxn][maxn][maxm];void initg() &#123; Set(g, -1); _for(i, 0, maxn) _for(j, 0, maxm) g[0][i][j] = 0; _for(k, 0, maxm) g[1][0][k] = 0; g[1][1][0] = 1; _for(k, 1, maxm) g[1][1][k] = 0; //_for(i, 0, maxn) g[i][1][0] = 1; g[2][1][1] = 2; g[2][1][0] = 0; //g[2][0][0] = 1; //g[2][0][1] = 0;&#125;// == g(i,j,k) finished ==// == function G(i,j,k) ==ll G(int i, int j, int k) &#123; if(g[i][j][k] &gt;= 0) return g[i][j][k]; ll res = 0; _rep(p, 1, i) _rep(q, 0, k) &#123; //debug(p); //debug(q); //debug(f[p][q]); if(q &gt;= p) continue; assert(f[p][q] &gt;= 0); //debug(f[p][q]); ll S = G(i-p, j-1, k-q); assert(S &gt;= 0); res += (f[p][q] * C(i-1, p-1) % mod * p % mod * S) % mod; res %= mod; &#125; return g[i][j][k] = res;&#125;// == G(i,j,k) finished ==// == function cal(i, j, k) ==ll cal(int i, int j, int k) &#123; assert(f[k][0] &gt;= 0); //debug(k), debug(f[k][0]); //puts(\"\"); //printf(\"i = %d, k = %d, %lld\\n\",i, k, C(i-1, k-1)); ll S1 = f[k][0] * C(i-1, k-1) % mod; //debug(C(i-1, k-1)); ll S2 = 0; _rep(x, 1, min(i-k, j)) &#123; S2 = (S2 + (G(i-k, x, j-x) * power(k, x)) % mod) % mod; &#125; // if(i == 3) debug(S2); return S1 * S2 % mod;&#125;// == cal(i, j, k) finsihed ==// == then solve ==const int N = 50;const int M = 1250;void solve() &#123; _rep(i, 3, N) &#123; f[i][0] = H[i]; _for(j, 1, i) &#123; //assert(f[i][j] &lt;= 0); f[i][j] = 0; _rep(k, 1, i - 1) &#123; f[i][j] = (f[i][j] + cal(i, j, k)) % mod; &#125; f[i][0] = (f[i][0] - f[i][j] + mod) % mod; &#125; &#125;&#125;// == solve finished ==int main() &#123; //freopen(\"input.txt\", \"r\", stdin); freopen(\"sol.out\", \"w\", stdout); initC(); table(); initf(); initg(); solve(); //debug(H[52]); //debug(H[3]); //debug(f[3][1]); //debug(f[3][2]); //debug(g[2][1][1]); //debug(g[2][1][0]); _rep(i, 1, N) &#123; cout &lt;&lt; i &lt;&lt; \": \"; printf(\" || H[i]=%lld || \", H[i]); _rep(j, 0, 10) printf(\"%lld \", f[i][j]); puts(\"\"); &#125; cout &lt;&lt; \"\\n===================\\n\" &lt;&lt; endl; // == get another table == _rep(i, 0, N) &#123; if(i == 0) &#123; _rep(j, 0, N) printf(\"0, \"); printf(\"\\n\"); continue; &#125; _rep(j, 0, N) &#123; if(f[i][j] &lt; 0) printf(\"0, \"); else printf(\"%lld, \", f[i][j]); &#125; printf(\"\\n\"); &#125; // == table end ==&#125; 康托尔思想POJ1037 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const int maxn = 20 + 5;const int N = 20;int n;ll m, f[maxn][maxn][2];void prework() &#123; Set(f, 0); f[1][1][1] = f[1][1][0] = 1; _rep(i, 2, N) _rep(j, 1, i) &#123; _rep(p, j, i - 1) f[i][j][0] += f[i - 1][p][1]; _rep(p, 1, j - 1) f[i][j][1] += f[i - 1][p][0]; &#125;&#125;bool used[maxn];void solve() &#123; Set(used, 0); int last, k; _rep(j, 1, n) &#123; if(f[n][j][1] &gt;= m) &#123; last = j; k = 1; break; &#125; else m -= f[n][j][1]; if(f[n][j][0] &gt;= m) &#123; last = j; k = 0; break; &#125; else m -= f[n][j][0]; &#125; //debug(last); //debug(k); used[last] = 1; printf(\"%d\", last); _rep(i, 2, n) &#123; int j = 0; k ^= 1; // assign new len to last // find out a new len, then get last len _rep(len, 1, n) &#123; if(used[len]) continue; j++; if((k == 0 &amp;&amp; len &lt; last) || (k == 1 &amp;&amp; len &gt; last)) &#123; // assign a new value to last if(f[n - i + 1][j][k] &gt;= m) &#123; last = len; break; &#125; else m -= f[n - i + 1][j][k]; &#125; &#125; used[last] = 1; printf(\" %d\", last); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); prework(); int kase; cin &gt;&gt; kase; while (kase--) &#123; cin &gt;&gt; n &gt;&gt; m; solve(); cout &lt;&lt; endl; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"https://www.fogsail.net/tags/dp/"}]},{"title":"动态规划优化(三)","slug":"20200203","date":"2020-02-03T12:01:32.000Z","updated":"2020-02-11T04:34:27.819Z","comments":true,"path":"2020/02/03/20200203/","link":"","permalink":"https://www.fogsail.net/2020/02/03/20200203/","excerpt":"这部分内容主要介绍了四边形不等式和数位dp","text":"这部分内容主要介绍了四边形不等式和数位dp 四边形不等式一维线性dp的四边形不等式优化Acwing304 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114const int maxn = 100000 + 5;int N, L, P;class Q &#123;public: int x, l, r;&#125;;Q q[maxn];ld f[maxn];ll S[maxn];void init() &#123; Set(f, 0); Set(S, 0);&#125;ld cal(int i, int j) &#123; ld ans = 1; ld num = abs((ld)(S[i] - S[j] + i - j - 1 - L)); _rep(k, 1, P) ans *= num; return ans + f[j];&#125;int bsearch(int i, int ql, int qr) &#123; int ans = 0; while (ql &lt;= qr) &#123; int mid = (ql + qr) &gt;&gt; 1; if(q[mid].l &lt;= i &amp;&amp; q[mid].r &gt;= i) &#123; ans = mid; break; &#125; if(q[mid].l &lt;= i) ql = mid + 1; else qr = mid - 1; &#125; return q[ans].x;&#125;int findpos(int i, int x, int l, int r) &#123; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (cal(mid, i) &gt; cal(mid, x)) l = mid + 1; else r = mid; &#125; return l;&#125;void insert(int i, int&amp; ql, int&amp; qr) &#123; int pos = -1; while (ql &lt;= qr) &#123; int lt = q[qr].l, rt = q[qr].r, xt = q[qr].x; if(cal(lt, i) &lt;= cal(lt, xt)) pos = q[qr--].l; else &#123; if(cal(rt, i) &lt; cal(rt, xt)) &#123; pos = findpos(i, xt, q[qr].l, q[qr].r); q[qr].r = pos - 1; &#125; break; &#125; &#125; if(pos != -1) &#123; q[++qr].l = pos; q[qr].r = N; q[qr].x = i; &#125;&#125;void solve() &#123; init(); cin &gt;&gt; N &gt;&gt; L &gt;&gt; P; // == get poetry sentences == _rep(i, 1, N) &#123; char str[35]; scanf(\"%s\", str); S[i] = S[i - 1] + strlen(str); &#125; // == poetry sentences finished == // == monotonic dp == int ql = 1, qr = 1; q[1].x = 0; q[1].l = 1; q[1].r = N; _rep(i, 1, N) &#123; int j = bsearch(i, ql, qr); if(i == 1) assert(j == 0); f[i] = cal(i, j); // == then pop front and try to insert i == while (ql &lt;= qr &amp;&amp; q[ql].r &lt;= i) ql++; q[ql].l = i + 1; insert(i, ql, qr); // == monotonic queue finished == &#125; // == monotonic finished == if(f[N] &gt; 1e18) puts(\"Too hard to arrange\"); else cout &lt;&lt; (ll)f[N] &lt;&lt; endl; _rep(i, 1, 20) putchar('-'); cout &lt;&lt; endl;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; cin &gt;&gt; T; while (T--) solve();&#125; 二维dp，四边形不等式，决策单调性 123456789101112131415161718192021222324252627282930313233343536373839404142434445const int maxn = 5000 + 5;const int inf = 0x3f3f3f3f;int N;int F[maxn][maxn], P[maxn][maxn];int a[maxn];int sum[maxn];void init() &#123; Set(F, inf); Set(P, 0); Set(sum, 0); _rep(i, 1, N) &#123; F[i][i] = 0; P[i][i] = i; &#125;&#125;void dp() &#123; init(); _rep(i, 1, N) &#123; scanf(\"%d\", &amp;a[i]); sum[i] = sum[i - 1] + a[i]; &#125; _forDown(i, N - 1, 1) _rep(j, i + 1, N) &#123; _rep(k, P[i][j - 1], P[i + 1][j]) &#123; int val = F[i][k] + F[k + 1][j] + (sum[j] - sum[i - 1]); if(val &lt; F[i][j]) &#123; F[i][j] = val; P[i][j] = k; &#125; &#125; &#125; printf(\"%d\\n\", F[1][N]);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (cin &gt;&gt; N &amp;&amp; N) &#123; dp(); &#125;&#125; 加西亚-瓦克斯算法POJ1738 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int maxn = 50000 + 5;int N, tot;ll ans, a[maxn];void init() &#123; tot = 1; ans = 0;&#125;void dfs(int k) &#123; ll tmp = a[k] + a[k - 1]; ans += tmp; tot--; // for successor, move right _for(i, k, tot) a[i] = a[i + 1]; // for pre, while a[i - 1] &lt; tmp, move left int i = 0; for(i = k - 1; i &gt;= 1 &amp;&amp; a[i - 1] &lt; tmp; i--) a[i] = a[i - 1]; a[i] = tmp; while (i &gt;= 2 &amp;&amp; a[i] &gt;= a[i - 2]) &#123; int r = tot - i; dfs(i - 1); i = tot - r; &#125;&#125;void GarsiaWachs() &#123; _for(i, 0, N) scanf(\"%lld\", &amp;a[i]); _for(i, 1, N) &#123; a[tot++] = a[i]; while (tot &gt;= 3 &amp;&amp; a[tot - 1] &gt;= a[tot - 3]) dfs(tot - 2); &#125; while (tot &gt; 1) dfs(tot - 1); printf(\"%lld\\n\", ans);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (cin &gt;&gt; N &amp;&amp; N) &#123; init(); GarsiaWachs(); &#125;&#125; 计数dp专题逆元法求组合数 codeforces559C 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const int SZ = 2000 + 10;const int maxn = 200000 + 10;const ll mod = 1000000000 + 7;int h, w, n;ll jc[maxn], jcinv[maxn];int f[SZ];struct A &#123; int x, y; bool operator&lt; (const A&amp; rhs) const &#123; return x &lt; rhs.x || (x == rhs.x &amp;&amp; y &lt; rhs.y); &#125;&#125;;A a[SZ];// == init jc ==inline ll power(ll a, int b) &#123; ll ans = 1; for(; b; b &gt;&gt;= 1) &#123; if(b &amp; 1) ans = ans * a % mod; a = a * a % mod; &#125; return ans;&#125;void init() &#123; Set(f, 0); jc[0] = 1; jcinv[0] = 1; _rep(i, 1, maxn) &#123; jc[i] = jc[i - 1] * i % mod; jcinv[i] = power(jc[i], mod - 2); &#125;&#125;// == init finished ==// == calculate C ==int C(int n, int m) &#123; return jc[n] * jcinv[m] % mod * jcinv[n - m] % mod;&#125;// == calculate finished ==// == input files ==void inp() &#123; cin &gt;&gt; h &gt;&gt; w &gt;&gt; n; _rep(i, 1, n) &#123; scanf(\"%d%d\", &amp;a[i].x, &amp;a[i].y); &#125; sort(a + 1, a + 1 + n); a[n + 1].x = h, a[n + 1].y = w;&#125;// == input finsihed ==// == dp ==void dp() &#123; _rep(i, 1, n + 1) &#123; f[i] = C(a[i].x + a[i].y - 2, a[i].x - 1); //debug(f[i]); _for(j, 1, i) &#123; if(a[j].x &gt; a[i].x || a[j].y &gt; a[i].y) continue; f[i] = (f[i] - (ll)f[j] * C(a[i].x - a[j].x + a[i].y - a[j].y, a[i].x - a[j].x)) % mod; &#125; &#125; cout &lt;&lt; (f[n + 1] + mod) % mod &lt;&lt; endl;&#125;// == dp finished ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); //debug(jc[2000]); // debug(jcinv[2000]); inp(); dp();&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"https://www.fogsail.net/tags/dp/"}]},{"title":"动态规划优化(二)","slug":"20200116","date":"2020-01-16T02:10:34.000Z","updated":"2020-02-03T04:15:17.540Z","comments":true,"path":"2020/01/16/20200116/","link":"","permalink":"https://www.fogsail.net/2020/01/16/20200116/","excerpt":"这部分内容介绍了单调队列优化，斜率优化等等","text":"这部分内容介绍了单调队列优化，斜率优化等等 辅助算法，区间最值的ST算法 单调队列优化dpPOJ1821 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int maxn = 16000 + 10;const int maxm = 100 + 10;class Node &#123;public: int S, L, P; bool operator&lt; (const Node&amp; rhs) const &#123; return S &lt; rhs.S; &#125;&#125;;Node A[maxn];int n, m;int f[maxm][maxn];void init() &#123; Set(f, 0);&#125;inline int g(int i, int k) &#123; return f[i - 1][k] - A[i].P * k;&#125;void solve() &#123; sort(A + 1, A + 1 + m); deque&lt;int&gt; que; _rep(i, 1, m) &#123; // == init queue == for(int k = max(0, A[i].S - A[i].L); k &lt;= A[i].S - 1; k++) &#123; while (!que.empty() &amp;&amp; g(i, que.back()) &lt;= g(i, k)) que.pop_back(); que.push_back(k); &#125; // == init finished == _rep(j, 1, n) &#123; f[i][j] = max(f[i - 1][j], f[i][j - 1]); if(j &gt;= A[i].S) &#123; while (!que.empty() &amp;&amp; j - A[i].L &gt; que.front()) que.pop_front(); if(!que.empty()) f[i][j] = max(f[i][j], A[i].P * j + g(i, que.front())); &#125; &#125; &#125; cout &lt;&lt; f[m][n] &lt;&lt; endl;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m; // == input == _rep(i, 1, m) &#123; scanf(\"%d%d%d\", &amp;A[i].L, &amp;A[i].P, &amp;A[i].S); &#125; // == input finished == init(); solve();&#125; 单调队列优化+二叉堆POJ3017 双端队列版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const int maxn = 100006;llong A[maxn];int N;llong M;multiset&lt;llong&gt; s;multiset&lt;llong&gt;::iterator it;llong f[maxn];void init() &#123; s.clear(); Set(f, 0);&#125;void solve() &#123; deque&lt;int&gt; que; llong sum = 0; int p = 1; _rep(i, 1, N) &#123; sum += A[i]; while (sum &gt; M) sum -= A[p++]; // == get que[front] == while (!que.empty() &amp;&amp; que.front() &lt; p) &#123; int t = que.front(); que.pop_front(); if(!que.empty() &amp;&amp; (it = s.find(f[t] + A[que.front()])) != s.end()) &#123; s.erase(it); &#125; &#125; // == que[front] finished == // == now que[front] is p == // == Monotonic queue == while (!que.empty() &amp;&amp; A[que.back()] &lt;= A[i]) &#123; int b = que.back(); que.pop_back(); if(!que.empty() &amp;&amp; (it = s.find(f[que.back()] + A[b])) != s.end()) &#123; s.erase(it); &#125; &#125; // == Monotonic queue finished == if(!que.empty()) s.insert(f[que.back()] + A[i]); que.push_back(i); f[i] = f[p - 1] + A[que.front()]; if(s.begin() != s.end()) f[i] = min(f[i], *s.begin()); &#125; cout &lt;&lt; f[N] &lt;&lt; endl;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; N &gt;&gt; M; // == input == _rep(i, 1, N) &#123; scanf(\"%lld\", &amp;A[i]); if(A[i] &gt; M) &#123; puts(\"-1\"); return 0; &#125; &#125; // == input finished == solve();&#125; ST+双端队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// == ST Algorithm ==void ST() &#123; _rep(i, 1, N) Q[i][0] = A[i]; int t = log(N) / log(2) + 1; _for(k, 1, t) _rep(i, 1, N - (1&lt;&lt;k) + 1) &#123; Q[i][k] = max(Q[i][k - 1], Q[i + (1 &lt;&lt; (k - 1))][k - 1]); &#125;&#125;llong ask(int l, int r) &#123; int k = log(r - l + 1) / log(2); return max(Q[l][k], Q[r - (1&lt;&lt;k) + 1][k]);&#125;// == ST Algorithm finished ==void solve() &#123; ST(); deque&lt;int&gt; que; llong sum = 0; int p = 1; _rep(i, 1, N) &#123; sum += A[i]; while (sum &gt; M) sum -= A[p++]; // == get que[front] == while (!que.empty() &amp;&amp; que.front() &lt; p) &#123; int t = que.front(); que.pop_front(); if(!que.empty() &amp;&amp; (it = s.find(f[t] + A[que.front()])) != s.end()) s.erase(it); &#125; // == que[front] finished, now que[front] = p // == Monotonic queue == while (!que.empty() &amp;&amp; A[que.back()] &lt;= A[i]) &#123; int b = que.back(); que.pop_back(); if(!que.empty() &amp;&amp; (it = s.find(f[que.back()] + A[b])) != s.end()) s.erase(it); &#125; if(!que.empty()) s.insert(f[que.back()] + A[i]); que.push_back(i); // == Monotonic queue finished == f[i] = f[p - 1] + ask(p, i); if(s.begin() != s.end()) f[i] = min(f[i], *s.begin()); &#125; cout &lt;&lt; f[N] &lt;&lt; endl;&#125; 单调队列优化多重背包HDU2191 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const int inf = 0xcf;const int maxn = 20000 + 10;int n, m;int f[maxn];int W[maxn], V[maxn], C[maxn];void init() &#123; Set(f, inf); f[0] = 0;&#125;inline int g(int i, int u, int k) &#123; return f[u + k * V[i]] - k * W[i];&#125;void solve() &#123; init(); _rep(i, 1, n) &#123; scanf(\"%d%d%d\", &amp;V[i], &amp;W[i], &amp;C[i]); _for(u, 0, V[i]) &#123; deque&lt;int&gt; que; // == status variable p == int maxp = (m - u) / V[i]; _forDown(k, maxp - 1, max(0, maxp - C[i])) &#123; while (!que.empty() &amp;&amp; g(i, u, que.back()) &lt;= g(i, u, k)) que.pop_back(); que.push_back(k); &#125; _forDown(p, maxp, 0) &#123; // == compare que.front and p-1 while (!que.empty() &amp;&amp; que.front() &gt; p - 1) que.pop_front(); if(!que.empty()) f[u + p * V[i]] = max(f[u + p * V[i]], g(i, u, que.front()) + p * W[i]); // == compare que.back and maintain monotonic queue if(p - 1 - C[i] &gt;= 0) &#123; int k2 = p - 1 - C[i]; while (!que.empty() &amp;&amp; g(i, u, que.back()) &lt;= g(i, u, k2)) que.pop_back(); que.push_back(k2); &#125; &#125; // == status variable finished == &#125; &#125; int ans = 0; _rep(i, 1, m) ans = max(ans, f[i]); cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;m, &amp;n); solve(); &#125;&#125; 斜率优化POJ1180 12345678910111213141516171819202122232425262728293031323334353637const int maxn = 300000 + 10;llong sumc[maxn], sumt[maxn];llong f[maxn];int n, s;void init() &#123; Set(f, 0x3f); f[0] = 0;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; s; init(); // == get input == _rep(i, 1, n) &#123; int t, c; scanf(\"%d%d\", &amp;t, &amp;c); sumt[i] = sumt[i - 1] + t; sumc[i] = sumc[i - 1] + c; &#125; // == input finished == deque&lt;int&gt; q; q.push_back(0); _rep(i, 1, n) &#123; while (q.size() &gt;= 2 &amp;&amp; (f[q[1]] - f[q[0]]) &lt;= (s + sumt[i]) * (sumc[q[1]] - sumc[q[0]]) ) q.pop_front(); f[i] = f[q[0]] - (s + sumt[i]) * sumc[q[0]] + sumt[i] * sumc[i] + s * sumc[n]; while (q.size() &gt;= 2 &amp;&amp; (f[*(q.end()-1)] - f[*(q.end()-2)]) * (sumc[i] - sumc[*(q.end()-1)]) &gt;= (f[i] - f[*(q.end()-1)]) * (sumc[*(q.end()-1)] - sumc[*(q.end()-2)]) ) q.pop_back(); q.push_back(i); &#125; cout &lt;&lt; f[n] &lt;&lt; endl;&#125; 斜率优化+二分或二叉堆BZOJ2726 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const int maxn = 300000 + 10;llong sumc[maxn], sumt[maxn];llong f[maxn];int q[maxn], ql, qr;int n, s;void init() &#123; Set(f, 0x3f); f[0] = 0; Set(q, 0); ql = qr = 0;&#125;int bSearch(const int ql, const int qr, int k) &#123; int l = ql, r = qr; if(l == r) return q[l]; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(f[q[mid + 1]] - f[q[mid]] &lt;= k * (sumc[q[mid + 1]] - sumc[q[mid]]) ) l = mid + 1; else r = mid; &#125; return q[l];&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; s; init(); // == get input == _rep(i, 1, n) &#123; int t, c; scanf(\"%d%d\", &amp;t, &amp;c); sumt[i] = sumt[i - 1] + t; sumc[i] = sumc[i - 1] + c; &#125; // == input finished == ql = qr = 1; q[1] = 0; _rep(i, 1, n) &#123; int p = bSearch(ql, qr, sumt[i] + s); f[i] = f[p] - (s + sumt[i]) * sumc[p] + sumt[i] * sumc[i] + s * sumc[n]; while (ql &lt; qr &amp;&amp; (f[q[qr]] - f[q[qr - 1]]) * (sumc[i] - sumc[q[qr]]) &gt;= (f[i] - f[q[qr]]) * (sumc[q[qr]] - sumc[q[qr - 1]]) ) qr--; q[++qr] = i; &#125; cout &lt;&lt; f[n] &lt;&lt; endl;&#125; 斜率优化任务规划模型codeforces311B 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int maxn = 100000 + 10;const int maxm = 100 + 10;const int inf = 0x3f;llong f[maxm][maxn], D[maxn], H[maxn], T[maxn], q[maxn];llong g[maxn];int N, M, P;llong A[maxn], S[maxn];void init() &#123; sort(A + 1, A + 1 + M); _rep(i, 1, M) &#123; S[i] = S[i - 1] + A[i]; &#125; Set(f, inf); Set(g, 0); Set(q, 0); f[0][0] = 0;&#125;void solve() &#123; _rep(i, 1, P) &#123; _rep(k, 1, M) g[k] = f[i - 1][k] + S[k]; int l = 1, r = 1; q[1] = 0; _rep(j, 1, M) &#123; while (l &lt; r &amp;&amp; (g[q[l+1]] - g[q[l]]) &lt;= (A[j] * (q[l+1] - q[l]) ) ) l++; f[i][j] = min(f[i - 1][j], g[q[l]] + A[j] * (j - q[l]) - S[j] ); while (l &lt; r &amp;&amp; ( (g[q[r]] - g[q[r-1]]) * (j - q[r]) &gt;= (g[j] - g[q[r]]) * (q[r] - q[r-1]) ) ) r--; q[++r] = j; &#125; &#125; cout &lt;&lt; f[P][M] &lt;&lt; endl;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); // == input == cin &gt;&gt; N &gt;&gt; M &gt;&gt; P; _rep(i, 2, N) &#123; int x; scanf(\"%d\", &amp;x); D[i] = D[i - 1] + x; &#125; _rep(i, 1, M) &#123; int h, t; scanf(\"%d%d\", &amp;h, &amp;t); A[i] = t - D[h]; &#125; // == input finished == // == init data == init(); // == init data finished == // == solve the problem == solve();&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"https://www.fogsail.net/tags/dp/"}]},{"title":"实用数据结构(五)","slug":"20200108","date":"2020-01-08T08:06:27.000Z","updated":"2020-01-10T18:05:42.492Z","comments":true,"path":"2020/01/08/20200108/","link":"","permalink":"https://www.fogsail.net/2020/01/08/20200108/","excerpt":"对莫队算法做一个总结然后介绍一些常用的数据结构比如splay-tree， kd-tree等等","text":"对莫队算法做一个总结然后介绍一些常用的数据结构比如splay-tree， kd-tree等等 莫队算法综合题WC2013糖果公园 需要注意的是，dfs序，莫队数组必须开 maxn \\times 2 大小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221const int maxn = 200000 + 10;// == Graph structure ==int head[maxn], nxt[maxn], ver[maxn];int tot = 0;void initG() &#123; Set(head, 0); Set(nxt, 0); Set(ver, 0); tot = 0;&#125;void add(int x, int y) &#123; ver[++tot] = y; nxt[tot] = head[x]; head[x] = tot;&#125;// == Graph structure finished ==// == get input ==int V[maxn], W[maxn], C[maxn];int cnt[maxn];int n, m, q;void init() &#123; Set(cnt, 0);&#125;void getinp() &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); _rep(i, 1, m) scanf(\"%d\", &amp;V[i]); _rep(i, 1, n) scanf(\"%d\", &amp;W[i]); _for(i, 1, n) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); add(u, v); add(v, u); &#125; _rep(i, 1, n) scanf(\"%d\", &amp;C[i]);&#125;// == input finished ==// == get dfs order and lca ==int fst[maxn], lst[maxn], dep[maxn], ord[maxn];int f[maxn][30];const int H = 25;int dfn = 0;void initdfs() &#123; Set(dep, 0); Set(f, 0); dep[1] = 1; dfn = 0;&#125;void dfs(int x) &#123; assert(dep[1] == 1); ord[++dfn] = x; fst[x] = dfn; for(int i = head[x]; i; i = nxt[i]) &#123; int y = ver[i]; if(dep[y]) continue; dep[y] = dep[x] + 1; f[y][0] = x; _rep(k, 1, H) f[y][k] = f[f[y][k - 1]][k - 1]; dfs(y); &#125; ord[++dfn] = x; lst[x] = dfn;&#125;int getlca(int x, int y) &#123; if(dep[x] &gt; dep[y]) swap(x, y); _forDown(i, H, 0) if(dep[f[y][i]] &gt;= dep[x]) y = f[y][i]; if(x == y) return x; _forDown(i, H, 0) if(f[y][i] != f[x][i]) &#123; x = f[x][i], y = f[y][i]; &#125; return f[x][0];&#125;// == dfs order and lca finished ==// == get qry and change ==class Qry &#123;public: int l, r, id, time, lca;&#125;;Qry qry[maxn];class Ch &#123;public: int val, pos;&#125;;Ch ch[maxn];int qn = 0, cn = 0;void getinp2() &#123; _rep(i, 1, q) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if(op) &#123; int lca = getlca(x, y); qry[++qn].time = cn; qry[qn].id = qn; if(fst[x] &gt; fst[y]) swap(x, y); if(x == lca) &#123; qry[qn].l = fst[x]; qry[qn].r = fst[y]; &#125; else &#123; qry[qn].l = lst[x]; qry[qn].r = fst[y]; qry[qn].lca = lca; &#125; &#125; else &#123; ch[++cn].pos = x; ch[cn].val = y; &#125; &#125;&#125;// == qry and change finished ==// == block ==int belong[maxn];int sz, t;void block() &#123; sz = sqrt(dfn); t = dfn / sz; _rep(i, 1, t) _rep(k, (i - 1) * sz + 1, i * sz) belong[k] = i; if(t * sz &lt; dfn) &#123; t++; _rep(k, (t - 1) * sz + 1, dfn) belong[k] = t; &#125;&#125;int cmp(const Qry&amp; a, const Qry&amp; b) &#123; if(belong[a.l] ^ belong[b.l]) return belong[a.l] &lt; belong[b.l]; if(belong[a.l] ^ belong[b.r]) return belong[a.r] &lt; belong[b.r]; return a.time &lt; b.time;&#125;// == block finsihed ==// == Mo algorithm ==int visMo[maxn];void push(int x, llong&amp; ans) &#123; ans += (llong)1 * V[C[x]] * W[++cnt[C[x]]];&#125;void del(int x, llong&amp; ans) &#123; ans -= (llong)1 * V[C[x]] * W[cnt[C[x]]--];&#125;void work(int x, llong&amp; ans) &#123; visMo[x] ? del(x, ans) : push(x, ans); visMo[x] ^= 1;&#125;void apply(int t, llong&amp; ans) &#123; if(visMo[ch[t].pos]) &#123; work(ch[t].pos, ans); swap(ch[t].val, C[ch[t].pos]); assert(visMo[ch[t].pos] == 0); work(ch[t].pos, ans); &#125; else swap(ch[t].val, C[ch[t].pos]);&#125;llong ANS[maxn];void solve() &#123; sort(qry + 1, qry + 1 + qn, cmp); int l = 1, r = 0, ptime = 0; llong ans = 0; _rep(i, 1, qn) &#123; int ql = qry[i].l, qr = qry[i].r, qt = qry[i].time, qlca = qry[i].lca; while (l &lt; ql) work(ord[l++], ans); while (l &gt; ql) work(ord[--l], ans); while (r &lt; qr) work(ord[++r], ans); while (r &gt; qr) work(ord[r--], ans); while (ptime &lt; qt) apply(++ptime, ans); while (ptime &gt; qt) apply(ptime--, ans); if(qlca) work(qlca, ans); ANS[qry[i].id] = ans; if(qlca) work(qlca, ans); &#125;&#125;// == Mo algorithm finished ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); initG(); init(); getinp(); initdfs(); dfs(1); getinp2(); block(); solve(); _rep(i, 1, qn) printf(\"%lld\\n\", ANS[i]);&#125; 数据结构优化计算几何GYM100729I 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127const int inf = 0x3f3f3f3f;const int maxn = 15;int ns, nw, np, r;// == Point structure ==class Point &#123;public: int x, y; Point(int x = 0, int y = 0) : x(x), y(y) &#123;&#125; Point operator+ (const Point&amp; rhs) const &#123; return Point(x + rhs.x, y + rhs.y); &#125; Point operator- (const Point&amp; rhs) const &#123; return Point(x - rhs.x, y - rhs.y); &#125; bool operator== (const Point&amp; rhs) const &#123; return x == rhs.x &amp;&amp; y == rhs.y; &#125; bool operator&lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x == rhs.x &amp;&amp; y &lt; rhs.y); &#125;&#125;;typedef Point Vector;llong Cross(const Vector&amp; A, const Vector&amp; B) &#123; return (llong)A.x * B.y - (llong)A.y * B.x;&#125;llong Length2(const Vector&amp; A) &#123; return (llong)A.x * A.x + (llong)A.y * A.y;&#125;Point readPoint() &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); return Point(x, y);&#125;// == Point structure finished ==// == Segment Structure ==class Line &#123;public: Point a, b;&#125;;Line walls[maxn];bool segmentProperIntersection(const Point&amp; a, const Point&amp; b, const Point&amp; c, const Point&amp; d) &#123; if(max(a.x, b.x) &lt; min(c.x, d.x) || max(a.y, b.y) &lt; min(c.y, d.y) || min(a.x, b.x) &gt; max(c.x, d.x) || min(a.y, b.y) &gt; max(c.y, d.y)) return 0; llong v1 = Cross(b - a, c - a), v2 = Cross(b - a, d - a); llong v3 = Cross(d - c, a - c), v4 = Cross(d - c, b - c); return v1 * v2 &lt;= 0 &amp;&amp; v3 * v4 &lt;= 0;&#125;// == Segment Structure finished ==set&lt;Point&gt; sen;vector&lt;Point&gt; ANS;// == solve the problem ==int check(Point p, Vector v) &#123; Point q = p + v; if(!sen.count(q)) return 0; int cnt = 0; _for(i, 0, nw) &#123; if(segmentProperIntersection(walls[i].a, walls[i].b, p, q)) cnt++; &#125; return cnt &lt;= r &amp;&amp; Length2(v) &lt;= (llong)(r - cnt) * (r - cnt);&#125;void solve(const Point&amp; p) &#123; _rep(dx, -r, r) _rep(dy, -r, r) &#123; if(Length2(Vector(dx, dy)) &gt; r * r) continue; if(check(p, Vector(dx, dy))) ANS.push_back(p + Vector(dx, dy)); &#125;&#125;// == solve finsihed ==void init() &#123; sen.clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d%d%d\", &amp;ns, &amp;r, &amp;nw, &amp;np); init(); _for(i, 0, ns) &#123; sen.insert(readPoint()); &#125; _for(i, 0, nw) &#123; walls[i].a = readPoint(); walls[i].b = readPoint(); &#125; // == input finished == // == then query for the products == while (np--) &#123; ANS.clear(); Point p = readPoint(); solve(p); printf(\"%d\", (int)ANS.size()); sort(ANS.begin(), ANS.end()); for(auto e : ANS) printf(\" (%d,%d)\", e.x, e.y); printf(\"\\n\"); &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"嵌套和分块数据结构(二)","slug":"20191211","date":"2019-12-11T06:12:52.000Z","updated":"2020-01-08T05:58:51.340Z","comments":true,"path":"2019/12/11/20191211/","link":"","permalink":"https://www.fogsail.net/2019/12/11/20191211/","excerpt":"这部分介绍了数据结构的综合包括前置知识，树的dfs序，树的重心倍增法求LCA等等然后介绍树上莫队和莫队综合","text":"这部分介绍了数据结构的综合包括前置知识，树的dfs序，树的重心倍增法求LCA等等然后介绍树上莫队和莫队综合 树有关的算法树遍历有关的算法 倍增求LCA LCA模版题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091const int maxn = 50000 + 10;const int maxt = 20;int n, m, t;int T;// == lca init() ==int f[maxn][maxt], dist[maxn], dep[maxn];// == lca finished ==// == graph ==int head[maxn], ver[maxn * 2], nxt[maxn * 2], w[maxn * 2];int tot = 0;void init() &#123; Set(head, 0); Set(ver, 0); Set(nxt, 0); Set(w, 0); Set(f, 0); Set(dist, 0); Set(dep, 0); tot = 0;&#125;void add(int x, int y, int z) &#123; ver[++tot] = y, nxt[tot] = head[x], head[x] = tot; w[tot] = z;&#125;// == graph finished ==// == init lca and bfs() ==queue&lt;int&gt; que;void bfs() &#123; t = (int)(log(n) / log(2)) + 1; que.push(1), dep[1] = 1; while (!que.empty()) &#123; int x = que.front(); que.pop(); for(int i = head[x]; i; i = nxt[i]) &#123; int y = ver[i]; if(dep[y]) continue; dep[y] = dep[x] + 1; f[y][0] = x; dist[y] = dist[x] + w[i]; _rep(k, 1, t) f[y][k] = f[f[y][k - 1]][k - 1]; que.push(y); &#125; &#125;&#125;// == bfs finished// == lca ==int lca(int x, int y) &#123; if(dep[x] &gt; dep[y]) swap(x, y); _forDown(k, t, 0) if(dep[f[y][k]] &gt;= dep[x]) y = f[y][k]; if(x == y) return x; _forDown(k, t, 0) if(f[x][k] != f[y][k]) &#123; x = f[x][k], y = f[y][k]; &#125; return f[x][0];&#125;// == lca finished ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;T); while (T--) &#123; init(); scanf(\"%d%d\", &amp;n, &amp;m); _for(i, 1, n) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); add(x, y, z); add(y, x, z); &#125; // == input finished == // bfs and lca bfs(); _rep(i, 1, m) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", dist[x] + dist[y] - 2 * dist[lca(x, y)]); &#125; &#125;&#125; 树上莫队SPOJCount on a tree II 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199const int maxn = 200200;int n, m, N;int a[maxn], buf[maxn];// == Graph structure ==int head[maxn], nxt[maxn], ver[maxn];int tot = 0;void init() &#123; Set(head, 0); Set(nxt, 0); Set(ver, 0); tot = 0;&#125;void add(int x, int y) &#123; ver[++tot] = y; nxt[tot] = head[x]; head[x] = tot;&#125;// == Graph structure finished ==// == discrete ==void discrete() &#123; sort(buf + 1, buf + 1 + n); N = unique(buf + 1, buf + 1 + n) - buf - 1; _rep(i, 1, n) a[i] = lower_bound(buf + 1, buf + 1 + N, a[i]) - buf;&#125;// == dicrete finsihed ==// == dfs order and lca ==int f[maxn][30], dep[maxn];int h = 0;int fst[maxn], lst[maxn];int ord[maxn], dfsn;void initdfs() &#123; Set(dep, 0); Set(fst, 0); Set(lst, 0); Set(ord, 0); dfsn = 0; dep[1] = 1; h = 20 + 5;&#125;void dfs(int x) &#123; assert(dep[1] == 1); ord[++dfsn] = x; fst[x] = dfsn; for(int i = head[x]; i; i = nxt[i]) &#123; int y = ver[i]; if(dep[y]) continue; dep[y] = dep[x] + 1; f[y][0] = x; _rep(k, 1, h) f[y][k] = f[f[y][k - 1]][k - 1]; dfs(y); &#125; ord[++dfsn] = x; lst[x] = dfsn;&#125;int LCA(int x, int y) &#123; if(dep[x] &gt; dep[y]) swap(x, y); _forDown(i, h, 0) if(dep[f[y][i]] &gt;= dep[x]) y = f[y][i]; if(x == y) return x; _forDown(i, h, 0) if(f[y][i] != f[x][i]) &#123; x = f[x][i], y = f[y][i]; &#125; return f[x][0];&#125;// == dfs order and lca finshed ==// == query and block ==class Qry &#123;public: int l, r, lca, id;&#125;;Qry qry[maxn];int belong[maxn];int sz, t;bool cmp(const Qry&amp; a, const Qry&amp; b) &#123; if(belong[a.l] ^ belong[b.l]) return belong[a.l] &lt; belong[b.l]; if(belong[a.l] &amp; 1) return a.r &lt; b.r; return a.r &gt; b.r;&#125;// [1, dfsn]void block() &#123; sz = sqrt(dfsn); t = dfsn / sz; _rep(i, 1, t) _rep(k, (i - 1) * sz + 1, i * sz) belong[k] = i; if(t * sz &lt; n) &#123; t++; _rep(k, (t - 1) * sz + 1, n) belong[k] = t; &#125;&#125;// == query and block finsihed ==// == Mo algorithm ==int CNT[maxn];int visMo[maxn];void initMo() &#123; Set(CNT, 0); Set(visMo, 0);&#125;inline void work(int pos, int&amp; ans) &#123; if(visMo[pos] == 0) if(++CNT[a[pos]] == 1) ans++; if(visMo[pos]) if(--CNT[a[pos]] == 0) ans--; visMo[pos] ^= 1;&#125;int ANS[maxn];int l = 1, r = 0, res = 0;void solve() &#123; sort(qry + 1, qry + 1 + m, cmp); _rep(i, 1, m) &#123; int ql = qry[i].l, qr = qry[i].r, qlca = qry[i].lca; // printf(\"%d %d\\n\", ql, qr); while (l &lt; ql) work(ord[l++], res); while (l &gt; ql) work(ord[--l], res); while (r &lt; qr) work(ord[++r], res); while (r &gt; qr) work(ord[r--], res); if(qlca) work(qlca, res); ANS[qry[i].id] = res; if(qlca) work(qlca, res); &#125;&#125;// == Mo;s algo finished ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); // == input data == scanf(\"%d%d\", &amp;n, &amp;m); _rep(i, 1, n) &#123; scanf(\"%d\", &amp;a[i]); buf[i] = a[i]; &#125; _for(i, 1, n) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); add(y, x); &#125; // == input finished == // == discrete == discrete(); // == discrete finished == // == get dfs order and lca == initdfs(); dfs(1); // == dfs order finished // == block query == // == block query finished == // == check the arr ord[] block(); _rep(i, 1, m) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); int lca = LCA(l, r); //debug(lca); if(fst[l] &gt; fst[r]) swap(l, r); qry[i].id = i; if(l == lca) &#123; qry[i].l = fst[l]; qry[i].r = fst[r]; &#125; else &#123; qry[i].l = lst[l]; qry[i].r = fst[r]; qry[i].lca = lca; &#125; &#125; // == Mo algorithm == initMo(); solve(); _rep(i, 1, m) printf(\"%d\\n\", ANS[i]);&#125; 回滚莫队BZOJ4241 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152const int maxn = 100000 + 10;const int maxb = 5000;int n, m, N;int a[maxn], typ[maxn], inp[maxn];class Qry &#123;public: int l, r, id;&#125;;Qry qry[maxn];// == discrete ==void discrete() &#123; sort(inp + 1, inp + 1 + n); N = unique(inp + 1, inp + 1 + n) - inp - 1; _rep(i, 1, n) typ[i] = lower_bound(inp + 1, inp + 1 + N, a[i]) - inp;&#125;// == discrete finished ==// == block ==int bl[maxn], br[maxn];int belong[maxn];int sz, t;void block() &#123; sz = sqrt(n); t = n / sz; _rep(i, 1, t) &#123; bl[i] = (i - 1) * sz + 1; br[i] = i * sz; _rep(k, bl[i], br[i]) belong[k] = i; &#125; if(t * sz &lt; n) &#123; t++; bl[t] = (t - 1) * sz + 1; br[t] = n; _rep(k, bl[t], br[t]) belong[k] = t; &#125;&#125;bool cmp(const Qry&amp; a, const Qry&amp; b) &#123; if(belong[a.l] ^ belong[b.l]) return belong[a.l] &lt; belong[b.l]; return a.r &lt; b.r;&#125;// == block finsihed ==int cnt[maxn];llong ANS[maxn];void initMo() &#123; Set(ANS, 0); Set(cnt, 0);&#125;llong force(int ql, int qr) &#123; llong res = 0; int tcnt[maxn]; _rep(i, ql, qr) tcnt[typ[i]] = 0; _rep(i, ql, qr) &#123; tcnt[typ[i]]++; res = max(res, (llong)1 * tcnt[typ[i]] * a[i]); //debug(res); &#125; return res;&#125;void solve() &#123; sort(qry + 1, qry + 1 + m, cmp); int i = 1; _rep(k, 1, t) &#123; int l = br[k] + 1, r = br[k]; Set(cnt, 0); llong res = 0; // brute force for seg in block for( ; belong[qry[i].l] == k; i++) &#123; int ql = qry[i].l, qr = qry[i].r; if(belong[ql] == belong[qr]) &#123; llong ans = force(ql, qr); ANS[qry[i].id] = ans; continue; &#125; llong fix = 0; while (r &lt; qr) &#123; r++; ++cnt[typ[r]]; res = max(res, (llong)1 * cnt[typ[r]] * a[r]); //debug(res); &#125; fix = res; while (l &gt; ql) &#123; l--; ++cnt[typ[l]]; res = max(res, (llong)1 * cnt[typ[l]] * a[l]); //debug(res); &#125; ANS[qry[i].id] = res; //debug(res); while (l &lt; br[k] + 1) &#123; --cnt[typ[l]]; ++l; &#125; res = fix; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); // == input == scanf(\"%d%d\", &amp;n, &amp;m); _rep(i, 1, n) &#123; scanf(\"%d\", &amp;a[i]); inp[i] = a[i]; &#125; _rep(i, 1, m) &#123; int _l, _r; scanf(\"%d%d\", &amp;_l, &amp;_r); qry[i].l = _l; qry[i].r = _r; qry[i].id = i; &#125; // == input finished == // == discrete == discrete(); // == discrete finished == // == block == block(); // == block finished == // == Mo Algorithm == initMo(); solve(); // == Mo Algo finished == _rep(i, 1, m) printf(\"%lld\\n\", ANS[i]);&#125; 莫队算法和树状数组值得注意的是，树状数组有以下几个特点1) 树状数组维护的一般是增量$d()$2) 或者是一个$val$出现的次数$in[]$ 提供的信息有：前缀和，以及单点修改其中，树状数组本身就表示局部和$C_{i} = A_{i - lowbit(i) + 1} + \\cdots + A_{i}$所以单点修改$A[i]$的时候，其实也是单点修改$C[i]$因为$A[i]$的变化会给$[i, i + lowbit(i), \\cdots, n]$ 带来变化，所以 123void add(int x, int d) &#123; while (x &lt;= n) C[x] += d, x += lowbit(x);&#125; 莫队算法和树状数组(二)LUOGU1972 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107const int maxn = 1000000 + 5;class Fwick &#123;public: vector&lt;int&gt; C; int n; void resize(int n) &#123; this-&gt;n = n; C.resize(n + 1); &#125; void clear() &#123; fill(C.begin(), C.end(), 0); &#125; int sum(int x) &#123; int ret = 0; while (x) &#123; ret += C[x]; x -= lowbit(x); &#125; return ret; &#125; void add(int x, int d) &#123; while (x &lt;= n) &#123; C[x] += d; x += lowbit(x); &#125; &#125; int find(int l, int r, int val) &#123; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(sum(mid) &lt; val) l = mid + 1; else r = mid; &#125; return l; &#125;&#125;;Fwick fwick;int A[maxn], N, vis[maxn];int ANS[maxn];int m;void init() &#123; Set(vis, 0); Set(ANS, 0);&#125;class Qry &#123;public: int l, r; int id; bool operator&lt; (const Qry&amp; rhs) const &#123; return r &lt; rhs.r; &#125;&#125;;Qry qry[maxn];void solve() &#123; _rep(i, 1, m) &#123; _rep(k, qry[i - 1].r + 1, qry[i].r) &#123; if(vis[A[k]]) fwick.add(vis[A[k]], -1); vis[A[k]] = k; fwick.add(vis[A[k]], 1); &#125; ANS[qry[i].id] = fwick.sum(qry[i].r) - fwick.sum(qry[i].l - 1); &#125; _rep(i, 1, m) printf(\"%d\\n\", ANS[i]);&#125;int main() &#123; freopen(\"./input.txt\", \"r\", stdin); init(); scanf(\"%d\", &amp;N); int maxv = 0; _rep(i, 1, N) &#123; scanf(\"%d\", &amp;A[i]); maxv = max(maxv, A[i]); &#125; fwick.resize(maxn); // == then input the query == scanf(\"%d\", &amp;m); _rep(i, 1, m) &#123; scanf(\"%d%d\", &amp;qry[i].l, &amp;qry[i].r); qry[i].id = i; &#125; sort(qry + 1, qry + 1 + m); // == then solve the problem == solve();&#125; 小z的袜子(代码优化)小z的袜子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115const int maxn = 50000 + 10;int n, m, A[maxn];// == block ==int belong[maxn], sz, t;void block() &#123; sz = sqrt(n); t = n / sz; _rep(i, 1, t) &#123; _rep(k, (i - 1) * sz + 1, i * sz) belong[k] = i; &#125; if(t * sz &lt; n) &#123; t++; _rep(k, (t - 1) * sz + 1, n) belong[k] = t; &#125;&#125;// == block finished ==inline llong gcd(llong a, llong b) &#123; return b ? gcd(b, a % b) : a;&#125;// == query structure ==class Qry &#123;public: int l, r; int id;&#125;;Qry qry[maxn];int cmp(const Qry&amp; a, const Qry&amp; b) &#123; if(belong[a.l] ^ belong[b.l]) return belong[a.l] &lt; belong[b.l]; if(belong[a.l] &amp; 1) return a.r &lt; b.r; return a.r &gt; b.r;&#125;// == query finished ==// == Mo algotithm ==llong num[maxn];void maintain(int x, int d, llong&amp; ans) &#123; ans -= num[x] * (num[x] - 1); num[x] += d; ans += num[x] * (num[x] - 1);&#125;llong ANS[maxn][2];void solve() &#123; int l = 1, r = 0; llong res = 0; _rep(i, 1, m) &#123; int ql = qry[i].l, qr = qry[i].r; if(ql == qr) &#123; ANS[qry[i].id][0] = 0; ANS[qry[i].id][1] = 1; continue; &#125; while (l &lt; ql) maintain(A[l++], -1, res); while (l &gt; ql) maintain(A[--l], 1, res); while (r &lt; qr) maintain(A[++r], 1, res); while (r &gt; qr) maintain(A[r--], -1, res); llong D = (llong)(qry[i].r - qry[i].l + 1) * (qry[i].r - qry[i].l); llong g = gcd(D, res); ANS[qry[i].id][0] = res; ANS[qry[i].id][1] = D; if(!g) ANS[qry[i].id][1] = 1; else &#123; ANS[qry[i].id][0] /= g; ANS[qry[i].id][1] /= g; &#125; &#125;&#125;// == Mo finished ==void init() &#123; Set(num, 0); Set(ANS, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); //freopen(\"output.txt\", \"w\", stdout); init(); // == get input == scanf(\"%d%d\", &amp;n, &amp;m); _rep(i, 1, n) scanf(\"%d\", &amp;A[i]); _rep(i, 1, m) &#123; scanf(\"%d%d\", &amp;qry[i].l, &amp;qry[i].r); qry[i].id = i; &#125; // == input finished == // == block == block(); // == block finsihed == // == solve the problem == sort(qry + 1, qry + 1 + m, cmp); solve(); _rep(i, 1, m) printf(\"%lld/%lld\\n\", ANS[i][0], ANS[i][1]);&#125; 区间众数的莫队算法(二)有时候我们不需要求出众数是多少而只需要知道，出现次数最多的那个数，出现了多少次","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"datastructure","slug":"datastructure","permalink":"https://www.fogsail.net/tags/datastructure/"}]},{"title":"嵌套和分块数据结构","slug":"20191210","date":"2019-12-10T06:12:47.000Z","updated":"2020-04-26T12:23:19.900Z","comments":true,"path":"2019/12/10/20191210/","link":"","permalink":"https://www.fogsail.net/2019/12/10/20191210/","excerpt":"本节内容介绍了一些嵌套的数据结构以及常用的算法思想包括离线分治，点分治，分块数据结构等等","text":"本节内容介绍了一些嵌套的数据结构以及常用的算法思想包括离线分治，点分治，分块数据结构等等 分块POJ3468 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103const int maxn = 100000 + 5;int n, m;llong a[maxn];int t;int pos[maxn];llong add[maxn], sum[maxn];// add[i] is tot segment[i] is added dvoid init() &#123; Set(pos, 0); Set(add, 0); Set(sum, 0);&#125;class Seg &#123;public: int l, r;&#125; seg[maxn];inline void cal() &#123; t = sqrt(n); _rep(i, 1, t) &#123; seg[i].l = (i - 1) * sqrt(n) + 1; seg[i].r = i * sqrt(n); &#125; if(seg[t].r &lt; n) &#123; t++; seg[t].l = seg[t - 1].r + 1; seg[t].r = n; &#125; _rep(i, 1, t) &#123; _rep(k, seg[i].l, seg[i].r) &#123; pos[k] = i; sum[i] += a[k]; &#125; &#125;&#125;void change(int l, int r, llong d) &#123; int p = pos[l], q = pos[r]; if(p == q) &#123; _rep(i, l, r) a[i] += d; sum[p] += d * (r - l + 1); &#125; else &#123; _rep(i, p + 1, q - 1) add[i] += d; _rep(i, l, seg[p].r) a[i] += d; sum[p] += d * (seg[p].r - l + 1); _rep(i, seg[q].l, r) a[i] += d; sum[q] += d * (r - seg[q].l + 1); &#125;&#125;llong ask(int l, int r) &#123; int p = pos[l], q = pos[r]; llong ans = 0; if(p == q) &#123; _rep(i, l, r) ans += a[i]; ans += add[p] * (r - l + 1); &#125; else &#123; _rep(i, p + 1, q - 1) &#123; ans += sum[i] + add[i] * (seg[i].r - seg[i].l + 1); &#125; _rep(i, l, seg[p].r) ans += a[i]; ans += add[p] * (seg[p].r - l + 1); _rep(i, seg[q].l, r) ans += a[i]; ans += add[q] * (r - seg[q].l + 1); &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); cin &gt;&gt; n &gt;&gt; m; _rep(i, 1, n) scanf(\"%lld\", &amp;a[i]); // init calculate cal(); while (m--) &#123; char op[3]; int l, r, d; scanf(\"%s\", op); scanf(\"%d%d\", &amp;l, &amp;r); if(op[0] == 'C') &#123; scanf(\"%d\", &amp;d); change(l, r, d); &#125; else printf(\"%lld\\n\", ask(l, r)); &#125;&#125; 分块解决区间众数BZOJ2724 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150const int maxn = 40000 + 5;const int T = 800 + 5;int f[T][T];int n, m, t;int a[maxn], b[maxn];int ct[maxn];vector&lt;int&gt; show[maxn];map&lt;int, int&gt; loc;class Seg &#123;public: int l, r;&#125;;Seg seg[maxn];int pos[maxn];void init() &#123; Set(pos, 0); Set(f, 0); _for(i, 0, maxn) show[i].clear(); Set(ct, 0); loc.clear();&#125;void discrete() &#123; sort(b + 1, b + 1 + n); int tot = unique(b + 1, b + 1 + n) - b - 1; _rep(i, 1, n) &#123; a[i] = lower_bound(b + 1, b + 1 + tot, a[i]) - b; show[a[i]].push_back(i); &#125;&#125;void split(const int len) &#123; _rep(i, 1, t) &#123; seg[i].l = (i - 1) * len + 1; seg[i].r = i * len; &#125; if(seg[t].r &lt; n) &#123; t++; seg[t].l = seg[t - 1].r + 1; seg[t].r = n; &#125; _rep(i, 1, n) &#123; _rep(j, seg[i].l, seg[i].r) pos[j] = i; &#125;&#125;inline void cal() &#123; _rep(i, 1, t) &#123; int ans = 0, cnt = 0; Set(ct, 0); _rep(j, seg[i].l, n) &#123; ct[a[j]]++; if(cnt &lt; ct[a[j]] || (cnt == ct[a[j]] &amp;&amp; a[j] &lt; ans)) &#123; cnt = ct[a[j]]; ans = a[j]; &#125; f[i][pos[j]] = ans; &#125; &#125;&#125;int count(int x, int l, int r) &#123; return upper_bound(show[x].begin(), show[x].end(), r) - lower_bound(show[x].begin(), show[x].end(), l);&#125;void update(int x, int l, int r, int &amp;ans, int &amp;cnt) &#123; int c = count(x, l, r); if(c &gt; cnt || (c == cnt &amp;&amp; x &lt; ans)) &#123; cnt = c; ans = x; &#125;&#125;int ask(int l, int r) &#123; int p = pos[l], q = pos[r]; int ans = 0, cnt = 0; if(p == q) &#123; _rep(i, l, r) update(a[i], l, r, ans, cnt); return b[ans]; &#125; int x = 0, y = 0; if(p + 1 &lt;= q - 1) &#123; x = p + 1; y = q - 1; &#125; _rep(i, l, seg[p].r) update(a[i], l, r, ans, cnt); _rep(i, seg[q].l, r) update(a[i], l, r, ans, cnt); if(f[x][y]) update(f[x][y], l, r, ans, cnt); //debug(ans); return b[ans];&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); cin &gt;&gt; n &gt;&gt; m; _rep(i, 1, n) scanf(\"%d\", &amp;a[i]); Cpy(b, a); // == discrete == discrete(); // == discrete finished == // == part == t = sqrt(n * log(n) / log(2)); int len = t ? n / t : n; // == split == split(len); // == split finished == // == calculate f() == cal(); // == f() finished== // == main algorithm == int res = 0; while (m--) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); l = (l + res - 1) % n + 1; r = (r + res - 1) % n + 1; //debug(l), debug(r); if(l &gt; r) swap(l, r); res = ask(l, r); printf(\"%d\\n\", res); &#125;&#125; 多变量分块Acwing250 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118const int maxn = 250000 + 5;int n, t;class Magnet &#123;public: int x, y, m, p, r;&#125;;Magnet P[maxn];queue&lt;Magnet&gt; que;int vis[maxn];Magnet st;int cnt = 0;void init() &#123; Set(vis, 0); cnt = 0;&#125;bool cmp(Magnet lhs, Magnet rhs) &#123; return lhs.m &lt; rhs.m;&#125;bool cmp2(Magnet a, Magnet b) &#123; return (llong)(a.x - st.x) * (a.x - st.x) + (llong)(a.y - st.y) * (a.y - st.y) &lt; (llong)(b.x - st.x) * (b.x - st.x) + (llong)(b.y - st.y) * (b.y - st.y);&#125;bool attr(Magnet a, Magnet b) &#123; return (llong)(b.x - st.x) * (b.x - st.x) + (llong)(b.y - st.y) * (b.y - st.y) &lt;= (llong)a.r * a.r;&#125;class Seg &#123;public: int l, r, M;&#125;;Seg seg[maxn];void cal() &#123; sort(P + 1, P + 1 + n, cmp); t = sqrt(n); _rep(i, 1, t) &#123; seg[i].l = (i - 1) * t + 1; seg[i].r = i * t; seg[i].M = P[seg[i].r].m; sort(P + seg[i].l, P + seg[i].r + 1, cmp2); &#125; if(seg[t].r &lt; n) &#123; t++; seg[t].l = seg[t - 1].r + 1; seg[t].r = n; seg[t].M = P[n].m; sort(P + seg[t].l, P + seg[t].r + 1, cmp2); &#125;&#125;void bfs() &#123; que.push(st); cnt = 1; while (!que.empty()) &#123; Magnet cur = que.front(); que.pop(); int k = 0; _rep(i, 1, t) &#123; if(seg[i].M &lt;= cur.p) k = i; else break; &#125; _rep(i, 1, k) &#123; while (seg[i].l &lt;= seg[i].r &amp;&amp; attr(cur, P[seg[i].l])) &#123; // check attr, and push if(!vis[seg[i].l]) &#123; vis[seg[i].l] = 1; que.push(P[seg[i].l]); cnt++; &#125; seg[i].l++; &#125; &#125; if(k != t) &#123; k++; _rep(i, seg[k].l, seg[k].r) &#123; if(!vis[i] &amp;&amp; P[i].m &lt;= cur.p &amp;&amp; attr(cur, P[i])) &#123; vis[i] = 1; que.push(P[i]); cnt++; &#125; &#125; &#125; &#125; cout &lt;&lt; cnt - 1 &lt;&lt; endl;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); cin &gt;&gt; st.x &gt;&gt; st.y &gt;&gt; st.p &gt;&gt; st.r &gt;&gt; n; _rep(i, 1, n) scanf(\"%d %d %d %d %d\", &amp;P[i].x, &amp;P[i].y, &amp;P[i].m, &amp;P[i].p, &amp;P[i].r); // == split into block cal(); // == split into block finished // == bfs bfs(); // == bfs finished&#125; 莫队算法莫队算法模版排序和分块 123456789101112131415161718bool cmp(const Qry&amp; a, const Qry&amp; b) &#123; if(belong[a.l] ^ belong[b.l]) return belong[a.l] &lt; belong[b.l]; if(belong[a.l] &amp; 1) return a.r &lt; b.r; return a.r &gt; b.r;&#125;void block() &#123; sz = sqrt(1.0 * n); t = n / sz; _rep(i, 1, t) _rep(k, (i - 1) * sz + 1, i * sz) &#123; belong[k] = i; &#125; if(t * sz &lt; n) &#123; t++; _rep(k, (t - 1) * sz + 1, n) belong[k] = t; &#125;&#125; Mo’s Algorithm主过程 123456789101112131415161718192021222324inline void add(int x, int&amp; ans) &#123; if(++num[x] == 1) ans++;&#125;inline void del(int x, int&amp; ans) &#123; if(--num[x] == 0) ans--;&#125;void solve() &#123; sort(qry + 1, qry + 1 + m, cmp); Set(num, 0); tans = 0; int l = 1, r = 0; _rep(i, 1, m) &#123; while (l &lt; qry[i].l) del(A[l++], tans); while (l &gt; qry[i].l) add(A[--l], tans); while (r &lt; qry[i].r) add(A[++r], tans); while (r &gt; qry[i].r) del(A[r--], tans); ANS[qry[i].id] = tans; &#125;&#125; 离线莫队(不带修改)有名的袜子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139const int maxn = 50000 + 10;int n, m, t;int color[maxn];llong Ans[maxn][2];class Q &#123;public: int l, r, id;&#125;;Q qry[maxn];class Blk &#123;public: int L, R;&#125;;Blk blk[maxn];bool cmp1(const Q&amp; lhs, const Q&amp; rhs) &#123; return lhs.l &lt; rhs.l || (lhs.l == rhs.l &amp;&amp; lhs.r &lt; rhs.r);&#125;bool cmp2(const Q&amp; lhs, const Q&amp; rhs) &#123; return lhs.r &lt; rhs.r;&#125;void block() &#123; sort(qry + 1, qry + 1 + m, cmp1); t = sqrt(m); _rep(i, 1, t) &#123; blk[i].L = (i - 1) * t + 1; blk[i].R = i * t; &#125; if(blk[t].R &lt; n) &#123; t++; blk[t].L = blk[t - 1].R + 1; blk[t].R = n; &#125;&#125;// == then solve the problem ==inline llong gcd(llong a, llong b) &#123; return b ? gcd(b, a % b) : a;&#125;int num[maxn];llong tans = 0;// tans used for temp ans in the blockvoid initBlk(int i) &#123; tans = 0; Set(num, 0); sort(qry + blk[i].L, qry + blk[i].R + 1, cmp2);&#125;void maintain(int x, int d, llong&amp; tans) &#123; tans -= num[x] * (num[x] - 1); num[x] += d; tans += num[x] * (num[x] - 1);&#125;void solve() &#123; _rep(i, 1, t) &#123; initBlk(i); // brute force for the first elem int l = qry[blk[i].L].l, r = qry[blk[i].L].r; _rep(k, l, r) maintain(color[k], 1, tans); int qid = blk[i].L; Ans[qry[qid].id][0] = tans; Ans[qry[qid].id][1] = (llong)(r - l + 1) * (r - l); int g = gcd(Ans[qry[qid].id][0], Ans[qry[qid].id][1]); if(g == 0) Ans[qry[qid].id][1] = 1; else &#123; Ans[qry[qid].id][0] /= g; Ans[qry[qid].id][1] /= g; &#125; // then get [blk[i].L + 1, blk[i].R] by recursion _rep(k, blk[i].L + 1, blk[i].R) &#123; // now qid = k; while (r &lt; qry[k].r) maintain(color[++r], 1, tans); while (r &gt; qry[k].r) maintain(color[r--], -1, tans); while (l &lt; qry[k].l) maintain(color[l++], -1, tans); while (l &gt; qry[k].l) maintain(color[--l], 1, tans); if(qry[k].l == qry[k].r) &#123; Ans[qry[k].id][0] = 0; Ans[qry[k].id][1] = 1; &#125; else &#123; Ans[qry[k].id][0] = tans; Ans[qry[k].id][1] = (llong)(qry[k].r - qry[k].l + 1) * (qry[k].r - qry[k].l); int g = gcd(Ans[qry[k].id][0], Ans[qry[k].id][1]); if(!g) Ans[qry[k].id][1] = 1; else &#123; Ans[qry[k].id][0] /= g; Ans[qry[k].id][1] /= g; &#125; &#125; &#125; &#125;&#125;// === solve finished ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); Set(Ans, 0); cin &gt;&gt; n &gt;&gt; m; _rep(i, 1, n) scanf(\"%d\", &amp;color[i]); _rep(i, 1, m) &#123; scanf(\"%d%d\", &amp;qry[i].l, &amp;qry[i].r); qry[i].id = i; &#125; // == input finished== // === then split query into block == block(); // === blocked === // == then query in each blocked sorted by cmp2 solve(); // === sorted finished _rep(i, 1, m) &#123; printf(\"%lld/%lld\\n\", Ans[i][0], Ans[i][1]); &#125;&#125; 不带修改的离线莫队，有时候需要一下两个函数往往在查询固定区间$[l, r]$中有多少个不同元素的时候，需要用到 12345678910int num[maxn];llong cnt;inline void add(int p, int&amp; ans) &#123; if(++num[A[p]] == 1) ans++;&#125;inline void rmv(int p, int&amp; ans) &#123; if(--num[A[p]] == 0) ans--;&#125; 带修改莫队BZOJ2120 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139const int maxn = 1000000 + 5;int n, m, t, sz;int CNT[maxn];int clr[maxn];int cntq = 0, cntc = 0;int ANS[maxn];void init() &#123; cntq = cntc = 0;&#125;class Query &#123;public: int l, r, id, time;&#125;;Query qry[maxn];inline void add(int x, int&amp; ans) &#123; if(++CNT[x] == 1) ans++;&#125;inline void del(int x, int&amp; ans) &#123; if(--CNT[x] == 0) ans--;&#125;// == init block ==int tans = 0;void initBlk() &#123; tans = 0;&#125;// == init block finished ==class Modify &#123;public: int pos, curC; void apply(int curL, int curR) &#123; if(curL &lt;= pos &amp;&amp; pos &lt;= curR) &#123; int oldC = clr[pos]; del(oldC, tans); add(curC, tans); &#125; swap(curC, clr[pos]); &#125;&#125;;Modify mdfy[maxn];// === block() by n ===int belong[maxn];void block() &#123; Set(belong, 0); sz = pow(n, 2.0 / 3.0); t = n / sz; _rep(i, 1, t) &#123; _rep(k, (i - 1) * sz + 1, i * sz) belong[k] = i; &#125; if(t * sz &lt; n) &#123; t++; _rep(k, (t - 1) * sz + 1, n) belong[k] = t; &#125; // debug(t);&#125;// == solve() ==bool cmp(const Query&amp; a, const Query&amp; b) &#123; if(belong[a.l] ^ belong[b.l]) return belong[a.l] &lt; belong[b.l]; if(belong[a.r] ^ belong[b.r]) return belong[a.r] &lt; belong[b.r]; return a.time &lt; b.time;&#125;void solve() &#123; sort(qry + 1, qry + 1 + cntq, cmp); initBlk(); assert(tans == 0); // get started ptime and [l, r] int ptime = 0, l = 0, r = 0; // then expand to other query by recursion _rep(i, 1, cntq) &#123; int ql = qry[i].l, qr = qry[i].r, qt = qry[i].time; while (l &lt; ql) del(clr[l++], tans); while (l &gt; ql) add(clr[--l], tans); while (r &lt; qr) add(clr[++r], tans); while (r &gt; qr) del(clr[r--], tans); while (ptime &lt; qt) mdfy[++ptime].apply(l, r); while (ptime &gt; qt) mdfy[ptime--].apply(l, r); ANS[qry[i].id] = tans; //debug(clr[1]); &#125;&#125;// == solve fnished ==// === block() finished ===int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); // == input == scanf(\"%d%d\", &amp;n, &amp;m); _rep(i, 1, n) &#123; scanf(\"%d\", &amp;clr[i]); &#125; assert(cntq == 0 &amp;&amp; cntc == 0); _rep(i, 1, m) &#123; char op[2]; scanf(\"%s\", op); if(op[0] == 'Q') &#123; Query&amp; curq = qry[++cntq]; scanf(\"%d%d\", &amp;curq.l, &amp;curq.r); curq.id = cntq; curq.time = cntc; //debug(curq.time); &#125; else &#123; Modify&amp; md = mdfy[++cntc]; scanf(\"%d%d\", &amp;md.pos, &amp;md.curC); // mdfy[] as a tag, we not really change here &#125; &#125; // == input finished == // == block == block(); // == block finished == solve(); _rep(i, 1, cntq) printf(\"%d\\n\", ANS[i]);&#125; 区间众数莫队处理Acwing249 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149const int maxn = 40000 + 10;const int maxt = 35 + 5;class Mode &#123;public: int CNT, pos; void clear() &#123; CNT = pos = 0; &#125;&#125;;Mode f[maxt][maxt], cur;int belong[maxn], c[maxt][maxt][maxn];void init() &#123; Set(belong, 0); Set(c, 0);&#125;int a[maxn], buf[maxn];int n, m, tot, t, sz;void discrete() &#123; Cpy(buf, a); sort(buf + 1, buf + 1 + n); tot = unique(buf + 1, buf + 1 + n) - buf - 1; _rep(i, 1, n) &#123; a[i] = lower_bound(buf + 1, buf + 1 + tot, a[i]) - buf; &#125;&#125;// == block ==class Blk &#123;public: int L, R;&#125;;Blk blk[maxn];void block() &#123; t = pow((double)n, 1.0 / 3.0); sz = t ? n / t : n; _rep(i, 1, t) &#123; blk[i].L = (i - 1) * sz + 1; blk[i].R = i * sz; &#125; if(blk[t].R &lt; n) &#123; t++; blk[t].L = blk[t - 1].R + 1; blk[t].R = n; &#125; _rep(i, 1, t) _rep(k, blk[i].L, blk[i].R) &#123; belong[k] = i; &#125;&#125;// == blocked finished ==// == init seg ==void initseg() &#123; cur.clear(); _for(i, 0, maxt) _for(j, 0, maxt) f[i][j].clear(); _rep(i, 1, t) _rep(j, i, t) &#123; _rep(k, blk[i].L, blk[j].R) &#123; ++c[i][j][a[k]]; &#125; _rep(x, 1, tot) &#123; if(f[i][j].CNT &lt; c[i][j][x]) &#123; f[i][j].CNT = c[i][j][x]; f[i][j].pos = x; &#125; &#125; &#125;&#125;// == init seg finished ==inline void maintain(int x, int y, int val) &#123; ++c[x][y][val]; if(c[x][y][val] &gt; cur.CNT || (c[x][y][val] == cur.CNT &amp;&amp; val &lt; cur.pos)) &#123; cur.CNT = c[x][y][val]; cur.pos = val; &#125;&#125;// == query ==int query(int l, int r) &#123; int p = belong[l], q = belong[r]; int x = 0, y = 0; if(p + 1 &lt;= q - 1) &#123; x = p + 1; y = q - 1; &#125; cur = f[x][y]; if(p == q) &#123; // at the same block _rep(i, l, r) maintain(x, y, a[i]); _rep(i, l, r) --c[x][y][a[i]]; &#125; else &#123; _rep(i, l, blk[p].R) maintain(x, y, a[i]); _rep(i, blk[q].L, r) maintain(x, y, a[i]); _rep(i, l, blk[p].R) --c[x][y][a[i]]; _rep(i, blk[q].L, r) --c[x][y][a[i]]; &#125; return buf[cur.pos];&#125;// == query finished ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); // == input == cin &gt;&gt; n &gt;&gt; m; _rep(i, 1, n) scanf(\"%d\", &amp;a[i]); // == input finished == // == discrete == discrete(); // == discrete finished == // == block == block(); // == block finished == // == then init Segment == initseg(); // == init segment finished == // == then solve() == int x = 0; while (m--) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); l = (l + x - 1) % n + 1; r = (r + x - 1) % n + 1; if(l &gt; r) swap(l, r); x = query(l, r); printf(\"%d\\n\", x); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"datastructure","slug":"datastructure","permalink":"https://www.fogsail.net/tags/datastructure/"}]},{"title":"实用数据结构(四)","slug":"20191129","date":"2019-11-29T04:56:23.000Z","updated":"2019-12-22T10:16:42.516Z","comments":true,"path":"2019/11/29/20191129/","link":"","permalink":"https://www.fogsail.net/2019/11/29/20191129/","excerpt":"本节内容主要针对一些数据结构进行优化包括线段树延迟标记，扫描线","text":"本节内容主要针对一些数据结构进行优化包括线段树延迟标记，扫描线 线段树延迟标记POJ3468 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const int maxn = 100000 + 10;int A[maxn], n, m;class segTree &#123;public: int l, r; llong sum, tag;#define l(x) tree[x].l#define r(x) tree[x].r#define sum(x) tree[x].sum#define tag(x) tree[x].tag&#125; tree[maxn * 4];void build(int p, int l, int r) &#123; l(p) = l, r(p) = r; //debug(p); if(l == r) &#123; sum(p) = A[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r); sum(p) = sum(p &lt;&lt; 1) + sum(p &lt;&lt; 1 | 1);&#125;void spread(int p) &#123; if(tag(p)) &#123; sum(p &lt;&lt; 1) += tag(p) * (r(p&lt;&lt;1) - l(p&lt;&lt;1) + 1); sum(p &lt;&lt; 1 | 1) += tag(p) * (r(p&lt;&lt;1 | 1) - l(p&lt;&lt;1 | 1) + 1); tag(p &lt;&lt; 1) += tag(p); tag(p &lt;&lt; 1 | 1) += tag(p); tag(p) = 0; &#125;&#125;void change(int p, int l, int r, int d) &#123; if(l &lt;= l(p) &amp;&amp; r(p) &lt;= r) &#123; sum(p) += (llong)d * (r(p) - l(p) + 1); tag(p) += d; return; &#125; spread(p); int mid = (l(p) + r(p)) &gt;&gt; 1; if(l &lt;= mid) change(p&lt;&lt;1, l, r, d); if(r &gt; mid) change(p&lt;&lt;1 | 1, l, r, d); sum(p) = sum(p&lt;&lt;1) + sum(p&lt;&lt;1 | 1);&#125;llong ask(int p, int l, int r) &#123; if(l &lt;= l(p) &amp;&amp; r(p) &lt;= r) return sum(p); spread(p); int mid = (l(p) + r(p)) &gt;&gt; 1; llong val = 0; if(l &lt;= mid) val += ask(p&lt;&lt;1, l, r); if(r &gt; mid) val += ask(p&lt;&lt;1 | 1, l, r); return val;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m; _rep(i, 1, n) scanf(\"%d\", &amp;A[i]); build(1, 1, n); while (m--) &#123; char op[2]; int l, r; scanf(\"%s%d%d\", op, &amp;l, &amp;r); if(op[0] == 'C') &#123; int d; scanf(\"%d\", &amp;d); change(1, l, r, d); &#125; else printf(\"%lld\\n\", ask(1, l, r)); &#125;&#125; 线段树多延迟标记UVA11992 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167const int maxn = 1e6 + 5;const int inf = 1e9 + 1;int r, c, m;const int maxr = 20 + 5;int Min = inf, Max = -inf, Sum = 0;void initQry() &#123; Min = inf; Max = -inf; Sum = 0;&#125;class segTree &#123;public: int l, r; int sum, maxv, minv; int tagAdd, tagSet;#define l(x) tree[x].l#define r(x) tree[x].r#define sum(x) tree[x].sum#define maxv(x) tree[x].maxv#define minv(x) tree[x].minv#define tagAdd(x) tree[x].tagAdd#define tagSet(x) tree[x].tagSet void clear() &#123; l = r = 0; sum = maxv = minv = 0; tagAdd = 0; tagSet = -1; &#125;&#125; tree[maxn * 4];void spread(int p) &#123; if(tagSet(p) &gt;= 0) &#123; tagSet(p &lt;&lt; 1) = tagSet(p &lt;&lt; 1 | 1) = tagSet(p); tagAdd(p &lt;&lt; 1) = tagAdd(p &lt;&lt; 1 | 1) = 0; maxv(p &lt;&lt; 1) = maxv(p &lt;&lt; 1 | 1) = tagSet(p); minv(p &lt;&lt; 1) = minv(p &lt;&lt; 1 | 1) = tagSet(p); sum(p &lt;&lt; 1) = tagSet(p) * (r(p &lt;&lt; 1) - l(p &lt;&lt; 1) + 1); sum(p &lt;&lt; 1 | 1) = tagSet(p) * (r(p &lt;&lt; 1 | 1) - l(p &lt;&lt; 1 | 1) + 1); tagSet(p) = -1; &#125; if(tagAdd(p) &gt; 0) &#123; tagAdd(p &lt;&lt; 1) += tagAdd(p); tagAdd(p &lt;&lt; 1 | 1) += tagAdd(p); maxv(p &lt;&lt; 1) += tagAdd(p); maxv(p &lt;&lt; 1 | 1) += tagAdd(p); minv(p &lt;&lt; 1) += tagAdd(p); minv(p &lt;&lt; 1 | 1) += tagAdd(p); sum(p &lt;&lt; 1) += tagAdd(p) * (r(p &lt;&lt; 1) - l(p &lt;&lt; 1) + 1); sum(p &lt;&lt; 1 | 1 ) += tagAdd(p) * (r(p &lt;&lt; 1 | 1) - l(p &lt;&lt; 1 | 1) + 1); tagAdd(p) = 0; &#125;&#125;void update(int p) &#123; sum(p) = sum(p &lt;&lt; 1) + sum(p &lt;&lt; 1 | 1); maxv(p) = max(maxv(p &lt;&lt; 1), maxv(p &lt;&lt; 1 | 1)); minv(p) = min(minv(p &lt;&lt; 1), minv(p &lt;&lt; 1 | 1));&#125;void build(int p, int l, int r) &#123; l(p) = l, r(p) = r; sum(p) = 0; maxv(p) = minv(p) = 0; tagAdd(p) = 0; tagSet(p) = -1; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r);&#125;void opSet(int p, int l, int r, int v) &#123; if(l &lt;= l(p) &amp;&amp; r(p) &lt;= r) &#123; sum(p) = v * (r(p) - l(p) + 1); maxv(p) = minv(p) = v; tagSet(p) = v; tagAdd(p) = 0; return; &#125; spread(p); int mid = (l(p) + r(p)) &gt;&gt; 1; if(l &lt;= mid) opSet(p &lt;&lt; 1, l, r, v); if(r &gt; mid) opSet(p &lt;&lt; 1 | 1, l, r, v); update(p);&#125;void opAdd(int p, int l, int r, int v) &#123; if(l &lt;= l(p) &amp;&amp; r(p) &lt;= r) &#123; sum(p) += v * (r(p) - l(p) + 1); maxv(p) += v; minv(p) += v; tagAdd(p) += v; return; &#125; spread(p); int mid = (l(p) + r(p)) &gt;&gt; 1; if(l &lt;= mid) opAdd(p &lt;&lt; 1, l, r, v); if(r &gt; mid) opAdd(p &lt;&lt; 1 | 1, l, r, v); update(p);&#125;void query(int p, int l, int r) &#123; if(l &lt;= l(p) &amp;&amp; r(p) &lt;= r) &#123; Sum += sum(p); Min = min(Min, minv(p)); Max = max(Max, maxv(p)); return; &#125; spread(p); int mid = (l(p) + r(p)) &gt;&gt; 1; if(l &lt;= mid) query(p &lt;&lt; 1, l, r); if(r &gt; mid) query(p &lt;&lt; 1 | 1, l, r); update(p);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d%d\", &amp;r, &amp;c, &amp;m) == 3) &#123; int op, x1, x2, y1, y2, v; build(1, 1, r * c); while (m--) &#123; scanf(\"%d\", &amp;op); if(op == 1) &#123; scanf(\"%d%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;v); _rep(i, x1, x2) &#123; opAdd(1, (i - 1) * c + y1, (i - 1) * c + y2, v); &#125; &#125; if(op == 2) &#123; scanf(\"%d%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;v); _rep(i, x1, x2) &#123; opSet(1, (i - 1) * c + y1, (i - 1) * c + y2, v); &#125; &#125; if(op == 3) &#123; scanf(\"%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); initQry(); _rep(i, x1, x2) &#123; query(1, (i - 1) * c + y1, (i - 1) * c + y2); &#125; printf(\"%d %d %d\\n\", Sum, Min, Max); &#125; &#125; &#125;&#125; 扫描线POJ1151 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596const int maxn = 100 + 5;int N, m;int kase = 0;class Node &#123;public: double x, y1, y2; int k; bool operator&lt; (const Node&amp; rhs) const &#123; return x &lt; rhs.x; &#125;&#125;;Node A[maxn &lt;&lt; 1];map&lt;double, int&gt; ny;double raw[maxn &lt;&lt; 1];void init() &#123; Set(raw, 0); ny.clear();&#125;void dicrete() &#123; sort(raw + 1, raw + 1 + N); m = unique(raw + 1, raw + 1 + N) - (raw + 1); _rep(i, 1, m) ny[raw[i]] = i;&#125;class Tree &#123;public: int l, r, cnt; double len;#define l(x) tree[x].l#define r(x) tree[x].r#define cnt(x) tree[x].cnt#define len(x) tree[x].len&#125; tree[maxn &lt;&lt; 3];void build(int p, int l, int r) &#123; l(p) = l; r(p) = r; len(p) = 0; cnt(p) = 0; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r);&#125;void change(int p, int l, int r, int d) &#123; if(l &lt;= l(p) &amp;&amp; r(p) &lt;= r) len(p) = ((cnt(p) += d) ? raw[r(p)+1] - raw[l(p)] : 0); if(l(p) == r(p)) return; int mid = (l(p) + r(p)) &gt;&gt; 1; if(l &lt;= mid) change(p &lt;&lt; 1, l, r, d); if(r &gt; mid) change(p &lt;&lt; 1 | 1, l, r, d); len(p) = (cnt(p) ? raw[r(p)+1] - raw[l(p)] : len(p&lt;&lt;1) + len(p&lt;&lt;1 | 1));&#125;double atlantis() &#123; sort(A + 1, A + 1 + N); build(1, 1, m - 1); // use subscribe to build seg tree double ans = 0; // scan line _for(i, 1, N) &#123; int y1 = ny[A[i].y1], y2 = ny[A[i].y2] - 1; change(1, y1, y2, A[i].k); ans += len(1) * (A[i + 1].x - A[i].x); &#125; printf(\"Test case #%d\\nTotal explored area: %.2f\\n\\n\", ++kase, ans);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (cin &gt;&gt; N &amp;&amp; N) &#123; init(); _rep(i, 1, N) &#123; int k = i &lt;&lt; 1; double y1, y2; scanf(\"%lf %lf %lf %lf\", &amp;A[k-1].x, &amp;y1, &amp;A[k].x, &amp;y2); raw[k-1] = A[k-1].y1 = A[k].y1 = y1; raw[k] = A[k-1].y2 = A[k].y2 = y2; A[k-1].k = 1; A[k].k = -1; &#125; N &lt;&lt;= 1; // discrete() // oldY --ny()--&gt; newY, raw[1-m]--&gt; oldY dicrete(); atlantis(); &#125;&#125; 扫描线周长问题扫描线处理周长问题更为复杂POJ1177 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126const int maxn = 5000 + 6;const int maxv = 20000 + 7;const int inf = 0x3f3f3f3f;int n, tot;int Max = -inf, Min = inf;void init() &#123; tot = 0; Max = -inf; Min = inf;&#125;class L &#123;public: int x1, x2; int y; int st; bool operator&lt; (const L&amp; rhs) const &#123; return y &lt; rhs.y; &#125;&#125;;L a[maxn &lt;&lt; 1];class segTree&#123;public: int l, r; bool lc, rc; int len; int cover; int cnt; // cnt: cover by discrete segment&#125; t[maxv &lt;&lt; 2];void build(int p, int l, int r) &#123; t[p].l = l; t[p].r = r; t[p].lc = t[p].rc = 0; t[p].len = t[p].cnt = t[p].cover = 0; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r);&#125;void check(int p) &#123; if(t[p].cover) &#123; t[p].len = t[p].r + 1 - t[p].l; t[p].lc = t[p].rc = 1; t[p].cnt = 1; &#125; else if(t[p].l == t[p].r) &#123; t[p].len = 0; t[p].lc = t[p].rc = 0; t[p].cnt = 0; &#125; else &#123; t[p].len = t[p&lt;&lt;1].len + t[p&lt;&lt;1 | 1].len; t[p].cnt = t[p&lt;&lt;1].cnt + t[p&lt;&lt;1 | 1].cnt; t[p].lc = t[p&lt;&lt;1].lc; t[p].rc = t[p&lt;&lt;1 | 1].rc; if(t[p&lt;&lt;1].rc &amp;&amp; t[p&lt;&lt;1 | 1].lc) t[p].cnt--; &#125;&#125;void change(int p, int l, int r, int d) &#123; if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123; t[p].cover += d; check(p); return; &#125; int mid = (t[p].l + t[p].r) &gt;&gt; 1; if(r &lt;= mid) change(p &lt;&lt; 1, l, r, d); else if(l &gt; mid) change(p &lt;&lt; 1 | 1, l, r, d); else &#123; change(p &lt;&lt; 1, l, mid, d); change(p &lt;&lt; 1 | 1, mid + 1, r, d); &#125; check(p);&#125;void picture() &#123; sort(a, a + tot); build(1, Min, Max - 1); int ans = 0, preOverlap = 0; _for(i, 0, tot) &#123; change(1, a[i].x1, a[i].x2 - 1, a[i].st); ans += abs(preOverlap - t[1].len); ans += 2 * t[1].cnt * (a[i + 1].y - a[i].y); preOverlap = t[1].len; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;n); init(); int x1, y1, x2, y2; _for(i, 0, n) &#123; scanf(\"%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); Max = max(Max, max(x1, x2)); Min = min(Min, min(x1, x2)); L&amp; a1 = a[tot]; L&amp; a2 = a[tot + 1]; a1.x1 = a2.x1 = x1; a1.x2 = a2.x2 = x2; a1.y = y1; a2.y = y2; a1.st = 1; a2.st = -1; tot += 2; &#125; picture();&#125; 扫描线与坐标离散化POJ2482 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112const int maxn = 10000 + 6;unsigned int n, W, H;int m;// discrete n -&gt; mclass R &#123;public: llong x; llong y1, y2; int c; bool operator&lt; (const R&amp; rhs) const &#123; return x &lt; rhs.x || (x == rhs.x &amp;&amp; c &lt; rhs.c); &#125;&#125;;R a[maxn &lt;&lt; 1];llong raw[maxn &lt;&lt; 1];map&lt;llong, int&gt; ny;void init() &#123; // Set(raw, 0); ny.clear();&#125;void discrete() &#123; sort(raw + 1, raw + 1 + n); m = unique(raw + 1, raw + 1 + n) - raw - 1; _rep(i, 1, m) &#123; ny[raw[i]] = i; &#125;&#125;class segTree &#123;public: int l, r, dat, tag;#define l(p) t[p].l#define r(p) t[p].r#define dat(p) t[p].dat#define tag(p) t[p].tag&#125; t[maxn &lt;&lt; 3];void build(int p, int l, int r) &#123; l(p) = l, r(p) = r; dat(p) = tag(p) = 0; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(p&lt;&lt;1, l, mid); build(p&lt;&lt;1 | 1, mid + 1, r);&#125;void spread(int p) &#123; tag(p&lt;&lt;1) += tag(p); dat(p&lt;&lt;1) += tag(p);; tag(p&lt;&lt;1 | 1) += tag(p); dat(p&lt;&lt;1 | 1) += tag(p); tag(p) = 0;&#125;void change(int p, int l, int r, int c) &#123; if(l &lt;= l(p) &amp;&amp; r(p) &lt;= r) &#123; dat(p) += c; tag(p) += c; return; &#125; if(tag(p)) spread(p); int mid = (l(p) + r(p)) &gt;&gt; 1; if(l &lt;= mid) change(p&lt;&lt;1, l, r, c); if(r &gt; mid) change(p&lt;&lt;1 | 1, l, r, c); dat(p) = max(dat(p&lt;&lt;1), dat(p&lt;&lt;1 | 1));&#125;void starsWindow() &#123; sort(a + 1, a + 1 + n); build(1, 1, m); int ans = 0; _rep(i, 1, n) &#123; int y1 = ny[a[i].y1], y2 = ny[a[i].y2]; change(1, y1, y2, a[i].c); ans = max(ans, dat(1)); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (cin &gt;&gt; n &gt;&gt; W &gt;&gt; H) &#123; init(); _rep(i, 1, n) &#123; int k = (i&lt;&lt;1); cin &gt;&gt; a[k-1].x &gt;&gt; a[k-1].y1 &gt;&gt; a[k-1].c; a[k].x = a[k-1].x + W; raw[k-1] = a[k].y1 = a[k-1].y1; raw[k] = a[k].y2 = a[k-1].y2 = a[k-1].y1 + H - 1; a[k].c = -a[k-1].c; &#125; // input finished n &lt;&lt;= 1; discrete(); starsWindow(); &#125;&#125; BST平衡二叉树 treap树GYM228544B 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182const int maxn = 100000 + 10;const int inf = 0x3f3f3f3f;class Treap &#123;public: int l, r; int val, rk; int cnt, sz;&#125;;Treap a[maxn];int tot, root, n;void init() &#123; tot = 0;&#125;int New(int val) &#123; a[++tot].val = val; a[tot].rk = rand(); a[tot].cnt = a[tot].sz = 1; return tot;&#125;void Update(int p) &#123; a[p].sz = a[a[p].l].sz + a[a[p].r].sz + a[p].cnt;&#125;void build() &#123; New(-inf), New(inf); root = 1, a[1].r = 2; Update(root);&#125;int rankByVal(int p, int val) &#123; if(p == 0) return 0; if(val == a[p].val) return a[a[p].l].sz + 1; if(val &lt; a[p].val) return rankByVal(a[p].l, val); return a[a[p].l].sz + a[p].cnt + rankByVal(a[p].r, val);&#125;int valByRank(int p, int rank) &#123; if(p == 0) return inf; if(a[a[p].l].sz &gt;= rank) return valByRank(a[p].l, rank); if(a[a[p].l].sz + a[p].cnt &gt;= rank) return a[p].val; return valByRank(a[p].r, rank - a[a[p].l].sz - a[p].cnt);&#125;void zig(int&amp; p) &#123; int q = a[p].l; a[p].l = a[q].r, a[q].r = p, p = q; Update(a[p].r), Update(p);&#125;void zag(int&amp; p) &#123; int q = a[p].r; a[p].r = a[q].l, a[q].l = p, p = q; Update(a[p].l), Update(p);&#125;void insert(int&amp; p, int val) &#123; if(p == 0) &#123; p = New(val); return; &#125; if(val == a[p].val) &#123; a[p].cnt++; Update(p); return;; &#125; if(val &lt; a[p].val) &#123; insert(a[p].l, val); if(a[p].rk &lt; a[a[p].l].rk) zig(p); &#125; else &#123; insert(a[p].r, val); if(a[p].rk &lt; a[a[p].r].rk) zag(p); &#125; Update(p);&#125;void remove(int&amp; p, int val) &#123; if(p == 0) return; if(val == a[p].val) &#123; if(a[p].cnt &gt; 1) &#123; a[p].cnt--; Update(p); return; &#125; if(a[p].l || a[p].r) &#123; if(a[p].r == 0 || a[a[p].l].rk &gt; a[a[p].r].rk) &#123; zig(p); remove(a[p].r, val); &#125; else &#123; zag(p); remove(a[p].l, val); &#125; Update(p); &#125; else p = 0; return; &#125; val &lt; a[p].val ? remove(a[p].l, val) : remove(a[p].r, val); Update(p);&#125;int getPre(int val) &#123; int ans = 1; int p = root; while (p) &#123; if(val == a[p].val) &#123; if(a[p].l &gt; 0) &#123; p = a[p].l; while (a[p].r &gt; 0) p = a[p].r; ans = p; &#125; break; &#125; if(a[p].val &lt; val &amp;&amp; a[p].val &gt; a[ans].val) ans = p; p = val &lt; a[p].val ? a[p].l : a[p].r; &#125; return a[ans].val;&#125;int getNext(int val) &#123; int ans = 2; int p = root; while (p) &#123; if(val == a[p].val) &#123; if(a[p].r &gt; 0) &#123; p = a[p].r; while (a[p].l &gt; 0) p = a[p].l; ans = p; &#125; break; &#125; if(a[p].val &gt; val &amp;&amp; a[p].val &lt; a[ans].val) ans = p; p = val &lt; a[p].val ? a[p].l : a[p].r; &#125; return a[ans].val;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); cin &gt;&gt; n; build(); while (n--) &#123; int op, x; scanf(\"%d%d\", &amp;op, &amp;x); switch (op)&#123; case 1: insert(root, x); break; case 2: remove(root, x); break; case 3: printf(\"%d\\n\", rankByVal(root, x) - 1); break; case 4: printf(\"%d\\n\", valByRank(root, x + 1)); break; case 5: printf(\"%d\\n\", getPre(x)); break; case 6: printf(\"%d\\n\", getNext(x)); break; &#125; &#125;&#125; Treap树(内存回收)HDU3726 Treap树删除的数组版本123456789101112131415161718192021222324252627282930313233void remove(int&amp; p, int val) &#123; if(p == 0) return; if(val == a[p].val) &#123; if(a[p].cnt &gt; 1) &#123; a[p].cnt--; Update(p); return; &#125; if(a[p].l &amp;&amp; a[p].r) &#123; if(a[a[p].l].rk &gt; a[a[p].r].rk) &#123; zig(p); remove(a[p].r, val); &#125; else &#123; zag(p); remove(a[p].l, val); &#125; &#125; else &#123; if(a[p].l == 0 &amp;&amp; a[p].r == 0) &#123; p = 0; return; &#125; else if(a[p].r == 0) p = a[p].l; else p = a[p].r; &#125; &#125; else &#123; val &lt; a[p].val ? remove(a[p].l, val) : remove(a[p].r, val); &#125; if(p != 0) Update(p);&#125; Treap树(回收内存)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296const int maxn = 20000 + 5;const int maxm = 60000 + 5;const int inf = 0x3f3f3f3f;int n, m;int weight[maxm], rmved[maxm];// === treap tree ===class Treap &#123;public: Treap* l; Treap* r; int val, dat; int sz; Treap(int val) : val(val) &#123; l = r = NULL; dat = rand(); sz = 1; &#125; void update() &#123; sz = 1; if(l != NULL) sz += l-&gt;sz; if(r != NULL) sz += r -&gt;sz; &#125;&#125;;typedef Treap* T;T a[maxn];void zig(T&amp; p) &#123; T q = p-&gt;l; p-&gt;l = q-&gt;r; q-&gt;r = p; p = q; p-&gt;r-&gt;update(); p-&gt;update();&#125;void zag(T&amp; p) &#123; T q = p-&gt;r; p-&gt;r = q-&gt;l; q-&gt;l = p; p = q; p-&gt;l-&gt;update(); p-&gt;update();&#125;void insert(T&amp; p, int val) &#123; if(p == NULL) &#123; p = new Treap(val); return; &#125; if(val &lt; p-&gt;val) &#123; insert(p-&gt;l, val); if(p-&gt;dat &lt; p-&gt;l-&gt;dat) zig(p); &#125; else &#123; insert(p-&gt;r, val); if(p-&gt;dat &lt; p-&gt;r-&gt;dat) zag(p); &#125; p-&gt;update();&#125;void remove(T&amp; p, int val) &#123; if(val == p-&gt;val) &#123; T u = p; if(p-&gt;l &amp;&amp; p-&gt;r) &#123; if(p-&gt;l-&gt;dat &gt; p-&gt;r-&gt;dat) &#123; zig(p); remove(p-&gt;r, val); &#125; else &#123; zag(p); remove(p-&gt;l, val); &#125; &#125; else &#123; if(p-&gt;l == NULL) p = p-&gt;r; else p = p-&gt;l; delete u; &#125; &#125; else &#123; val &lt; p-&gt;val ? remove(p-&gt;l, val) : remove(p-&gt;r, val); &#125; if(p != NULL) p-&gt;update();&#125;// pre is the max of min&#123;&#125;int getPre(const T&amp; root, int val) &#123; int ans = -inf; T p = root; while (p) &#123; if(val == p-&gt;val) &#123; if(p-&gt;l != NULL) &#123; p = p-&gt;l; while (p-&gt;r != NULL) p = p-&gt;r; ans = p-&gt;val; &#125; break; &#125; if(p-&gt;val &lt; val &amp;&amp; p-&gt;val &gt; ans) ans = p-&gt;val; p = val &lt; p-&gt;val ? p-&gt;l : p-&gt;r; &#125; return ans;&#125;// next is the min of max&#123;&#125;int getNxt(const T&amp; root, int val) &#123; int ans = inf; T p = root; while (p) &#123; if(val == p-&gt;val) &#123; if(p-&gt;r != NULL) &#123; p = p-&gt;r; while (p-&gt;l != NULL) p = p-&gt;l; ans = p-&gt;val; &#125; break; &#125; if(p-&gt;val &gt; val &amp;&amp; p-&gt;val &lt; ans) ans = p-&gt;val; p = val &lt; p-&gt;val ? p-&gt;l : p-&gt;r; &#125; return ans;&#125;int rankByVal(T p, int val) &#123; if(p == NULL) return 0; if(val == p-&gt;val) return p-&gt;l-&gt;sz + 1; if(val &lt; p-&gt;val) return rankByVal(p-&gt;l, val); return p-&gt;l-&gt;sz + 1 + rankByVal(p-&gt;r, val);&#125;int valByRank(T p, int rank) &#123; if(p == NULL || rank &lt;= 0 || rank &gt; p-&gt;sz) return 0; int s = p-&gt;r == NULL ? 0 : p-&gt;r-&gt;sz; if(rank == s + 1) return p-&gt;val; else if(rank &lt;= s) return valByRank(p-&gt;r, rank); else return valByRank(p-&gt;l, rank - 1 - s);&#125;// === treap tree finished ===// === algorithm about forestvoid mergeto(T&amp; src, T&amp; dest) &#123; if(src-&gt;l != NULL) mergeto(src-&gt;l, dest); if(src-&gt;r != NULL) mergeto(src-&gt;r, dest); insert(dest, src-&gt;val); delete src; src = NULL;&#125;void rmvTree(T&amp; p) &#123; if(p-&gt;l != NULL) rmvTree(p-&gt;l); if(p-&gt;r != NULL) rmvTree(p-&gt;r); delete p; p = NULL;&#125;// === forest algorithm finishedclass Edge &#123;public: int from, to;&#125;;Edge edges[maxm];// === Union Find ===int pa[maxn];int findset(int x) &#123; return pa[x] != x ? pa[x] = findset(pa[x]) : x;&#125;void initpa(int n) &#123; _rep(i, 1, n) pa[i] = i;&#125;// === Union Find finished ===// == main algorithm ==void addEdge(int x) &#123; int u = findset(edges[x].from), v = findset(edges[x].to); if(u != v) &#123; if(a[u]-&gt;sz &lt; a[v]-&gt;sz) &#123; pa[u] = v; mergeto(a[u], a[v]); &#125; else &#123; pa[v] = u; mergeto(a[v], a[u]); &#125; &#125;&#125;void changeWeight(int x, int v) &#123; int u = findset(x); remove(a[u], weight[x]); insert(a[u], v); weight[x] = v;&#125;llong ans = 0;int qcnt = 0;void query(int x, int k) &#123; qcnt++; ans += valByRank(a[findset(x)], k);&#125;// == main algorithm finished ==// === get input ===class CMD &#123;public: char type; int x, p;&#125;;vector&lt;CMD&gt; cmds;void init() &#123; Set(weight, 0); Set(rmved, 0); cmds.clear(); ans = qcnt = 0;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while (scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; init(); _rep(i, 1, n) scanf(\"%d\", &amp;weight[i]); _rep(i, 1, m) scanf(\"%d%d\", &amp;edges[i].from, &amp;edges[i].to); // then read cmds for(;;) &#123; char type; int x = 0, p = 0, v = 0; cin &gt;&gt; type; if(type == 'E') break; scanf(\"%d\", &amp;x); if(type == 'D') rmved[x] = 1; if(type == 'Q') scanf(\"%d\", &amp;p); if(type == 'C') &#123; scanf(\"%d\", &amp;v); p = weight[x]; weight[x] = v; &#125; cmds.push_back((CMD) &#123; type, x, p &#125;); &#125; // read finished //initpa(n); // then build the last Graph _rep(i, 1, n) &#123; pa[i] = i; if(a[i] != NULL) rmvTree(a[i]); a[i] = new Treap(weight[i]); &#125; _rep(i, 1, m) if(!rmved[i]) addEdge(i); _forDown(i, cmds.size() - 1, 0) &#123; if(cmds[i].type == 'D') addEdge(cmds[i].x); if(cmds[i].type == 'Q') query(cmds[i].x, cmds[i].p); if(cmds[i].type == 'C') changeWeight(cmds[i].x, cmds[i].p); &#125; if(qcnt) printf(\"Case %d: %.6lf\\n\", ++kase, ans / (double)qcnt); else printf(\"Case %d: 0\\n\", ++kase); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"动态规划优化(一)","slug":"20191123","date":"2019-11-23T10:00:04.000Z","updated":"2019-11-29T03:48:03.423Z","comments":true,"path":"2019/11/23/20191123/","link":"","permalink":"https://www.fogsail.net/2019/11/23/20191123/","excerpt":"本节内容主要讲述一些进阶的动态规划包括轮廓线动态规划，四边形不等式，单调队列优化等等","text":"本节内容主要讲述一些进阶的动态规划包括轮廓线动态规划，四边形不等式，单调队列优化等等 轮廓线动态规划POJ2411 12345678910111213141516171819202122232425262728293031323334353637383940const int maxn = 11 + 1;llong f[maxn][1 &lt;&lt; maxn];bool inS[1 &lt;&lt; maxn];int N, M;void init() &#123; Set(f, 0); f[0][0] = 1;&#125;inline void cal() &#123; _for(i, 0, 1 &lt;&lt; M) &#123; bool cnt = 0, hasOdd = 0; _for(k, 0, M) &#123; if((i &gt;&gt; k) &amp; 1) hasOdd |= cnt, cnt = 0; else cnt ^= 1; &#125; inS[i] = hasOdd | cnt ? 0 : 1; &#125;&#125;void dp() &#123; _rep(i, 1, N) _for(j, 0, 1 &lt;&lt; M) &#123; f[i][j] = 0; _for(k, 0, 1 &lt;&lt; M) &#123; if((j &amp; k) == 0 &amp;&amp; inS[j | k]) f[i][j] += f[i - 1][k]; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (cin &gt;&gt; N &gt;&gt; M &amp;&amp; N) &#123; init(); cal(); dp(); cout &lt;&lt; f[N][0] &lt;&lt; endl; &#125;&#125; 状态压缩POJ1185 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596const int inf = 0x3f3f3f3f;const int maxn = 100 + 1, maxs = 160;const int maxm = 10 + 1;int f[maxn][maxs][maxs];int fbid[maxn];int cnt[maxs];int buf[maxs];int N, M;int tot = 0;void init() &#123; Set(fbid, 0); Set(cnt, 0); Set(buf, 0); tot = 0;&#125;int getone(int x) &#123; int cnt = 0; while (x) &#123; if((x &amp; 1) == 1) cnt++; x &gt;&gt;= 1; &#125; return cnt;&#125;bool ok(int x) &#123; if(x &amp; (x &lt;&lt; 1)) return false; if(x &amp; (x &lt;&lt; 2)) return false; return true;&#125;inline void cal() &#123; tot = 0; _for(st, 0, 1 &lt;&lt; M) if(ok(st)) &#123; buf[tot] = st; cnt[tot++] = getone(st); &#125;&#125;void initdp() &#123; Set(f, -1); f[0][0][0] = 0;&#125;bool valid(int i, int st) &#123; if(fbid[i] &amp; st) return false; return true;&#125;int dp() &#123; int ans = 0; _for(k, 0, tot) if(valid(1, buf[k])) &#123; f[1][k][0] = cnt[k]; ans = max(ans, f[1][k][0]); //debug(ans); &#125; _rep(i, 2, N) &#123; _for(j, 0, tot) if(valid(i, buf[j])) &#123; _for(k, 0, tot) if(valid(i - 1, buf[k]) &amp;&amp; (buf[k]&amp;buf[j]) == 0) &#123; int pre = 0; _for(l, 0, tot) if(f[i - 1][k][l] != -1 &amp;&amp; valid(i - 2, buf[l]) &amp;&amp; (buf[l]&amp;buf[j]) == 0) &#123; pre = max(pre, f[i - 1][k][l]); &#125; f[i][j][k] = max(f[i][j][k], pre + cnt[j]); if(i == N) ans = max(ans, f[i][j][k]); &#125; &#125; &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); scanf(\"%d%d\", &amp;N, &amp;M); _rep(i, 1, N) &#123; char t[maxm]; scanf(\"%s\", t); //debug(t); _for(j, 0, M) &#123; if(t[j] == 'H') &#123; fbid[i] |= (1 &lt;&lt; (M-1-j)); &#125; &#125; //debug(fbid[i]); &#125; // then dp cal(); initdp(); printf(\"%d\\n\", dp());&#125; RMQ倍增算法 HDU1806 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const int maxn = 100000 + 5;const int maxlog = 20;int A[maxn];int N, Q;class RMQ &#123;public: int f[maxn][maxlog]; void init(const vector&lt;int&gt;&amp; A) &#123; int n = A.size();; _for(i, 0, n) f[i][0] = A[i]; for(int j = 1; (1&lt;&lt;j) &lt;= n; j++) &#123; for(int i = 0; i + (1&lt;&lt;j) - 1 &lt; n; i++) &#123; f[i][j] = max(f[i][j - 1], f[i + (1&lt;&lt;(j-1))][j - 1]); &#125; &#125; &#125; int query(int L, int R) &#123; int k = 0; while ((1&lt;&lt;(k+1)) &lt;= R - L + 1) k++; return max(f[L][k], f[R-(1&lt;&lt;k)+1][k]); &#125;&#125;;int _left[maxn], _right[maxn], idx[maxn];vector&lt;int&gt; cnt;// cnt[seg id]void init() &#123; Set(_left, 0); Set(_right, 0); Set(idx, 0); cnt.clear();&#125;inline void cal(vector&lt;int&gt;&amp; cnt) &#123; int s = -1; _rep(i, 0, N) &#123; if(i == 0 || A[i] &gt; A[i-1]) &#123; if(i &gt; 0) &#123; cnt.push_back(i - s); _for(k, s, i) &#123; idx[k] = cnt.size() - 1; _left[k] = s; _right[k] = i - 1; &#125; &#125; s = i; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;N, &amp;Q) == 2) &#123; _for(i, 0, N) scanf(\"%d\", &amp;A[i]); A[N] = A[N - 1] + 1; // special for RMQ init(); cal(cnt); // then rmq RMQ rmq; rmq.init(cnt); // then query while (Q--) &#123; int L, R, ans; scanf(\"%d%d\", &amp;L, &amp;R); L--, R--; if(idx[L] == idx[R]) ans = R - L + 1; else &#123; ans = max(_right[L] - L + 1, R - _left[R] + 1); if(idx[L] + 1 &lt; idx[R]) ans = max(ans, rmq.query(idx[L] + 1, idx[R] - 1)); &#125; printf(\"%d\\n\", ans); &#125; &#125;&#125; 复习，双向链表邻值查找DoubleLink 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const int maxn = 100000 + 5;int N;class Node &#123;public: int x, k, pre, nxt; bool operator&lt; (const Node&amp; rhs) const &#123; return x &lt; rhs.x; &#125;&#125;;Node A[maxn];int B[maxn];class Ans &#123;public: int x, k;&#125;;Ans ans[maxn];int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;N); _rep(i, 1, N) &#123; scanf(\"%d\", &amp;A[i].x); A[i].k = i; &#125; sort(A + 1, A + 1 + N); _rep(i, 1, N) &#123; B[A[i].k] = i; A[i].pre = i - 1; A[i].nxt = i + 1; &#125; int l = 1, r = N; _forDown(i, N, 1) &#123; if(B[i] == r) &#123; ans[i].x = A[r].x - A[A[r].pre].x; ans[i].k = A[A[r].pre].k; r = A[r].pre; &#125; else if(B[i] == l) &#123; ans[i].x = A[A[l].nxt].x - A[l].x; ans[i].k = A[A[l].nxt].k; l = A[l].nxt; &#125; else &#123; ans[i].x = A[A[B[i]].nxt].x - A[B[i]].x; ans[i].k = A[A[B[i]].nxt].k; if(A[B[i]].x - A[A[B[i]].pre].x &lt;= ans[i].x) &#123; ans[i].x = A[B[i]].x - A[A[B[i]].pre].x; ans[i].k = A[A[B[i]].pre].k; &#125; &#125; A[A[B[i]].pre].nxt = A[B[i]].nxt; A[A[B[i]].nxt].pre = A[B[i]].pre; &#125; _rep(i, 2, N) printf(\"%d %d\\n\", ans[i].x, ans[i].k);&#125; 倍增优化dpNOIP2012 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#define MPR(a, b) make_pair(a, b)const int maxn = 100000 + 5, inf = 0x3f3f3f3f;const int maxlog = 20;int N, lgN, m;int h[maxn], x[maxn], s[maxn];int ga[maxn], gb[maxn];int f[maxlog][maxn][2], da[maxlog][maxn][2], db[maxlog][maxn][2];int la = 0, lb = 0;multiset&lt;pair&lt;int, int&gt; &gt; st;typedef multiset&lt;pair&lt;int, int&gt; &gt;::iterator SII;SII it1, it2, it3, it4, it;void init() &#123; st.clear(); st.insert(make_pair(inf, 0)); st.insert(make_pair(-inf, 0)); st.insert(make_pair(inf, 0)); st.insert(make_pair(-inf, 0)); h[0] = 0; Set(ga, 0); Set(gb, 0); la = lb = 0;&#125;// pair(value, id)inline void calg() &#123; for(int i = N; i; i--) &#123; st.insert(MPR(h[i], i)); it = st.find(MPR(h[i], i)); it1 = (++it); it2 = (++it); it3 = (--(--(--it))); it4 = (--it); int a = (*it3).first != -inf ? h[i] - (*it3).first : inf; int b = (*it1).first != inf ? (*it1).first - h[i] : inf; if(a &lt;= b) &#123; // choose it3 as gb[] gb[i] = (*it3).second; // (it1, it4) cmp a = (*it4).first != -inf ? h[i] - (*it4).first : inf; ga[i] = (a &lt;= b ? (*it4).second : (*it1).second); &#125; else &#123; // choose it1 as gb[] gb[i] = (*it1).second; b = (*it2).first != inf ? (*it2).first - h[i] : inf; ga[i] = (a &lt;= b ? (*it3).second : (*it2).second); &#125; &#125;&#125;void calf() &#123; _rep(i, 1, N) &#123; f[0][i][0] = ga[i]; f[0][i][1] = gb[i]; &#125; _rep(i, 1, N) &#123; f[1][i][0] = f[0][ f[0][i][0] ][1]; f[1][i][1] = f[0][ f[0][i][1] ][0]; &#125; _for(i, 2, lgN) &#123; _rep(j, 1, N) &#123; f[i][j][0] = f[i-1][ f[i-1][j][0] ][0]; f[i][j][1] = f[i-1][ f[i-1][j][1] ][1]; &#125; &#125;&#125;void cald() &#123; _rep(i, 1, N) &#123; da[0][i][0] = abs(h[i] - h[ga[i]]); db[0][i][1] = abs(h[i] - h[gb[i]]); da[0][i][1] = db[0][i][0] = 0; &#125; _rep(i, 1, N) &#123; da[1][i][0] = da[0][i][0]; db[1][i][1] = db[0][i][1]; da[1][i][1] = da[0][ f[0][i][1] ][0]; db[1][i][0] = db[0][ f[0][i][0] ][1]; &#125; _for(i, 2, lgN) _rep(j, 1, N) _for(k, 0, 2) &#123; da[i][j][k] = da[i-1][j][k] + da[i-1][ f[i-1][j][k] ][k]; db[i][j][k] = db[i-1][j][k] + db[i-1][ f[i-1][j][k] ][k]; &#125;&#125;void calS(int S, int X) &#123; // always start from A, A first la = lb = 0; int p = S; _forDown(i, lgN, 0) &#123; if(f[i][p][0] &amp;&amp; la + lb + da[i][p][0] + db[i][p][0] &lt;= X) &#123; la += da[i][p][0]; lb += db[i][p][0]; p = f[i][p][0]; &#125; &#125;&#125;void solve1() &#123; calS(1, x[0]); // ans1 (pID, heightValue) //double ans1[2] = &#123;1, (lb ? (double)la / lb : inf)&#125;; pair&lt;int, double&gt; ans1 = MPR(1, (double)(lb ? (double)la / lb : inf)); _rep(i, 2, N) &#123; calS(i, x[0]); if((double)la / lb &lt; ans1.second || ((double)la / lb == ans1.second &amp;&amp; h[i] &gt; h[ans1.first])) &#123; ans1 = MPR(i, (double)la / lb); &#125; &#125; cout &lt;&lt; ans1.first &lt;&lt; endl;&#125;void solve2() &#123; _rep(i, 1, m) &#123; calS(s[i], x[i]); //cout &lt;&lt; s[i] &lt;&lt; \" \" &lt;&lt; x[i] &lt;&lt; endl; printf(\"%d %d\\n\", la, lb); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; N; lgN = log(N) / log(2.0); // debug(lgN); _rep(i, 1, N) scanf(\"%d\", &amp;h[i]); cin &gt;&gt; x[0] &gt;&gt; m; _rep(i, 1, m) scanf(\"%d%d\", &amp;s[i], &amp;x[i]); // input finished, then solve init(); calg(); calf(); cald(); solve1(); solve2();&#125; 串匹配和倍增Acwing294 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const int maxl = 100 + 5, maxn = 1000000 + 5;const int maxlog = 30;llong f[maxl][maxlog + 2];string s1, s2;int n1, n2;void init() &#123; Set(f, 0);&#125;inline bool cal() &#123; _for(i, 0, s1.size()) &#123; int p = i; f[i][0] = 0; _for(j, 0, s2.size()) &#123; int cnt = 0; // then try to find s1[p] matched s2[j] while (s1[p] != s2[j]) &#123; p = (p + 1) % (int)s1.size(); if(++cnt &gt;= s1.size()) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return false; &#125; &#125; p = (p + 1) % (int)s1.size(); f[i][0] += cnt + 1; &#125; &#125; return true;&#125;void dp() &#123; _rep(j, 1, maxlog) _for(i, 0, s1.size()) &#123; f[i][j] = f[i][j - 1] + f[(i + f[i][j-1] ) % s1.size()][j - 1]; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (cin &gt;&gt; s2 &gt;&gt; n2 &gt;&gt; s1 &gt;&gt; n1) &#123; init(); // debug(s2); if(!cal()) continue; dp(); llong m = 0; _for(st, 0, s1.size()) &#123; llong x = st, ans = 0; // then connect 2^k _forDown(k, maxlog, 0) &#123; if(x + f[x % s1.size()][k] &lt;= n1 * s1.size()) &#123; x += f[x % s1.size()][k]; ans += (1 &lt;&lt; k); &#125; &#125; m = max(m, ans); &#125; cout &lt;&lt; m / n2 &lt;&lt; endl; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"https://www.fogsail.net/tags/dp/"}]},{"title":"动态规划专题(六)","slug":"20191113","date":"2019-11-13T12:51:23.000Z","updated":"2019-11-23T07:25:02.493Z","comments":true,"path":"2019/11/13/20191113/","link":"","permalink":"https://www.fogsail.net/2019/11/13/20191113/","excerpt":"本节内容对树形dp做一个复习另外还有部分状态压缩dp的内容","text":"本节内容对树形dp做一个复习另外还有部分状态压缩dp的内容 树形dp 树形dp常见套路POJ1463 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const int maxn = 1500 + 5;int hasFa[maxn];int f[maxn][2];vector&lt;int&gt; son[maxn];int N;void init() &#123; Set(hasFa, 0); Set(f, 0); _for(i, 0, maxn) son[i].clear();&#125;void dp(int u) &#123; f[u][0] = 0; f[u][1] = 1; _for(i, 0, son[u].size()) &#123; int v = son[u][i]; dp(v); f[u][0] += f[v][1]; f[u][1] += (min(f[v][0], f[v][1])); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;N) != EOF) &#123; init(); _for(i, 0, N) &#123; int u, k; scanf(\"%d:(%d)\", &amp;u, &amp;k); _for(j, 0, k) &#123; int v; scanf(\"%d\", &amp;v); son[u].push_back(v); hasFa[v] = 1; &#125; &#125; // then input finished int r = 0; _for(i, 0, N) if(!hasFa[i]) &#123; r = i; break; &#125; dp(r); printf(\"%d\\n\", min(f[r][0], f[r][1])); &#125;&#125; 树形背包问题，倒序遍历LA3797 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const int maxn = 200 + 5;const int inf = 0x3f3f3f3f;map&lt;string, int&gt; dic;int tot = 0;int N, M;vector&lt;int&gt; son[maxn];bool hasFa[maxn];int cost[maxn];int sum[maxn];int f[maxn][maxn];void init() &#123; dic.clear(); tot = 0; Set(hasFa, 0); Set(sum, 0); _for(i, 0, maxn) son[i].clear();&#125;void initdp() &#123; _rep(i, 1, N) if(!hasFa[i]) son[0].push_back(i); Set(f, inf); f[0][0] = 0;&#125;void dp(int u) &#123; f[u][0] = 0; sum[u] = 1; _for(i, 0, son[u].size()) &#123; int v = son[u][i]; dp(v); sum[u] += sum[v]; //debug(sum[u]); _forDown(t, N, 1) _forDown(j, t, 0) &#123; if(t - j &lt; 0) continue; f[u][t] = min(f[u][t], f[v][j] + f[u][t - j]); &#125; &#125; if(u) f[u][sum[u]] = cost[u];&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string data; while (getline(cin, data)) &#123; if(data[0] == '#') break; init(); stringstream ss(data); ss &gt;&gt; N &gt;&gt; M; //debug(N), debug(M); _for(i, 0, N) &#123; getline(cin, data); stringstream ss(data); string ctry, dctry; int x; ss &gt;&gt; ctry &gt;&gt; x; //debug(ctry), debug(x); if(!dic.count(ctry)) dic[ctry] = ++tot; cost[dic[ctry]] = x; //debug(dic[ctry]); while (ss &gt;&gt; dctry) &#123; //debug(dctry); if(!dic.count(dctry)) dic[dctry] = ++tot; //debug(dic[dctry]); son[dic[ctry]].push_back(dic[dctry]); hasFa[dic[dctry]] = 1; &#125; &#125; //puts(\"\"); // input finished assert(tot == N); initdp(); //for(auto x : son[0]) cout &lt;&lt; x &lt;&lt; \" \"; dp(0); int ans = inf; _forDown(k, N, M) ans = min(ans, f[0][k]); printf(\"%d\\n\", ans); &#125;&#125; 树形dp与换根法HDU2196 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107const int maxn = 10000 + 10;int f1[maxn], f12nd[maxn], f2[maxn];int pass[maxn];int N;class Graph &#123;public: int tot; int head[maxn], ver[maxn * 2], nxt[maxn * 2]; int w[maxn * 2]; void clear() &#123; tot = 1; Set(head, 0); Set(ver, 0); Set(nxt, 0); Set(w, 0); &#125; void add(int x, int y, int z) &#123; ver[++tot] = y; w[tot] = z; nxt[tot] = head[x]; head[x] = tot; &#125;&#125;;Graph G;void init() &#123; Set(f1, -1); Set(f12nd, -1); Set(f2, -1); Set(pass, 0); G.clear();&#125;bool vis[maxn];void initvis() &#123; Set(vis, 0);&#125;void dp1(int u) &#123; if(f1[u] &gt;= 0) return; f1[u] = f12nd[u] = f2[u] = pass[u] = 0; vis[u] = 1; for(int e = G.head[u]; e; e = G.nxt[e]) &#123; int v = G.ver[e]; if(vis[v]) continue; //debug(v); dp1(v); if(f1[u] &lt; f1[v] + G.w[e]) &#123; f12nd[u] = max(f12nd[u], f1[u]); f1[u] = f1[v] + G.w[e]; pass[u] = v; &#125; else if(f12nd[u] &lt; f1[v] + G.w[e]) &#123; f12nd[u] = f1[v] + G.w[e]; &#125; &#125; return;&#125;void dp2(int u) &#123; vis[u] = 1; for(int e = G.head[u]; e; e = G.nxt[e]) &#123; int v = G.ver[e]; if(vis[v]) continue; if(v == pass[u]) &#123; // u - v is the segment of longest path f2[v] = max(f2[u], f12nd[u]) + G.w[e]; &#125; else f2[v] = max(f1[u], f2[u]) + G.w[e]; dp2(v); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;N) == 1 &amp;&amp; N) &#123; init(); _rep(i, 2, N) &#123; int v, w; scanf(\"%d%d\", &amp;v, &amp;w); G.add(i, v, w); G.add(v, i, w); &#125; // then dp1 and dp2 initvis(); dp1(1); initvis(); dp2(1); _rep(i, 1, N) printf(\"%d\\n\", max(f1[i], f2[i])); &#125;&#125; 高斯消元BZOJ2337 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const int maxn = 100 + 10;const int maxm = 10000 + 10;double A[maxn][maxn];double K[maxn];int N, M;class Graph &#123;public: int tot; int head[maxn], ver[maxm &lt;&lt; 1], nxt[maxm &lt;&lt; 1], w[maxm &lt;&lt; 1]; void clear() &#123; tot = 1; Set(head, 0); Set(ver, 0); Set(nxt, 0); Set(w, 0); &#125; void add(int x, int y, int z) &#123; ver[++tot] = y; w[tot] = z; nxt[tot] = head[x]; head[x] = tot; &#125;&#125;;Graph G;void init() &#123; G.clear(); Set(A, 0); Set(K, 0);&#125;void Gauss() &#123; _rep(i, 1, N) &#123; int r = i; _rep(j, i + 1, N) if(fabs(A[j][i]) &gt; fabs(A[r][i])) r = j; if(r != i) _rep(k, 1, N + 1) swap(A[i][k], A[r][k]); double t = A[i][i]; _rep(k, i + 1, N + 1) A[i][k] /= t; _rep(j, 1, N) if(i != j) &#123; double t = A[j][i]; _rep(k, 1, N + 1) A[j][k] -= t * A[i][k]; &#125; &#125;&#125;double build() &#123; double ans = 0.0; _for(i, 0, 30) &#123; Set(A, 0); _for(u, 1, N) &#123; A[u][u] = 1.0; for(int e = G.head[u]; e; e = G.nxt[e]) &#123; int v = G.ver[e]; if((1 &lt;&lt; i) &amp; G.w[e]) A[u][v] += 1.0 / K[u], A[u][N + 1] += 1.0 / K[u]; else A[u][v] -= 1.0 / K[u]; &#125; &#125; A[N][N] = 1.0; Gauss(); ans += A[1][N + 1] * (double)(1 &lt;&lt; i); &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;M); _rep(i, 1, M) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); G.add(u, v, w); K[u] += 1.0, K[v] += 1.0; if(u == v) K[u] -= 1.0; else G.add(v, u, w); &#125; // then build matrix printf(\"%.3lf\\n\", build());&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"https://www.fogsail.net/tags/dp/"}]},{"title":"动态规划专题(五)","slug":"20191102","date":"2019-11-02T11:55:51.000Z","updated":"2019-11-12T16:12:08.590Z","comments":true,"path":"2019/11/02/20191102/","link":"","permalink":"https://www.fogsail.net/2019/11/02/20191102/","excerpt":"本节内容主要讲述动态规划中环形与后效性处理常见的策略","text":"本节内容主要讲述动态规划中环形与后效性处理常见的策略 环形与后效性处理POJ2228 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const int maxn = 4000;const int inf = 0x3f3f3f3f;int N, B;int U[maxn];int f[2][maxn][2];void init() &#123; Set(f, -inf);&#125;void initdp1() &#123; f[1 &amp; 1][1][1] = f[1 &amp; 1][0][0] = 0;&#125;void initdp2() &#123; f[1 &amp; 1][1][1] = U[1];&#125;int dp1() &#123; _rep(i, 2, N) _rep(j, 0, B) &#123; f[i &amp; 1][j][0] = max(f[(i - 1) &amp; 1][j][0], f[(i - 1) &amp; 1][j][1]); if(j - 1 &gt;= 0) f[i &amp; 1][j][1] = max(f[(i - 1) &amp; 1][j - 1][0], f[(i - 1) &amp; 1][j - 1][1] + U[i]); &#125; return max(f[N &amp; 1][B][0], f[N &amp; 1][B][1]);&#125;int dp2() &#123; _rep(i, 2, N) _rep(j, 0, B) &#123; f[i &amp; 1][j][0] = max(f[(i - 1) &amp; 1][j][0], f[(i - 1) &amp; 1][j][1]); if(j - 1 &gt;= 0) f[i &amp; 1][j][1] = max(f[(i - 1) &amp; 1][j - 1][0], f[(i - 1) &amp; 1][j - 1][1] + U[i]); &#125; return f[N &amp; 1][B][1];&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;B); _rep(i, 1, N) scanf(\"%d\", &amp;U[i]); if(B == 0) &#123; printf(\"0\"); return 0; &#125; init(); initdp1(); int ans1 = dp1(); init(); initdp2(); int ans2 = dp2(); printf(\"%d\", max(ans1, ans2));&#125; 复习：滑动窗口最值问题CH5501 1234567891011121314151617181920const int maxn = 2000000 + 5;int A[maxn], ans = 0;int N;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;N); _rep(i, 1, N) scanf(\"%d\", &amp;A[i]); _rep(i, N + 1, (N &lt;&lt; 1)) A[i] = A[i - N]; deque&lt;int&gt; dq; dq.push_front(1); _rep(i, 2, (N &lt;&lt; 1)) &#123; while (!dq.empty() &amp;&amp; dq.back() &lt; i - N / 2) dq.pop_back(); ans = max(ans, A[i] + A[dq.back()] + i - dq.back()); while (!dq.empty() &amp;&amp; A[i] - i &gt;= A[dq.front()] - dq.front()) dq.pop_front(); dq.push_front(i); &#125; printf(\"%d\\n\", ans);&#125; 行阶梯形矩阵处理后效性问题codeforces24D 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const int maxn = 1000 + 5;double f[maxn][maxn], D[maxn][maxn];int N, M;int x, y;void init() &#123; Set(f, 0); Set(D, 0);&#125;void dp() &#123; _forDown(i, N - 1, x) &#123; D[1][1] = D[M][M] = 2.0 / 3.0; D[1][M + 1] = f[i + 1][1] / 3.0 + 1; D[1][2] = D[M][M - 1] = -1 / 3.0; D[M][M + 1] = f[i + 1][M] / 3.0 + 1; _rep(j, 2, M - 1) &#123; D[j][j - 1] = D[j][j + 1] = -1 / 4.0; D[j][j] = 3.0 / 4.0; D[j][M + 1] = f[i + 1][j] / 4.0 + 1; &#125; // row of matrix finished _rep(j, 1, M) &#123; double r = D[j + 1][j] / D[j][j]; D[j + 1][j] = 0; D[j + 1][j + 1] -= r * D[j][j + 1]; D[j + 1][M + 1] -= r * D[j][M + 1]; &#125; _forDown(j, M, 1) &#123; double r = D[j - 1][j] / D[j][j]; D[j - 1][j] = 0; D[j - 1][M + 1] -= r * D[j][M + 1]; f[i][j] = D[j][M + 1] / D[j][j]; &#125; &#125;&#125;int main() &#123; //freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;M); scanf(\"%d%d\", &amp;x, &amp;y); init(); if(M == 1) &#123; printf(\"%d\\n\", (N - x) * 2); return 0; &#125; dp(); printf(\"%.4lf\\n\", f[x][y]);&#125; 线性dp总结 NOIP2010 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int maxn = 120 + 5;const int maxA = 350 + 5;const int maxm = 40 + 5;int N, M;int A[maxA];int C[maxn];int f[maxn][maxm][maxm][maxm];void initdp() &#123; Set(f, 0);&#125;void dp() &#123; _rep(i, 1, M) for(int l1 = 0; l1 &lt;= C[1] &amp;&amp; l1 &lt;= M; l1++) for(int l2 = 0; l2 &lt;= C[2] &amp;&amp; l2 &lt;= M - l1; l2++) for(int l3 = 0; l3 &lt;= C[3] &amp;&amp; l3 &lt;= M - l1 - l2; l3++) &#123; int&amp; ans = f[i][l1][l2][l3]; int l4 = i - l1 - l2 - l3; int u = 1 + l1 + 2 * l2 + 3 * l3 + 4 * l4; if(l4) ans = f[i - 1][l1][l2][l3]; if(l1) ans = max(ans, f[i - 1][l1 - 1][l2][l3]); if(l2) ans = max(ans, f[i - 1][l1][l2 - 1][l3]); if(l3) ans = max(ans, f[i - 1][l1][l2][l3 - 1]); ans += A[u]; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;M); _rep(i, 1, N) scanf(\"%d\", &amp;A[i]); _rep(i, 1, M) &#123; int x; scanf(\"%d\", &amp;x); C[x]++; &#125; // input finished, then dp initdp(); dp(); printf(\"%d\\n\", f[M][C[1]][C[2]][C[3]] + A[1]);&#125; SGU104 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const int maxn = 100 + 10;int f[maxn][maxn];const int inf = 0x3f3f3f3f;int A[maxn][maxn], N, M;int pre[maxn][maxn];void initdp() &#123; Set(f, -inf); Set(pre, 0); _for(i, 0, maxn) f[0][i] = 0;&#125;int dp() &#123; _rep(i, 1, N) _rep(j, i, M - (N - i)) &#123; int&amp; ans = f[i][j]; _for(k, i - 1, j) &#123; int tmp = f[i - 1][k] + A[i][j]; if(tmp &gt; ans) &#123; ans = tmp; pre[i][j] = k; &#125; &#125; &#125; int ans = -inf; _rep(i, 1, M) ans = max(ans, f[N][i]); return ans;&#125;void print(int i, int j) &#123; if(i == 0) return; print(i - 1, pre[i][j]); printf(\"%d \", j);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;M); _rep(i, 1, N) _rep(j, 1, M) scanf(\"%d\", &amp;A[i][j]); // then dp() initdp(); int res = dp(); printf(\"%d\\n\", res); int j; _rep(i, 1, M) if(f[N][i] == res) j = i; print(N, j);&#125; POJ1952 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int maxn = 5000 + 5;const int inf = 0x3f3f3f3f;int f[maxn];int g[maxn];int A[maxn];int N;void initdp() &#123; Set(f, 0); Set(g, 0); A[0] = inf; g[0] = 1;&#125;int dp() &#123; _rep(i, 1, N) &#123; _forDown(j, i - 1, 0) &#123; if(A[j] &gt; A[i]) f[i] = max(f[i], f[j] + 1); &#125; &#125; int ans = 0; _rep(i, 1, N) ans = max(ans, f[i]); return ans;&#125;void dp2() &#123; _rep(i, 1, N) &#123; _for(j, 1, i) if(A[i] == A[j]) f[j] = -inf; _for(j, 0, i) if( (j == 0 || A[j] &gt; A[i]) &amp;&amp; f[i] == f[j] + 1) g[i] += g[j]; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;N); _rep(i, 1, N) scanf(\"%d\", &amp;A[i]); initdp(); int res = dp(); printf(\"%d \", res); dp2(); int cnt = 0; _rep(i, 1, N) if(f[i] == res) cnt += g[i]; printf(\"%d\\n\", cnt);&#125; LCS执行方案输出POJ1934 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const int maxn = 80 + 5;char A[maxn], B[maxn];int N = 0, M = 0;const int inf = 0x3f3f3f3f;int f[maxn][maxn];int locA[maxn][26], locB[maxn][26];vector&lt;string&gt; res;void initdp() &#123; Set(f, 0); Set(locA, 0); Set(locB, 0); assert(N != 0); res.clear(); _rep(i, 1, N) &#123; _for(ch, 0, 26) &#123; if(A[i] - 'a' == ch) locA[i][ch] = i; else locA[i][ch] = locA[i - 1][ch]; &#125; &#125; _rep(i, 1, M) &#123; _for(ch, 0, 26) &#123; if(B[i] - 'a' == ch) locB[i][ch] = i; else locB[i][ch] = locB[i - 1][ch]; &#125; &#125;&#125;int dp() &#123; _rep(i, 1, N) _rep(j, 1, M) &#123; f[i][j] = max(f[i - 1][j], f[i][j - 1]); if(A[i] == B[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); &#125; return f[N][M];&#125;void dfs(int x, int y, int len, string str) &#123; if(len == 0) &#123; res.push_back(str); return; &#125; if(!x || !y) return; _for(ch, 0, 26) &#123; int l1 = locA[x][ch], l2 = locB[y][ch]; if(f[l1][l2] != len) continue; dfs(l1 - 1, l2 - 1, len - 1, char(ch + 'a') + str); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%s\", A + 1); scanf(\"%s\", B + 1); N = strlen(A + 1), M = strlen(B + 1); //debug(N), debug(M); initdp(); int len = dp(); //debug(ans); string str; dfs(N, M, len, str); sort(res.begin(), res.end()); _for(i, 0, res.size()) cout &lt;&lt; res[i] &lt;&lt; endl;&#125; 线性dp杂题POJ1722 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const int BASE = 10000;const int maxn = 20000 + 5;const int maxl = 100 + 5;int N, T;int f[maxl][maxn];int A[maxn];int op[maxl];void initdp() &#123; Set(f, 0); Set(op, 0);&#125;void dp() &#123; f[1][BASE + A[1]] = 1; f[2][BASE + A[1] - A[2]] = -1; _rep(i, 3, N) _rep(j, 0, BASE + BASE) &#123; if(f[i - 1][j]) &#123; f[i][j + A[i]] = 1; f[i][j - A[i]] = -1; &#125; &#125;&#125;void out(int T) &#123; int S = T + BASE; _forDown(i, N, 2) &#123; op[i] = f[i][S]; if(op[i] == 1) S -= A[i]; if(op[i] == -1) S += A[i]; &#125; int cnt = 0; _rep(i, 2, N) &#123; if(op[i] == 1) &#123; cout &lt;&lt; i - 1 - cnt &lt;&lt; endl; cnt++; &#125; &#125; _rep(i, 2, N) &#123; if(op[i] == -1) cout &lt;&lt; 1 &lt;&lt; endl; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;T); _rep(i, 1,N) scanf(\"%d\", &amp;A[i]); initdp(); dp(); out(T);&#125; POJ1187 12345678910111213141516171819202122232425262728293031323334353637383940414243const int maxd = 30 + 5;const int maxn = 10 + 5;const int mod = 11380;int f[maxd][maxn][maxn][maxn];int D, L1, L2, L3;void initdp() &#123; Set(f, 0); _rep(d, 0, D) f[d][0][0][0] = 1;&#125;void dp() &#123; _rep(d, 1, D) &#123; _rep(l1, 0, L1) _rep(l2, 0, L2) _rep(l3, 0, L3) &#123; if(!l1 &amp;&amp; !l2 &amp;&amp; !l3) continue; int sum = 0; _rep(p, 1, l1) _rep(q, 0, l2) _rep(r, 0, l3) sum = (sum + (f[d-1][p-1][q][r] * f[d][l1-p][l2-q][l3-r] % mod)) % mod; _rep(q, 1, l2) _rep(r, 0, l3) sum = (sum + (f[d-1][0][q-1][r] * f[d][l1][l2-q][l3-r]) % mod) % mod; _rep(r, 1, l3) sum = (sum + (f[d-1][0][0][r-1] * f[d][l1][l2][l3-r]) % mod) % mod; f[d][l1][l2][l3] = sum; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d%d%d\", &amp;L1, &amp;L2, &amp;L3, &amp;D); initdp(); if(D == 0) &#123; if(!L1 &amp;&amp; !L2 &amp;&amp; !L3) puts(\"1\"); else puts(\"0\"); return 0; &#125; // then dp() dp(); printf(\"%d\\n\", (f[D][L1][L2][L3] - f[D-1][L1][L2][L3] + mod) % mod);&#125; 区间dp字符串折叠POJ2176 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const int maxn = 100 + 10;const int inf = 0x3f3f3f3f;char str[maxn];int N;class Seg &#123;public: int plen; char pstr[maxn];&#125;;Seg f[maxn][maxn];void init() &#123; N = strlen(str + 1);&#125;void initdp() &#123; _rep(i, 1, N) &#123; f[i][i].plen = 1; f[i][i].pstr[0] = str[i]; &#125;&#125;void folding(int i, int j) &#123; // fold str[i, j] int l = j - i + 1; _rep(ll, 1, l / 2) &#123; if(l % ll) continue; int ii = i, jj = i + ll; while (str[ii] == str[jj] &amp;&amp; jj &lt;= j) ii++, jj++; if(jj &gt; j) &#123; // can fold // ll from [1, l / 2], try to find min fold // 2(A) is better than 1(AA) int cnt = l / ll; // str[i, i + ll - 1] is pattern substring sprintf(f[i][j].pstr, \"%d\", cnt); strcat(f[i][j].pstr, \"(\"); strcat(f[i][j].pstr, f[i][i + ll - 1].pstr); strcat(f[i][j].pstr, \")\"); f[i][j].plen = strlen(f[i][j].pstr); break; &#125; &#125;&#125;void dp() &#123; _rep(len, 2, N) _rep(i, 1, N - len + 1) &#123; int j = i + len - 1; f[i][j].plen = inf; folding(i, j); _for(k, i, j) &#123; if(f[i][j].plen &gt; f[i][k].plen + f[k + 1][j].plen) &#123; f[i][j].plen = f[i][k].plen + f[k + 1][j].plen; strcpy(f[i][j].pstr, f[i][k].pstr); strcat(f[i][j].pstr, f[k + 1][j].pstr); &#125; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%s\", str + 1) != EOF) &#123; init(); initdp(); dp(); printf(\"%s\\n\", f[1][N].pstr); &#125;&#125; 多重背包多重背包 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int maxn = 6 + 3;const int maxm = 20000 + 5;const int N = 6;bitset&lt;maxm&gt; f;int A[maxn];void initdp() &#123; f &amp;= 1; f[0] = 1;&#125;bool dp() &#123; int totV = 0; _rep(x, 1, 6) totV += x * A[x]; if(totV &amp; 1) return false; else totV /= 2; _rep(i, 1, N) &#123; // value is i for(int p = 1; p &lt;= A[i]; p &lt;&lt;= 1) &#123; f |= (f &lt;&lt; (p * i)); A[i] -= p; &#125; if(A[i]) f |= (f &lt;&lt; (A[i] * i)); &#125; if(f[totV]) return true; else return false;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (1) &#123; int finished = true; _rep(i, 1, N) scanf(\"%d\", &amp;A[i]); _rep(i, 1, N) if(A[i] != 0) finished = false; if(finished) return 0; initdp(); bool flag = dp(); if(flag) puts(\"Can\"); else puts(\"Can't\"); &#125;&#125; 2D区间dpPOJ1191 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int N = 8;const int maxn = 15 + 2;int f[maxn][N + 2][N + 2][N + 2][N + 2];int A[N + 2][N + 2];int n;int S[N + 2][N + 2];double tot = 0;const int inf = 0x3f3f3f3f;void init() &#123; Set(f, inf); Set(S, 0); _rep(i, 1, N) _rep(j, 1, N) &#123; S[i][j] = S[i-1][j] + S[i][j-1] - S[i-1][j-1] + A[i][j]; &#125; _rep(x1, 1, N) _rep(y1, 1, N) &#123; _rep(x2, x1, N) _rep(y2, y1, N) &#123; int t = S[x2][y2] - S[x2][y1-1] - S[x1-1][y2] + S[x1-1][y1-1]; f[0][x1][y1][x2][y2] = t * t; &#125; &#125;&#125;void dp(int k, int x1, int y1, int x2, int y2) &#123; int&amp; ans = f[k][x1][y1][x2][y2]; ans = inf; _for(a, x1, x2) &#123; ans = min(ans, f[k-1][x1][y1][a][y2] + f[0][a+1][y1][x2][y2]); ans = min(ans, f[k-1][a+1][y1][x2][y2] + f[0][x1][y1][a][y2]); &#125; _for(b, y1, y2) &#123; ans = min(ans, f[k-1][x1][y1][x2][b] + f[0][x1][b+1][x2][y2]); ans = min(ans, f[k-1][x1][b+1][x2][y2] + f[0][x1][y1][x2][b]); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;n); _rep(i, 1, N) _rep(j, 1, N) &#123; scanf(\"%d\", &amp;A[i][j]); tot += A[i][j]; &#125; init(); _rep(k, 1, n - 1) _rep(x1, 1, N) _rep(y1, 1, N) &#123; _rep(x2, x1, N) _rep(y2, y1, N) &#123; dp(k, x1, y1, x2, y2); &#125; &#125; double avr = (double)(tot / n); //debug(tot); double ans = sqrt(1.0 * f[n - 1][1][1][N][N] / n - (avr * avr)); printf(\"%.3f\\n\", ans);&#125; 区间dp破环成链破环成链 12345678910111213141516171819202122232425262728293031323334353637const int maxn = 100 + 2;int f[maxn * 2][maxn * 2];int e[maxn * 2];int N;void initdp() &#123; Set(f, 0);&#125;void dp() &#123; _rep(len, 1, N) for(int i = 1; i + len - 1 &lt;= (N &lt;&lt; 1); i++) &#123; int j = i + len - 1; _for(k, i, j) &#123; f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + e[i] * e[k + 1] * e[j + 1]); &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;N) != EOF) &#123; _rep(i, 1, N) scanf(\"%d\", &amp;e[i]); _rep(i, N + 1, (N &lt;&lt; 1)) e[i] = e[i - N]; //_rep(i, 1, 2*N) printf(\"%d \", e[i]); initdp(); dp(); int ans = 0; _rep(i, 1, N) ans = max(ans, f[i][i + N - 1]); printf(\"%d\\n\", ans); &#125;&#125; 区间dp增加状态POJ1390 1234567891011121314151617181920212223242526272829303132333435363738394041424344const int maxn = 200 + 10;int f[maxn][maxn][maxn];int A[maxn];int N;void init() &#123; Set(f, -1);&#125;int dp(int i, int j, int k) &#123; if(i &gt; j) return 0; int&amp; ans = f[i][j][k]; if(i == j) return ans = (1 + k) * (1 + k); if(ans &gt;= 0) return ans; int p = j; while (p &gt;= i &amp;&amp; A[p] == A[j]) p--; p++; ans = dp(i, p-1, 0) + (k + j-p+1) * (k + j-p+1); _for(q, i, p) &#123; if(A[q] == A[j] &amp;&amp; A[q+1] != A[q]) &#123; ans = max(ans, dp(i, q, k+j-p+1) + dp(q+1, p-1, 0)); &#125; &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); _rep(kase, 1, T) &#123; printf(\"Case %d: \", kase); scanf(\"%d\", &amp;N); _rep(i, 1, N) scanf(\"%d\", &amp;A[i]); init(); // then dp() printf(\"%d\\n\", dp(1, N, 0)); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"https://www.fogsail.net/tags/dp/"}]},{"title":"计算几何初步","slug":"20191028","date":"2019-10-28T07:27:09.000Z","updated":"2019-11-01T14:42:28.366Z","comments":true,"path":"2019/10/28/20191028/","link":"","permalink":"https://www.fogsail.net/2019/10/28/20191028/","excerpt":"这篇文章主要介绍了计算几何的初步和计算几何相关的dp问题","text":"这篇文章主要介绍了计算几何的初步和计算几何相关的dp问题 点和直线 UVA11178 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Point &#123;public: double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vector;Vector operator+ (const Vector&amp; lhs, const Vector&amp; rhs) &#123; return Vector(lhs.x + rhs.x, lhs.y + rhs.y); &#125;Vector operator- (const Vector&amp; lhs, const Vector&amp; rhs) &#123; return Vector(lhs.x - rhs.x, lhs.y - rhs.y); &#125;Vector operator* (const Vector&amp; lhs, double p) &#123; return Vector(lhs.x * p, lhs.y * p); &#125;double Dot(const Vector&amp; A, const Vector&amp; B) &#123; return A.x * B.x + A.y * B.y; &#125;double Length(const Vector&amp; A) &#123; return sqrt(Dot(A, A)); &#125;double Angle(const Vector&amp; A, const Vector&amp; B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125;double Cross(const Vector&amp; A, const Vector&amp; B) &#123; return A.x * B.y - A.y * B.x; &#125;Point readPoint() &#123; double x, y; scanf(\"%lf%lf\", &amp;x, &amp;y); return Point(x, y);&#125;Point getLineIntersection(Point P, Vector v, Point Q, Vector w) &#123; Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125;Vector Rotate(const Vector&amp; A, double rad) &#123; return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125;Point getD(Point A, Point B, Point C) &#123; Vector v1 = C - B; double a1 = Angle(A - B, v1); v1 = Rotate(v1, a1 / 3); Vector v2 = B - C; double a2 = Angle(A - C, v2); v2 = Rotate(v2, -a2 / 3); return getLineIntersection(B, v1, C, v2);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); Point A, B, C, D, E, F; while (T--) &#123; A = readPoint(); B = readPoint(); C = readPoint(); D = getD(A, B, C); E = getD(B, C, A); F = getD(C, A, B); printf(\"%.6lf %.6lf %.6lf %.6lf %.6lf %.6lf\", D.x, D.y, E.x, E.y, F.x, F.y); printf(\"\\n\"); &#125;&#125; Euler一笔画LA3263 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const double eps = 1e-10;int dcmp(double x) &#123; if(fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;class Point &#123;public: double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vector;bool operator&lt; (const Point&amp; lhs, const Point&amp; rhs) &#123; return lhs.x &lt; rhs.x || (lhs.x == rhs.x &amp;&amp; lhs.y &lt; rhs.y); &#125;bool operator== (const Point&amp; lhs, const Point&amp; rhs) &#123; return dcmp(lhs.x - rhs.x) == 0 &amp;&amp; dcmp(lhs.y - rhs.y) == 0; &#125;Vector operator+ (const Vector&amp; lhs, const Vector&amp; rhs) &#123; return Vector(lhs.x + rhs.x, lhs.y + rhs.y); &#125;Vector operator- (const Vector&amp; lhs, const Vector&amp; rhs) &#123; return Vector(lhs.x - rhs.x, lhs.y - rhs.y); &#125;Vector operator* (const Vector&amp; lhs, double p) &#123; return Vector(lhs.x * p, lhs.y * p); &#125;double Dot(const Vector&amp; A, const Vector&amp; B) &#123; return A.x * B.x + A.y * B.y; &#125;double Length(const Vector&amp; A) &#123; return sqrt(Dot(A, A)); &#125;double Angle(const Vector&amp; A, const Vector&amp; B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125;double Cross(const Vector&amp; A, const Vector&amp; B) &#123; return A.x * B.y - A.y * B.x; &#125;Point readPoint() &#123; double x, y; scanf(\"%lf%lf\", &amp;x, &amp;y); return Point(x, y);&#125;Point getLineIntersection(const Point&amp; P, const Vector&amp; v, const Point&amp; Q, const Vector&amp; w) &#123; Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125;Vector Rotate(const Vector&amp; A, double rad) &#123; return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125;bool segmentProperIntersection(const Point&amp; a1, const Point&amp; a2, const Point&amp; b1, const Point&amp; b2) &#123; double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1); double c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0;&#125;bool onSegment(Point p, Point a1, Point a2) &#123; return dcmp(Cross(a1 - p, a2 - p)) == 0 &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt; 0;&#125;const int maxn = 300 + 10;Point p[maxn], v[maxn * maxn];int N;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while (scanf(\"%d\", &amp;N) == 1 &amp;&amp; N) &#123; printf(\"Case %d: \", ++kase); _for(i, 0, N) &#123; scanf(\"%lf%lf\", &amp;p[i].x, &amp;p[i].y); v[i] = p[i]; &#125; N--; int cnt = N, e = N; _for(i, 0, N) _for(j, i + 1, N) &#123; if(segmentProperIntersection(p[i], p[i + 1], p[j], p[j + 1])) &#123; v[cnt++] = getLineIntersection(p[i], p[i + 1] - p[i], p[j], p[j + 1] - p[j]); &#125; &#125; sort(v, v + cnt); cnt = unique(v, v + cnt) - v; //debug(cnt); _for(i, 0, cnt) _for(j, 0, N) &#123; if(onSegment(v[i], p[j], p[j + 1])) e++; &#125; printf(\"There are %d pieces.\\n\", e + 2 - cnt); &#125;&#125; 距离微分UVA11796 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119const double eps = 1e-10;int dcmp(double x) &#123; if(fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;class Point &#123;public: double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vector;bool operator&lt; (const Point&amp; lhs, const Point&amp; rhs) &#123; return lhs.x &lt; rhs.x || (lhs.x == rhs.x &amp;&amp; lhs.y &lt; rhs.y); &#125;bool operator== (const Point&amp; lhs, const Point&amp; rhs) &#123; return dcmp(lhs.x - rhs.x) == 0 &amp;&amp; dcmp(lhs.y - rhs.y) == 0; &#125;Vector operator+ (const Vector&amp; lhs, const Vector&amp; rhs) &#123; return Vector(lhs.x + rhs.x, lhs.y + rhs.y); &#125;Vector operator- (const Vector&amp; lhs, const Vector&amp; rhs) &#123; return Vector(lhs.x - rhs.x, lhs.y - rhs.y); &#125;Vector operator* (const Vector&amp; lhs, double p) &#123; return Vector(lhs.x * p, lhs.y * p); &#125;Vector operator/ (const Vector&amp; lhs, double p) &#123; return Vector(lhs.x / p, lhs.y / p); &#125;double Dot(const Vector&amp; A, const Vector&amp; B) &#123; return A.x * B.x + A.y * B.y; &#125;double Length(const Vector&amp; A) &#123; return sqrt(Dot(A, A)); &#125;double Angle(const Vector&amp; A, const Vector&amp; B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125;double Cross(const Vector&amp; A, const Vector&amp; B) &#123; return A.x * B.y - A.y * B.x; &#125;Point readPoint() &#123; double x, y; scanf(\"%lf%lf\", &amp;x, &amp;y); return Point(x, y);&#125;Point getLineIntersection(const Point&amp; P, const Vector&amp; v, const Point&amp; Q, const Vector&amp; w) &#123; Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125;Vector Rotate(const Vector&amp; A, double rad) &#123; return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125;bool segmentProperIntersection(const Point&amp; a1, const Point&amp; a2, const Point&amp; b1, const Point&amp; b2) &#123; double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1); double c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0;&#125;bool onSegment(Point p, Point a1, Point a2) &#123; return dcmp(Cross(a1 - p, a2 - p)) == 0 &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt; 0;&#125;double distanceToLine(const Point&amp; P, const Point&amp; A, const Point&amp; B) &#123; Vector v1 = B - A, v2 = P - A; return fabs(Cross(v1, v2)) / Length(v1);&#125;double distanceToSegment(const Point&amp; P, const Point&amp; A, const Point&amp; B) &#123; if(A == B) return Length(P - A); Vector v1 = B - A, v2 = P - A, v3 = P - B; if(dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if(dcmp(Dot(v1, v3) &gt; 0)) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);&#125;const int maxn = 50 + 10;const double inf = 1e9;int T, NA, NB;Point A[maxn], B[maxn];double Min, Max;void update(Point P, Point A, Point B) &#123; Min = min(Min, distanceToSegment(P, A, B)); Max = max(Max, Length(P - A)); Max = max(Max, Length(P - B));&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;T); _rep(kase, 1, T) &#123; printf(\"Case %d: \", kase); scanf(\"%d%d\", &amp;NA, &amp;NB); _for(i, 0, NA) A[i] = readPoint(); _for(i, 0, NB) B[i] = readPoint(); double lenA = 0, lenB = 0; _for(i, 0, NA - 1) lenA += Length(A[i + 1] - A[i]); _for(i, 0, NB - 1) lenB += Length(B[i + 1] - B[i]); int sa = 0, sb = 0; Point pa = A[0], pb = B[0]; Min = inf; Max = -inf; while (sa &lt; NA - 1 &amp;&amp; sb &lt; NB - 1) &#123; double La = Length(A[sa + 1] - pa); double Lb = Length(B[sb + 1] - pb); double t = min(La / lenA, Lb / lenB); Vector va = (A[sa + 1] - pa) / La * lenA * t; Vector vb = (B[sb + 1] - pb) / Lb * lenB * t; update(pa, pb, pb + vb - va); // pa = pa + delta_a pa = pa + va; pb = pb + vb; if(pa == A[sa + 1]) sa++; if(pb == B[sb + 1]) sb++; &#125; printf(\"%.0lf\\n\", Max - Min); &#125;&#125; 和圆有关的计算几何 UVA12304 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307const double eps = 1e-6;const double PI = acos(-1);int dcmp(double x) &#123; if(fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;class Point &#123;public: double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vector;bool operator&lt; (const Point&amp; lhs, const Point&amp; rhs) &#123; return lhs.x &lt; rhs.x || (lhs.x == rhs.x &amp;&amp; lhs.y &lt; rhs.y); &#125;bool operator== (const Point&amp; lhs, const Point&amp; rhs) &#123; return dcmp(lhs.x - rhs.x) == 0 &amp;&amp; dcmp(lhs.y - rhs.y) == 0; &#125;Vector operator+ (const Vector&amp; lhs, const Vector&amp; rhs) &#123; return Vector(lhs.x + rhs.x, lhs.y + rhs.y); &#125;Vector operator- (const Vector&amp; lhs, const Vector&amp; rhs) &#123; return Vector(lhs.x - rhs.x, lhs.y - rhs.y); &#125;Vector operator* (const Vector&amp; lhs, double p) &#123; return Vector(lhs.x * p, lhs.y * p); &#125;Vector operator/ (const Vector&amp; lhs, double p) &#123; return Vector(lhs.x / p, lhs.y / p); &#125;double Dot(const Vector&amp; A, const Vector&amp; B) &#123; return A.x * B.x + A.y * B.y; &#125;double Length(const Vector&amp; A) &#123; return sqrt(Dot(A, A)); &#125;double Angle(const Vector&amp; A, const Vector&amp; B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125;double Cross(const Vector&amp; A, const Vector&amp; B) &#123; return A.x * B.y - A.y * B.x; &#125;Point readPoint() &#123; double x, y; scanf(\"%lf%lf\", &amp;x, &amp;y); return Point(x, y);&#125;Point getLineIntersection(const Point&amp; P, const Vector&amp; v, const Point&amp; Q, const Vector&amp; w) &#123; Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125;Vector Rotate(const Vector&amp; A, double rad) &#123; return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125;bool segmentProperIntersection(const Point&amp; a1, const Point&amp; a2, const Point&amp; b1, const Point&amp; b2) &#123; double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1); double c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0;&#125;bool onSegment(Point p, Point a1, Point a2) &#123; return dcmp(Cross(a1 - p, a2 - p)) == 0 &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt; 0;&#125;double distanceToLine(const Point&amp; P, const Point&amp; A, const Point&amp; B) &#123; Vector v1 = B - A, v2 = P - A; return fabs(Cross(v1, v2)) / Length(v1);&#125;double distanceToSegment(const Point&amp; P, const Point&amp; A, const Point&amp; B) &#123; if(A == B) return Length(P - A); Vector v1 = B - A, v2 = P - A, v3 = P - B; if(dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if(dcmp(Dot(v1, v3) &gt; 0)) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);&#125;Vector Normal(Vector A) &#123; double L = Length(A); return Vector(-A.y / L, A.x / L);&#125;/***** solve circle problem *******/class Circle &#123;public: Point c; double r; Circle(Point c, double r) : c(c), r(r) &#123;&#125; Point point(double rad) &#123; return Point(c.x + r * cos(rad), c.y + r * sin(rad)); &#125;&#125;;class Line &#123;public: Point p; Vector v; Line(Point p, Vector v) : p(p), v(v) &#123;&#125; Point point(double t) &#123; return p + v * t; &#125; Line move(double d) &#123; return Line(p + Normal(v) * d, v); &#125;&#125;;double angle(Vector v) &#123; return atan2(v.y, v.x);&#125;int getLineCircleIntersection(Line L, Circle C, double&amp; t1, double&amp; t2, vector&lt;Point&gt;&amp; sol) &#123; double a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y; double e = a * a + c * c, f = 2 * (a * b + c * d), g = (b * b + d * d - C.r * C.r); double delta = f * f - 4 * e * g; if(dcmp(delta) &lt; 0) return 0; if(dcmp(delta) == 0) &#123; t1 = t2 = -f / (2 * e); sol.push_back(L.point(t1)); return 1; &#125; t1 = (-f - sqrt(delta)) / (2 * e); sol.push_back(L.point(t1)); t2 = (-f + sqrt(delta)) / (2 * e); sol.push_back(L.point(t2)); return 2;&#125;int getCircleCircleIntersection(Circle C1, Circle C2, vector&lt;Point&gt;&amp; sol) &#123; double d = Length(C1.c - C2.c); if(dcmp(d) == 0) &#123; if(dcmp(C1.r - C2.r) == 0) return -1; return 0; &#125; if(dcmp(C1.r + C2.r - d) &lt; 0) return 0; if(dcmp(fabs(C1.r - C2.r) - d) &gt; 0) return 0; double a = angle(C2.c - C1.c); double da = acos((C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d)); Point p1 = C1.point(a - da), p2 = C1.point(a + da); sol.push_back(p1); if(p1 == p2) return 1; sol.push_back(p2); return 2;&#125;// find circumscribedCircleCircle circumscribedCircle(Point p1, Point p2, Point p3) &#123; double Bx = p2.x - p1.x, By = p2.y - p1.y; double Cx = p3.x - p1.x, Cy = p3.y - p1.y; double D = 2 * (Bx * Cy - By * Cx); double cx = p1.x + (Cy * (Bx * Bx + By * By) - By * (Cx * Cx + Cy * Cy)) / D; double cy = p1.y + (Bx * (Cx * Cx + Cy * Cy) - Cx * (Bx * Bx + By * By)) / D; Point p = Point(cx, cy); return Circle(p, Length(p1 - p));&#125;// find inscribedCircleCircle inscribedCircle(Point p1, Point p2, Point p3) &#123; double a = Length(p2 - p3); double b = Length(p3 - p1); double c = Length(p1 - p2); Point p = (p1 * a + p2 * b + p3 * c) / (a + b + c); return Circle(p, distanceToLine(p, p1, p2));&#125;void format(const Circle&amp; C) &#123; printf(\"(%.6lf,%.6lf,%.6lf)\\n\", C.c.x, C.c.y, C.r);&#125;// formatting raddouble lineAngleDegree(const Vector&amp; v) &#123; double ang = angle(v) * 180.0 / PI; while (dcmp(ang) &lt; 0) ang += 360; while (dcmp(ang - 180) &gt;= 0) ang -= 180; return ang;&#125;// from one point p, get tangentsint getTangents(Point p, Circle C, Vector* v) &#123; Vector u = C.c - p; double dist = Length(u); if(dist &lt; C.r) return 0; else if(dcmp(dist - C.r) == 0) &#123; v[0] = Rotate(u, PI / 2); return 1; &#125; else &#123; double ang = asin(C.r / dist); v[0] = Rotate(u, -ang); v[1] = Rotate(u, ang); return 2; &#125;&#125;void format(vector&lt;double&gt;&amp; ans) &#123; int n = ans.size(); sort(ans.begin(), ans.end()); printf(\"[\"); if(n) &#123; printf(\"%.6lf\", ans[0]); _for(i, 1, n) printf(\",%.6lf\", ans[i]); &#125; printf(\"]\\n\");&#125;// CircleThroughAPointAndTangentToALineWithRadius// first we constructLineLine getLine(double x1, double y1, double x2, double y2) &#123; Point p1(x1, y1); Point p2(x2, y2); return Line(p1, p2 - p1);&#125;vector&lt;Point&gt; CircleThroughAPointAndTangentToALineWithRadius(Point p, Line L, double r) &#123; vector&lt;Point&gt; ans; double t1, t2; getLineCircleIntersection(L.move(-r), Circle(p, r), t1, t2, ans); getLineCircleIntersection(L.move(r), Circle(p, r), t1, t2, ans); //debug(ans.size()); return ans;&#125;void format(vector&lt;Point&gt; ans) &#123; int n = ans.size(); sort(ans.begin(), ans.end()); printf(\"[\"); if(n) &#123; printf(\"(%.6lf,%.6lf)\", ans[0].x, ans[0].y); _for(i, 1, n) printf(\",(%.6lf,%.6lf)\", ans[i].x, ans[i].y); &#125; printf(\"]\\n\");&#125;// CircleTangentToTwoLinesWithRadiusPoint getLineIntersection(Line a, Line b) &#123; return getLineIntersection(a.p, a.v, b.p, b.v);&#125;vector&lt;Point&gt; CircleTangentToTwoLinesWithRadius(Line a, Line b, double r) &#123; vector&lt;Point&gt; ans; Line L1 = a.move(-r), L2 = a.move(r); Line L3 = b.move(-r), L4 = b.move(r); ans.push_back(getLineIntersection(L1, L3)); ans.push_back(getLineIntersection(L1, L4)); ans.push_back(getLineIntersection(L2, L3)); ans.push_back(getLineIntersection(L2, L4)); return ans;&#125;// CircleTangentToTwoDisjointCirclesWithRadiusvector&lt;Point&gt; CircleTangentToTwoDisjointCirclesWithRadius(Circle c1, Circle c2, double r) &#123; vector&lt;Point&gt; ans; Vector vtmp = c2.c - c1.c; double dist = Length(vtmp); int d = dcmp(dist - c1.r - c2.r - 2 * r); if(d &gt; 0) return ans; getCircleCircleIntersection(Circle(c1.c, c1.r + r), Circle(c2.c, c2.r + r), ans); return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string cmd; while (cin &gt;&gt; cmd) &#123; double x1, y1, x2, y2, x3, y3, x4, y4, xp, yp, xc, yc, r1, r2, r; if(cmd == \"CircumscribedCircle\") &#123; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3; format(circumscribedCircle(Point(x1, y1), Point(x2, y2), Point(x3, y3))); &#125; if(cmd == \"InscribedCircle\") &#123; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3; format(inscribedCircle(Point(x1, y1), Point(x2, y2), Point(x3, y3))); &#125; if(cmd == \"TangentLineThroughPoint\") &#123; cin &gt;&gt; xc &gt;&gt; yc &gt;&gt; r &gt;&gt; xp &gt;&gt; yp; Vector vec[2]; vector&lt;double&gt; ans; int cnt = getTangents(Point(xp, yp), Circle(Point(xc, yc), r), vec); _for(i, 0, cnt) ans.push_back(lineAngleDegree(vec[i])); format(ans); &#125; if(cmd == \"CircleThroughAPointAndTangentToALineWithRadius\") &#123; cin &gt;&gt; xp &gt;&gt; yp &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; r; format(CircleThroughAPointAndTangentToALineWithRadius(Point(xp, yp), getLine(x1, y1, x2, y2), r)); &#125; if(cmd == \"CircleTangentToTwoLinesWithRadius\") &#123; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3 &gt;&gt; x4 &gt;&gt; y4 &gt;&gt; r; format(CircleTangentToTwoLinesWithRadius(getLine(x1, y1, x2, y2), getLine(x3, y3, x4, y4), r)); &#125; if(cmd == \"CircleTangentToTwoDisjointCirclesWithRadius\") &#123; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; r1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; r2 &gt;&gt; r; format(CircleTangentToTwoDisjointCirclesWithRadius(Circle(Point(x1, y1), r1), Circle(Point(x2, y2), r2), r)); &#125; &#125;&#125; 和圆弧有关的问题LA2572 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202const double eps = 5 * 1e-13;const double PI = acos(-1);const double PI2 = 2 * PI;int dcmp(double x) &#123; if(fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;class Point &#123;public: double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vector;bool operator&lt; (const Point&amp; lhs, const Point&amp; rhs) &#123; return lhs.x &lt; rhs.x || (lhs.x == rhs.x &amp;&amp; lhs.y &lt; rhs.y); &#125;bool operator== (const Point&amp; lhs, const Point&amp; rhs) &#123; return dcmp(lhs.x - rhs.x) == 0 &amp;&amp; dcmp(lhs.y - rhs.y) == 0; &#125;Vector operator+ (const Vector&amp; lhs, const Vector&amp; rhs) &#123; return Vector(lhs.x + rhs.x, lhs.y + rhs.y); &#125;Vector operator- (const Vector&amp; lhs, const Vector&amp; rhs) &#123; return Vector(lhs.x - rhs.x, lhs.y - rhs.y); &#125;Vector operator* (const Vector&amp; lhs, double p) &#123; return Vector(lhs.x * p, lhs.y * p); &#125;Vector operator/ (const Vector&amp; lhs, double p) &#123; return Vector(lhs.x / p, lhs.y / p); &#125;double Dot(const Vector&amp; A, const Vector&amp; B) &#123; return A.x * B.x + A.y * B.y; &#125;double Length(const Vector&amp; A) &#123; return sqrt(Dot(A, A)); &#125;double Angle(const Vector&amp; A, const Vector&amp; B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125;double Cross(const Vector&amp; A, const Vector&amp; B) &#123; return A.x * B.y - A.y * B.x; &#125;Point readPoint() &#123; double x, y; scanf(\"%lf%lf\", &amp;x, &amp;y); return Point(x, y);&#125;Point getLineIntersection(const Point&amp; P, const Vector&amp; v, const Point&amp; Q, const Vector&amp; w) &#123; Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125;Vector Rotate(const Vector&amp; A, double rad) &#123; return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125;bool segmentProperIntersection(const Point&amp; a1, const Point&amp; a2, const Point&amp; b1, const Point&amp; b2) &#123; double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1); double c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0;&#125;bool onSegment(Point p, Point a1, Point a2) &#123; return dcmp(Cross(a1 - p, a2 - p)) == 0 &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt; 0;&#125;double distanceToLine(const Point&amp; P, const Point&amp; A, const Point&amp; B) &#123; Vector v1 = B - A, v2 = P - A; return fabs(Cross(v1, v2)) / Length(v1);&#125;double distanceToSegment(const Point&amp; P, const Point&amp; A, const Point&amp; B) &#123; if(A == B) return Length(P - A); Vector v1 = B - A, v2 = P - A, v3 = P - B; if(dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if(dcmp(Dot(v1, v3) &gt; 0)) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);&#125;Vector Normal(Vector A) &#123; double L = Length(A); return Vector(-A.y / L, A.x / L);&#125;class Circle &#123;public: Point c; double r; Circle(Point c = &#123;0.0, 0.0&#125;, double r = 0.0) : c(c), r(r) &#123;&#125; Point point(double rad) &#123; return Point(c.x + r * cos(rad), c.y + r * sin(rad)); &#125;&#125;;typedef Circle Pan;class Line &#123;public: Point p; Vector v; Line(Point p, Vector v) : p(p), v(v) &#123;&#125; Point point(double t) &#123; return p + v * t; &#125; Line move(double d) &#123; return Line(p + Normal(v) * d, v); &#125;&#125;;double angle(Vector v) &#123; return atan2(v.y, v.x);&#125;int getLineCircleIntersection(Line L, Circle C, double&amp; t1, double&amp; t2, vector&lt;Point&gt;&amp; sol) &#123; double a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y; double e = a * a + c * c, f = 2 * (a * b + c * d), g = (b * b + d * d - C.r * C.r); double delta = f * f - 4 * e * g; if(dcmp(delta) &lt; 0) return 0; if(dcmp(delta) == 0) &#123; t1 = t2 = -f / (2 * e); sol.push_back(L.point(t1)); return 1; &#125; t1 = (-f - sqrt(delta)) / (2 * e); sol.push_back(L.point(t1)); t2 = (-f + sqrt(delta)) / (2 * e); sol.push_back(L.point(t2)); return 2;&#125;double Normalize(double rad, double base = PI) &#123; return rad - PI2 * floor((rad + PI - base) / PI2);&#125;void getCircleCircleIntersection(Circle C1, Circle C2, vector&lt;double&gt;&amp; rad) &#123; double d = Length(C1.c - C2.c); if(dcmp(d) == 0) &#123; return; &#125; if(dcmp(C1.r + C2.r - d) &lt; 0) return; if(dcmp(fabs(C1.r - C2.r) - d) &gt; 0) return; double a = angle(C2.c - C1.c); double da = acos((C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d)); rad.push_back(Normalize(a - da)); rad.push_back(Normalize(a + da));&#125;/** Now we solve the problem **/const int maxn = 100 + 5;int N;Pan pans[maxn];bool vis[maxn];void init() &#123; Set(vis, 0);&#125;int topmost(Point p) &#123; _forDown(i, N - 1, 0) &#123; if(Length(pans[i].c - p) &lt; pans[i].r) return i; &#125; return -1;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (cin &gt;&gt; N) &#123; if(!N) break; init(); _for(i, 0, N) &#123; double x, y, r; cin &gt;&gt; x &gt;&gt; y &gt;&gt; r; pans[i] = Circle(Point(x, y), r); assert(pans[i].r != 0); &#125; _for(k, 0, N) &#123; // first check circle circle intersection vector&lt;double&gt; rad; rad.push_back(0.0); rad.push_back(PI2); _for(i, 0, N) getCircleCircleIntersection(pans[k], pans[i], rad); sort(rad.begin(), rad.end()); // then check rad[i] adjacent to rad[i + 1] _for(i, 0, rad.size() - 1) &#123; double mid = (rad[i] + rad[i + 1]) / 2.0; for(int dr = -1; dr &lt;= 1; dr += 2) &#123; double r2 = pans[k].r - dr * eps; int t = topmost(Point(pans[k].c.x + r2 * cos(mid), pans[k].c.y + r2 * sin(mid))); if(t &gt;= 0) vis[t] = true; &#125; &#125; &#125; int ans = 0; _for(i, 0, N) if(vis[i]) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 点在多边形内的判定 凸包","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"计算几何","slug":"计算几何","permalink":"https://www.fogsail.net/tags/计算几何/"}]},{"title":"动态规划专题(四)","slug":"20191025","date":"2019-10-25T07:49:36.000Z","updated":"2019-11-02T11:04:26.897Z","comments":true,"path":"2019/10/25/20191025/","link":"","permalink":"https://www.fogsail.net/2019/10/25/20191025/","excerpt":"本节内容主要写了一些普通dp的实践大多数不涉及dp的优化包括线性dp，树形dp，图上的dp等等","text":"本节内容主要写了一些普通dp的实践大多数不涉及dp的优化包括线性dp，树形dp，图上的dp等等 线性dp的单点增加思想LA5841 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const int maxn = 5000 + 10;char p[maxn], q[maxn];const int inf = 0x3f3f3f3f;int f[2][maxn], cnt[2][maxn];int N, M;int sp[256 + 5], ep[256 + 5], sq[256 + 5], eq[256 + 5];int k = 0;void init() &#123; Set(sp, inf); Set(sq, inf); Set(ep, 0); Set(eq, 0); N = strlen(p + 1); M = strlen(q + 1); _rep(i, 1, N) &#123; sp[p[i]] = min(sp[p[i]], i); ep[p[i]] = i; //debug(ep[p[i]]); &#125; _rep(i, 1, M) &#123; sq[q[i]] = min(sq[q[i]], i); eq[q[i]] = i; &#125;&#125;void initdp() &#123; Set(f, 0); Set(cnt, 0); k = 0;&#125;void dp() &#123; _rep(i, 0, N) &#123; _rep(j, 0, M) &#123; // if(i == 0 &amp;&amp; j == 0) continue; int v1 = inf, v2 = inf; if(i) v1 = f[k ^ 1][j] + cnt[k ^ 1][j]; if(j) v2 = f[k][j - 1] + cnt[k][j - 1]; f[k][j] = min(v1, v2); if(i) &#123; // Move p[i] cnt[k][j] = cnt[k ^ 1][j]; if(i == sp[p[i]] &amp;&amp; j &lt; sq[p[i]]) cnt[k][j]++; if(i == ep[p[i]] &amp;&amp; j &gt;= eq[p[i]]) cnt[k][j]--; &#125; else if(j) &#123; // Move q[j] cnt[k][j] = cnt[k][j - 1]; if(j == sq[q[j]] &amp;&amp; i &lt; sp[q[j]]) cnt[k][j]++; if(j == eq[q[j]] &amp;&amp; i &gt;= ep[q[j]]) cnt[k][j]--; &#125; &#125; k ^= 1; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s\", p + 1); scanf(\"%s\", q + 1); init(); //debug(p[1]); //debug(ep['A']); assert(ep[p[1]] != 0); initdp(); dp(); printf(\"%d\\n\", f[k ^ 1][M]); &#125;&#125; 其他水题UVA11584 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const int maxn = 1000 + 10;const int inf = 0x3f;char str[maxn];int vis[maxn][maxn];int pali[maxn][maxn];int N;void init() &#123; // Set(vis, 0); Set(pali, 0);&#125;int f[maxn];void initdp() &#123; N = strlen(str + 1); Set(f, inf); f[0] = 0; _rep(i, 1, N) f[i] = i;&#125;int isPali(int i, int j) &#123; if(i &gt;= j) return 1; if(str[i] != str[j]) return 0; if(vis[i][j]) return pali[i][j]; vis[i][j] = true; return pali[i][j] = isPali(i + 1, j - 1);&#125;void dp() &#123; _rep(i, 1, N) _for(j, 0, i) &#123; if(isPali(j + 1, i)) f[i] = min(f[i], f[j] + 1); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; init(); scanf(\"%s\", str + 1); initdp(); dp(); printf(\"%d\\n\", f[N]); &#125;&#125; UVA11400 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int maxn = 1000 + 10;const int inf = 0x3f;int N;int f[maxn];class Light &#123;public: int V; int K; int C; int L; bool operator&lt; (const Light&amp; rhs) const &#123; return V &lt; rhs.V; &#125;&#125;;Light l[maxn];int sum[maxn];void initdp() &#123; sort(l + 1, l + 1 + N); Set(f, inf); Set(sum, 0); f[0] = 0; _rep(i, 1, N) sum[i] = sum[i - 1] + l[i].L;&#125;void dp() &#123; _rep(i, 1, N) &#123; _rep(j, 0, i - 1) f[i] = min(f[i], f[j] + (sum[i] - sum[j]) * l[i].C + l[i].K); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;N) &amp;&amp; N) &#123; _rep(i, 1, N) scanf(\"%d%d%d%d\", &amp;l[i].V, &amp;l[i].K, &amp;l[i].C, &amp;l[i].L); initdp(); dp(); cout &lt;&lt; f[N] &lt;&lt; endl; &#125;&#125; 重点讲讲fgets的用法注意事项1 12345fgets(char* str, int maxn, stdin);最多读取的大小是maxn - 1的大小，因为字符串是以'\\0'结尾的当输入的数据大于maxn指定的大小的时候，fgets()会读取maxn - 1个字符预留1个字符存储'\\n' 注意事项2 12345678'\\n'也仅仅是一个普通字符，也会存入数组中也就是说，如果你输入的字符长度n &lt; maxnfgets()存储str的内存地址开始，往后第n + 2个字节后面会多出来'\\n'和'\\0'str[0, N + 1]存储'xxx \\n\\0'str[N + 2, maxn]全部被'\\0'填充 fgets()会存储换行符’\\n’进入str[]中123456也就是说，如果n &lt; maxnlen = strlen(str) - 1才是字符串长度或者人为处理if(str[strlen(str) - 1] == '\\n') str[strlen(str) - 1] = '\\0';n = strlen(str); 注意事项3 123fgets()只是读取读取到的字节会覆盖原地址的存储没有覆盖到的保持原样 注意事项4 12345fgets()如果读取n &gt; maxn的数据只能在str[]中存储maxn - 1个字符而多余的字符残留在缓存中下一次输入必须要清空缓存 记忆化搜索和递推水题(模版题)UVA10003 123456789101112131415161718192021222324252627282930313233343536const int maxn = 50 + 5;int A[maxn];int f[maxn][maxn], vis[maxn][maxn];int N, L;void init() &#123; Set(f, 0); Set(vis, 0); A[0] = 0; A[N + 1] = L;&#125;int dp(int i, int j) &#123; if(i &gt;= j - 1) return 0; if(vis[i][j]) return f[i][j]; vis[i][j] = 1; int&amp; ans = f[i][j]; ans = -1; _rep(k, i + 1, j - 1) &#123; int v = dp(i, k) + dp(k, j) + A[j] - A[i]; if(ans &lt; 0 || v &lt; ans) ans = v; &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;L, &amp;N) == 2 &amp;&amp; L) &#123; init(); _rep(i, 1, N) scanf(\"%d\", &amp;A[i]); printf(\"The minimum cutting is %d.\\n\", dp(0, N + 1)); &#125;&#125; 括号序列LA2451 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const int maxn = 100 + 5;int f[maxn][maxn];int N;char str[maxn];void init() &#123; N = strlen(str);&#125;void initdp() &#123; Set(f, -1); _for(i, 0, N) &#123; f[i + 1][i] = 0; f[i][i] = 1; &#125;&#125;bool match(char a, char b) &#123; return (a == '(' &amp;&amp; b == ')') || (a == '[' &amp;&amp; b == ']');&#125;void dp() &#123; for(int i = N - 2; i &gt;= 0; i--) &#123; _for(j, i + 1, N) &#123; f[i][j] = N; if(match(str[i], str[j])) f[i][j] = min(f[i][j], f[i + 1][j - 1]); _for(k, i, j) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); &#125; &#125;&#125;void print(int i, int j) &#123; if(i &gt; j) return; if(i == j) &#123; if(str[i] == '(' || str[i] == ')') printf(\"()\"); else printf(\"[]\"); return; &#125; if(match(str[i], str[j]) &amp;&amp; f[i][j] == f[i + 1][j - 1]) &#123; printf(\"%c\", str[i]); print(i + 1, j - 1); printf(\"%c\", str[j]); return; &#125; _for(k, i, j) &#123; if(f[i][j] == f[i][k] + f[k + 1][j]) &#123; print(i, k); print(k + 1, j); return; &#125; &#125;&#125;void read(char* str) &#123; fgets(str, maxn, stdin);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); getchar(); while (T--) &#123; read(str); read(str); if(str[strlen(str) - 1] == '\\n') str[strlen(str) - 1] = '\\0'; init(); //debug(N); initdp(); dp(); print(0, N - 1); cout &lt;&lt; endl; if(T) cout &lt;&lt; endl; &#125;&#125; 和计算几何有关的dp以上算法的状态转移方程归纳如下 LA3132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235// computation Geometry headerconst double eps = 1e-10;const double PI = acos(-1);const double PI2 = 2 * PI;int dcmp(double x) &#123; if(fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;class Point &#123;public: double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vector;bool operator&lt; (const Point&amp; lhs, const Point&amp; rhs) &#123; return lhs.x &lt; rhs.x || (lhs.x == rhs.x &amp;&amp; lhs.y &lt; rhs.y); &#125;bool operator== (const Point&amp; lhs, const Point&amp; rhs) &#123; return dcmp(lhs.x - rhs.x) == 0 &amp;&amp; dcmp(lhs.y - rhs.y) == 0; &#125;Vector operator+ (const Vector&amp; lhs, const Vector&amp; rhs) &#123; return Vector(lhs.x + rhs.x, lhs.y + rhs.y); &#125;Vector operator- (const Vector&amp; lhs, const Vector&amp; rhs) &#123; return Vector(lhs.x - rhs.x, lhs.y - rhs.y); &#125;Vector operator* (const Vector&amp; lhs, double p) &#123; return Vector(lhs.x * p, lhs.y * p); &#125;Vector operator/ (const Vector&amp; lhs, double p) &#123; return Vector(lhs.x / p, lhs.y / p); &#125;double Dot(const Vector&amp; A, const Vector&amp; B) &#123; return A.x * B.x + A.y * B.y; &#125;double Length(const Vector&amp; A) &#123; return sqrt(Dot(A, A)); &#125;double Angle(const Vector&amp; A, const Vector&amp; B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125;double Cross(const Vector&amp; A, const Vector&amp; B) &#123; return A.x * B.y - A.y * B.x; &#125;Point readPoint() &#123; double x, y; scanf(\"%lf%lf\", &amp;x, &amp;y); return Point(x, y);&#125;Point getLineIntersection(const Point&amp; P, const Vector&amp; v, const Point&amp; Q, const Vector&amp; w) &#123; Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125;Vector Rotate(const Vector&amp; A, double rad) &#123; return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125;bool segmentProperIntersection(const Point&amp; a1, const Point&amp; a2, const Point&amp; b1, const Point&amp; b2) &#123; double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1); double c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0;&#125;bool onSegment(Point p, Point a1, Point a2) &#123; return dcmp(Cross(a1 - p, a2 - p)) == 0 &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt; 0;&#125;double distanceToLine(const Point&amp; P, const Point&amp; A, const Point&amp; B) &#123; Vector v1 = B - A, v2 = P - A; return fabs(Cross(v1, v2)) / Length(v1);&#125;double distanceToSegment(const Point&amp; P, const Point&amp; A, const Point&amp; B) &#123; if(A == B) return Length(P - A); Vector v1 = B - A, v2 = P - A, v3 = P - B; if(dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if(dcmp(Dot(v1, v3) &gt; 0)) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);&#125;Vector Normal(Vector A) &#123; double L = Length(A); return Vector(-A.y / L, A.x / L);&#125;class Circle &#123;public: Point c; double r; Circle(Point c = &#123;0.0, 0.0&#125;, double r = 0.0) : c(c), r(r) &#123;&#125; Point point(double rad) &#123; return Point(c.x + r * cos(rad), c.y + r * sin(rad)); &#125;&#125;;typedef Circle Pan;class Line &#123;public: Point p; Vector v; Line(Point p, Vector v) : p(p), v(v) &#123;&#125; Point point(double t) &#123; return p + v * t; &#125; Line move(double d) &#123; return Line(p + Normal(v) * d, v); &#125;&#125;;double angle(Vector v) &#123; return atan2(v.y, v.x);&#125;int getLineCircleIntersection(Line L, Circle C, double&amp; t1, double&amp; t2, vector&lt;Point&gt;&amp; sol) &#123; double a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y; double e = a * a + c * c, f = 2 * (a * b + c * d), g = (b * b + d * d - C.r * C.r); double delta = f * f - 4 * e * g; if(dcmp(delta) &lt; 0) return 0; if(dcmp(delta) == 0) &#123; t1 = t2 = -f / (2 * e); sol.push_back(L.point(t1)); return 1; &#125; t1 = (-f - sqrt(delta)) / (2 * e); sol.push_back(L.point(t1)); t2 = (-f + sqrt(delta)) / (2 * e); sol.push_back(L.point(t2)); return 2;&#125;double Normalize(double rad, double base = PI) &#123; return rad - PI2 * floor((rad + PI - base) / PI2);&#125;void getCircleCircleIntersection(Circle C1, Circle C2, vector&lt;double&gt;&amp; rad) &#123; double d = Length(C1.c - C2.c); if(dcmp(d) == 0) &#123; return; &#125; if(dcmp(C1.r + C2.r - d) &lt; 0) return; if(dcmp(fabs(C1.r - C2.r) - d) &gt; 0) return; double a = angle(C2.c - C1.c); double da = acos((C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d)); rad.push_back(Normalize(a - da)); rad.push_back(Normalize(a + da));&#125;typedef vector&lt;Point&gt; Polygon;int isPointInPolygon(const Point&amp; p, const Polygon&amp; poly) &#123; int n = poly.size(); int wn = 0; _for(i, 0, n) &#123; const Point&amp; p1 = poly[i]; const Point&amp; p2 = poly[(i+1) % n]; if(p1 == p || p2 == p || onSegment(p, p1, p2)) return -1; int k = dcmp(Cross(p2 - p1, p - p1)); int d1 = dcmp(p1.y - p.y);; int d2 = dcmp(p2.y - p.y); if(k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) wn++; if(k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) wn--; &#125; if(wn != 0) return 1; return 0;&#125;// poly[a], poly[b]// (poly[a], poly[b]) is diagonalbool isDiagonal(const Polygon&amp; poly, int a, int b) &#123; int n = poly.size(); _for(i, 0, n) &#123; if(i != a &amp;&amp; i != b &amp;&amp; onSegment(poly[i], poly[a], poly[b])) return false; &#125; _for(i, 0, n) &#123; if(segmentProperIntersection(poly[i], poly[(i+1) % n], poly[a], poly[b])) return false; &#125; Point midp = (poly[a] + poly[b]) * 0.5; return isPointInPolygon(midp, poly) == 1;&#125;// then solve the problemconst int maxn = 100 + 5;const int inf = 1e9;double f[maxn][maxn];void initdp(const Polygon&amp; poly) &#123; int n = poly.size(); _for(i, 0, n) _for(j, 0, n) f[i][j] = -1;&#125;double dp(const Polygon&amp; poly) &#123; int n = poly.size(); _forDown(i, n - 2, 0) _for(j, i + 1, n) &#123; if(i + 1 == j) f[i][j] = 0; else if(!(i == 0 &amp;&amp; j == n - 1) &amp;&amp; !isDiagonal(poly, i, j)) f[i][j] = inf; else &#123; f[i][j] = inf; _for(k, i + 1, j) &#123; double m = max(f[i][k], f[k][j]); double area = fabs(Cross(poly[j] - poly[i], poly[k] - poly[i])) * 0.5; m = max(m, area); f[i][j] = min(f[i][j], m); &#125; &#125; &#125; return f[0][n - 1];&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T, N; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;N); double x, y; Polygon poly; _for(i, 0, N) &#123; scanf(\"%lf%lf\", &amp;x, &amp;y); poly.push_back(Point(x, y)); &#125; assert(poly.size() &gt; 0); initdp(poly); printf(\"%.1lf\\n\", dp(poly)); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"https://www.fogsail.net/tags/dp/"}]},{"title":"动态规划专题(三)","slug":"20191022","date":"2019-10-22T06:58:25.000Z","updated":"2019-10-25T07:01:45.265Z","comments":true,"path":"2019/10/22/20191022/","link":"","permalink":"https://www.fogsail.net/2019/10/22/20191022/","excerpt":"这篇文章主要介绍背包问题和区间dp问题","text":"这篇文章主要介绍背包问题和区间dp问题 多重背包多重背包常见的优化有二进制拆分还有单调队列优化 POJ1742 123456789101112131415161718192021222324252627282930313233343536373839404142const int maxm = 100000 + 5, maxn = 1000 + 5;int A[maxn], C[maxn];int N2 = 1;int N, M;bitset&lt;maxm&gt; f;void initdp() &#123; N2 = 1; f &amp;= 1; f[0] = 1;&#125;int dp() &#123; _rep(i, 1, N) &#123; for(int p = 1; p &lt;= C[i]; p &lt;&lt;= 1) &#123; // f |= (f &lt;&lt; (p * A[i])); C[i] -= p; &#125; if(C[i]) f |= (f &lt;&lt; (C[i] * A[i])); &#125; int ans = 0; _rep(i, 1, M) if(f[i]) ans += f[i]; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;N, &amp;M) == 2 &amp;&amp; N) &#123; _rep(i, 1, N) scanf(\"%d\", &amp;A[i]); _rep(i, 1, N) scanf(\"%d\", &amp;C[i]); // then dp initdp(); cout &lt;&lt; dp() &lt;&lt; endl; &#125;&#125; 分组背包 区间dp分析方法和模版 CH5301本例作为模版 123456789101112131415161718192021222324252627282930313233343536373839const int maxn = 300 + 5;const int inf = 0x3f;int A[maxn];int N;int f[maxn][maxn];int sum[maxn];void initdp() &#123; Set(sum, 0); Set(f, inf); _rep(i, 1, N) &#123; sum[i] = sum[i - 1] + A[i]; assert(sum[i] != 0); f[i][i] = 0; &#125;&#125;void dp() &#123; _rep(len, 2, N) _rep(l, 1, N - len + 1) &#123; int r = l + len - 1; for(int k = l; k &lt; r; k++) f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r]); f[l][r] += (sum[r] - sum[l - 1]); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;N); _rep(i, 1, N) &#123; scanf(\"%d\", &amp;A[i]); //debug(A[i]); &#125; initdp(); dp(); printf(\"%d\\n\", f[1][N]);&#125; POJ1179 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const int maxn = 100 + 5;const int inf = 0x3f3f3f3f;struct Node &#123; int x; char op;&#125;;Node nodes[maxn];int Fmax[maxn][maxn], Fmin[maxn][maxn];int N;void initdp() &#123; Set(Fmax, -inf); Set(Fmin, inf); _rep(i, 1, (N &lt;&lt; 1)) &#123; Fmax[i][i] = Fmin[i][i] = nodes[i].x; assert(Fmax[i][i] != -inf &amp;&amp; Fmin[i][i] != inf); &#125;&#125;void dp() &#123; _rep(len, 2, N) &#123; for(int l = 1; l + len - 1 &lt;= (N &lt;&lt; 1); l++) &#123; int r = l + len - 1; _rep(k, l + 1, r) &#123; if(nodes[k].op == 't') &#123; // update Fmax and Fmin Fmax[l][r] = max(Fmax[l][r], Fmax[l][k - 1] + Fmax[k][r]); Fmin[l][r] = min(Fmin[l][r], Fmin[l][k - 1] + Fmin[k][r]); &#125; else &#123; // update Fmax and Fmin, much more complicate Fmax[l][r] = max(Fmax[l][r], max(Fmax[l][k - 1] * Fmax[k][r], Fmin[l][k - 1] * Fmin[k][r])); Fmin[l][r] = min(Fmin[l][r], min(Fmin[l][k - 1] * Fmin[k][r], min(Fmax[l][k - 1] * Fmax[k][r], min(Fmin[l][k - 1] * Fmax[k][r], Fmax[l][k - 1] * Fmin[k][r])))); &#125; &#125; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;N); _rep(i, 1, N) &#123; int x; char op; cin &gt;&gt; op &gt;&gt; x; nodes[i].op = op; nodes[i].x = x; //debug(nodes[i].x); &#125; _rep(i, N + 1, (N &lt;&lt; 1)) &#123; nodes[i] = nodes[i - N]; assert(nodes[i].x == nodes[i - N].x &amp;&amp; nodes[i].op == nodes[i - N].op); &#125; initdp(); dp(); int ans = -inf; _rep(i, 1, N) ans = max(ans, Fmax[i][i + N - 1]); cout &lt;&lt; ans &lt;&lt; endl; _rep(i, 1, N) if(Fmax[i][i + N - 1] == ans) cout &lt;&lt; i &lt;&lt; \" \";&#125; 区间dp的递归算法和记忆化搜索CH5302 1234567891011121314151617181920212223242526272829303132333435const int maxn = 300 + 5;const int MOD = 1000000000;char str[maxn];int N;int f[maxn][maxn];void initdp() &#123; Set(f, -1);&#125;int dp(int l, int r) &#123; if(l &gt; r) return 0; if(l == r) return 1; int&amp; ans = f[l][r]; if(ans != -1) return ans; ans = 0; if(str[l] == str[r]) &#123; for(int k = l + 2; k &lt;= r; k++) &#123; ans = (ans + (llong)dp(l + 1, k - 1) * (llong)dp(k, r)) % MOD; &#125; &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%s\", str + 1); N = strlen(str + 1); initdp(); cout &lt;&lt; dp(1, N) &lt;&lt; endl;&#125; 树形dp模版题CH5401 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int maxn = 6000 + 5;int H[maxn];bool hasFa[maxn];int f[maxn][2];vector&lt;int&gt; son[maxn];int N;void initdp() &#123; Set(f, 0);&#125;void dp(int x) &#123; f[x][1] = H[x]; f[x][0] = 0; _for(i, 0, son[x].size()) &#123; int y = son[x][i]; dp(y); f[x][0] += max(f[y][0], f[y][1]); f[x][1] += f[y][0]; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; N; _rep(i, 1, N) scanf(\"%d\", &amp;H[i]); _for(i, 0, N) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); hasFa[x] = 1; son[y].push_back(x); &#125; int root = 0; _rep(i, 1, N) if(!hasFa[i]) &#123; root = i; break; &#125; assert(root != 0); initdp(); // then dp dp(root); cout &lt;&lt; max(f[root][0], f[root][1]) &lt;&lt; endl;&#125; 树形dp和背包综合CH5402 12345678910111213141516171819202122232425262728293031323334353637383940414243const int maxn = 300 + 5;int score[maxn];vector&lt;int&gt; son[maxn];int N, M;int f[maxn][maxn];const int inf = 0xcf;void initdp() &#123; Set(f, inf);&#125;void dp(int x) &#123; f[x][0] = 0; _for(i, 0, son[x].size()) &#123; int y = son[x][i]; dp(y); _forDown(t, M, 0) &#123; _forDown(j, t, 0) &#123; if(t - j &lt; 0) continue; f[x][t] = max(f[x][t], f[x][t - j] + f[y][j]); &#125; &#125; &#125; if(x) for(int t = M; t &gt; 0; t--) f[x][t] = f[x][t - 1] + score[x];&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; N &gt;&gt; M; _rep(i, 1, N) &#123; int x; cin &gt;&gt; x &gt;&gt; score[i]; son[x].push_back(i); &#125; initdp(); dp(0); cout &lt;&lt; f[0][M] &lt;&lt; endl;&#125; 树形dp, 二次扫描与换根POJ3585 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108const int maxn = 200000 + 10;const int inf = 0x3f;int N;class Graph &#123;public: int tot; int head[maxn], ver[maxn * 2], nxt[maxn * 2]; int w[maxn * 2]; void clear() &#123; tot = 1; Set(head, 0); Set(ver, 0); Set(nxt, 0); Set(w, 0); &#125; void add(int x, int y, int z) &#123; ver[++tot] = y; w[tot] = z; nxt[tot] = head[x]; head[x] = tot; &#125;&#125;;Graph G;int deg[maxn], vis[maxn];int ds[maxn], f[maxn];void init() &#123; G.clear(); Set(deg, 0); Set(vis, 0); Set(ds, 0); Set(f, 0);&#125;void dp(int x) &#123; assert(vis[x] == 0); ds[x] = 0; vis[x] = 1; for(int i = G.head[x]; i; i = G.nxt[i]) &#123; int y = G.ver[i]; if(vis[y]) continue; dp(y); if(deg[y] == 1) ds[x] += G.w[i]; else ds[x] += min(G.w[i], ds[y]); &#125;&#125;void initdfs(int root) &#123; Set(vis, 0); f[root] = ds[root];&#125;void dfs(int x) &#123; vis[x] = 1; for(int i = G.head[x]; i; i = G.nxt[i]) &#123; int y = G.ver[i]; if(vis[y]) continue; int flow = min(ds[y], G.w[i]); if(deg[x] == 1) f[y] = ds[y] + G.w[i]; else &#123; f[y] = ds[y] + min(G.w[i], f[x] - flow); &#125; dfs(y); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; init(); scanf(\"%d\", &amp;N); _for(i, 1, N) &#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); G.add(x, y, z); G.add(y, x, z); deg[x]++; deg[y]++; &#125; // then dp int root = 1; dp(root); initdfs(root); dfs(root); int ans = 0; _rep(i, 1, N) ans = max(ans, f[i]); cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"https://www.fogsail.net/tags/dp/"}]},{"title":"动态规划专题(二)","slug":"20191017","date":"2019-10-16T23:12:00.000Z","updated":"2019-10-21T15:40:59.584Z","comments":true,"path":"2019/10/17/20191017/","link":"","permalink":"https://www.fogsail.net/2019/10/17/20191017/","excerpt":"这篇文章主要介绍线性结构上的动态规划","text":"这篇文章主要介绍线性结构上的动态规划 线性结构上的动态规划利用线性相关，线性无关，减少dp维度 CH5103 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const int maxn = 50 + 10;int A[maxn][maxn];int M, N;int F[maxn * 2][maxn][maxn];void init() &#123; // Set(A, 0);&#125;void initDP() &#123; // Set(F, -1); F[0][1][1] = A[1][1];&#125;void dp() &#123; // _for(i, 0, M + N - 2) &#123; for(int x1 = 1; x1 &lt;= M &amp;&amp; x1 &lt;= i + 1; x1++) &#123; int y1 = i + 2 - x1; for(int x2 = 1; x2 &lt;= M &amp;&amp; x2 &lt;= i + 1; x2++) &#123; int y2 = i + 2 - x2; // both right, both down if(x1 == x2) &#123; F[i + 1][x1][x2] = max(F[i + 1][x1][x2], F[i][x1][x2] + A[x1][y1 + 1]); F[i + 1][x1 + 1][x2 + 1] = max(F[i + 1][x1 + 1][x2 + 1], F[i][x1][x2] + A[x1 + 1][y1]); &#125; else &#123; F[i + 1][x1][x2] = max(F[i + 1][x1][x2], F[i][x1][x2] + A[x1][y1 + 1] + A[x2][y2 + 1]); F[i + 1][x1 + 1][x2 + 1] = max(F[i + 1][x1 + 1][x2 + 1], F[i][x1][x2] + A[x1 + 1][y1] + A[x2 + 1][y2]); &#125; // x1 down, x2 right if(x2 == x1 + 1) &#123; F[i + 1][x1 + 1][x2] = max(F[i + 1][x1 + 1][x2], F[i][x1][x2] + A[x1 + 1][y1]); &#125; else F[i + 1][x1 + 1][x2] = max(F[i + 1][x1 + 1][x2], F[i][x1][x2] + A[x1 + 1][y1] + A[x2][y2 + 1]); // x1 right, x2 down if(x1 == x2 + 1) &#123; F[i + 1][x1][x2 + 1] = max(F[i + 1][x1][x2 + 1], F[i][x1][x2] + A[x1][y1 + 1]); &#125; else F[i + 1][x1][x2 + 1] = max(F[i + 1][x1][x2 + 1], F[i][x1][x2] + A[x1][y1 + 1] + A[x2 + 1][y2]); &#125; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); scanf(\"%d%d\", &amp;M, &amp;N); _rep(i, 1, M) _rep(j, 1, N) scanf(\"%d\", &amp;A[i][j]); // then initDP() and dp() initDP(); dp(); cout &lt;&lt; F[N + M - 2][M][M] &lt;&lt; endl;&#125; 状态机处理线性dp(状态压缩)SGU167 需要执行方案输出怎么办？建立一个状态 12345678910111213struct Status &#123; int i, k, l, r, dl, dr;&#125;;// used to print pathStatus pre[maxn][maxn * maxn][maxn][maxn][2][2];// 在dp的时候const int last = f[i - 1][k - (r - l + 1)][p][q][1][0];if(maxv1 &lt; last) &#123; maxv1 = last; _pre1 = &#123;i - 1, k - (r - l + 1), p, q, 1, 0&#125;; //debug(_pre1.k);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144const int maxn = 15 + 1;const int MOD = 16;const int maxk = 225 + 1;int N, M, K;int A[maxn][maxn];int f[maxn][maxk][maxn][maxn][2][2];int pre[maxn][maxk][maxn][maxn][2][2];int code(int l, int r, int dl, int dr) &#123; return (l &lt;&lt; 12) + (r &lt;&lt; 8) + (dl &lt;&lt; 4) + dr;&#125;void decode(const int val, int&amp; l, int&amp; r, int&amp; dr, int&amp; dl) &#123; l = (val &gt;&gt; 12) % MOD; r = (val &gt;&gt; 8) % MOD; dr = (val &gt;&gt; 4) % MOD; dl = (val) % MOD;&#125;void initDP() &#123; Set(f, 0); Set(pre, 0);&#125;int dp(int&amp; ans, int&amp; fi) &#123; initDP(); _rep(i, 1, N) _rep(k, 1, K) _rep(l, 1, M) _rep(r, 1, M) &#123; if(k &lt; (r - l + 1)) continue; // (spand, spand) int&amp; _f1 = f[i][k][l][r][1][0]; int&amp; _pre1 = pre[i][k][l][r][1][0]; int maxv1 = 0; _rep(p, l, r) _rep(q, p, r) &#123; const int last = f[i - 1][k - (r - l + 1)][p][q][1][0]; if(maxv1 &lt; last) &#123; maxv1 = last; //_pre1 = &#123;i - 1, k - (r - l + 1), p, q, 1, 0&#125;; //debug(_pre1.k); //_pre1 = code(p, q, 1, 0); _pre1 = (p &lt;&lt; 12) + (q &lt;&lt; 8) + (1 &lt;&lt; 4) + 0; &#125; &#125; _rep(j, l, r) maxv1 += A[i][j]; _f1 = maxv1; // (spand, shrink) int&amp; _f2 = f[i][k][l][r][1][1]; int&amp; _pre2 = pre[i][k][l][r][1][1]; int maxv2 = 0; _rep(p, l, r) _rep(q, r, M) _for(dr, 0, 2) &#123; const int last = f[i - 1][k - (r - l + 1)][p][q][1][dr]; if(maxv2 &lt; last) &#123; maxv2 = last; //_pre2 = code(p, q, 1, dr); //debug(_pre2.k); _pre2 = (p &lt;&lt; 12) + (q &lt;&lt; 8) + (1 &lt;&lt; 4) + dr; &#125; &#125; _rep(j, l, r) maxv2 += A[i][j]; _f2 = maxv2; // (shrink, spand) int&amp; _f3 = f[i][k][l][r][0][0]; int&amp; _pre3 = pre[i][k][l][r][0][0]; int maxv3 = 0; _rep(p, 1, l) _rep(q, l, r) _for(dl, 0, 2) &#123; const int last = f[i - 1][k - (r - l + 1)][p][q][dl][0]; if(maxv3 &lt; last) &#123; maxv3 = last; //_pre3 = code(p, q, dl, 0); //debug(_pre3.k); _pre3 = (p &lt;&lt; 12) + (q &lt;&lt; 8) + (dl &lt;&lt; 4) + 0; &#125; &#125; _rep(j, l, r) maxv3 += A[i][j]; _f3 = maxv3; // (shrink, shrink) int&amp; _f4 = f[i][k][l][r][0][1]; int&amp; _pre4 = pre[i][k][l][r][0][1]; int maxv4 = 0; _rep(p, 1, l) _rep(q, r, M) _for(dl, 0, 2) _for(dr, 0, 2) &#123; const int last = f[i - 1][k - (r - l + 1)][p][q][dl][dr]; if(maxv4 &lt; last) &#123; maxv4 = last; //_pre4 = code(p, q, dl, dr); //debug(_pre4.k); _pre4 = (p &lt;&lt; 12) + (q &lt;&lt; 8) + (dl &lt;&lt; 4) + dr; &#125; &#125; _rep(j, l, r) maxv4 += A[i][j]; _f4 = maxv4; &#125; // then get ret; int ret = 0; _rep(i, 1, N) _rep(l, 1, M) _rep(r, l, M) _for(dl, 0, 2) _for(dr, 0, 2) &#123; if(ret &lt; f[i][K][l][r][dl][dr]) &#123; ret = f[i][K][l][r][dl][dr]; //ans = &#123;i, K, l, r, dl, dr&#125;; // ans = code(l, r, dl, dr); ans = (l &lt;&lt; 12) + (r &lt;&lt; 8) + (dl &lt;&lt; 4) + dr; fi = i; &#125; &#125; return ret;&#125;void printAns(int ans, int row, int K) &#123; if(row == 0 || K &lt;= 0) return; int al, ar, adl, adr; //decode(ans, al, ar, adl, adr); al = (ans &gt;&gt; 12) % MOD; ar = (ans &gt;&gt; 8) % MOD; adl = (ans &gt;&gt; 4) % MOD; adr = (ans) % MOD; _rep(i, al, ar) printf(\"%d %d\\n\", row, i); printAns(pre[row][K][al][ar][adl][adr], row - 1, K - (ar - al + 1));&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d%d\", &amp;N, &amp;M, &amp;K); _rep(i, 1, N) _rep(j, 1, M) scanf(\"%d\", &amp;A[i][j]); // then dp int ans, ai; printf(\"Oil : %d\\n\", dp(ans, ai)); printAns(ans, ai, K);&#125; 线性dp的等效状态GYM100340A 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889const int maxn = 30 + 5;const int maxm = 5000 + 5;const int inf = 0x3f3f3f3f;int N, M;int g[maxn], f[maxn][maxm];int S[maxn];int prei[maxn][maxm], prej[maxn][maxm];int ans[maxn];struct Cld &#123; int g; int id; bool operator&lt; (const Cld&amp; rhs) const &#123; return g &gt; rhs.g; &#125;&#125;;Cld cld[maxn];void initDP() &#123; Set(f, inf); Set(S, 0); f[0][0] = 0; _rep(i, 1, N) S[i] = S[i - 1] + cld[i].g;&#125;int dp() &#123; initDP(); _rep(i, 1, N) _rep(j, i, M) &#123; f[i][j] = f[i][j - i]; //debug(f[i][j]); prei[i][j] = i; prej[i][j] = j - i; _for(k, 0, i) &#123; int sum = k * (S[i] - S[k]); if(sum + f[k][j - (i - k)] &lt; f[i][j]) &#123; f[i][j] = sum + f[k][j - (i - k)]; prei[i][j] = k; prej[i][j] = j - (i - k); &#125; &#125; &#125; return f[N][M];&#125;void printAns(int i, int j) &#123; if(i == 0) return; //debug(prei[i][j]), debug(prej[i][j]); printAns(prei[i][j], prej[i][j]); //debug(prei[i][j]), debug(prej[i][j]); if(i == prei[i][j]) &#123; _rep(u, 1, i) ans[cld[u].id]++; &#125; else &#123; _rep(u, prei[i][j] + 1, i) ans[cld[u].id] = 1; &#125; return;&#125;int main() &#123; freopen(\"cookies.in\",\"r\",stdin); freopen(\"cookies.out\", \"w\", stdout); scanf(\"%d%d\", &amp;N, &amp;M); _rep(i, 1, N) &#123; int _g; scanf(\"%d\", &amp;_g); cld[i].g = _g; cld[i].id = i; &#125; sort(cld + 1, cld + 1 + N); // then dp cout &lt;&lt; dp() &lt;&lt; endl; printAns(N, M); _rep(i, 1, N) &#123; if(i != 1) printf(\" \"); printf(\"%d\", ans[i]); &#125; cout &lt;&lt; endl;&#125; 背包问题0-1背包CH5201 12345678910111213141516171819const int maxm = 100000 + 10;const int inf = 0x3f3f3f3f;int N, M;const int maxn = 100 + 5;int A[maxn];int dp[maxm];int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;N, &amp;M); _rep(i, 1, N) scanf(\"%d\", &amp;A[i]); Set(dp, 0); dp[0] = 1; _rep(i, 1, N) _forDown(j, M, A[i]) dp[j] += dp[j - A[i]]; cout &lt;&lt; dp[M] &lt;&lt; endl;&#125; 0-1背包练习UVA12563 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const int maxn = 50 + 5;int N, T, kase;const int inf = 0x3f3f3f3f;int t[maxn];int f[maxn][maxn * 180 + 678];int ans = 0;void initdp() &#123; ans = 0; Set(f, -inf); f[0][T] = 0;&#125;void dp() &#123; // int res; _rep(i, 1, N) &#123; _rep(j, 1, T) f[i][j] = f[i - 1][j]; _rep(j, 1, T) &#123; if(j + t[i] &gt; T) continue; f[i][j] = max(f[i][j], f[i - 1][j + t[i]] + 1); ans = max(ans, f[i][j]); &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;kase); _rep(cas, 1, kase) &#123; printf(\"Case %d:\", cas); scanf(\"%d%d\", &amp;N, &amp;T); _rep(i, 1, N) scanf(\"%d\", &amp;t[i]); // then dp initdp(); dp(); int ret = 0; for(int j = 1; j &lt;= T; j++) &#123; if(f[N][j] == ans) &#123; // ans = f[N][j]; ret = j; break; &#125; &#125; printf(\" %d %d\\n\", ans + 1, (T - ret) + 678); &#125;&#125; 完全背包CH5202 12345678910111213141516171819const int maxn = 4000 + 10;unsigned f[maxn];int N;const unsigned MOD = 2147483648u;void initDP() &#123; Set(f, 0); f[0] = 1;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;N); initDP(); _rep(i, 1, N) _rep(j, i, N) f[j] += f[j - i]; cout &lt;&lt; (f[N] - 1) % MOD &lt;&lt; endl;&#125; 0-1背包多条件(多维度)POJ1015 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596const int base = 400, maxn = 200 + 10, maxk = 800 + 5;const int maxm = 20 + 5;const int inf = 0x3f3f3f3f;vector&lt;int&gt; ans;int f[maxm][maxk];int p[maxn], d[maxn];int sump, sumd;struct St &#123; int i, j, k;&#125;;St st[maxn][maxm][maxk];void init() &#123; ans.clear(); Set(f, -inf); Set(p, 0); Set(d, 0); f[0][0 + base] = 0; sump = sumd = 0;&#125;int N, M;int dp() &#123; _rep(i, 1, N) &#123; _rep(j, 0, M) _rep(k, 0, base * 2) st[i][j][k] = &#123;i - 1, j, k&#125;; for(int j = M; j; j--) &#123; _rep(k, 0, base * 2) &#123; if((k - (p[i] - d[i])) &lt; 0 || (k - (p[i] - d[i])) &gt; 800) continue; if(f[j - 1][k - (p[i] - d[i])] + p[i] + d[i] &gt; f[j][k]) &#123; f[j][k] = f[j - 1][k - (p[i] - d[i])] + p[i] + d[i]; st[i][j][k] = &#123;i - 1, j - 1, k - (p[i] - d[i])&#125;; &#125; &#125; &#125; &#125; int ret = 0; _rep(k, 0, 400) &#123; if(f[M][400 + k] &gt;= 0 &amp;&amp; f[M][400 + k] &gt;= f[M][400 - k]) &#123; ret = 400 + k; break; &#125; if(f[M][400 - k] &gt;= 0) &#123; ret = 400 - k; break; &#125; &#125; return ret;&#125;void print(int i, int j, int k) &#123; if(j == 0) return; const St pre = st[i][j][k]; print(pre.i, pre.j, pre.k); if(pre.j != j &amp;&amp; f[pre.j][pre.k] &gt;= 0) &#123; ans.push_back(i); sump += p[i]; sumd += d[i]; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 1; while ((cin &gt;&gt; N &gt;&gt; M) &amp;&amp; (M || N)) &#123; //debug(M); init(); printf(\"Jury #%d\\n\", kase++); _rep(i, 1, N) &#123; cin &gt;&gt; p[i] &gt;&gt; d[i]; &#125; // then dp; int ansk = dp(); print(N, M, ansk); printf(\"Best jury has value %d for prosecution and value %d for defence:\\n\", sump, sumd); //printf(\"(%d %d)\", sump, sumd); // puts(\"\"); _for(i, 0, ans.size()) printf(\" %d\", ans[i]); printf(\"\\n\\n\"); &#125;&#125; 线性dp实践(DAG模型))状态转移方程和图解描述如下 LA2728 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const int maxt = 200 + 5;const int maxn = 50 + 5;const int inf = 0x3f3f3f3f;int T, N;int f[maxt][maxn];int t[maxn];int M1, M2;int d[maxn], e[maxn];int hasTrain[maxt][maxn][2];void initdp() &#123; Set(f, inf); f[T][N] = 0;&#125;void initTrain() &#123; Set(hasTrain, 0); _rep(i, 1, M1) &#123; int st = d[i]; hasTrain[d[i]][1][0] = 1; int j = 1; _rep(k, 1, N - 1) &#123; st += t[k]; if (st &lt;= T) hasTrain[st][++j][0] = 1; &#125; &#125; _rep(i, 1, M2) &#123; int st = e[i]; hasTrain[st][N][1] = 1; int j = N; _forDown(k, N - 1, 1) &#123; st += t[k]; if(st &lt;= T) hasTrain[st][--j][1] = 1; &#125; &#125;&#125;void dp() &#123; initTrain(); initdp(); _forDown(i, T - 1, 0) _rep(j, 1, N) &#123; f[i][j] = f[i + 1][j] + 1; if(hasTrain[i][j][0] &amp;&amp; j + 1 &lt;= N &amp;&amp; i + t[j] &lt;= T) &#123; f[i][j] = min(f[i][j], f[i + t[j]][j + 1]); &#125; if(hasTrain[i][j][1] &amp;&amp; j - 1 &gt;= 1 &amp;&amp; i + t[j - 1] &lt;= T) &#123; f[i][j] = min(f[i][j], f[i + t[j - 1]][j - 1]); &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 1; while (scanf(\"%d\", &amp;N) &amp;&amp; N) &#123; scanf(\"%d\", &amp;T); _rep(i, 1, N - 1) scanf(\"%d\", &amp;t[i]); scanf(\"%d\", &amp;M1); _rep(i, 1, M1) scanf(\"%d\", &amp;d[i]); scanf(\"%d\", &amp;M2); _rep(i, 1, M2) scanf(\"%d\", &amp;e[i]); printf(\"Case Number %d: \", kase++); // solve the problem: dp(); if(f[0][1] &gt;= inf) printf(\"impossible\"); else cout &lt;&lt; f[0][1]; puts(\"\"); &#125;&#125; POJ2241 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const int maxn = 30 + 5;int N;int block[maxn][3];int f[maxn][3];void getdim(int* v, int i, int j) &#123; int id = 0; _for(k, 0, 3) if(k != j) v[id++] = block[i][k];&#125;void initdp() &#123; Set(f, 0);&#125;int dp(int i, int j) &#123; int&amp; ans = f[i][j]; if(ans &gt; 0) return ans; ans = 0; int v1[2], v2[2]; getdim(v1, i, j); _for(a, 0, N) _for(b, 0, 3) &#123; getdim(v2, a, b); if(v1[0] &lt; v2[0] &amp;&amp; v1[1] &lt; v2[1]) ans = max(ans, dp(a, b)); &#125; ans += block[i][j]; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 1; while (scanf(\"%d\", &amp;N) &amp;&amp; N) &#123; _for(i, 0, N) &#123; _for(j, 0, 3) scanf(\"%d\", &amp;block[i][j]); sort(block[i], block[i] + 3); &#125; // then dp initdp(); int ret = 0; _for(i, 0, N) _for(j, 0, 3) ret = max(ret, dp(i, j)); printf(\"Case %d: maximum height = %d\\n\", kase++, ret); &#125;&#125; 线性dp的递归求解LA3305 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int maxn = 1000 + 5;const int inf = 0x3f3f3f3f;class Node &#123;public: double x, y;&#125;;Node nodes[maxn];int N;double f[maxn][maxn];double dist(int i, int j) &#123; return sqrt((nodes[i].x - nodes[j].x) * (nodes[i].x - nodes[j].x) + (nodes[i].y - nodes[j].y) * (nodes[i].y - nodes[j].y));&#125;void initdp() &#123; Set(f, 0.0);&#125;double dp(int i, int j) &#123; double&amp; ans = f[i][j]; if(ans &gt; 0) return ans; if(i == N - 1) &#123; // ans = dist(N - 1, N) + dist(j, N); &#125; else &#123; // ans = min(dp(i + 1, j) + dist(i, i + 1), dp(i + 1, i) + dist(i + 1, j)); &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;N) == 1) &#123; _rep(i, 1, N) scanf(\"%lf%lf\", &amp;nodes[i].x, &amp;nodes[i].y); // then dp() initdp(); double ret = dp(2, 1); printf(\"%.2lf\\n\", ret + dist(2, 1)); &#125;&#125; 多段图的最短路UVA116 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const int maxm = 10 + 5, maxn = 100 + 5;const int inf = 0x3f3f3f3f;int A[maxm][maxn];int M, N;int f[maxm][maxn];int nxt[maxm][maxn];int first = 0;int ans = inf;void initDP() &#123; first = 0; ans = inf; Set(f, inf); Set(nxt, 0); //_rep(i, 1, M) f[i][N] = A[i][N]; // dp _forDown(j = N - 1 down to 1)&#125;int dp() &#123; _forDown(j, N, 1) _rep(i, 1, M) &#123; if(j == N) &#123; f[i][j] = A[i][j]; //debug(f[i][j]); &#125; else &#123; // int ni[3] = &#123;i - 1, i, i + 1&#125;; int nj = j + 1; if(i == 1) ni[0] = M; if(i == M) ni[2] = 1; sort(ni, ni + 3); _for(k, 0, 3) &#123; if(f[i][j] &gt; f[ni[k]][nj] + A[i][j]) &#123; assert(ni[k] != 0 &amp;&amp; ni[k] != M + 1); f[i][j] = f[ni[k]][nj] + A[i][j]; nxt[i][j] = ni[k]; &#125; &#125; &#125; if(j == 1 &amp;&amp; ans &gt; f[i][j]) &#123; assert(f[i][j] != inf); ans = f[i][j]; first = i; &#125; &#125; return ans;&#125;void print(int i, int j) &#123; if(j &gt; N) return; if(j != 1) printf(\" \"); printf(\"%d\", i); print(nxt[i][j], j + 1);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;M, &amp;N) == 2 &amp;&amp; M) &#123; //debug(N); _rep(i, 1, M) _rep(j, 1, N) &#123; scanf(\"%d\", &amp;A[i][j]); //debug(A[i][j]); &#125; // dp initDP(); int ret = dp(); //print(first, 1); printf(\"%d\", first); for(int u = nxt[first][1], j = 2; j &lt;= N; j++, u = nxt[u][j - 1]) printf(\" %d\", u); printf(\"\\n%d\\n\", ret); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"https://www.fogsail.net/tags/dp/"}]},{"title":"高效算法设计(八)","slug":"20190925","date":"2019-09-24T19:01:09.000Z","updated":"2019-10-12T14:48:00.367Z","comments":true,"path":"2019/09/25/20190925/","link":"","permalink":"https://www.fogsail.net/2019/09/25/20190925/","excerpt":"这篇博文的内容是接着《算法竞赛》第八章的习题介绍了一些比较冷门的，也可能比较无聊，更多是考察抖机灵而非算法应用的题目","text":"这篇博文的内容是接着《算法竞赛》第八章的习题介绍了一些比较冷门的，也可能比较无聊，更多是考察抖机灵而非算法应用的题目 枚举组合分析LA6286 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384int A[4];int cur;void init() &#123; Set(A, 0); cur = 0;&#125;void move(int step) &#123; int id = abs(step); cur += step; printf(\" %d\", cur); A[id]--;&#125;void move(int step, int cnt) &#123; _for(i, 0, cnt) move(step);&#125;void solve() &#123; printf(\"0\"); int cnt3 = A[3] / 3; int n = A[3] % 3; if(n == 0) &#123; move(3, cnt3); move(1); move(-3, cnt3); move(1); move(3, cnt3); &#125; if(n == 1) &#123; move(3, cnt3 + 1); move(-2); move(-3, cnt3); move(1); move(3, cnt3); move(2); &#125; if(n == 2) &#123; move(3, cnt3 + 1); move(-1); move(-3, cnt3); move(-1); move(3, cnt3 + 1); &#125; move(1, A[1] - 1); int cnt2 = A[2] / 2, n2 = A[2] % 2; if(n2 == 0) &#123; move(2, cnt2); move(1); move(-2, cnt2); &#125; if(n2 == 1) &#123; move(2, cnt2 + 1); move(-1); move(-2, cnt2); &#125; puts(\"\");&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; while(scanf(\"%d\", &amp;T) == 1) &#123; while (T--) &#123; init(); scanf(\"%d%d%d\", &amp;A[1], &amp;A[2], &amp;A[3]); solve(); &#125; &#125;&#125; 枚举的编程技巧LA6401 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const int maxn = 500 + 5;const int inf = 0x3f;int a, b, m, n;int d[maxn][maxn];int dep[maxn];llong ans, v, s;void init() &#123; ans = 0;&#125;void initdep() &#123; Set(dep, inf);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d%d%d\", &amp;a, &amp;b, &amp;m, &amp;n) == 4) &#123; init(); _for(x, 0, m) _for(y, 0, n) scanf(\"%d\", &amp;d[x][y]); if(b &gt; a) swap(a, b); // always a &gt;= b _for(x, 0, m) _rep(y, 0, n) &#123; initdep(); _for(xx, x, m) &#123; int aa = xx - x + 1; if(aa &gt; a) break; // dep[y] = min(dep[y], d[xx][y]); // debug(dep[y]); _for(yy, y, n) &#123; int bb = yy - y + 1; if(bb &gt; a || min(bb, aa) &gt; b) break; // then we solve the problem dep[yy] = min(dep[yy], d[xx][yy]); if(yy) dep[yy] = min(dep[yy - 1], dep[yy]); s = aa * bb * 1LL; v = aa * bb * dep[yy] * 1LL; int rem = (v % (m * n - s) == 0) ? 1 : 0; ans = max(ans, 1LL * (dep[yy] + (v / (m * n - s)) - rem) * s); &#125; &#125; &#125; printf(\"%lld\\n\", ans); &#125;&#125; 贪心算法处理阶段决策思想: 舍弃的值最少 LA3660 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667llong solve(llong n, llong m, llong cntn, llong cnts, llong cntw, llong cnte) &#123; llong ans = 0; if(cnts &gt; cntn) swap(cnts, cntn); if(cnte &gt; cntw) swap(cnte, cntw); if(cntn) &#123; ans += n * m; n--; cntn -= cnts; if(cntn == 0) ans += n * m * (2 * cnts - 1); else &#123; ans += n * m * 2 * cnts; cntn--; &#125; cnts = 0; &#125; if(cntw) &#123; cntw -= cnte; if(cntw == 0) cnte = cnte * 2 - 1; else &#123; cnte = cnte * 2; cntw--; &#125; while (m + (m - 1) * cnte &lt;= n &amp;&amp; cntn) &#123; ans += n * m; cntn--; n--; &#125; ans += n * m; m--; ans += n * m * cnte; cnte = 0; &#125; while (n * m &gt; 0 &amp;&amp; cntw + cntn &gt; 0) &#123; ans += n * m; if((n &gt; m &amp;&amp; cntn) || cntw == 0) &#123; cntn--; n--; &#125; else &#123; cntw--; m--; &#125; &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); llong n, m, cntn, cnts, cntw, cnte; int kase = 0; while (scanf(\"%lld%lld\", &amp;n, &amp;m) &amp;&amp; n &amp;&amp; m) &#123; scanf(\"%lld%lld%lld%lld\", &amp;cntn, &amp;cnts, &amp;cntw, &amp;cnte); // then solve the problem llong res = max(solve(n, m, cntn, cnts, cntw, cnte), solve(m, n, cnte, cntw, cntn, cnts)); printf(\"Case %d: %lld\\n\", ++kase, res); &#125;&#125; set优化贪心LA4977 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int maxn = 1000000 + 5;int last[maxn], ans[maxn];int rain[maxn];int n, m;void init() &#123; Set(last, 0); Set(ans, 0); Set(rain, 0);&#125;bool solve() &#123; set&lt;int&gt; noRain; bool ok = true; _rep(i, 1, m) &#123; if(rain[i] == 0) &#123; noRain.insert(i); continue; &#125; ans[i] = -1; auto day = noRain.lower_bound(last[rain[i]]); if(day == noRain.end()) &#123; ok = false; break; &#125; ans[*day] = rain[i]; last[rain[i]] = i; noRain.erase(*day); &#125; return ok;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; init(); scanf(\"%d%d\", &amp;n, &amp;m); _rep(i, 1, m) scanf(\"%d\", &amp;rain[i]); // then solve the problem bool ok = solve(); if(!ok) printf(\"NO\\n\"); else &#123; printf(\"YES\\n\"); bool first = 1; _rep(i, 1, m) &#123; if(ans[i] == -1) continue; if(first) first = 0; else printf(\" \"); printf(\"%d\", ans[i]); &#125; puts(\"\"); &#125; &#125;&#125; 扫描法一般的思路, 按照一定的条件往前走, 看最远能走到哪里 POJ2364 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899const int maxn = 1000 + 5;int lh, rh, lhi, rhi;int l, r;int lx[maxn], rx[maxn];int leftx, rightx;void init() &#123; Set(lx, 0); Set(rx, 0); lh = rh = 0;&#125;int solve() &#123; if(lh == rh) &#123; int lt = 0, rt = 0; for(int i = l, h = lx[l]; i &gt; lhi; i--) &#123; lt += h; h = max(h, lx[i - 1]); &#125; for(int i = r, h = rx[r]; i &gt; rhi; i--) &#123; rt += h; h = max(h, rx[i - 1]); &#125; return (lhi + rhi + 1) * lh * 2 + min(lt, rt) * 2 * 2; &#125; int M = min(lh, rh), lgi = 0, rgi = 0; // water can reach at most x = lgi or rgi // the first higher than M // [lgi, rgi] is the rectangle area while (lgi &lt; l &amp;&amp; lx[lgi] &lt; M) lgi++; while (rgi &lt; r &amp;&amp; rx[rgi] &lt; M) rgi++; // [lhi, rgi] is the rectangle area // [lgi, rhi] is the rectangle area int lt = 0, rt = 0; int t = 0; if(lh &lt; rh) &#123; for(int i = l, h = lx[l]; i &gt; lhi; i--) &#123; lt += h; h = max(h, lx[i - 1]); &#125; // right we may not reach rhi, just fill at rgi for(int i = rgi, h = M; rx[i] &lt;= M; i++) &#123; rt += h; h = max(h, rx[i + 1]); &#125; t = lt &gt; rt ? (lt + rt) : 2 * lt; &#125; if(lh &gt; rh) &#123; for(int i = r, h = rx[r]; i &gt; rhi; i--) &#123; rt += h; h = max(h, rx[i - 1]); &#125; for(int i = lgi, h = M; lx[i] &lt;= M; i++) &#123; lt += h; h = max(h, lx[i + 1]); &#125; t = rt &gt; lt ? (lt + rt) : 2 * rt; &#125; return t * 2 + (lgi + rgi + 1) * 2 * M;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (cin &gt;&gt; leftx &gt;&gt; rightx &amp;&amp; leftx &amp;&amp; rightx) &#123; init(); l = (-leftx) / 2, r = rightx / 2; for(int i = leftx; i &lt; 0; i += 2) &#123; int ii = (-i) / 2; cin &gt;&gt; lx[ii]; if(lx[ii] &gt;= lh) lh = lx[ii], lhi = ii; &#125; for(int i = 1; i &lt;= rightx; i += 2) &#123; int ii = i / 2; cin &gt;&gt; rx[ii]; if(rx[ii] &gt; rh) rh = rx[ii], rhi = ii; &#125; // then solve the problem printf(\"%d\\n\", solve()); &#125;&#125; 反向图UVA11175 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int maxn = 300 + 5;int n = -1, k = -1;int T;vector&lt;int&gt; G[maxn], invG[maxn];int indeg[maxn];bool check(int n) &#123; _for(u, 0, n) &#123; fill_n(indeg, n, 0); for(auto s : invG[u]) &#123; for(auto x : G[s]) indeg[x]++; &#125; _for(v, 0, n) &#123; if(v == u) continue; if(indeg[v] == 0 || indeg[v] == invG[u].size()) continue; return false; &#125; &#125; return true;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;T); _rep(kase, 1, T) &#123; scanf(\"%d%d\", &amp;n, &amp;k); assert(n != -1 &amp;&amp; k != -1); _for(i, 0, n) G[i].clear(), invG[i].clear(); _for(i, 0, k) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); invG[v].push_back(u); &#125; // then solve the problem bool ok = check(n); printf(\"Case #%d: %s\\n\", kase, (ok ? \"Yes\" : \"No\")); &#125;&#125; 随机算法优化枚举UVA12559 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const double pi = acos(-1);class Circle &#123;public: int r, x, y; Circle(int _r = 0, int _x = 0, int _y = 0) : r(_r), x(_x), y(_y) &#123;&#125; bool operator&lt; (const Circle&amp; rhs) const &#123; if(r != rhs.r) return r &lt; rhs.r; if(x != rhs.x) return x &lt; rhs.x; return y &lt; rhs.y; &#125;&#125;;ostream&amp; operator&lt;&lt; (ostream&amp; os, const Circle&amp; c) &#123; char buf[128]; sprintf(buf, \" (%d,%d,%d)\", c.r, c.x, c.y); return os &lt;&lt; buf;&#125;bool inRange(int x, int l, int r) &#123; if(l &gt; r) return inRange(x, r, l); return l &lt;= x &amp;&amp; x &lt;= r;&#125;vector&lt;string&gt; lines;vector&lt;Circle&gt; ans;void init() &#123; lines.clear(); ans.clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); _rep(kase, 1, T) &#123; init(); int w, h; scanf(\"%d%d\", &amp;w, &amp;h); lines.resize(h); _for(i, 0, h) cin &gt;&gt; lines[i]; // then we solve the problem _rep(r, 5, 50) _rep(x, r, w - r) _rep(y, r, h - r) &#123; int tot = 0, black = 0; // then enumerate _for(i, 0, 100) &#123; double deg = 2 * pi * (rand() / (RAND_MAX + 1.0)); int cx = (int)(x + r * cos(deg) + 0.5), cy = (int)(y + r * sin(deg) + 0.5); if(inRange(cx, 0, w - 1) &amp;&amp; inRange(cy, 0, h - 1) &amp;&amp; lines[cy][cx] == '1') black++; tot++; if(tot &gt; 10 &amp;&amp; black * 2 &lt; tot) break; &#125; if(black / (double) tot &gt; 0.8) ans.push_back(Circle(r, x, y)); &#125; printf(\"Case %d: \", kase); cout &lt;&lt; ans.size(); _for(i, 0, ans.size()) cout &lt;&lt; ans[i]; cout &lt;&lt; endl; &#125;&#125; 杂题LA6043 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const int maxn = 1000000 + 5;int L, P;struct Node &#123; int pre, nxt;&#125;;Node nodes[maxn];int twist[maxn];int level[maxn];void del(int x) &#123; level[x] = 0; nodes[nodes[x].pre].nxt = nodes[x].nxt; nodes[nodes[x].nxt].pre = nodes[x].pre;&#125;void init() &#123; Set(twist, 0); Set(level, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); _rep(kase, 1, T) &#123; init(); scanf(\"%d%d\", &amp;L, &amp;P); _for(i, 0, L) &#123; nodes[i].pre = i - 1; nodes[i].nxt = i + 1; &#125; nodes[0].pre = L - 1; nodes[L - 1].nxt = 0; _rep(i, 1, P) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); // (u, v) twist[u] = v; twist[v] = u; level[u] = 1; level[v] = -1; &#125; // then we solve the problem _for(i, 0, L) if(level[i] == 0) del(i); int idx = 0; while (P) &#123; bool untie = false; while (level[idx] == 0) idx++; for(int i = nodes[idx].nxt; i != idx &amp;&amp; untie == false; i = nodes[i].nxt) &#123; int u = i, v = nodes[i].nxt; if(level[u] == level[v] &amp;&amp; (nodes[twist[u]].nxt == twist[v] || nodes[twist[v]].nxt == twist[u])) &#123; del(u); del(v); del(twist[u]); del(twist[v]); P -= 2; untie = true; &#125; else if(twist[u] == v || twist[v] == u) &#123; del(u); del(v); P -= 1; untie = true; &#125; &#125; if(untie == false) break; &#125; printf(\"Case #%d: \", kase); if(P) printf(\"NO\\n\"); else printf(\"YES\\n\"); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://www.fogsail.net/tags/贪心/"}]},{"title":"实用数据结构(三)","slug":"20190920","date":"2019-09-20T08:31:36.000Z","updated":"2019-10-14T07:39:04.166Z","comments":true,"path":"2019/09/20/20190920/","link":"","permalink":"https://www.fogsail.net/2019/09/20/20190920/","excerpt":"这篇博文介绍一下线段树以及应用","text":"这篇博文介绍一下线段树以及应用 线段树概论 线段树求区间和CH4301 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394const int maxn = 500000 + 2;const int inf = maxn;int n, m;int A[maxn];class SegTree &#123;public: int l, r, dat; int sum, lmax, rmax;&#125;;typedef SegTree Node;SegTree t[maxn * 4];void build(int p, int l, int r) &#123; t[p].l = l; t[p].r = r; if(l == r) &#123; t[p].dat = t[p].sum = t[p].lmax = t[p].rmax = A[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r); t[p].sum = t[p &lt;&lt; 1].sum + t[p &lt;&lt; 1 | 1].sum; t[p].lmax = max(t[p &lt;&lt; 1].lmax, t[p &lt;&lt; 1].sum + t[p &lt;&lt; 1 | 1].lmax); t[p].rmax = max(t[p &lt;&lt; 1 | 1].rmax, t[p &lt;&lt; 1 | 1].sum + t[p &lt;&lt; 1].rmax); t[p].dat = max(max(t[p &lt;&lt; 1].dat, t[p &lt;&lt; 1 | 1].dat), t[p &lt;&lt; 1].rmax + t[p &lt;&lt; 1 | 1].lmax);&#125;void change(int p, int x, int v) &#123; if(t[p].l == t[p].r) &#123; t[p].sum = t[p].dat = t[p].lmax = t[p].rmax = v; return; &#125; int mid = (t[p].l + t[p].r) &gt;&gt; 1; if(x &lt;= mid) change(p &lt;&lt; 1, x, v); else change(p &lt;&lt; 1 | 1, x, v); t[p].sum = t[p &lt;&lt; 1].sum + t[p &lt;&lt; 1 | 1].sum; t[p].lmax = max(t[p &lt;&lt; 1].lmax, t[p &lt;&lt; 1].sum + t[p &lt;&lt; 1 | 1].lmax); t[p].rmax = max(t[p &lt;&lt; 1 | 1].rmax, t[p &lt;&lt; 1 | 1].sum + t[p &lt;&lt; 1].rmax); t[p].dat = max(max(t[p &lt;&lt; 1].dat, t[p &lt;&lt; 1 | 1].dat), t[p &lt;&lt; 1].rmax + t[p &lt;&lt; 1 | 1].lmax);&#125;Node ask(int p, int x, int y) &#123; // ask [x, y] dat if(x &lt;= t[p].l &amp;&amp; t[p].r &lt;= y) return t[p]; Node nl, nr, ans; nl.lmax = nl.rmax = nl.sum = nl.dat = nr.lmax = nr.rmax = nr.dat = nr.sum = -inf; ans.sum = 0; int mid = (t[p].l + t[p].r) &gt;&gt; 1; if(x &lt;= mid) &#123; nl = ask(p &lt;&lt; 1, x, y); ans.sum += nl.sum; &#125; if(y &gt; mid) &#123; nr = ask(p &lt;&lt; 1 | 1, x, y); ans.sum += nr.sum; &#125; ans.dat = max(max(nl.dat, nr.dat), nl.rmax + nr.lmax); ans.lmax = max(nl.lmax, nl.sum + nr.lmax); ans.rmax = max(nr.rmax, nr.sum + nl.rmax); if(x &gt; mid) ans.lmax = max(ans.lmax, nr.lmax); if(y &lt;= mid) ans.rmax = max(ans.rmax, nl.rmax); return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;m); _rep(i, 1, n) scanf(\"%d\", &amp;A[i]); build(1, 1, n); while (m--) &#123; int op, x, y; scanf(\"%d%d%d\", &amp;op, &amp;x, &amp;y); if(op == 1) &#123; if(x &gt; y) swap(x, y); cout &lt;&lt; ask(1, x, y).dat &lt;&lt; endl; &#125; if(op == 2) change(1, x, y); &#125;&#125; 线段树求区间和(有条件)如果线段树求区间和加了一些条件比如在区间和相同的时候, 要求[l, r], l尽量小, 如果还有多解, 要求r也尽量小此类问题可以对线段树维护的信息进行调整 1234输入的时候就对sum[]前缀和预处理lmax换成lx, 表示从左边开始, 能够扩展的最长前缀的下标rmax换成rx, 表示从右边开始, 能够扩展的最长后缀的下标dat表示当前这个[l, r]区间, 能够找到的最优连续子区间是pair&lt;int, int&gt; dat LA3938 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#define lowbit(i) (i &amp; (-i))typedef pair&lt;int, int&gt; PII;const int maxn = 500000 + 2;llong sum[maxn];int n, m;void init() &#123; Set(sum, 0);&#125;llong cal(const PII x) &#123; return sum[x.second] - sum[x.first - 1];&#125;PII better(const PII&amp; lhs, const PII&amp; rhs) &#123; llong suml = cal(lhs), sumr = cal(rhs); if(suml != sumr) return suml &gt; sumr ? lhs : rhs; return lhs &lt; rhs ? lhs : rhs;&#125;class SegTree &#123;public: int l, r; PII dat; int lx, rx;&#125;;SegTree t[maxn * 4];typedef SegTree Node;Node combine(const Node&amp; lhs, const Node&amp; rhs) &#123; Node ret; ret.l = lhs.l; ret.r = rhs.r; ret.lx = better(PII(lhs.l, lhs.lx), PII(lhs.l, rhs.lx)).second; ret.rx = better(PII(rhs.rx, rhs.r), PII(lhs.rx, rhs.r)).first; // then ret.dat = cross ret.dat = better(better(lhs.dat, rhs.dat), PII(lhs.rx, rhs.lx)); return ret;&#125;void build(int p, int l, int r) &#123; t[p].l = l; t[p].r = r; if(l == r) &#123; t[p].lx = t[p].rx = l; t[p].dat = PII(l, l); return; &#125; int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r); t[p].lx = better(PII(t[p &lt;&lt; 1].l, t[p &lt;&lt; 1].lx), PII(t[p &lt;&lt; 1].l, t[p &lt;&lt; 1 | 1].lx)).second; t[p].rx = better(PII(t[p &lt;&lt; 1 | 1].rx, t[p &lt;&lt; 1 | 1].r), PII(t[p &lt;&lt; 1].rx, t[p &lt;&lt; 1 | 1].r)).first; t[p].dat = better(better(t[p &lt;&lt; 1].dat, t[p &lt;&lt; 1 | 1].dat), PII(t[p &lt;&lt; 1].rx, t[p &lt;&lt; 1 | 1].lx));&#125;Node ask(int p, int x, int y) &#123; if(x &lt;= t[p].l &amp;&amp; t[p].r &lt;= y) return t[p]; int mid = (t[p].l + t[p].r) &gt;&gt; 1; Node ans; if(x &lt;= mid &amp;&amp; mid &lt; y) &#123; // both left tree and right tree ans = combine(ask(p &lt;&lt; 1, x, y), ask(p &lt;&lt; 1 | 1, x, y)); &#125; else if(x &lt;= mid) &#123; // only left ans = ask(p &lt;&lt; 1, x, y); &#125; else if(mid &lt; y) &#123; ans = ask(p &lt;&lt; 1 | 1, x, y); &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 1; while (scanf(\"%d%d\", &amp;n, &amp;m) != EOF) &#123; init(); _rep(i, 1, n) &#123; llong x; scanf(\"%lld\", &amp;x); sum[i] = sum[i - 1] + x; &#125; build(1, 1, n); printf(\"Case %d:\\n\", kase++); _rep(i, 1, m) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); PII res = ask(1, x, y).dat; printf(\"%d %d\\n\", res.first, res.second); &#125; &#125;&#125; 线段树+树状数组处理区间增加问题CH4302 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116const int maxn = 500000 + 10;int n, m;llong A[maxn], B[maxn];llong fwick[maxn];llong gcd(llong a, llong b) &#123; return b ? gcd(b, a % b) : a;&#125;void add(int x, llong d) &#123; for(; x &lt;= n; x += lowbit(x)) fwick[x] += d;&#125;llong sum(int x) &#123; llong ret = 0; for(; x &gt; 0; x -= lowbit(x)) ret += fwick[x]; return ret;&#125;void init() &#123; Set(A, 0); Set(B, 0); Set(fwick, 0);&#125;class SegTree &#123;public: int l, r; llong dat;&#125;;SegTree t[maxn * 4];typedef SegTree Node;void build(int p, int l, int r) &#123; t[p].l = l; t[p].r = r; if(l == r) &#123; t[p].dat = B[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r); t[p].dat = gcd(t[p &lt;&lt; 1].dat, t[p &lt;&lt; 1 | 1].dat);&#125;void change(int p, int x, llong v) &#123; if(t[p].l == t[p].r) &#123; t[p].dat += v; return; &#125; int mid = (t[p].l + t[p].r) &gt;&gt; 1; if(x &lt;= mid) change(p &lt;&lt; 1, x, v); else change(p &lt;&lt; 1 | 1, x, v); t[p].dat = gcd(t[p &lt;&lt; 1].dat, t[p &lt;&lt; 1 | 1].dat);&#125;llong ask(int p, int l, int r) &#123; if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123; return abs(t[p].dat); &#125; int mid = (t[p].l + t[p].r) &gt;&gt; 1; llong ret = 0; if(l &lt;= mid) ret = gcd(ret, ask(p &lt;&lt; 1, l, r)); if(r &gt; mid) ret = gcd(ret, ask(p &lt;&lt; 1 | 1, l, r)); return abs(ret);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); scanf(\"%d%d\", &amp;n, &amp;m); _rep(i, 1, n) &#123; scanf(\"%lld\", &amp;A[i]); B[i] = A[i] - A[i - 1]; &#125; // then build segTree build(1, 1, n); _for(i, 0, m) &#123; // query char str[2]; scanf(\"%s\", str); int l, r; scanf(\"%d%d\", &amp;l, &amp;r); if(str[0] == 'Q') &#123; // llong al = A[l] + sum(l); llong val = l &lt; r ? ask(1, l + 1, r) : 0; printf(\"%lld\\n\", gcd(al, val)); &#125; if(str[0] == 'C') &#123; // llong d; scanf(\"%lld\", &amp;d); change(1, l, d); if(r &lt; n) change(1, r + 1, -d); add(l, d); add(r + 1, -d); &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"实用数据结构(二)","slug":"20190915","date":"2019-09-15T14:36:23.000Z","updated":"2019-12-27T10:39:00.059Z","comments":true,"path":"2019/09/15/20190915/","link":"","permalink":"https://www.fogsail.net/2019/09/15/20190915/","excerpt":"这篇博文主要介绍一下fenwick树状数组线段树","text":"这篇博文主要介绍一下fenwick树状数组线段树 树状数组 HDU2492 把待求的前缀和exist[1] + exist[2] + … + exist[n]用fenwick树封装fenwick成员函数中, x表示exist的下标 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const int maxn = 200000 + 10;inline int lowbit(int x) &#123; return x &amp; (-x);&#125;int cnt1[maxn], cnt2[maxn];int A[maxn];void init() &#123; Set(cnt1, 0); Set(cnt2, 0);&#125;class Fenwick &#123;public: vector&lt;int&gt; exist; int n; void clear() &#123; fill(exist.begin(), exist.end(), 0); &#125; void resize(int n) &#123; this-&gt;n = n; exist.resize(n); &#125; int sum(int x) &#123; int ret = 0; while (x &gt; 0) &#123; ret += exist[x]; x -= lowbit(x); &#125; return ret; &#125; void add(int x, int d) &#123; while (x &lt;= n) &#123; exist[x] += d; x += lowbit(x); &#125; &#125;&#125;;Fenwick fwick;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; init(); int maxa = 0; int n; scanf(\"%d\", &amp;n); _rep(i, 1, n) &#123; scanf(\"%d\", &amp;A[i]); maxa = max(maxa, A[i]); &#125; fwick.resize(maxa); fwick.clear(); _rep(i, 1, n) &#123; int val = A[i]; fwick.add(val, 1); cnt1[i] = fwick.sum(val - 1); &#125; fwick.clear(); _forDown(i, n, 1) &#123; int val = A[i]; fwick.add(val, 1); cnt2[i] = fwick.sum(val - 1); //debug(cnt2[i]); &#125; llong ans = 0; _rep(i, 1, n) &#123; ans += ((llong)cnt2[i] * (llong)(i - 1 - cnt1[i]) + (llong)cnt1[i] * (llong)(n - i - cnt2[i])); &#125; printf(\"%lld\\n\", ans); &#125;&#125; 树状数组求解区间问题(一)CH242 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const int maxm = 100000 + 10;const int maxn = 100000 + 10;int n, m;llong A[maxn];void init() &#123; Set(A, 0);&#125;class Fenwick &#123;public: int n; vector&lt;int&gt; h; void resize(int n) &#123; this-&gt;n = n; h.resize(n); &#125; void clear() &#123; fill(h.begin(), h.end(), 0); &#125; int sum(int x) &#123; int ret = 0; while (x) &#123; ret += h[x]; x -= lowbit(x); &#125; return ret; &#125; void add(int x, int d) &#123; while (x &lt;= n) &#123; h[x] += d; x += lowbit(x); &#125; &#125;&#125;;Fenwick fwick;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); cin &gt;&gt; n &gt;&gt; m; _rep(i, 1, n) cin &gt;&gt; A[i]; //debug(A[n]); //fflush(stdin); fwick.clear(); fwick.resize(maxn); //getchar(); _for(i, 0, m) &#123; char ch; cin &gt;&gt; ch; //debug(ch); if(ch == 'C') &#123; // int l, r, d; cin &gt;&gt; l &gt;&gt; r &gt;&gt; d; //debug(l); fwick.add(l, d); fwick.add(r + 1, -d); &#125; else &#123; // int x; cin &gt;&gt; x; cout &lt;&lt; A[x] + (llong)fwick.sum(x) &lt;&lt; endl; &#125; &#125;&#125; 树状数组求解区间问题(二)POJ3468 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const int maxn = 100000 + 10;int n, m;int A[maxn];llong sum[maxn];void init() &#123; Set(A, 0); Set(sum, 0);&#125;class Fwick &#123;public: llong C[2][maxn]; int n; void clear() &#123; memset(C, 0, sizeof(C)); &#125; void resize(int n) &#123; this-&gt;n = n; &#125; llong ask(int k, int x) &#123; llong ret = 0; while (x) &#123; ret += C[k][x]; x -= lowbit(x); &#125; return ret; &#125; void add(int k, int x, int d) &#123; while (x &lt;= n) &#123; C[k][x] += d; x += lowbit(x); &#125; &#125;&#125;;Fwick fwick;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); scanf(\"%d%d\", &amp;n, &amp;m); _rep(i, 1, n) &#123; scanf(\"%d\", &amp;A[i]); sum[i] = sum[i - 1] + A[i]; &#125; fwick.clear(); fwick.resize(n); _for(i, 0, m) &#123; char op[2]; scanf(\"%s\", op); if(op[0] == 'C') &#123; // int l, r, d; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;d); fwick.add(0, l, d); fwick.add(0, r + 1, -d); fwick.add(1, l, l * d); fwick.add(1, r + 1, -(r + 1) * d); &#125; else &#123; // int l, r; scanf(\"%d%d\", &amp;l, &amp;r); llong ans = sum[r] + (r + 1) * fwick.ask(0, r) - fwick.ask(1, r); ans -= (sum[l - 1] + l * fwick.ask(0, l - 1) - fwick.ask(1, l - 1)); printf(\"%lld\\n\", ans); &#125; &#125;&#125; 树状数组解决区间第k大数问题树状数组+二分POJ2182 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#define lowbit(i) (i &amp; (-i))const int maxn = 100000 + 10;int A[maxn], n, ANS[maxn];void init() &#123; Set(A, 0); Set(ANS, 0);&#125;class Fwick &#123;public: vector&lt;int&gt; C; int n; void resize(int n) &#123; this-&gt;n = n; C.resize(n); &#125; void clear() &#123; fill(C.begin(), C.end(), 0); &#125; int sum(int x) &#123; int ret = 0; while (x) &#123; ret += C[x]; x -= lowbit(x); &#125; return ret; &#125; void add(int x, int d) &#123; while (x &lt;= n) &#123; C[x] += d; x += lowbit(x); &#125; &#125; int find(int l, int r, int val) &#123; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(sum(mid) &lt; val) l = mid + 1; else r = mid; &#125; return l; &#125;&#125;;Fwick fwick;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); scanf(\"%d\", &amp;n); fwick.resize(n); fwick.clear(); fwick.add(1, 1); _rep(i, 2, n) &#123; scanf(\"%d\", &amp;A[i]); fwick.add(i, 1); &#125; _forDown(i, n, 1) &#123; int val = A[i] + 1; int p = fwick.find(1, n, val); ANS[i] = p; fwick.add(p, -1); &#125; _rep(i, 1, n) cout &lt;&lt; ANS[i] &lt;&lt; endl;&#125; POJ2828 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990const int maxn = 200000 + 10;int n;class Peo &#123;public: int p, v;&#125;;Peo peo[maxn];int ans[maxn];void init() &#123; Set(ans, 0);&#125;class Fwick &#123;public: vector&lt;int&gt; C; int n; void resize(int n) &#123; this-&gt;n = n; C.resize(n); &#125; void clear() &#123; fill(C.begin(), C.end(), 0); &#125; int sum(int x) &#123; int ret = 0; while (x) &#123; ret += C[x]; x -= lowbit(x); &#125; return ret; &#125; void add(int x, int d) &#123; while (x &lt;= n) &#123; C[x] += d; x += lowbit(x); &#125; &#125; int find(int l, int r, int val) &#123; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(sum(mid) &lt; val) l = mid + 1; else r = mid; &#125; return l; &#125;&#125;;Fwick fwick;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (~scanf(\"%d\", &amp;n)) &#123; //debug(n); init(); fwick.resize(n); fwick.clear(); _rep(i, 1, n) &#123; //debug(i); scanf(\"%d%d\", &amp;peo[i].p, &amp;peo[i].v); //debug(peo[i].p); //debug(peo[i].v); fwick.add(i, 1); &#125; _forDown(i, n, 1) &#123; int val = peo[i].p; int pos = fwick.find(1, n, val + 1); //debug(pos); ans[pos] = peo[i].v; fwick.add(pos, -1); //debug(peo[i].v); &#125; _rep(i, 1, n) &#123; if(i != n) printf(\"%d \", ans[i]); else printf(\"%d\\n\", ans[i]); &#125; &#125;&#125; 树状数组处理栈(扩展域)LA5902 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#define lowbit(i) (i &amp; (-i))const int maxn = 100000 + 10;int n, m;int pos[maxn];void init() &#123; Set(pos, 0);&#125;class Fwick &#123;public: vector&lt;int&gt; C; int n; void resize(int n) &#123; C.resize(n + 1); this-&gt;n = n; &#125; void clear() &#123; fill(C.begin(), C.end(), 0); &#125; int sum(int x) &#123; int ret = 0; while (x) &#123; ret += C[x]; x -= lowbit(x); &#125; return ret; &#125; void add(int x, int d) &#123; while (x &lt;= n) &#123; C[x] += d; x += lowbit(x); &#125; &#125;&#125;;Fwick fwick;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; //init(); scanf(\"%d%d\", &amp;n, &amp;m); fwick.resize((maxn + 1) * 2); fwick.clear(); int st = maxn; _rep(i, 1, n) &#123; pos[i] = st + i; fwick.add(pos[i], 1); &#125; _for(i, 0, m) &#123; int x; scanf(\"%d\", &amp;x); printf(\"%d%c\", fwick.sum(pos[x] - 1), i == m - 1 ? '\\n' : ' '); fwick.add(pos[x], -1); pos[x] = st--; fwick.add(pos[x], 1); &#125; &#125;&#125; 树状数组和康托尔排列UVA11525 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const int maxn = 50000 + 10;int n;class Fwick &#123;public: vector&lt;int&gt; C; int n; void resize(int n) &#123; this-&gt;n = n; C.resize(n + 1); &#125; void clear() &#123; fill(C.begin(), C.end(), 0); &#125; int sum(int x) &#123; int ret = 0; while (x) &#123; ret += C[x]; x -= lowbit(x); &#125; return ret; &#125; void add(int x, int d) &#123; while (x &lt;= n) &#123; C[x] += d; x += lowbit(x);; &#125; &#125; int find(int l, int r, int val) &#123; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(sum(mid) &lt; val) l = mid + 1; else r = mid; &#125; return l; &#125;&#125;;Fwick fwick;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); fwick.resize(n); fwick.clear(); _rep(i, 1, n) fwick.add(i, 1); _rep(i, 1, n) &#123; int x; scanf(\"%d\", &amp;x); int pos = fwick.find(1, n, x + 1); printf(\"%d%c\", pos, i == n ? '\\n' : ' '); fwick.add(pos, -1); &#125; &#125;&#125; 并查集练习并查集和坐标离散化BZOJ4195 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const int maxn = 100000 + 10;class Con &#123;public: int i, j; int e;&#125;;Con cons[maxn];int n;int pa[maxn * 2];int arr[maxn * 2];void init() &#123; _for(i, 0, maxn) pa[i] = i; Set(arr, 0);&#125;int find(int x) &#123; return x == pa[x] ? x : (pa[x] = find(pa[x]));&#125;void discrete(int* arr, int m, int&amp; n) &#123; sort(arr, arr + m); n = unique(arr, arr + m) - arr;&#125;int query(int* arr, int n, int x) &#123; return lower_bound(arr, arr + n, x) - arr;&#125;void solve() &#123; int m = n * 2; int n2 = 0; discrete(arr, m, n2); _rep(i, 0, n2) pa[i] = i; _for(i, 0, n) &#123; int p = find(query(arr, n2, cons[i].i)), q = find(query(arr, n2, cons[i].j)); if(cons[i].e) pa[p] = q; &#125; _for(i, 0, n) &#123; int p = find(query(arr, n2, cons[i].i)), q = find(query(arr, n2, cons[i].j)); if(!cons[i].e &amp;&amp; p == q) &#123; printf(\"NO\\n\"); return; &#125; &#125; printf(\"YES\\n\");&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; init(); scanf(\"%d\", &amp;n); _for(i, 0, n) &#123; scanf(\"%d%d%d\", &amp;cons[i].i, &amp;cons[i].j, &amp;cons[i].e); arr[i * 2] = cons[i].i; arr[i * 2 + 1] = cons[i].j; &#125; // then solve the problem solve(); &#125;&#125; 并查集+贪心POJ1456 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int maxn = 10000 + 10;int pa[maxn];int n;void initPa(int n) &#123; _rep(i, 0, n) pa[i] = i;&#125;int find(int x) &#123; return x == pa[x] ? x : (pa[x] = find(pa[x]));&#125;class Stuf &#123;public: int prof, day; bool operator&lt; (const Stuf&amp; rhs) const &#123; return prof &gt; rhs.prof; &#125;&#125;;Stuf stufs[maxn];int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) != EOF) &#123; int maxd = 0; _for(i, 0, n) &#123; scanf(\"%d%d\", &amp;stufs[i].prof, &amp;stufs[i].day); maxd = max(maxd, stufs[i].day); &#125; sort(stufs, stufs + n); initPa(maxd); int ans = 0; _for(i, 0, n) &#123; int d = find(stufs[i].day); if(d) &#123; ans += stufs[i].prof; pa[d] = d - 1; &#125; &#125; printf(\"%d\\n\", ans); &#125;&#125; 并查集按秩压缩并查集执行Union(int rootp, int rootq)操作之后pa[rootp] = rootqrootp及其后代元素都成为rootq的子节点这个时候sz[rootq] += sz[rootp] 另外 1std::ios::sync_with_stdio(false); 比scanf好用 CH4101 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const int maxn = 30000 + 1;int pa[maxn];int d[maxn];int sz[maxn];void init() &#123; _for(i, 0, maxn) sz[i] = 1; _for(i, 0, maxn) d[i] = 0;&#125;void initPa(int n) &#123; _rep(i, 0, n) pa[i] = i;&#125;int find(int x) &#123; if(x == pa[x]) return x; int root = find(pa[x]); d[x] += d[pa[x]]; return pa[x] = root;&#125;void Union(int p, int q) &#123; pa[p] = q; d[p] = sz[q]; sz[q] += sz[p];&#125;int main() &#123; std::ios::sync_with_stdio(false); freopen(\"input.txt\", \"r\", stdin); int T; cin &gt;&gt; T; initPa(maxn); init(); while (T--) &#123; char cmd; cin &gt;&gt; cmd; int i, j; cin &gt;&gt; i &gt;&gt; j; //debug(i); //debug(j); int p = find(i), q = find(j); //debug(p); //debug(q); if(cmd == 'C') &#123; // if(p == q) cout &lt;&lt; abs(d[i] - d[j]) - 1 &lt;&lt; endl; else cout &lt;&lt; \"-1\" &lt;&lt; endl; &#125; else &#123; // Union(p, q); &#125; &#125;&#125; 并查集处理奇偶运算POJ1733 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const int maxn = 10000 + 10;struct Query &#123; int l, r, ans;&#125;;Query query[maxn];void discrete(int* arr, int n, int&amp; n2) &#123; sort(arr + 1, arr + 1 + n); n2 = unique(arr + 1, arr + 1 + n) - arr - 1;&#125;int getid(int* arr, int n2, int x) &#123; return lower_bound(arr + 1, arr + 1 + n2, x) - arr;&#125;int arr[maxn], n, m;int pa[maxn], d[maxn];void init() &#123; Set(arr, 0);&#125;void initPa(int n) &#123; _rep(i, 0, n) pa[i] = i; _rep(i, 0, n) d[i] = 0;&#125;int find(int x) &#123; if(x == pa[x]) return x; int root = find(pa[x]); d[x] ^= d[pa[x]]; return pa[x] = root;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; int k = 0; _rep(i, 1, m) &#123; char str[5]; cin &gt;&gt; query[i].l &gt;&gt; query[i].r; scanf(\"%s\", str); if(str[0] == 'o') query[i].ans = 1; else query[i].ans = 0; arr[++k] = query[i].l - 1; arr[++k] = query[i].r; &#125; discrete(arr, k, n); //debug(n); // [0, m - 1] is all query initPa(n); _rep(i, 1, m) &#123; int x = getid(arr, n, query[i].l - 1); int y = getid(arr, n, query[i].r); int p = find(x), q = find(y); if(p == q) &#123; // if( (d[x] ^ d[y]) != query[i].ans ) &#123; cout &lt;&lt; i - 1 &lt;&lt; endl; return 0; &#125; &#125; else &#123; pa[p] = q; d[p] = d[x] ^ d[y] ^ query[i].ans; &#125; &#125; cout &lt;&lt; m &lt;&lt; endl; return 0;&#125; 并查集扩展域 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const int maxn = (10000 + 1) * 2;struct Query &#123; int l, r, ans;&#125;;Query query[maxn];void discrete(int* arr, int n, int&amp; n2) &#123; sort(arr + 1, arr + 1 + n); n2 = unique(arr + 1, arr + 1 + n) - arr - 1;&#125;int getid(int* arr, int n2, int x) &#123; return lower_bound(arr + 1, arr + 1 + n2, x) - arr;&#125;int arr[maxn], n, m;int pa[maxn];void init() &#123; Set(arr, 0);&#125;void initPa(int n) &#123; _rep(i, 0, n) pa[i] = i;&#125;int find(int x) &#123; return x == pa[x] ? x : find(pa[x]);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m; int k = 0; _rep(i, 1, m) &#123; char str[5]; cin &gt;&gt; query[i].l &gt;&gt; query[i].r; scanf(\"%s\", str); if(str[0] == 'o') query[i].ans = 1; else query[i].ans = 0; arr[++k] = query[i].l - 1; arr[++k] = query[i].r; &#125; discrete(arr, k, n); initPa(n * 2); _rep(i, 1, m) &#123; int x = getid(arr, n, query[i].l - 1); int y = getid(arr, n, query[i].r); int xodd = x, xeven = x + n; int yodd = y, yeven = y + n; if(query[i].ans == 0) &#123; if(find(xodd) == find(yeven)) &#123; cout &lt;&lt; i - 1 &lt;&lt; endl; return 0; &#125; pa[find(xodd)] = find(yodd); pa[find(xeven)] = find(yeven); &#125; else &#123; if(find(xodd) == find(yodd)) &#123; cout &lt;&lt; i - 1 &lt;&lt; endl; return 0; &#125; pa[find(xodd)] = find(yeven); pa[find(xeven)] = find(yodd); &#125; &#125; cout &lt;&lt; m &lt;&lt; endl;&#125; 扩展域多节点POJ1182 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const int maxn = 50000 + 10;int pa[maxn * 3];int n, k;// usage: initPa(n * 3)void initPa(int n) &#123; _rep(i, 0, n) pa[i] = i;&#125;int find(int x) &#123; return x == pa[x] ? x : pa[x] = find(pa[x]);&#125;// x: self x + n: eat x + 2n: enemyint main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;k); initPa(n * 3); int ans = 0; _for(i, 0, k) &#123; int cmd, x, y; scanf(\"%d%d%d\", &amp;cmd, &amp;x, &amp;y); if(cmd == 2 &amp;&amp; (x == y)) &#123; ans++; continue; &#125; if(x &gt; n || y &gt; n) &#123; ans++; continue; &#125; if(cmd == 1) &#123; // if((find(x + n) == find(y)) || (find(x) == find(y + n))) &#123; ans++; continue; &#125; &#125; if(cmd == 2) &#123; // if((find(x) == find(y)) || (find(x) == find(y + n))) &#123; ans++; continue; &#125; &#125; if(cmd == 1) &#123; // pa[find(x)] = find(y); pa[find(x + n)] = find(y + n); pa[find(x + n * 2)] = find(y + n * 2); &#125; else if(cmd == 2) &#123; // pa[find(x)] = find(y + n * 2); pa[find(x + n)] = find(y); pa[find(x + n * 2)] = find(y + n); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 并查集删除与扩展域CH4901 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const int maxn = 20000 + 10;const int maxm = 100000 + 10;int pa[maxn * 2];int n, m;void initPa(int n) &#123; _rep(i, 0,n) pa[i] = i;&#125;// usage initPa(n * 2);class Cfl &#123;public: int x, y, val; bool operator&lt; (const Cfl&amp; rhs) const &#123; return val &gt; rhs.val; &#125;&#125;;Cfl cfl[maxm];int find(int x) &#123; return x == pa[x] ? x : pa[x] = find(pa[x]);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;m); _for(i, 0, m) &#123; scanf(\"%d%d%d\", &amp;cfl[i].x, &amp;cfl[i].y, &amp;cfl[i].val); &#125; initPa(n * 2); sort(cfl, cfl + m); _for(i, 0, m) &#123; Cfl&amp; cur = cfl[i]; //debug(cur.x); if(find(cur.x) == find(cur.y)) &#123; printf(\"%d\\n\", cur.val); return 0; &#125; pa[find(cur.x)] = find(cur.y + n); pa[find(cur.y)] = find(cur.x + n); &#125; printf(\"0\\n\"); return 0;&#125; POJ2912 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111const int maxn = 500 + 10;const int maxm = 2000 + 10;int pa[maxn * 3];void initPa(int n) &#123; _rep(i, 0, n) pa[i] = i;&#125;// usage: initPa(n * 3)// self: x lower: x + n greater: x + n * 2class Expr &#123;public: int x; char op; int y;&#125;;Expr expr[maxm];int n, m;int line[maxm];void init() &#123; Set(line, 0);&#125;int find(int x) &#123; return x == pa[x] ? x : pa[x] = find(pa[x]);&#125;bool conflict(const Expr&amp; expr) &#123; int x = expr.x, y = expr.y; char op = expr.op; //debug(op); if(op == '&gt;') &#123; //puts(\"ok\"); if((find(x) == find(y)) || (find(x) == find(y + n * 2))) return 1; pa[find(x + n * 2)] = find(y); pa[find(x)] = find(y + n); pa[find(x + n)] = find(y + n * 2); &#125; if(op == '&lt;') &#123; //puts(\"ok\"); if((find(x) == find(y)) || (find(x) == find(y + n))) return 1; pa[find(x + n)] = find(y); pa[find(x)] = find(y + n * 2); pa[find(x + n * 2)] = find(y + n); &#125; if(op == '=') &#123; //puts(\"ok\"); if((find(x) == find(y + n)) || (find(x + n) == find(y))) return 1; pa[find(x)] = find(y); pa[find(x + n)] = find(y + n); pa[find(x + n * 2)] = find(y + n * 2); &#125; return 0;&#125;void Rochambeau() &#123; // _for(i, 0, m) scanf(\"%d%c%d\", &amp;expr[i].x, &amp;expr[i].op, &amp;expr[i].y); //debug(expr[0].op); init(); int cnt = 0, id = 0; _for(i, 0, n) &#123; // i is judge bool fail = 0; _rep(k, 0, n * 3) pa[k] = k; _for(j, 0, m) &#123; Expr cur = expr[j]; //debug(cur.x); //debug(cur.y); if(cur.x != i &amp;&amp; cur.y != i &amp;&amp; conflict(cur)) &#123; fail = 1; if(j &gt; line[i]) line[i] = j + 1; break; &#125; &#125; if(!fail) &#123; id = i; cnt++; &#125; &#125; //debug(cnt); if(!cnt) puts(\"Impossible\"); else if(cnt == 1) &#123; int ans = 0; _for(i, 0, n) if(line[i] &gt; ans) ans = line[i]; printf(\"Player %d can be determined to be the judge after %d lines\\n\", id, ans); &#125; else puts(\"Can not determine\");&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;n, &amp;m) != EOF) Rochambeau();&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"图算法和图模型(一)","slug":"20190910","date":"2019-09-10T11:01:53.000Z","updated":"2020-04-19T07:57:30.772Z","comments":true,"path":"2019/09/10/20190910/","link":"","permalink":"https://www.fogsail.net/2019/09/10/20190910/","excerpt":"本篇内容主要写了和dfs有关的算法比如tarjan算法, kosaraju算法等等主要围绕图的割顶与桥展开","text":"本篇内容主要写了和dfs有关的算法比如tarjan算法, kosaraju算法等等主要围绕图的割顶与桥展开 tarjan算法(无向图) 判桥12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const int maxn = 100000 + 10;// == define Edge and Graph ==class Edge &#123;public: int from, to; Edge(int f = 0, int t = 0) : from(f), to(t) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];int n, m;// == Edge and Graph finished ==// == info for tarjan ==int dfn[maxn], low[maxn];bool bridge[maxn];int Clock = 0;void init() &#123; edges.clear(); edges.push_back(Edge()); edges.push_back(Edge()); // just for NIL Set(dfn, 0); Set(low, 0); Set(bridge, 0); Clock = 0;&#125;// == info finished ==// == tarjan ==void addEdge(int u, int v) &#123; edges.push_back(Edge(u, v)); G[u].push_back(edges.size() - 1);&#125;void tarjan(int u, int eID) &#123; dfn[u] = low[u] = ++Clock; _for(i, 0, G[u].size()) &#123; int id = G[u][i]; int v = edges[id].to; if(!dfn[v]) &#123; tarjan(v, id); low[u] = min(low[u], low[v]); if(low[v] &gt; dfn[u]) bridge[id] = bridge[id^1] = 1; &#125; else if(id != (eID^1)) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125;&#125;// == tarjan fisihed ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m; init(); _rep(i, 1, m) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; _rep(i, 1, n) if(!dfn[i]) tarjan(i, 0); for(int i = 2; i &lt; edges.size(); i += 2) &#123; if(bridge[i]) printf(\"%d %d\\n\", edges[i^1].to, edges[i].to); &#125;&#125; 判割点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const int maxn = 100000 + 10;// == Edge and Graph definition ==class Edge &#123;public: int to; Edge() &#123;&#125;; Edge(int to) : to(to) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];int n, m;// == Edge and Graph finsihed ==// == info used for tarjan ==int dfn[maxn], low[maxn];bool cut[maxn];int Clock = 0;int root = 0;void init() &#123; Clock = 0; root = 0; edges.clear(); edges.push_back(Edge()); edges.push_back(Edge()); // NIL edges Set(dfn, 0); Set(low, 0); Set(cut, 0);&#125;// == info finished ==// == tarjan ==void addEdge(int u, int v) &#123; edges.push_back(Edge(v)); G[u].push_back(edges.size() - 1);&#125;void tarjan(int u) &#123; dfn[u] = low[u] = ++Clock; int cld = 0; _for(i, 0, G[u].size()) &#123; int v = edges[G[u][i]].to; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u]) &#123; cld++; if(u != root || cld &gt; 1) cut[u] = true; &#125; &#125; else low[u] = min(low[u], dfn[v]); &#125;&#125;// == tarjan finsihed ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m; init(); _rep(i, 1, m) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v), addEdge(v, u); &#125; _rep(i, 1, n) if(!dfn[i]) &#123; root = i; tarjan(i); &#125; _rep(i, 1, n) if(cut[i]) printf(\"%d \", i); puts(\"are cut-vertexes\");&#125; BZOJ1123 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const int maxn = 100000 + 10;class Edge &#123;public: int from, to; Edge(int f = 0, int t = 0) : from(f), to(t) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];int dfn[maxn], low[maxn], cut[maxn], size[maxn];llong ans[maxn];int clk;int root;int n, m;void init() &#123; edges.clear(); edges.push_back(Edge()); Set(dfn, 0); Set(low, 0); Set(ans, 0); Set(cut, 0); Set(size, 0); clk = 0;&#125;void addEdge(int u, int v) &#123; edges.push_back(Edge(u, v)); G[u].push_back(edges.size() - 1);&#125;void tarjan(int u) &#123; dfn[u] = low[u] = ++clk; size[u] = 1; int cld = 0, sum = 0; _for(i, 0, G[u].size()) &#123; int eid = G[u][i]; int v = edges[eid].to; //debug(v); if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); size[u] += size[v]; if(low[v] &gt;= dfn[u]) &#123; cld++; ans[u] += (llong)(size[v]) * (n - size[v]); sum += size[v]; if(u != root || cld &gt; 1) cut[u] = 1; &#125; &#125; else low[u] = min(low[u], dfn[v]); &#125; if(!cut[u]) ans[u] = 2 * (n - 1); else &#123; ans[u] += ((n - 1) + (llong)(n - 1 - sum) * (sum + 1)); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); scanf(\"%d%d\", &amp;n, &amp;m); _for(i, 0, m) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if(u == v) continue; addEdge(u, v); addEdge(v, u); &#125; // node start from 1 root = 1; tarjan(root); _rep(i, 1, n) printf(\"%lld\\n\", ans[i]);&#125; tarjan无向图的双连通分量 tarjan算法求边双连通分量并缩点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134const int maxn = 100000 + 10;// == define Edge and Graph ==class Edge &#123;public: int to; Edge() &#123;&#125; Edge(int to) : to(to) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];// == Edge and Graph finished ==// == eDCC graph ==vector&lt;Edge&gt; eDCC;vector&lt;int&gt; GC[maxn];// == eDCC finsihed ==// == tarjan info ==int n, m;int dfn[maxn], low[maxn];bool bridge[maxn &lt;&lt; 1];int Clock = 0;void init() &#123; Clock = 0; edges.clear(); edges.push_back(Edge()); edges.push_back(Edge()); // NIL edges Set(dfn, 0); Set(low, 0); Set(bridge, 0);&#125;// == tarjan info finsihed ==// == tarjan ==void addEdge(int u, int v) &#123; edges.push_back(Edge(v)); G[u].push_back(edges.size() - 1);&#125;void tarjan(int u, int in_edge) &#123; dfn[u] = low[u] = ++Clock; _for(i, 0, G[u].size()) &#123; int eid = G[u][i], v = edges[eid].to; if(!dfn[v]) &#123; tarjan(v, eid); low[u] = min(low[u], low[v]); if(low[v] &gt; dfn[u]) bridge[eid] = bridge[eid^1] = 1; &#125; else if(eid != (in_edge^1)) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125;&#125;// == tarjan finsihed ==// == calculate eDCC ==int dcc = 0;int belong[maxn];void initDCC() &#123; eDCC.clear(); eDCC.push_back(Edge()); eDCC.push_back(Edge()); // used as NIL dcc = 0; Set(belong, 0);&#125;void add_c(int u, int v) &#123; eDCC.push_back(Edge(v)); GC[u].push_back(eDCC.size() - 1);&#125;void dfs(int u) &#123; belong[u] = dcc; _for(i, 0, G[u].size()) &#123; int eid = G[u][i], v = edges[eid].to; if(belong[v] || bridge[eid]) continue; dfs(v); &#125;&#125;void getDCC() &#123; _rep(i, 1, n) &#123; if(!belong[i]) &#123; ++dcc; dfs(i); &#125; &#125; printf(\"There are %d e-DCCs.\\n\", dcc); _rep(i, 1, n) printf(\"%d belongs to DCC %d.\\n\", i, belong[i]); _for(i, 2, edges.size()) &#123; int u = edges[i^1].to, v = edges[i].to; if(belong[u] == belong[v]) continue; add_c(belong[u], belong[v]); &#125; printf(\"缩点之后的森林，点数 %d，边数 %d\\n\", dcc, (eDCC.size()-1)&gt;&gt;1); for(int i = 2; i &lt; eDCC.size(); i += 2) &#123; printf(\"eDCC%d &lt;---&gt; eDCC%d\\n\", eDCC[i^1].to, eDCC[i].to); &#125;&#125;// == eDCC finsihed ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m; init(); _rep(i, 1, m) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; // == tarjan == _rep(i, 1, n) if(!dfn[i]) tarjan(i, 0); for(int i = 2; i &lt; edges.size(); i += 2) if(bridge[i]) &#123; printf(\"%d %d\\n\", edges[i^1].to, edges[i].to); &#125; // == eDCC == initDCC(); getDCC();&#125; tarjan算法求点双连通分量并缩点连通分量的编号统一用 $cnt$ 表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164const int maxn = 100000 + 10;// == define Edge and Graph ==class Edge &#123;public: int to; Edge() &#123;&#125; Edge(int to) : to(to) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];// == Edge and Graph finsihed ==// == tarjan info ==int n, m;vector&lt;int&gt; dcc[maxn];int dfn[maxn], low[maxn], cnt = 0, Clock = 0;bool cut[maxn];stack&lt;int&gt; stk;int root = 0;void init() &#123; cnt = 0; Clock = 0; root = 0; edges.clear(); edges.push_back(Edge()); edges.push_back(Edge()); // NIL edges Set(dfn, 0); Set(low, 0); Set(cut, 0); while(!stk.empty()) stk.pop();&#125;// == tarjan info finished ==// == tarjan main ==void addEdge(int u, int v) &#123; edges.push_back(Edge(v)); G[u].push_back(edges.size() - 1);&#125;void tarjan(int u) &#123; dfn[u] = low[u] = ++Clock; stk.push(u); if(u == root &amp;&amp; G[u].size() == 0) &#123; // single point dcc[++cnt].push_back(u); return; &#125; int cld = 0; _for(i, 0, G[u].size()) &#123; int eid = G[u][i], v = edges[eid].to; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); // judge cut-point if(low[v] &gt;= dfn[u]) &#123; cld++; if(u != root || cld &gt; 1) cut[u] = true; // save the point in the same DCC cnt++; for(;;) &#123; int z = stk.top(); stk.pop(); dcc[cnt].push_back(z); if(z == v) break; &#125; dcc[cnt].push_back(u); &#125; &#125; else low[u] = min(low[u], dfn[v]); &#125;&#125;// == tarjan finsihed ==// == vDCC Graph ==vector&lt;int&gt; GC[maxn];vector&lt;Edge&gt; vDCC;int belong[maxn], newID[maxn];int num = 0;void initDCC() &#123; vDCC.clear(); vDCC.push_back(Edge()); vDCC.push_back(Edge()); // NIL edges Set(belong, 0); Set(newID, 0); num = 0;&#125;void add_c(int u, int v) &#123; vDCC.push_back(Edge(v)); GC[u].push_back(vDCC.size() - 1);&#125;// == vDCC finsihed ==void getDCC() &#123; // input DCC nodes and data _rep(i, 1, cnt) &#123; printf(\"v-DCC #%d:\", i); _for(j, 0, dcc[i].size()) &#123; printf(\" %d\", dcc[i][j]); &#125; puts(\"\"); &#125; // point reduction num = cnt; _rep(i, 1, n) if(cut[i]) newID[i] = ++num; // build new Graph for vDCC _rep(i, 1, cnt) _for(j, 0, dcc[i].size()) &#123; int z = dcc[i][j]; if(cut[z]) &#123; add_c(i, newID[z]), add_c(newID[z], i); &#125; else belong[z] = i; &#125; // print info printf(\"缩点之后的森林，点数 %d, 边数 %d\\n\", num, (int)(vDCC.size() - 1) &gt;&gt; 1); printf(\"下图编号 1～%d 的为原图的v-DCC，编号 &gt;=%d 的为原图的割点\\n\", cnt, cnt); for(int i = 2; i &lt; vDCC.size(); i += 2) &#123; printf(\"vDCC#%d &lt;-----&gt; vDCC#%d\\n\", vDCC[i^1].to, vDCC[i].to); &#125;&#125;// == vDCC Graph finished ==int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m; init(); _rep(i, 1, m) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if(u == v) continue; addEdge(u, v), addEdge(v, u); &#125; // == tarjan == _rep(i, 1, n) if(!dfn[i]) &#123; root = i, tarjan(i); &#125; _rep(i, 1, n) if(cut[i]) printf(\"%d \", i); puts(\"are cut vertexes\"); // == tarjan finished == initDCC(); getDCC();&#125; euler路径 POJ2230 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const int maxn = 100000 + 10;int n, m;int st;vector&lt;int&gt; G[maxn];int head[maxn];stack&lt;int&gt; stk;vector&lt;int&gt; ans;struct Edge &#123; int u, v; Edge(int u = 0, int v = 0) : u(u), v(v) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;void init() &#123; _for(i, 0, maxn) G[i].clear(); while(!stk.empty()) stk.pop(); edges.push_back(Edge()); edges.push_back(Edge()); Set(head, 0); ans.clear();&#125;void addEdge(int u, int v) &#123; edges.push_back(Edge(u, v)); G[u].push_back(edges.size() - 1);&#125;void euler() &#123; stk.push(st); while (!stk.empty()) &#123; int x = stk.top(), i = head[x]; // debug(x); if(i &lt; G[x].size()) &#123; int eid = G[x][i]; int y = edges[eid].v; stk.push(y); head[x] = i + 1; &#125; else &#123; stk.pop(); ans.push_back(x); &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m; _rep(i, 1, m) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); addEdge(x, y); addEdge(y, x); &#125; st = 1; euler(); for(int i = ans.size() - 1; i &gt;= 0; i--) printf(\"%d\\n\", ans[i]);&#125; tarjan算法(有向图) tarjan有向图的强连通分量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134const int maxn = 100000 + 10;// == define Edge and Graph ==class Edge &#123;public: int to; Edge() &#123;&#125; Edge(int to) : to(to) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];inline void addEdge(int u, int v) &#123; edges.push_back(Edge(v)); G[u].push_back(edges.size() - 1);&#125;// == Edge and Graph finsihed ==// == SCC Graph ==vector&lt;int&gt; GC[maxn];vector&lt;int&gt; SCC[maxn];vector&lt;Edge&gt; eSCC;inline void add_c(int u, int v) &#123; eSCC.push_back(Edge(v)); GC[u].push_back(eSCC.size() - 1);&#125;// == SCC finished ==// == tarjan info ==int dfn[maxn], low[maxn];int ins[maxn];int cnt = 0, Clock = 0;int belong[maxn];stack&lt;int&gt; stk;void init() &#123; Set(dfn, 0); Set(low, 0); cnt = Clock = 0; edges.push_back(Edge()); edges.push_back(Edge()); // used as NIL&#125;void initSCC() &#123; Set(belong, 0); Set(ins, 0); eSCC.push_back(Edge()); eSCC.push_back(Edge()); // used as NIL while (!stk.empty()) stk.pop();&#125;// == tarjan info finished ==// == tarjan and get SCC ==void tarjan(int u) &#123; dfn[u] = low[u] = ++Clock; stk.push(u), ins[u] = 1; _for(i, 0, G[u].size()) &#123; int v = edges[G[u][i]].to; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(ins[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if(low[u] == dfn[u]) &#123; cnt++; for(;;) &#123; int z = stk.top(); stk.pop(); ins[z] = 0; belong[z] = cnt; SCC[cnt].push_back(z); if(z == u) break; &#125; &#125;&#125;// == tarjan and SCC finsihed ==int n, m;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m; init(); initSCC(); _rep(i, 1, m) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v); &#125; _rep(i, 1, n) if(!dfn[i]) tarjan(i); _rep(u, 1, n) _for(i, 0, G[u].size()) &#123; int v = edges[G[u][i]].to; if(belong[v] == belong[u]) continue; add_c(belong[u], belong[v]); &#125; // print ans _rep(i, 1, cnt) &#123; printf(\"连通分量#%d含有的点为:\", i); _for(j, 0, SCC[i].size()) printf(\" %d\", SCC[i][j]); printf(\"\\n\"); &#125; puts(\"\"); printf(\"缩点之后的图显示如下： \\n\"); _rep(i, 1, cnt + 1) &#123; if(GC[i].size() == 0) continue; _for(j, 0, GC[i].size()) &#123; int v = eSCC[GC[i][j]].to; printf(\"#%d &lt;==&gt; #%d\\n\", i, v); &#125; &#125; _rep(i, 1, n) &#123; printf(\"low[%d]=%d \",i, low[i]); &#125; puts(\"\");&#125; 树的直径 树形dp求树的直径123456789101112131415161718192021// 树形dp求树的直径void dp(int u, int&amp; ans) &#123; vis[u] = 1; _for(i, 0, G[u].size()) &#123; int eid = G[u][i], v = edges[G[u][i]].to; if(vis[v]) continue; dp(v, ans); ans = max(ans, d[u] + d[v] + edges[eid].w); d[u] = max(d[u], d[v] + edges[eid].w); &#125;&#125;int main() &#123; ans = 0; memset(d, 0, sizeof(d)); memset(vis, 0, sizeof(vis)); // root一般取直径的一个端点 dp(root, ans);&#125; 两次dfs求树的直径并记忆化1234567891011121314151617181920212223242526272829303132333435int pa[maxn], d[maxn], vis[maxn];void dfs(int u, int&amp; p) &#123; vis[u] = 1; _for(i, 0, G[u].size()) &#123; int eid = G[u][i], v = edges[eid].to; if(vis[v]) continue; if((d[v] = d[u] + edges[eid].w) &gt;= d[p]) p = v; pa[v] = eid; dfs(v, p); &#125; vis[u] = 0;&#125;// 这时候获取了直径的一个端点p// we get one endpoint of diameterint main() &#123; Set(pa, 0); Set(d, 0); Set(vis, 0); // first dfs to find p and get d[] int p = 1; dfs(1, p); // second dfs d[p] = pa[p] = 0; int q = p; dfs(p, q); // p--&gt;q is the path of diameter&#125; 实践BZOJ1912 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697const int maxn = 100000 + 10;class Edge &#123;public: int to, weight; Edge(int t = 0, int w = 0) : to(t), weight(w) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];int n, k;int pa[maxn * 2], d[maxn * 2], vis[maxn * 2];void init() &#123; edges.push_back(Edge()); edges.push_back(Edge()); _for(i, 0, maxn) G[i].clear(); Set(pa, 0); Set(d, 0); Set(vis, 0);&#125;void addEdge(int from, int to, int w) &#123; edges.push_back(Edge(to, w)); G[from].push_back(edges.size() - 1);&#125;void dfs(int u, int&amp; to) &#123; vis[u] = 1; _for(i, 0, G[u].size()) &#123; int eid = G[u][i], v = edges[eid].to; if(vis[v]) continue; if((d[v] = d[u] + edges[eid].weight) &gt;= d[to]) to = v; pa[v] = eid; dfs(v, to); &#125; vis[u] = 0;&#125;void dp(int u, int&amp; ans) &#123; vis[u] = 1; _for(i, 0, G[u].size()) &#123; int eid = G[u][i], v = edges[eid].to; if(vis[v]) continue; dp(v, ans); ans = max(ans, d[u] + d[v] + edges[eid].weight); d[u] = max(d[u], d[v] + edges[eid].weight); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); scanf(\"%d%d\", &amp;n, &amp;k); _for(i, 0, n) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v, 1); addEdge(v, u, 1); &#125; // then solve the problem int to = 1; dfs(1, to); d[to] = pa[to] = 0; int tto = to; dfs(to, tto); // [to, tto] is the longest path in a tree int ans = ((n - 1) &lt;&lt; 1) - d[tto] + 1; if(k == 2) &#123; while (pa[tto]) &#123; int eid = pa[tto]; edges[eid].weight = edges[eid ^ 1].weight = -1; tto = edges[eid ^ 1].to; &#125; tto = 0; Set(d, 0); Set(vis, 0); dp(to, tto); ans -= (tto - 1); &#125; printf(\"%d\\n\", ans);&#125; tarjan算法实践","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"Graph","slug":"Graph","permalink":"https://www.fogsail.net/tags/Graph/"}]},{"title":"高效算法设计(七)","slug":"20190909","date":"2019-09-09T07:17:31.000Z","updated":"2019-09-23T13:00:47.284Z","comments":true,"path":"2019/09/09/20190909/","link":"","permalink":"https://www.fogsail.net/2019/09/09/20190909/","excerpt":"本节内容对一些序列的问题进行归纳总结","text":"本节内容对一些序列的问题进行归纳总结 中途相遇法这种方法有点类似数学中的夹逼准则 LA3232 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081typedef vector&lt;int&gt;::iterator vii;const int maxn = 5000 + 10;vector&lt;int&gt; H[maxn], L[maxn];int N[maxn];int n;void init() &#123; _for(i, 0, maxn) &#123; H[i].clear(); L[i].clear(); &#125; Set(N, 0);&#125;bool find1(int p) &#123; _for(i, 0, H[p].size()) &#123; int q = H[p][i]; vii rit = upper_bound(L[p].begin(), L[p].end(), q); if(rit == L[p].end()) continue; int r = *rit; vii sit = upper_bound(H[p].begin(), H[p].end(), r); while (sit != H[p].end()) &#123; int s = *sit; if(binary_search(L[q].begin(), L[q].end(), s)) return true; sit++; &#125; &#125; return false;&#125;bool find2(int p) &#123; _for(i, 0, L[p].size()) &#123; int q = L[p][i]; vii rit = upper_bound(H[p].begin(), H[p].end(), q); if(rit == H[p].end()) continue; int r = *rit; vii sit = upper_bound(L[p].begin(), L[p].end(), r); while (sit != L[p].end()) &#123; int s = *sit; if(binary_search(H[q].begin(), H[q].end(), s)) return true; sit++; &#125; &#125; return false;&#125;bool solve() &#123; _for(i, 0, n) if(find1(i) || find2(i)) return true; return false;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; init(); scanf(\"%d\", &amp;n); _for(i, 0, n) scanf(\"%d\", &amp;N[i]); _for(i, 0, n) _for(j, i + 1, n) &#123; if(N[j] &gt; N[i]) H[i].push_back(j); else if(N[j] &lt; N[i]) L[i].push_back(j); &#125; if(solve()) printf(\"YES\\n\"); else printf(\"NO\\n\"); &#125;&#125; 连续的几个数, 连续的子区间最小这一系列的问题, 可以用滑动窗口解决UVA11536 滑动窗口中可能会出现: 滑动窗口的长度不固定的情况，这时候注意1/ win在[L, …]中向右滑动win不一定会真正删除A[L]处的元素 2/ 只有A[L]中的数在win中出现的次数为1的时候窗口从L中滑走，win才算是彻底删除了A[L] 3/ 我们需要用map记录每个值在窗口中出现的次数 4/ 滑动窗口和区间扩张相结合的模版 12345678910111213141516171819202122for(int L = 0, R = 0; L &lt; N; L++) &#123; if(R &gt;= N) break; while (win中没有选够点) &#123; ins(R, win); R++; if(R &gt;= N) break; &#125; [L, R]构成了新的滑动窗口 滑动窗口是我们需要的值 if(win选够点了) 滑动窗口能否优化呢? 滑动窗口最左边的A[L]元素有没有冗余？A[L]出现次数可能大于1 或者是, 滑动窗口并不包含A[L], A[L]我们不需要 ans = min(ans, R - L + 1); slide L, del(L, win) R = max(L, R);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const int maxn = 1000000 + 10;int n, m, k;int x[maxn];void cal() &#123; _for(i, 0, n) &#123; if(i &lt; 3) x[i] = i + 1; else x[i] = (x[i - 3] + x[i - 2] + x[i - 1]) % m + 1; &#125;&#125;bool valid(int x) &#123; return 1 &lt;= x &amp;&amp; x &lt;= k;&#125;void ins(int x, map&lt;int, int&gt;&amp; win) &#123; if(valid(x)) win[x] = win[x] + 1;&#125;void del(int x, map&lt;int, int&gt;&amp; win) &#123; if(!win.count(x)) return; win[x] = win[x] - 1; if(win[x] &lt; 1) win.erase(x);&#125;int solve() &#123; map&lt;int, int&gt; win; win.clear(); int ans = 0; for(int L = 0, R = 0; L &lt; n; L++) &#123; while (win.size() &lt; k) &#123; ins(x[R], win); R++; if(R &gt;= n) break; &#125; if(R &gt;= n) break; if(win.size() == k) &#123; // enough points while (win[x[L]] &gt; 1 || !win.count(x[L])) &#123; del(x[L], win); L++; &#125; if(!ans) ans = R - L + 1; else ans = min(ans, R - L + 1); &#125; del(x[L], win); &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); _rep(t, 1, T) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); // then we init cal() x[] and solve() cal(); printf(\"Case %d: \", t); int ans = solve(); if(!ans) printf(\"sequence nai\\n\"); else printf(\"%d\\n\", ans - 1); &#125;&#125; 连续子序列权值问题LA3517 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990const int maxn = 100000 + 10;int n;llong L[maxn], R[maxn], sum[maxn], A[maxn];stack&lt;int&gt; stk;// stk used to store indexvoid init() &#123; Set(sum, 0); Set(A, 0); Set(L, 0); Set(R, 0);&#125;void popGreater(int i) &#123; while(!stk.empty() &amp;&amp; A[stk.top()] &gt;= A[i]) stk.pop();&#125;void solve() &#123; while (!stk.empty()) stk.pop(); _rep(i, 1, n) &#123; popGreater(i); L[i] = stk.empty() ? 0 : stk.top(); stk.push(i); &#125; while (!stk.empty()) stk.pop(); _forDown(i, n, 1) &#123; popGreater(i); R[i] = stk.empty() ? n + 1 : stk.top(); stk.push(i); &#125; llong ans = -1, ansl = -1, ansr = -1; _rep(i, 1, n) &#123; // if A[i] is min value llong li = L[i], ri = R[i] - 1, tmp = (sum[ri] - sum[li]) * A[i]; li++; bool update = false; if(tmp &lt; ans) continue; if(tmp &gt; ans) update = true; if(tmp == ans) &#123; if(ansr - ansl &gt; ri - li) update = true; else if(ansr - ansl == ri - li) update = li &lt; ansl; &#125; ans = max(tmp, ans); if(update) &#123; ansl = li; ansr = ri; &#125; &#125; printf(\"%lld\\n%lld %lld\\n\", ans, ansl, ansr);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); bool first = true; while (scanf(\"%d\", &amp;n) == 1) &#123; init(); if(first) first = false; else puts(\"\"); bool all0 = true; _rep(i, 1, n) &#123; scanf(\"%lld\", &amp;A[i]); if(A[i]) all0 = false; sum[i] = A[i] + sum[i - 1]; &#125; if(all0) &#123; printf(\"0\\n1 1\\n\"); continue; &#125; // then solve the problem solve(); &#125;&#125; 坐标离散化LA2689 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const int maxn = 100 + 4;class Point &#123;public: int x, y; bool operator&lt; (const Point&amp; rhs) const &#123; if(x != rhs.x) return x &lt; rhs.x; return y &lt; rhs.y; &#125;&#125;;Point P[maxn];int dy[maxn];int ans, ansX, ansY;void init() &#123; Set(dy, 0); ans = ansX = ansY = 0;&#125;int N, W, H;void solve() &#123; int n = unique(dy, dy + N + 2) - dy; _for(i, 0, n) _for(j, i + 1, n) &#123; int minY = dy[i], maxY = dy[j]; int hh = maxY - minY, last = 0, ww = 0; _for(k, 0, N) &#123; Point&amp; cur = P[k]; if(cur.y &lt;= minY || cur.y &gt;= maxY) continue; ww = cur.x - last; if(ans &lt; min(ww, hh)) &#123; ans = min(ww, hh); ansX = last, ansY = minY; &#125; last = cur.x; &#125; ww = W - last; if(ans &lt; min(ww, hh)) &#123; ans = min(ww, hh); ansX = last, ansY = minY; &#125; &#125; printf(\"%d %d %d\\n\", ansX, ansY, ans);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; init(); scanf(\"%d%d%d\", &amp;N, &amp;W, &amp;H); _for(i, 0, N) &#123; scanf(\"%d%d\", &amp;P[i].x, &amp;P[i].y); dy[i] = P[i].y; &#125; dy[N] = 0, dy[N + 1] = H; // discrete sort(dy, dy + N + 2); sort(P, P + N); solve(); if(T) printf(\"\\n\"); &#125;&#125; 逆序对(找规律枚举)LA4000 123456789101112131415161718192021222324252627const int maxn = 500 + 10;int n;int A[maxn];void init() &#123; Set(A, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; init(); scanf(\"%d\", &amp;n); _for(i, 0, n) scanf(\"%d\", &amp;A[i]); int cnt = 0; _for(i, 0, n - 1) _for(j, i + 1, n) &#123; if(A[i] &gt; A[j]) cnt++; &#125; if(n % 2 &amp;&amp; cnt % 2) cout &lt;&lt; \"impossible\" &lt;&lt; endl; else cout &lt;&lt; \"possible\" &lt;&lt; endl; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://www.fogsail.net/tags/贪心/"}]},{"title":"再论后缀自动机","slug":"20190829","date":"2019-08-28T17:59:06.000Z","updated":"2019-10-24T10:24:58.491Z","comments":true,"path":"2019/08/29/20190829/","link":"","permalink":"https://www.fogsail.net/2019/08/29/20190829/","excerpt":"在之前已经对后缀自动机的概念进行了阐述后缀数组与后缀自动机 其实这种思想有很多应用对这个算法的构造和思考如下","text":"在之前已经对后缀自动机的概念进行了阐述后缀数组与后缀自动机 其实这种思想有很多应用对这个算法的构造和思考如下 后缀自动机构造原理 LCS问题的O(nlogn)解法HDU1159 12345678910111213141516171819202122232425262728293031323334353637383940414243const int maxn = 1000 + 5;char A[maxn], B[maxn];vector&lt;int&gt; loc[maxn];vector&lt;int&gt; C, D;void init() &#123; _for(i, 0, maxn) loc[i].clear(); C.clear(); D.clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%s%s\", A, B) != EOF) &#123; init(); int lenA = strlen(A), lenB = strlen(B); _forDown(i, lenB - 1, 0) loc[B[i] - 'a'].push_back(i); _for(i, 0, lenA) &#123; int x = A[i] - 'a'; if(loc[x].empty()) continue; _for(j, 0, loc[x].size()) &#123; C.push_back(loc[x][j]); &#125; &#125; if(!C.empty()) &#123; D.push_back(C[0]); _for(i, 1, C.size()) &#123; if(C[i] &gt; D.back()) D.push_back(C[i]); else &#123; vii it = lower_bound(D.begin(), D.end(), C[i]); *it = C[i]; &#125; &#125; &#125; cout &lt;&lt; D.size() &lt;&lt; endl; &#125;&#125; LCS问题的O(n)算法LCS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const int maxl = 250005;const int maxn = maxl * 2;class SAM &#123;public: int sz, last; int trans[maxn][26], link[maxn], maxlen[maxn]; SAM() &#123; Set(trans, 0); Set(link, 0); Set(maxlen, 0); sz = last = 1; &#125; void extend(int ch) &#123; int cur = ++sz, p = last; maxlen[cur] = maxlen[p] + 1; for( ; p &amp;&amp; trans[p][ch] == 0; p = link[p]) trans[p][ch] = cur; if(p == 0) link[cur] = 1; else &#123; int q = trans[p][ch]; if(maxlen[p] + 1 == maxlen[q]) link[cur] = q; else &#123; int clone = ++sz; maxlen[clone] = maxlen[p] + 1; Cpy(trans[clone], trans[q]); link[clone] = link[q]; for( ; p &amp;&amp; trans[p][ch] == q; p = link[p]) trans[p][ch] = clone; link[q] = link[cur] = clone; &#125; &#125; last = cur; &#125; int LCS(const char* str) &#123; int len = strlen(str); int lcs = 0, tmplen = 0; int cur = 1; _for(i, 0, len) &#123; int x = str[i] - 'a'; if(trans[cur][x]) &#123; cur = trans[cur][x]; tmplen++; &#125; else &#123; while (cur &amp;&amp; trans[cur][x] == 0) cur = link[cur]; if(cur) &#123; tmplen = maxlen[cur] + 1; cur = trans[cur][x]; &#125; else &#123; tmplen = 0; cur = 1; &#125; &#125; lcs = max(lcs, tmplen); &#125; return lcs; &#125;&#125;;SAM sam;int main() &#123; freopen(\"input.txt\", \"r\", stdin); char A[maxl], B[maxl]; scanf(\"%s%s\", A, B); int lenA = strlen(A), lenB = strlen(B); _for(i, 0, lenA) sam.extend(A[i] - 'a'); cout &lt;&lt; sam.LCS(B) &lt;&lt; endl;&#125; SAM根据maxlen对节点排序 SAM求子串出现次数子串的长度为k比如ababa, 有很多长度为3的子串其中’aba’出现2次, ‘bab’出现1次 求长度为k的子串最多可能出现多少次？ Substrings SAM和拓扑排序(BFS版本)这种写法会超时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455SAM sam;vector&lt;int&gt; G[maxn];int indeg[maxn];llong ans[maxn];void init() &#123; Set(cnt, 0); Set(ans, 0); Set(indeg, 0);&#125;void build() &#123; _rep(i, 1, sam.sz) &#123; G[i].push_back(sam.link[i]); indeg[sam.link[i]]++; &#125;&#125;void topo() &#123; queue&lt;int&gt; que; _rep(i, 0, sam.sz) if(indeg[i] == 0) que.push(i); while (!que.empty()) &#123; int u = que.front(); que.pop(); _for(i, 0, G[u].size()) &#123; int v = G[u][i]; cnt[v] += cnt[u]; if(--indeg[v] == 0) que.push(v); &#125; &#125; _rep(i, 1, sam.sz) ans[sam.maxlen[i]] = max(ans[sam.maxlen[i]], cnt[i]);&#125;// usage: build() topo()int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); char str[maxl]; scanf(\"%s\", str); int len = strlen(str); _for(i, 0, len) sam.extend(str[i] - 'a'); build(); topo(); _forDown(i, len, 1) ans[i] = max(ans[i], ans[i + 1]); _rep(i, 1, len) cout &lt;&lt; ans[i] &lt;&lt; endl;&#125; 用RadixSort优化拓扑排序从小到大的排序, 按照maxlen的排名maxlen从[0, len], 序号依次是{1, 2, …, sam.sz} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394const int maxl = 250000 + 5;const int maxn = maxl * 2;llong cnt[maxn];int len;class SAM &#123;public: int maxlen[maxn], link[maxn], trans[maxn][26]; int last, sz; SAM() &#123; Set(maxlen, 0); Set(link, 0); Set(trans, 0); last = sz = 1; &#125; void extend(int ch) &#123; int cur = ++sz, p = last; maxlen[cur] = maxlen[p] + 1; cnt[cur] = 1; for( ; p &amp;&amp; trans[p][ch] == 0; p = link[p]) trans[p][ch] = cur; if(p == 0) link[cur] = 1; else &#123; int q = trans[p][ch]; if(maxlen[q] == maxlen[p] + 1) link[cur] = q; else &#123; int clone = ++sz; maxlen[clone] = maxlen[p] + 1; Cpy(trans[clone], trans[q]); link[clone] = link[q]; for(; p &amp;&amp; trans[p][ch] == q; p = link[p]) trans[p][ch] = clone; link[q] = link[cur] = clone; &#125; &#125; last = cur; &#125;&#125;;SAM sam;// use Radix sort instead of bfs-topoSortint C[maxn];int id[maxn];llong ans[maxn];void init() &#123; Set(cnt, 0); Set(C, 0); Set(id, 0); Set(ans, 0);&#125;void rsort() &#123; Set(C, 0); _rep(i, 1, sam.sz) C[sam.maxlen[i]]++; _rep(i, 1, len) C[i] += C[i - 1]; _forDown(i, sam.sz, 1) id[C[sam.maxlen[i]]--] = i; _forDown(i, sam.sz, 1) &#123; int u = id[i]; cnt[sam.link[u]] += cnt[u]; &#125;&#125;void solve() &#123; _rep(i, 1, sam.sz) ans[sam.maxlen[i]] = max(ans[sam.maxlen[i]], cnt[i]); _forDown(i, len, 1) ans[i] = max(ans[i], ans[i + 1]);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); char str[maxl]; scanf(\"%s\", str); len = strlen(str); _for(i, 0, len) sam.extend(str[i] - 'a'); rsort(); solve(); _rep(i, 1, len) printf(\"%d\\n\", ans[i]);&#125; 值得注意的是cnt[suffix]随着len的增加, 是递减的所以刷cnt[i]的值的时候, 从大的len往小的len刷 12345for(int i = sam.sz; i &gt;= 1; i--) &#123; // 找到排名最靠后的点, 也就是len最长的点 int u = id[i]; cnt[sam.link[u]] += cnt[u];&#125; endpos()性质","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"高效算法设计(六)","slug":"20190828","date":"2019-08-28T05:23:26.000Z","updated":"2019-09-09T06:58:52.247Z","comments":true,"path":"2019/08/28/20190828/","link":"","permalink":"https://www.fogsail.net/2019/08/28/20190828/","excerpt":"本节针对贪心算法中的区间相关问题做一系列阐述","text":"本节针对贪心算法中的区间相关问题做一系列阐述 区间相关问题选择不相交区间HDU2037 123456789101112131415161718192021222324252627282930313233343536373839404142const int maxn = 100 + 10;class Seg &#123;public: int l, r; Seg(int _l = 0, int _r = 0) : l(_l), r(_r) &#123;&#125;&#125;;Seg seg[maxn];vector&lt;int&gt; chooseID;int n;void init() &#123; chooseID.clear();&#125;bool cmp(const Seg&amp; lhs, const Seg&amp; rhs) &#123; return lhs.r &lt; rhs.r;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; init(); int lastR = -1; _for(i, 0, n) scanf(\"%d%d\", &amp;seg[i].l, &amp;seg[i].r); sort(seg, seg + n, cmp); lastR = seg[0].r; chooseID.push_back(0); _for(i, 1, n) &#123; if(seg[i].l &gt;= lastR) &#123; chooseID.push_back(i); lastR = seg[i].r; &#125; &#125; printf(\"%d\\n\", (int)chooseID.size()); &#125;&#125; 活动选择问题活动串行执行贪心算法很显然第一步是按照活动的结束时间排序 然后看看从当前时间出发，能不能安排此次活动？如果不能的话，说明存在一个活动的时间过长了，导致溢出活动的截止日期如果活动发生溢出的话，我们需要把过长的那个活动时间给替换掉 替换成什么活动呢？用优先队列维护活动的持续时间，默认优先队列的top是活动时间最长的如果当前的活动持续时间 &lt; pq.top()timing = timing - pq.top() + cur.持续时间pq.push(cur.持续时间) 1234567891011121314151617int timing = 0;sort(acts, acts + N);_for(i, 0, N) &#123; Act&amp; cur = acts[i]; // 看看能不能安排当前活动 if(timing + cur.持续时间 &lt;= cur.结束时间) &#123; timing += cur.持续时间; pq.push(cur.持续时间) &#125; else if(!pq.empty() &amp;&amp; cur.持续时间 &lt; pq.top()) &#123; timing = timing - pq.top() + cur.持续时间; pq.pop(); pq.push(cur.持续时间) &#125;&#125; LA3507 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int maxn = 800000 + 10;int N;class Ord &#123;public: int q, d; Ord(int _q = 0, int _d = 0) : q(_q), d(_d) &#123;&#125; bool operator&lt; (const Ord&amp; rhs) const &#123; return d &lt; rhs.d; &#125;&#125;;Ord ords[maxn];int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; cin &gt;&gt; T; _for(t, 0, T) &#123; if(t) puts(\"\"); cin &gt;&gt; N; _for(i, 0, N) cin &gt;&gt; ords[i].q &gt;&gt; ords[i].d; sort(ords, ords + N); int timing = 0; priority_queue&lt;int&gt; pq; _for(i, 0, N) &#123; const Ord&amp; cur = ords[i]; if(timing + cur.q &lt;= cur.d) &#123; timing += cur.q; pq.push(cur.q); &#125; else if(!pq.empty() &amp;&amp; cur.q &lt; pq.top()) &#123; timing = timing - pq.top() + cur.q; pq.pop(); pq.push(cur.q); &#125; &#125; cout &lt;&lt; pq.size() &lt;&lt; endl; &#125;&#125; 区间选点问题LA2519 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int maxn = 1000 + 10;class Seg &#123;public: double l, r;&#125;;bool cmp(const Seg&amp; lhs, const Seg&amp; rhs) &#123; if(lhs.r != rhs.r) return lhs.r &lt; rhs.r; else return lhs.l &gt; rhs.l;&#125;Seg seg[maxn];int n, d;int kase = 1;bool ok = 1;void init() &#123; ok = 1;&#125;int solve() &#123; sort(seg, seg + n, cmp); int cur = seg[0].r, ans = 1; _for(i, 1, n) &#123; if(seg[i].l - cur &lt;= 1e-4) continue; cur = seg[i].r; ans++; &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;n, &amp;d) == 2 &amp;&amp; (n || d)) &#123; init(); _for(i, 0, n) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); if(ok) &#123; if(y &gt; d) &#123; ok = false; continue; &#125; double dist = sqrt(d * d - y * y); seg[i].l = x - dist; seg[i].r = x + dist; &#125; &#125; // input finished, then solve the problem printf(\"Case %d: \", kase++); if(!ok) printf(\"-1\\n\"); else &#123; printf(\"%d\\n\", solve()); &#125; &#125;&#125; LA3835 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const int maxn = 100000 + 10;const double eps = 1e-4;int L, D, N;double dcmp(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;class Seg &#123;public: double l, r; Seg(double _l = 0, double _r = 0) : l(_l), r(_r) &#123;&#125;&#125;;bool cmp(const Seg&amp; lhs, const Seg&amp; rhs) &#123; if(dcmp(lhs.r - rhs.r) != 0) return dcmp(lhs.r - rhs.r) &lt; 0; else return dcmp(lhs.l - rhs.l) &gt; 0;&#125;typedef Seg Point;Seg seg[maxn];Seg getSeg(double x, double y) &#123; double d = sqrt(D * D - y * y); double from = x - d, to = x + d; if(dcmp(from) &lt; 0) from = 0; if(dcmp(to - L) &gt; 0) to = L; return Seg(from, to);&#125;int solve() &#123; sort(seg, seg + N, cmp); int ans = 1; double cur = seg[0].r; _for(i, 1, N) &#123; if(dcmp(seg[i].l - cur) &lt; 0) continue; if(dcmp(seg[i].l - cur) &gt; 0) &#123; cur = seg[i].r; ans++; &#125; &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (cin &gt;&gt; L &gt;&gt; D &gt;&gt; N) &#123; _for(i, 0, N) &#123; double x, y; cin &gt;&gt; x &gt;&gt; y; seg[i] = getSeg(x, y); &#125; cout &lt;&lt; solve() &lt;&lt; endl; &#125;&#125; 区间选点问题变形在区间[1, n]内选择n个不同的整数使得第i个整数在闭区间[li, ri]中 UVA11134 当区间两个端点的取值在[1, n]的时候可以换一个角度思考这时候贪心算法就相当于 为$x \\in [1, n]$的每一个x, 选择一个区间贪心选择思路是 123456789101112131415_rep(x, 1, n) &#123; chose = -1, minr = n + 1; // 让区间的右端点尽可能小, 维护一个minr // minr的取值要尽量小 // vis &lt; 0表示区间没有被选择过 _for(i, 0, n) &#123; if(seg[i].l &lt;= x) &#123; if(vis[i] &lt; 0 &amp;&amp; seg[i].r &lt; minr) &#123; minr = seg[i].r; chose = i; &#125; &#125; &#125;&#125; 123456789101112131415161718192021bool solve(Seg* seg, int* ans) &#123; fill(ans, ans + n, -1); _rep(x, 1, n) &#123; int chose = -1, minr = n + 1; _for(i, 0, n) &#123; if(x &gt;= seg[i].l) &#123; if(ans[i] &lt; 0 &amp;&amp; seg[i].r &lt; minr) &#123; minr = seg[i].r; chose = i; &#125; &#125; &#125; if(minr &lt; x || chose &lt; 0) return false; ans[chose] = x; &#125; return true;&#125; 选取等长的子线段LA6279 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const int maxn = 100000 + 10;const double eps = 1e-7;int dcmp(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;class Seg &#123;public: int from, to; bool operator&lt; (const Seg&amp; rhs) const &#123; return from &lt;= rhs.from; &#125;&#125;;Seg seg[maxn];int n;bool solve(const double len) &#123; double lastr = 0; _for(i, 0, n) &#123; Seg&amp; cur = seg[i]; lastr = max((double)cur.from, lastr) + len; if(lastr &gt; cur.to) return false; &#125; return true;&#125;int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;void output(double x) &#123; double _p = floor(x + eps); if(dcmp(_p - x) == 0) &#123; printf(\"%.0lf/1\\n\", _p); return;; &#125; int p = 1, q = 1; double ans = 1; _rep(i, 1, n) &#123; int pp = (int)(floor(x * (double)i + 0.5)); double tmp = (double)pp / i; if(fabs(tmp - x) &lt; fabs(ans - x)) &#123; p = pp; q = i; ans = tmp; &#125; &#125; int g = gcd(p, q); printf(\"%d/%d\\n\", p / g, q / g);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) == 1) &#123; _for(i, 0, n) &#123; scanf(\"%d%d\", &amp;seg[i].from, &amp;seg[i].to); &#125; sort(seg, seg + n); double l = 1, r = (double)1000000.0 / n; double mid; assert(dcmp(l - r) &lt;= 0); _for(t, 0, 50) &#123; mid = (l + r) / 2; if(!solve(mid)) r = mid; else l = mid; &#125; // output (l + r) / 2 //debug((l + r) / 2 ); output((l + r) / 2); &#125;&#125; 子线段选择LA5845 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int maxn = 100000 + 10;int n;class Seg &#123;public: int from, to; bool operator&lt; (const Seg&amp; rhs) const &#123; if(to != rhs.to) return to &lt; rhs.to; else return from &lt; rhs.from; &#125;&#125;;Seg seg[maxn];int solve() &#123; int ans = 0, last = -1; _for(i, 0, n) &#123; Seg&amp; cur = seg[i]; if(cur.to == last) continue; if(cur.from &lt;= last) &#123; last++; &#125; if(cur.from &gt; last) &#123; ans++; last = cur.to; &#125; &#125; return ans - 1;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); _for(i, 0, n) &#123; scanf(\"%d%d\", &amp;seg[i].from, &amp;seg[i].to); &#125; sort(seg, seg + n); printf(\"%d\\n\", solve()); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://www.fogsail.net/tags/贪心/"}]},{"title":"高效算法设计(五)","slug":"20190826","date":"2019-08-26T06:21:11.000Z","updated":"2019-08-28T00:50:00.634Z","comments":true,"path":"2019/08/26/20190826/","link":"","permalink":"https://www.fogsail.net/2019/08/26/20190826/","excerpt":"本节内容再深入贪心算法和算法设计其中会用到一些数学证明辅助证明一些性质 然后在这些性质的基础上进行贪心选择","text":"本节内容再深入贪心算法和算法设计其中会用到一些数学证明辅助证明一些性质 然后在这些性质的基础上进行贪心选择 构造法LA4378 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const int maxn = 100000 + 10;class Data &#123;public: int val, id; Data(int v = 0, int i = 0) : val(v), id(i) &#123;&#125;&#125;;bool cmp(const Data&amp; lhs, const Data&amp; rhs) &#123; return lhs.val &gt; rhs.val;&#125;Data data[maxn];int ans[maxn];int n;void init() &#123; Set(ans, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (~scanf(\"%d\", &amp;n)) &#123; init(); llong sum = 0; _for(i, 0, n) &#123; scanf(\"%d\", &amp;data[i].val); data[i].id = i; sum += data[i].val; &#125; if(sum % 2) &#123; printf(\"No\\n\"); continue; &#125; else sum /= 2; sort(data, data + n, cmp); _for(i, 0, n) &#123; if(data[i].val &lt;= sum) &#123; sum -= data[i].val; ans[data[i].id] = 1; &#125; else ans[data[i].id] = -1; &#125; printf(\"Yes\\n\"); _for(i, 0, n - 1) printf(\"%d \", ans[i]); printf(\"%d\\n\", ans[n - 1]); &#125;&#125; 环形排列UVA10570 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const int maxn = 500 + 10;int A[maxn], B[maxn], pos[maxn];int N;void init() &#123; Set(A, 0); Set(B, 0); Set(pos, 0);&#125;void copy(int st, int step) &#123; _for(i, 0, N) &#123; B[i] = A[(st + step * i + N) % N]; pos[B[i]] = i; &#125;&#125;int solve() &#123; int ans = 0; _for(i, 0, N) &#123; int p = pos[i]; if(p == i) continue; pos[B[i]] = p; pos[i] = i; swap(B[i], B[p]); ans++; &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;N) == 1 &amp;&amp; N) &#123; init(); _for(i, 0, N) &#123; scanf(\"%d\", &amp;A[i]); A[i]--; &#125; int res = maxn; _for(i, 0, N) &#123; copy(i, 1); res = min(res, solve()); copy(i, -1); res = min(res, solve()); &#125; printf(\"%d\\n\", res); &#125;&#125; 图上的贪心算法LA4993 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const int maxn = 10000 + 10;class Edge &#123;public: int from, to; Edge(int f = 0, int t = 0) : from(f), to(t) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];int n, m, k;int color[maxn], vis[maxn];void init() &#123; Set(color, 0); Set(vis, 0); _for(i, 0, maxn) G[i].clear(); edges.clear(); k = 0;&#125;void initVis() &#123; Set(vis, 0);&#125;void addEdge(int from, int to) &#123; edges.push_back(Edge(from, to)); int m = edges.size(); G[from].push_back(m - 1);&#125;void dfs(int u) &#123; initVis(); _for(i, 0, G[u].size()) &#123; Edge cur = edges[G[u][i]]; if(color[cur.to]) vis[color[cur.to]] = 1; &#125; _rep(i, 1, k) &#123; if(!vis[i]) &#123; color[u] = i; break; &#125; &#125; _for(i, 0, G[u].size()) &#123; Edge cur = edges[G[u][i]]; if(!color[cur.to]) dfs(cur.to); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while (scanf(\"%d%d\", &amp;n, &amp;m) != EOF) &#123; init(); if(++kase &gt; 1) printf(\"\\n\"); int u, v; _for(i, 0, m) &#123; scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u - 1, v - 1); addEdge(v - 1, u - 1); &#125; _for(i, 0, n) k = max(k, (int)G[i].size()); if(k % 2 == 0) k++; cout &lt;&lt; k &lt;&lt; endl; dfs(0); _for(i, 0, n) cout &lt;&lt; color[i] &lt;&lt; endl; &#125;&#125; 枚举排列处理小数点的方法123456789101112int readint() &#123; char buf[8]; scanf(\"%s\", buf); int a = 0, b = 0; sscanf(buf, \"%d\", &amp;a); char* pp = strchr(buf, '.'); if(pp) sscanf(++pp, \"%d\", &amp;b); return a * 100 + b;&#125; exampleLA3664 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const int maxn = 16384 + 5;vector&lt;int&gt; per[maxn];vector&lt;int&gt; rk;int n;void init() &#123; _for(i, 0, maxn) per[i].clear(); rk.clear();&#125;int readint() &#123; char buf[8]; scanf(\"%s\", buf); int a = 0, b = 0; sscanf(buf, \"%d\", &amp;a); char* pp = strchr(buf, '.'); if(pp) sscanf(++pp, \"%d\", &amp;b); return a * 100 + b;&#125;int read() &#123; int x; scanf(\"%d\", &amp;x); return x;&#125;int solve() &#123; int lastScore = -1, lastID = -1; _for(i, 0, rk.size()) &#123; int id = rk[i]; if(lastScore == -1) lastScore = per[id].front(); else &#123; bool found = false; _for(j, 0, per[id].size()) &#123; if(per[id][j] &lt; lastScore || (per[id][j] == lastScore &amp;&amp; id &gt; lastID)) &#123; lastScore = per[id][j]; found = true; break; &#125; &#125; if(!found) return -1; &#125; lastID = id; &#125; return lastScore;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); for(int kase = 1; scanf(\"%d\", &amp;n) == 1 &amp;&amp; n; kase++) &#123; init(); _for(i, 0, n) &#123; per[i].clear(); per[i].push_back(0); _for(j, 0, 3) per[i].push_back(readint()); per[i].push_back(per[i][1] + per[i][2]); per[i].push_back(per[i][1] + per[i][3]); per[i].push_back(per[i][2] + per[i][3]); per[i].push_back(per[i][1] + per[i][2] + per[i][3]); sort(per[i].begin(), per[i].end(), greater&lt;int&gt;()); &#125; _for(i, 0, n) rk.push_back(read() - 1); // then solve the problem int ans = solve(); if(ans == -1) printf(\"Case %d: No solution\\n\", kase); else printf(\"Case %d: %d.%02d\\n\", kase, ans / 100, ans % 100); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://www.fogsail.net/tags/贪心/"}]},{"title":"高效算法设计(四)","slug":"20190813","date":"2019-08-13T11:49:53.000Z","updated":"2019-08-27T01:08:14.221Z","comments":true,"path":"2019/08/13/20190813/","link":"","permalink":"https://www.fogsail.net/2019/08/13/20190813/","excerpt":"贪心算法有很多综合的应用这里主要阐述一下如何在算法设计中引入一些数学思想和算法分析的思想 训练题目以《算法竞赛入门经典第二版》中第八章的题目为主","text":"贪心算法有很多综合的应用这里主要阐述一下如何在算法设计中引入一些数学思想和算法分析的思想 训练题目以《算法竞赛入门经典第二版》中第八章的题目为主 水题中途相遇法POJ2782 算法分析, 先把最大和最小的装起来看看行不行?可以，就把最大最小的装袋，然后R— 123[i, R]R--相当于出队列i++相当于i出队列 不可以呢？i++, 就是i单独装袋 123456789101112131415161718const int maxn = 100000 + 10;int n, M;int l[maxn];int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; M; _for(i, 0, n) cin &gt;&gt; l[i]; sort(l, l + n, greater&lt;int&gt;()); int ans = 0; _for(i, 0, n) &#123; ans++; if(l[i] + l[n - 1] &lt;= M) n--; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 暴力枚举LA6196 123456789101112131415161718192021222324const int maxn = 1000 + 10;int n;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string D[maxn], P; while(cin &gt;&gt; n &amp;&amp; n) &#123; _for(i, 0, n) cin &gt;&gt; D[i]; sort(D, D + n); string L = D[n / 2 - 1], R = D[n / 2]; P = \"A\"; _for(i, 0, L.size()) &#123; while(P[i] &lt;= 'Z' &amp;&amp; P &lt; L) P[i]++; if(P[i] &lt;= 'Z' &amp;&amp; L &lt;= P &amp;&amp; P &lt; R) break; if(L[i] != P[i]) P[i]--; P += \"A\"; &#125; cout &lt;&lt; P &lt;&lt; endl; &#125;&#125; 区间非连续子序列预处理有一类问题称为在区间中选出若干个点(不一定连续), 这若干个点组成的子序列需要满足一定条件 UVA11491 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const int maxn = 100000 + 10;char buf[maxn];int A[maxn];int g[maxn][10];int N, D;void init() &#123; Set(buf, 0);; Set(A, 0); Set(g, 0);&#125;void initCal() &#123; _rep(x, 0, 9) &#123; int pos = N; _forDown(i, N - 1, 0) &#123; if(A[i] == x) pos = i; g[i][x] = pos; &#125; &#125;&#125;bool valid(int x, int L, int R, int E) &#123; // can x valid in [L, R] return g[L][x] &lt;= R &amp;&amp; R - g[L][x] &gt;= E;&#125;int selectMax(int L, int R, int E, int&amp; pos) &#123; _forDown(x, 9, 0) &#123; if(!valid(x, L, R, E)) continue; pos = g[L][x]; return x; &#125;&#125;void solve(int E) &#123; initCal(); int L = 0; string ans; while (E--) &#123; int pos; ans += selectMax(L, N - 1, E, pos) + '0'; L = pos + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(scanf(\"%d%d\", &amp;N, &amp;D) == 2 &amp;&amp; N &amp;&amp; D) &#123; init(); scanf(\"%s\", buf); _for(i, 0, N) A[i] = buf[i] - '0'; // input finished solve(N - D); &#125;&#125; 图形旋转问题LA5237 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125const int maxn = 13;class Point &#123;public: int x, y; Point(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125; bool operator&lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x == rhs.x &amp;&amp; y &lt; rhs.y); &#125; bool operator== (const Point&amp; rhs) const &#123; return x == rhs.x &amp;&amp; y == rhs.y; &#125;&#125;;Point operator+ (const Point&amp; lhs, const Point&amp; rhs) &#123; return Point(lhs.x + rhs.x, lhs.y + rhs.y);&#125;Point operator- (const Point&amp; lhs, const Point&amp; rhs) &#123; return Point(lhs.x - rhs.x, lhs.y - rhs.y);&#125;Point rotate(const Point&amp; s, const Point&amp; r) &#123; Point dv = s - r; Point ans = r + Point(dv.y, -dv.x); return ans;&#125;class Line &#123;public: Point from, to; bool vertical; Line rot(const Point&amp; r) &#123; Line ret; ret.from = ::rotate(from, r); ret.to = ::rotate(to, r); return ret; &#125; void normalize() &#123; vertical = (from.x == to.x); if(vertical) &#123; if(from.y &gt; to.y) swap(from.y, to.y); &#125; else &#123; if(from.x &gt; to.x) swap(from.x, to.x); &#125; &#125;&#125;;int n;vector&lt;Line&gt; lines;void init() &#123; lines.clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(cin &gt;&gt; n &amp;&amp; n) &#123; init(); Line l; l.to = Point(1, 0); l.vertical = false; lines.push_back(l); int minY = l.from.y, maxY = l.from.y; int minX = l.from.x, maxX = l.to.x; // debug(maxX); Point st = l.from, rt = l.to; // s rotate around r //debug(lines.size()); _for(i, 0, n) &#123; int sz = lines.size(); _for(j, 0, sz) &#123; Line nl = lines[j].rot(rt); nl.normalize(); lines.push_back(nl); // debug(lines.size()); &#125; rt = rotate(st, rt); &#125; // rotate finished map&lt;Point, char&gt; mp; _for(i, 0, lines.size()) &#123; Point&amp; lp = lines[i].from; lp.x *= 2; if(lines[i].vertical) lp.x--; minX = min(minX, lp.x); maxX = max(maxX, lp.x); minY = min(minY, lp.y); maxY = max(maxY, lp.y); //debug(maxY); //debug(maxX); mp[lp] = lines[i].vertical ? '|' : '_'; &#125; // output // debug(minX); string buf; _forDown(y, maxY, minY) &#123; buf.clear(); _rep(x, minX, maxX) &#123; Point cur(x, y); if(mp.count(cur)) buf += mp[cur]; else buf += ' '; &#125; while(*(buf.rbegin()) == ' ') buf.erase(buf.size() - 1); cout &lt;&lt; buf &lt;&lt; endl; &#125; cout &lt;&lt; '^' &lt;&lt; endl; &#125;&#125; 求最小操作次数LA6152 123456789101112131415161718192021222324252627282930313233343536373839string S, T;int diff[2][2];void init() &#123; Set(diff, 0);&#125;int solve() &#123; int q0 = 0, q1 = 0; int ans = 0; _for(i, 0, S.size()) if(S[i] != T[i]) &#123; if(S[i] == '0') diff[0][1]++; if(S[i] == '1') diff[1][0]++; if(S[i] == '?' &amp;&amp; T[i] == '0') q0++; if(S[i] == '?' &amp;&amp; T[i] == '1') q1++; &#125; int x = min(diff[0][1], diff[1][0]); ans = x + q0; diff[0][1] -= x; diff[1][0] -= x; if(diff[1][0] &gt; q1) return -1; ans += diff[1][0] + diff[0][1] + q1; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; cin &gt;&gt; kase; for(int t = 1; cin &gt;&gt; S &gt;&gt; T; t++) &#123; init(); int ans = solve(); printf(\"Case %d: %d\\n\", t, ans); &#125;&#125; 二分思想处理冒泡排序想办法找到i这个位置应该放置的数然后pos[i] =&gt; i，进行归位 LA6588 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const int maxn = 100000 + 10;int n, arr[maxn];vector&lt;pair&lt;int, int&gt; &gt; vec;void init() &#123; Set(arr, 0); vec.clear();&#125;int Find(int x) &#123; _rep(i, 1, n) if(arr[i] == x) return i; return -1;&#125;void swapSeg(int from, int to) &#123; // [from, to] int len = to - from + 1; _for(i, 0, len / 2) swap(arr[from + i], arr[from + len / 2 + i]); vec.push_back(make_pair(from, to));&#125;void solve() &#123; _rep(i, 1, n) &#123; if(arr[i] == i) continue; int pos = Find(i); int to = i + (pos - i) * 2 - 1; while (to &gt; n) &#123; int len = pos - i + 1; if(len % 2) swapSeg(i + 1, pos); else swapSeg(i, pos); pos = Find(i); to = i + (pos - i) * 2 - 1; &#125; swapSeg(i, to); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; init(); scanf(\"%d\", &amp;n); _rep(i, 1, n) scanf(\"%d\", &amp;arr[i]); solve(); printf(\"%lu\\n\", vec.size()); _for(i, 0, vec.size()) printf(\"%d %d\\n\", vec[i].first, vec[i].second); &#125;&#125; 环形链表型的冒泡排序UVA11925 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849vector&lt;int&gt; cmd, A;int n;void init() &#123; cmd.clear(); A.clear();&#125;bool ok() &#123; _for(i, 0, n) &#123; if(A[i] != i + 1) return false; &#125; return true;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; init(); int x; _for(i, 0, n) &#123; scanf(\"%d\", &amp;x); A.push_back(x); &#125; // input finished, then solve if(n == 1) &#123; puts(\"\"); continue; &#125; while(true) &#123; if(ok()) break; if(A[0] &gt; A[1] &amp;&amp; A[0] != n) &#123; swap(A[0], A[1]); cmd.push_back(1); &#125; else &#123; A.insert(A.begin(), A[n - 1]); A.resize(n); cmd.push_back(2); &#125; &#125; _forDown(i, cmd.size() - 1, 0) printf(\"%d\", cmd[i]); printf(\"\\n\"); &#125;&#125; 过滤排序(冒泡排序的变形)其实从冒泡排序的思想出发还可以引伸出一种排序叫filter sort(过滤排序) 算法思想如下","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://www.fogsail.net/tags/贪心/"}]},{"title":"高效算法设计(三)","slug":"20190809","date":"2019-08-09T07:10:42.000Z","updated":"2019-09-10T06:53:31.392Z","comments":true,"path":"2019/08/09/20190809/","link":"","permalink":"https://www.fogsail.net/2019/08/09/20190809/","excerpt":"这里主要阐述一下贪心算法的实践以及一些具体的应用所需的头文件见高效算法设计(二) 复习一下, 优先队列从小到大输出1priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; que;","text":"这里主要阐述一下贪心算法的实践以及一些具体的应用所需的头文件见高效算法设计(二) 复习一下, 优先队列从小到大输出1priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; que; “最大值尽量小”优化POJ1505 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const int maxn = 500 + 10;int A[maxn], m, k;int last[maxn];llong tot = 0;int maxv = -1;void init() &#123; Set(A, 0); Set(last, 0); tot = 0; maxv = -1;&#125;int solve(llong x) &#123; llong ans = 0; // do not exceed x int cnt = 1; _for(i, 0, m) &#123; if(ans + A[i] &lt;= x) ans += A[i]; else &#123; ans = A[i]; cnt++; &#125; &#125; return cnt;&#125;void print(llong x) &#123; // do not exceed x llong ans = 0; int remain = k; _forDown(i, m - 1, 0) &#123; if(ans + A[i] &gt; x || i + 1 &lt; remain) &#123; last[i] = 1; remain--; ans = A[i]; &#125; else ans += A[i]; &#125; _for(i, 0, m-1) &#123; printf(\"%d \", A[i]); if(last[i]) printf(\"/ \"); &#125; printf(\"%d\\n\", A[m - 1]);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while(kase--) &#123; init(); scanf(\"%d%d\", &amp;m, &amp;k); _for(i, 0, m) &#123; scanf(\"%d\", &amp;A[i]); tot += A[i]; maxv = max(maxv, A[i]); &#125; // then we finished input // binary search llong L = maxv, R = tot; while(L &lt; R) &#123; llong mid = L + (R - L) / 2; if(solve(mid) &lt;= k) R = mid; else L = mid + 1; &#125; print(L); &#125;&#125; 找规律的题(无聊水题)UVA12627 这个题目略显无聊 12345678910111213141516171819202122llong tot(int k) &#123; return k == 0 ? 1 : 3 * tot(k - 1);&#125;llong f(int k, int i) &#123; if(i == 0) return 0; if(k == 0) return 1; int exp = (1 &lt;&lt; (k - 1)); if(i &lt; exp) return 2 * f(k - 1, i); else return 2 * tot(k - 1) + f(k - 1, i - exp);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T, k, a, b; scanf(\"%d\", &amp;T); _rep(kase, 1, T) &#123; cin &gt;&gt; k &gt;&gt; a &gt;&gt; b; cout &lt;&lt; \"Case \" &lt;&lt; kase &lt;&lt; \": \" &lt;&lt; f(k, b) - f(k, a - 1) &lt;&lt; \"\\n\"; &#125;&#125; 模拟+贪心水题UVA11093 枚举思路[i, p] 无法到p+1, 则从[i, i+1, …, p]都无法到p+1$k \\in [i, i+1, \\cdots, p]$在$k$这个点, 油量$\\geq 0$, 而如果$k$作为起点, 油量$=0$大于0都走不到，更不用说等于0了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const int maxn = 100001 + 10;int p[maxn], q[maxn];int n;void init() &#123; Set(p, 0); Set(q, 0);&#125;int go(int s) &#123; int oil = p[s] - q[s]; for(int i = (s + 1) % n; i != s; i = (i + 1) % n) &#123; if(oil &lt; 0) return i; // i is the point cannot reached oil += (p[i] - q[i]); &#125; // s-1 to s, oil &lt; 0, cannot reached s again // oil &gt;= 0, means s-1 to s, can go if(oil &lt; 0) return -1; return s;&#125;int solve() &#123; int from = 0; for( ; ;) &#123; int to = go(from); if(to &lt; from) return -1; if(to == from) return from; from = to; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); _rep(kase, 1, T) &#123; init(); scanf(\"%d\", &amp;n); _for(i, 0, n) scanf(\"%d\", &amp;p[i]); _for(i, 0, n) scanf(\"%d\", &amp;q[i]); // input finished, then solve the problem int ans = solve(); printf(\"Case %d: \", kase); if(ans &lt; 0) printf(\"Not possible\\n\"); else printf(\"Possible from station %d\\n\", ans + 1); &#125;&#125; 位运算和贪心枚举LA2440 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const int maxm = 200000 + 10;const int maxn = 100000 + 10;int n, m;class Gate &#123;public: int a, b, o; void clear() &#123; a = b = o = 0; &#125;&#125;;Gate gates[maxm];void init() &#123; _for(i, 0, maxm) gates[i].clear();&#125;// k 0s: 00...011...1// as data flows to gates[1...m]int output(int k) &#123; _rep(i, 1, m) &#123; int a = gates[i].a; int b = gates[i].b; int va = a &lt; 0 ? (-a) &gt; k : gates[a].o; int vb = b &lt; 0 ? (-b) &gt; k : gates[b].o; gates[i].o = !(va &amp; vb); &#125; return gates[m].o;&#125;int solve(int vn) &#123; // vn are all 0 int L = 1, R = n; while(L &lt; R) &#123; int M = L + (R - L) / 2; if(output(M) == vn) R = M; else L = M + 1; &#125; return L;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while(T--) &#123; init(); scanf(\"%d%d\", &amp;n, &amp;m); _rep(i, 1, m) scanf(\"%d%d\", &amp;gates[i].a, &amp;gates[i].b); // input finished // solve gates A = 0 int v0 = output(0); // all 1 int vn = output(n); // all zero if(v0 == vn) &#123; _rep(i, 1, n) printf(\"0\"); &#125; else &#123; // int x = solve(vn); _for(i, 1, x) printf(\"0\"); printf(\"x\"); _rep(i, x + 1, n) printf(\"1\"); &#125; printf(\"\\n\"); &#125;&#125; 滑动窗口滑动窗口问题在“连续的s个元素”问题中应用非常广泛尽量保证滑动窗口的大小不变, 然后维护一个map win和只出现一次的数的个数 LA4294 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const int maxn = 100000 + 10;int A[maxn * 3], ok[maxn * 3];map&lt;int, int&gt; win;typedef map&lt;int, int&gt;::iterator mii;int n, s;void init() &#123; Set(A, -1); Set(ok, 0); win.clear();&#125;// i is the index of A[i]bool ins(int i, map&lt;int, int&gt;&amp; win) &#123; int first = 0; if(!win.count(A[i])) first = true; win[A[i]] = win[A[i]] + 1; return first;&#125;bool del(int i, map&lt;int, int&gt;&amp; win) &#123; if(!win.count(A[i])) return false; win[A[i]] = win[A[i]] - 1; if(win[A[i]] &lt; 1) &#123; win.erase(A[i]); return true; &#125; else return false;&#125;void slide() &#123; win.clear(); int cnt = 0; _for(i, 0, s + n + 1) &#123; if(cnt == s) ok[i] = true; if(i &lt; s &amp;&amp; cnt == i) ok[i] = true; if(i + s &gt; s + n &amp;&amp; cnt == s + n - i) ok[i] = true; if(i == s + n) break; if(A[i] != -1 &amp;&amp; del(i, win)) cnt--; if(A[i + s] != -1 &amp;&amp; ins(i + s, win)) cnt++; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; cin &gt;&gt; T; while (T--) &#123; init(); cin &gt;&gt; s &gt;&gt; n; _for(i, 0, n) cin &gt;&gt; A[s + i]; // then solve the problem slide(); int ans = 0; _for(i, 0, s) &#123; bool valid = 1; for(int j = i + 1; j &lt; s + n + 1; j += s) if(!ok[j]) valid = false; if(valid) ans++; &#125; if(ans &gt;= n + 1) ans = s; printf(\"%d\\n\", ans); &#125;&#125; 区间扩展并且记录上一个元素的位置HDU2756 12345678910111213141516171819202122232425262728293031323334353637const int maxn = 1000000 + 10;int A[maxn];map&lt;int, int&gt; last;int pre[maxn];int n;void init() &#123; Set(A, 0); Set(pre, 0); last.clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; while(scanf(\"%d\", &amp;T) != EOF) &#123; while (T--) &#123; init(); scanf(\"%d\", &amp;n); _for(i, 0, n) &#123; scanf(\"%d\", &amp;A[i]); if (!last.count(A[i])) pre[i] = -1; else pre[i] = last[A[i]]; last[A[i]] = i; &#125; int R = 0, ans = 0; _for(L, 0, n) &#123; while (R &lt; n &amp;&amp; pre[R] &lt; L) R++; ans = max(ans, R - L); &#125; printf(\"%d\\n\", ans); &#125; &#125;&#125; 中途相遇法与分治思想LA6258 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const int maxn = 200000 + 5;int pre[maxn], nxt[maxn], A[maxn];map&lt;int, int&gt; cur;int n;void initCur() &#123; cur.clear();&#125;void init() &#123; Set(pre, 0); Set(nxt, 0); Set(A, 0);&#125;inline bool uniq(int p, int L, int R) &#123; return pre[p] &lt; L &amp;&amp; nxt[p] &gt; R;&#125;bool check(int L, int R) &#123; if(L &gt;= R) return true; for(int d = 0; L + d &lt;= R - d; d++) &#123; if(uniq(L + d, L, R)) return check(L, L + d - 1) &amp;&amp; check(L + d + 1, R); if(L + d == R - d) break; if(uniq(R - d, L, R)) return check(L, R - d - 1) &amp;&amp; check(R - d + 1, R); &#125; return false;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; // init(); initCur(); scanf(\"%d\", &amp;n); _for(i, 0, n) &#123; scanf(\"%d\", &amp;A[i]); if(!cur.count(A[i])) pre[i] = -1; else pre[i] = cur[A[i]]; cur[A[i]] = i; &#125; initCur(); _forDown(i, n - 1, 0) &#123; if(!cur.count(A[i])) nxt[i] = n; else nxt[i] = cur[A[i]]; cur[A[i]] = i; &#125; if(check(0, n - 1)) printf(\"non-boring\\n\"); else printf(\"boring\\n\"); &#125;&#125; 贪心和博弈LA6271 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const int maxn = 1024 + 5;char G[maxn][maxn];int n;// vector&lt;int&gt; win, gray point; vector&lt;int&gt; lose, black pointvoid solve() &#123; vector&lt;int&gt; win, lose; _rep(i, 2, n) &#123; if(G[1][i] == '1') win.push_back(i); else lose.push_back(i); &#125; int rnd = n; while (rnd &gt; 1) &#123; vector&lt;int&gt; win2, lose2, last; // phase 1 _for(i, 0, lose.size()) &#123; int _lose = lose[i]; bool matched = false; _for(j, 0, win.size()) &#123; int&amp; _win = win[j]; if(_win &gt; 0 &amp;&amp; G[_win][_lose] == '1') &#123; printf(\"%d %d\\n\", _win, _lose); win2.push_back(_win); _win = 0; matched = true; break; &#125; &#125; if(!matched) last.push_back(_lose); &#125; // phase 2 bool first = true; _for(i, 0, win.size()) &#123; int _win = win[i]; if(_win &gt; 0) &#123; if(first) &#123; printf(\"1 %d\\n\", _win); first = false; &#125; else last.push_back(_win); &#125; &#125; // phase 3 for(int i = 0; i &lt; last.size(); i += 2) &#123; printf(\"%d %d\\n\", last[i], last[i + 1]); int keep = last[i]; if(G[last[i + 1]][keep] == '1') keep = last[i + 1]; if(G[1][keep] == '1') win2.push_back(keep); else lose2.push_back(keep); &#125; win = win2; lose = lose2; rnd &gt;&gt;= 1; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(scanf(\"%d\", &amp;n) == 1) &#123; _rep(i, 1, n) scanf(\"%s\", G[i] + 1); // input finished solve(); &#125;&#125; 扫描法水题LA4621 1234567891011121314151617181920212223242526272829303132const int maxn = 1000000 + 10;int n, p[maxn], s[maxn], h[maxn];int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; scanf(\"%d\", &amp;n); _for(i, 0, n) scanf(\"%d\", &amp;p[i]); _for(i, 0, n) scanf(\"%d\", &amp;s[i]); int ans = 0; int level = s[0]; _for(i, 0, n) &#123; if(level &lt; p[i]) level = p[i]; if(level &gt; s[i]) level = s[i]; h[i] = level; &#125; level = s[n - 1]; _forDown(i, n - 1, 0) &#123; if(level &lt; p[i]) level = p[i]; if(level &gt; s[i]) level = s[i]; ans += min(level, h[i]) - p[i]; &#125; printf(\"%d\\n\", ans); &#125;&#125; 单调栈和状态组织LA4950 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const int maxn = 1000 + 10;char grid[maxn][maxn];int height[maxn], ans[maxn * 2];int n, m;class Rec &#123;public: int c, h; Rec(int _c = 0, int _h = 0) : c(_c), h(_h) &#123;&#125;&#125;;Rec stk[maxn];void init() &#123; Set(height, 0); Set(ans, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; init(); scanf(\"%d%d\", &amp;n, &amp;m); _for(i, 0, n) scanf(\"%s\", grid[i]); _for(i, 0, n) &#123; int top = -1; _for(j, 0, m) &#123; if(grid[i][j] == '#') &#123; top = -1; height[j] = 0; &#125; else &#123; // land can be sold height[j]++; Rec cur(j, height[j]); if(top &lt; 0) stk[++top] = cur; else &#123; while(top &gt;= 0 &amp;&amp; stk[top].h &gt;= cur.h) cur.c = stk[top--].c; if(top &lt; 0 || stk[top].h - stk[top].c &lt; cur.h - cur.c) stk[++top] = cur; &#125; ans[j - stk[top].c + stk[top].h + 1]++; &#125; &#125; &#125; _rep(i, 1, n + m) if(ans[i]) printf(\"%d x %d\\n\", ans[i], i * 2); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://www.fogsail.net/tags/贪心/"}]},{"title":"高效算法设计(二)","slug":"20190805","date":"2019-08-05T11:06:12.000Z","updated":"2019-08-08T16:44:15.505Z","comments":true,"path":"2019/08/05/20190805/","link":"","permalink":"https://www.fogsail.net/2019/08/05/20190805/","excerpt":"在贪心算法的基础上再加一些辅助的优化和求解策略比如数据结构优化，扫描线等等","text":"在贪心算法的基础上再加一些辅助的优化和求解策略比如数据结构优化，扫描线等等 头文件 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;#include &lt;assert.h&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int maxn = 1000 + 10;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++) 扫描线行列式优化POJ2280 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const int maxn = 1000 + 10;int n;class Point &#123;public: int x, y; double deg; bool operator&lt; (const Point&amp; rhs) const &#123; return deg &lt; rhs.deg; &#125;&#125;;Point mol[maxn], pt[maxn];int color[maxn];void init() &#123; Set(color, 0);&#125;bool det(const Point&amp; A, const Point&amp; B) &#123; return A.x * B.y - A.y * B.x &gt;= 0;&#125;int solve() &#123; if(n &lt;= 2) return 2; int ans = 0; // update ans // i as pivot _for(i, 0, n) &#123; int k = 0; _for(j, 0, n) &#123; if(j == i) continue; pt[k].x = mol[j].x - mol[i].x; pt[k].y = mol[j].y - mol[i].y; if(color[j]) &#123; pt[k].x = -pt[k].x; pt[k].y = -pt[k].y; &#125; pt[k].deg = atan2(pt[k].y, pt[k].x); k++; &#125; // i as pivot, original point // all nodes relative coordinates =&gt; pt[0, k) sort(pt, pt + k); int R = 0, cnt = 2; _for(L, 0, k) &#123; if(R == L) &#123; R = (R + 1) % k; cnt++; &#125; while(R != L &amp;&amp; det(pt[L], pt[R])) &#123; R = (R + 1) % k; cnt++; &#125; cnt--; ans = max(ans, cnt); &#125; &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; init(); _for(i, 0, n) scanf(\"%d%d%d\", &amp;mol[i].x, &amp;mol[i].y, &amp;color[i]); printf(\"%d\\n\", solve()); &#125;&#125; 贪心模版: 区间扩展HDU2756 123456789101112131415161718192021222324252627int A[maxn];void init() &#123; Set(A, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase, n; while(scanf(\"%d\", &amp;kase) != EOF) &#123; while(kase--) &#123; scanf(\"%d\", &amp;n); init(); _for(i, 0, n) scanf(\"%d\", &amp;A[i]); set&lt;int&gt; inter; int R = 0, ans = 0; _for(L, 0, n) &#123; while(R &lt; n &amp;&amp; !inter.count(A[R])) inter.insert(A[R++]); ans = max(ans, R - L); inter.erase(A[L]); &#125; printf(\"%d\\n\", ans); &#125; &#125;&#125; 单调栈与单调队列单调栈POJ2559 123456789101112131415161718192021222324252627282930313233343536373839404142434445const int maxn = 100000 + 10;class Rec &#123;public: int h, w; Rec(int _h = 0, int _w = 0) : h(_h), w(_w) &#123;&#125;&#125;;int n;Rec recs[maxn];llong ans;stack&lt;Rec&gt; stk;void init() &#123; ans = 0; while(!stk.empty()) stk.pop();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (cin &gt;&gt; n &amp;&amp; n) &#123; init(); stk.push(Rec(0, 0)); _rep(i, 1, n + 1) &#123; int x; if(i == n + 1) x = 0; else scanf(\"%d\", &amp;x); if(stk.top().h &lt; x) stk.push(Rec(x, 1)); else &#123; int width = 0; while (stk.top().h &gt; x) &#123; width += stk.top().w; ans = max(ans, (llong)width * stk.top().h); stk.pop(); &#125; stk.push(Rec(x, width + 1)); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 单调队列最大子序和 1234567891011121314151617181920212223242526272829303132333435const int maxn = 300000 + 10;int A[maxn];llong S[maxn];int n, m;deque&lt;int&gt; que;void init() &#123; Set(A, 0); Set(S, 0); while(!que.empty()) que.pop_front();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); cin &gt;&gt; n &gt;&gt; m; _rep(i, 1, n) &#123; scanf(\"%d\", &amp;A[i]); S[i] = S[i - 1] + A[i]; &#125; llong ans = 0; // use [que.back(), que.front()] to match [i - m, i - 1] // ans = max(ans, [que.back(), i]) que.push_front(0); _rep(i, 1, n) &#123; while(!que.empty() &amp;&amp; que.back() &lt; i - m) que.pop_back(); ans = max(ans, S[i] - S[que.back()]); while(!que.empty() &amp;&amp; S[que.front()] &gt;= S[i]) que.pop_front(); que.push_front(i); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 单调性+区间扩张涉及单调性优化贪心的问题，往往和一个值的“生存周期”有关选择生存周期尽量长的g[j] &gt;= g[i], i不进入集合，这里要取等因为j位置之前已经出现过了，相当于j经历了很多考验g[j] == g[i]的时候，更应该保留j LA4976 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const int maxn = 200000 + 10;int n, a[maxn], f[maxn], g[maxn];void init() &#123; Set(a, 0); Set(f, 0); Set(g, 0);&#125;void initCal() &#123; g[0] = 1; _for(i, 1, n) &#123; if(a[i] &gt; a[i - 1]) g[i] = g[i - 1] + 1; else g[i] = 1; &#125; f[n - 1] = 1; _forDown(i, n - 2, 0) &#123; if(a[i] &lt; a[i + 1]) f[i] = f[i + 1] + 1; else f[i] = 1; &#125;&#125;class Node &#123;public: int A, g; Node(int _A = 0, int _g = 0) : A(_A), g(_g) &#123;&#125; bool operator&lt; (const Node&amp; rhs) const &#123; return A &lt; rhs.A; &#125;&#125;;typedef set&lt;Node&gt;::iterator sit;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while(kase--) &#123; scanf(\"%d\", &amp;n); init(); _for(i, 0, n) scanf(\"%d\", &amp;a[i]); if(n == 1) &#123; printf(\"1\\n\"); continue; &#125; initCal(); // init calculate f() and g() // then solve set&lt;Node&gt; tb; tb.clear(); tb.insert(Node(a[0], g[0])); int ans = 1; _for(i, 1, n) &#123; Node cur(a[i], g[i]); sit it = tb.lower_bound(cur); bool keep = true; if(it != tb.begin()) &#123; Node last = *(--it); int len = last.g + f[i]; ans = max(ans, len); if(cur.g &lt;= last.g) keep = false; &#125; if(keep) &#123; tb.erase(cur); tb.insert(cur); it = tb.find(cur); it++; while(it != tb.end() &amp;&amp; (it-&gt;A &gt; cur.A &amp;&amp; it-&gt;g &lt;= cur.g)) tb.erase(it++); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 斜率优化LA4726 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int maxn = 100000 + 10;int S[maxn], st[maxn];char str[maxn];int n, L;void init() &#123; Set(S, 0); Set(st, 0); Set(str, 0);&#125;void initCal() &#123; S[0] = 0; _rep(i, 1, n) S[i] = S[i - 1] + str[i] - '0';&#125;int minusSlope(int x1, int x2, int x3, int x4) &#123; return (S[x2] - S[x1 - 1]) * (x4 - x3 + 1) - (S[x4] -S[x3 - 1]) * (x2 - x1 + 1);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while(kase--) &#123; init(); scanf(\"%d%d%s\", &amp;n, &amp;L, str + 1); // input finished initCal(); int ansL = 1, ansR = n; int l = 0, r = 0; _rep(t, L, n) &#123; // st[l, r) is candidate start point // t - L + 1 represent start point // stack st, put value t - L + 1 while (r - l &gt; 1 &amp;&amp; minusSlope(st[r - 2], t - L, st[r - 1], t - L) &gt;= 0) r--; st[r++] = t - L + 1; // find tangent point st[l] // [st[l], t) is the max while(r - l &gt; 1 &amp;&amp; minusSlope(st[l], t, st[l + 1], t) &lt;= 0) l++; int dslp = minusSlope(st[l], t, ansL, ansR); if(dslp &gt; 0 || (dslp == 0 &amp;&amp; t - st[l] &lt; ansR - ansL)) &#123; ansL = st[l]; ansR = t; &#125; &#125; printf(\"%d %d\\n\", ansL, ansR); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://www.fogsail.net/tags/贪心/"}]},{"title":"动态规划专题(一)","slug":"20190731","date":"2019-07-31T08:39:18.000Z","updated":"2020-06-17T01:27:46.846Z","comments":true,"path":"2019/07/31/20190731/","link":"","permalink":"https://www.fogsail.net/2019/07/31/20190731/","excerpt":"这篇文章主要介绍线性dp以李煜东大神的《算法竞赛进阶指南》和刘汝佳的紫书为蓝本再加上几道比较复杂的dp题","text":"这篇文章主要介绍线性dp以李煜东大神的《算法竞赛进阶指南》和刘汝佳的紫书为蓝本再加上几道比较复杂的dp题 线性dp暴力求解POJ2279 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//// main.cpp// POJ2279//// Created by zhangmin chen on 2019/7/31.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;#include &lt;assert.h&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int maxn = 5 + 1;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)int N[maxn], k;void solve() &#123; // _rep(i, 1, k) scanf(\"%d\", &amp;N[i]); while(k &lt; 5) N[++k] = 0; // _rep(i, 0, 5) debug(N[i]); // cout &lt;&lt; endl; llong f[N[1] + 1][N[2] + 1][N[3] + 1][N[4] + 1][N[5] + 1]; Set(f, 0); // then DP f[0][0][0][0][0] = 1; _rep(i, 0, N[1]) _rep(j, 0, N[2]) _rep(k, 0, N[3]) _rep(l, 0, N[4]) _rep(m, 0, N[5]) &#123; if(i &lt; N[1]) f[i + 1][j][k][l][m] += f[i][j][k][l][m]; if(j &lt; N[2] &amp;&amp; j &lt; i) f[i][j + 1][k][l][m] += f[i][j][k][l][m]; if(k &lt; N[3] &amp;&amp; k &lt; j) f[i][j][k + 1][l][m] += f[i][j][k][l][m]; if(l &lt; N[4] &amp;&amp; l &lt; k) f[i][j][k][l + 1][m] += f[i][j][k][l][m]; if(m &lt; N[5] &amp;&amp; m &lt; l) f[i][j][k][l][m + 1] += f[i][j][k][l][m]; &#125; cout &lt;&lt; f[N[1]][N[2]][N[3]][N[4]][N[5]] &lt;&lt; endl;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(scanf(\"%d\", &amp;k) == 1 &amp;&amp; k) solve();&#125; 刷表dp(递归求解)模版OPENJUDGE2760123456789101112131415161718192021222324int dp[maxn][maxn];int tb[maxn][maxn];int n;void init() &#123; Set(dp, -1); Set(tb, 0);&#125;int solve(int i, int j) &#123; if(dp[i][j] &gt;= 0) return dp[i][j]; int&amp; ans = dp[i][j]; return ans = tb[i][j] + (i == n ? 0 : max(solve(i + 1, j), solve(i + 1, j + 1)));&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); scanf(\"%d\", &amp;n); _rep(i, 1, n) _rep(j, 1, i) scanf(\"%d\", &amp;tb[i][j]); cout &lt;&lt; solve(1, 1) &lt;&lt; endl;&#125; DAG DP模版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Rec &#123;public: int a, b;&#125;;Rec rec[maxn];int G[maxn][maxn];int n;int F[maxn];void init() &#123; Set(G, 0); Set(F, -1);&#125;bool valid(Rec&amp; lhs, Rec&amp; rhs) &#123; return (lhs.a &lt; rhs.a &amp;&amp; lhs.b &lt; rhs.b) || (lhs.a &lt; rhs.b &amp;&amp; lhs.b &lt; rhs.a);&#125;// i in j// G[i][j] = 1// i -&gt; jint dp(int x) &#123; if(F[x] != -1) return F[x]; int&amp; ans = F[x]; ans = 1; _rep(i, 1, n) if(G[x][i]) ans = max(ans, dp(i) + 1); return ans;&#125;void printAns(int u) &#123; printf(\"%d \", u); _rep(i, 1, n) if(G[u][i] &amp;&amp; F[u] == F[i] + 1) &#123; printAns(i); break; &#125; return;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); scanf(\"%d\", &amp;n); _rep(i, 1, n) scanf(\"%d%d\", &amp;rec[i].a, &amp;rec[i].b); _rep(i, 1, n) _rep(j, 1, n) G[i][j] = valid(rec[i], rec[j]); _rep(i, 1, n) if(F[i] == -1) F[i] = dp(i); int tid = 0; _rep(i, 1, n) if(F[i] &gt; F[tid]) tid = i; cout &lt;&lt; F[tid] &lt;&lt; endl; printAns(tid); cout &lt;&lt; endl; &#125; DAG用解答树刷表法，思路很清晰 硬币问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int V[maxn];int S, N;int minV[maxn], maxV[maxn];int d[maxn];int minCoin[maxn], maxCoin[maxn];void init() &#123; Set(V, 0); Set(minV, inf); Set(maxV, -inf); Set(d, -1); Set(minCoin, 0); Set(maxCoin, 0);&#125;void dp() &#123; minV[0] = maxV[0] = 0; _rep(i, 1, S) _rep(j, 1, N) &#123; if(i &gt;= V[j]) &#123; minV[i] = min(minV[i], minV[i - V[j]] + 1); maxV[i] = max(maxV[i], maxV[i - V[j]] + 1); &#125; &#125; printf(\"%d %d\\n\", minV[S], maxV[S]);&#125;// usage:// minCoin[coinValue] = coinIDvoid dp2() &#123; minV[0] = maxV[0] = 0; _rep(i, 1, S) _rep(j, 1, N) if(i &gt;= V[j]) &#123; if(minV[i] &gt; minV[i - V[j]] + 1) &#123; minV[i] = minV[i - V[j]] + 1; minCoin[i] = j; &#125; if(maxV[i] &lt; maxV[i - V[j]] + 1) &#123; maxV[i] = maxV[i - V[j]] + 1; maxCoin[i] = j; &#125; &#125; printf(\"%d %d\\n\", minV[S], maxV[S]);&#125;void printAns(int* d, int S) &#123; while(S) &#123; printf(\"%d \", d[S]); S -= V[d[S]]; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); scanf(\"%d%d\", &amp;N, &amp;S); _rep(i, 1, N) scanf(\"%d\", &amp;V[i]); dp2(); printAns(minCoin, S); cout &lt;&lt; endl; printAns(maxCoin, S);&#125; LCIS问题LCIS最长公共上升子序列 $\\textbf{algorithm}$$f(i, j) \\text{ 表示 } A[1\\cdots i]的子序列, B[1\\cdots j]的子序列构成的$$\\text{并且以 } B[j] \\text{ 结尾的 LICS 长度}$ \\begin{cases} f(i, j) = f(i - 1, j) && A_i \\neq B_j \\\\ f(i, j) = \\max\\limits_{0 \\leqslant k","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"https://www.fogsail.net/tags/dp/"}]},{"title":"暴力求解和IDA*(四)","slug":"20190729","date":"2019-07-29T13:03:46.000Z","updated":"2019-08-28T04:06:32.692Z","comments":true,"path":"2019/07/29/20190729/","link":"","permalink":"https://www.fogsail.net/2019/07/29/20190729/","excerpt":"接上一篇的内容不过在暴力搜索的时候，会有一些复杂的情况需要数据结构辅助","text":"接上一篇的内容不过在暴力搜索的时候，会有一些复杂的情况需要数据结构辅助 并查集辅助搜索HDU3144 算法分析 容易写错的地方因为这里是尝试连接，并不是一开始就压缩合并并查集 12345return x == pa[x] ? x : findSet(pa[x]);这里我们先不需要另pa[x] = findSet(pa[x]);而是根据我们的尝试，放置'\\' or '/'再Union 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155//// main.cpp// HDU3144//// Created by zhangmin chen on 2019/7/28.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;#include &lt;assert.h&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int maxn = 7 + 5;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)int tar[maxn][maxn];int cur[maxn][maxn];char sign[maxn][maxn];int pa[maxn * maxn];int n;void initSet() &#123; _for(i, 0, maxn * maxn) pa[i] = i;&#125;int findSet(int x) &#123; return x == pa[x] ? x : findSet(pa[x]);&#125;void init() &#123; Set(tar, -1); Set(cur, 0); Set(sign, 0);&#125;bool ok(int p) &#123; int x = p / n, y = p % n; // if(tar[x][y] != -1 &amp;&amp; tar[x][y] != cur[x][y]) return false; if(x == n - 1 &amp;&amp; tar[x + 1][y] != -1 &amp;&amp; tar[x + 1][y] != cur[x + 1][y]) return false; if(y == n - 1 &amp;&amp; tar[x][y + 1] != -1 &amp;&amp; tar[x][y + 1] != cur[x][y + 1]) return false; if(x == n - 1 &amp;&amp; y == n - 1 &amp;&amp; tar[x + 1][y + 1] != -1 &amp;&amp; tar[x + 1][y + 1] != cur[x + 1][y + 1]) return false; return true;&#125;bool dfs(int p) &#123; if(p == n * n) return true; int x = p / n, y = p % n; // code: (x + p) // try to put (x + p) with '/' sign[x][y] = '/'; int pa1 = findSet(x + p + 1); int pa2 = findSet(x + p + 1 + n); if(pa1 != pa2) &#123; int tmp = pa[pa1]; pa[pa1] = pa2; cur[x][y + 1]++; cur[x + 1][y]++; if(ok(p) &amp;&amp; dfs(p + 1)) return true; cur[x + 1][y]--; cur[x][y + 1]--; pa[pa1] = tmp; &#125; sign[x][y] = '\\\\'; pa1 = findSet(x + p); pa2 = findSet(x + p + n + 2); if(pa1 != pa2) &#123; int tmp = pa[pa1]; pa[pa1] = pa2; cur[x][y]++; cur[x + 1][y + 1]++; if(ok(p) &amp;&amp; dfs(p + 1)) return true; cur[x + 1][y + 1]--; cur[x][y]--; pa[pa1] = tmp; &#125; return false;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); // int kase; // scanf(\"%d\", &amp;kase); while (scanf(\"%d\", &amp;n) != EOF) &#123; // init(); initSet(); // scanf(\"%d\", &amp;n); _for(i, 0, n + 1) _for(j, 0, n + 1) &#123; char ch; cin &gt;&gt; ch; if(ch == '.') tar[i][j] = -1; else tar[i][j] = ch - '0'; &#125; /* _for(i, 0, n + 1) &#123; _for(j, 0, n + 1) printf(\"% 2d\", tar[i][j]); printf(\"\\n\"); &#125; */ // input finished, then dfs dfs(0); _for(i, 0, n) &#123; _for(j, 0, n) cout &lt;&lt; sign[i][j]; printf(\"\\n\"); &#125; &#125;&#125; 表达式划分和搜索LA5217 省略头文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131const int ch[3] = &#123;'*', '+', '-'&#125;;set&lt;string&gt; output;char str[maxn];string res;int sign[maxn];int len = 0;bool ok = 0;bool cmp(const string&amp; lhs, const string&amp; rhs) &#123; return strcmp(lhs.c_str(), rhs.c_str()) &lt; 0;&#125;void init() &#123; output.clear(); res.clear(); Set(sign, 0); len = (int)(strlen(str) - 1); ok = 0;&#125;// is digit [0, len - 1]inline int cal() &#123; // use operator to divide operator into diffrent part int val1[maxn], val2[maxn]; int k1 = 0, k2 = 0; int cmd1[maxn], cmd2[maxn]; int p1 = 0, p2 = 0; // str -&gt; val1[] val1[0] = str[0] - '0'; _for(i, 0, len - 1) &#123; if(sign[i] == 3) &#123; // add no cmd if(val1[k1] == 0) return 0; val1[k1] = val1[k1] * 10 + str[i + 1] - '0'; &#125; else &#123; cmd1[p1++] = sign[i]; val1[++k1] = str[i + 1] - '0'; &#125; &#125; // cmd [0, p1 - 1], total length p1 // val1[] -&gt; val2[] // connect val1[] through '*' // val1[i] cmd[i] val1[i + 1] val2[0] = val1[0]; _for(i, 0, p1) &#123; if(cmd1[i] == 0) &#123; // val2[k2] *= val1[i + 1]; &#125; else &#123; cmd2[p2++] = cmd1[i]; val2[++k2] = val1[i + 1]; &#125; &#125; int ans = val2[0]; _for(i, 0, p2) &#123; if(cmd2[i] == 1) &#123; ans += val2[i + 1]; &#125; else &#123; ans -= val2[i + 1]; &#125; &#125; return ans;&#125;void dfs(int d) &#123; if(d == len - 1) &#123; // calculate // [0, len - 1] int val = cal(); //debug(val); if(val == 2000) &#123; // ok = 1; res += str[0]; _for(j, 0, d) &#123; if(sign[j] == 3) &#123; // put no operator res += str[j + 1]; &#125; else &#123; // res += ch[sign[j]]; res += str[j + 1]; &#125; &#125; //cout &lt;&lt; \"ans\" &lt;&lt; ans &lt;&lt; endl; output.insert(res); res.clear(); &#125; return; &#125; _for(i, 0, 4) &#123; sign[d] = i; dfs(d + 1); &#125;&#125;void solve() &#123; if(strcmp(str, \"2000=\") == 0) &#123; printf(\" IMPOSSIBLE\\n\"); return; &#125; dfs(0); if(ok == 0) printf(\" IMPOSSIBLE\\n\"); else &#123; for(auto&amp; it : output) &#123; cout &lt;&lt; \" \" &lt;&lt; it &lt;&lt; \"=\" &lt;&lt; endl; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while (scanf(\"%s\", str) &amp;&amp; str[0] != '=') &#123; init(); printf(\"Problem %d\\n\", ++kase); // then we solve the problem solve(); &#125;&#125; 运算符优先级划分表达式(性能好)123456789101112131415161718192021222324252627282930313233343536inline int cal() &#123; int val1[maxn], val2[maxn]; int k1 = 0, k2 = 0; vector&lt;int&gt; cmd1, cmd2; val1[0] = str[0] - '0'; _for(i, 0, len - 1) &#123; if(sign[i] == 3) &#123; // add no operator if(val1[k1] == 0) return 0; val1[k1] = val1[k1] * 10 + str[i + 1] - '0'; &#125; else &#123; cmd1.push_back(sign[i]); val1[++k1] = str[i + 1] - '0'; &#125; &#125; // then calculate * val2[0] = val1[0]; _for(i, 0, cmd1.size()) &#123; if(cmd1[i] == 0) val2[k2] *= val1[i + 1]; else &#123; cmd2.push_back(cmd1[i]); val2[++k2] = val1[i + 1]; &#125; &#125; int ans = val2[0]; _for(i, 0, cmd2.size()) &#123; if(cmd2[i] == 1) ans += val2[i + 1]; else ans -= val2[i + 1]; &#125; return ans;&#125; 运算符优先级划分表达式STL(性能差，但是易于实现)1234567891011121314151617181920212223242526272829303132333435363738394041inline int cal() &#123; vector&lt;int&gt; val1, val2; vector&lt;int&gt; cmd1, cmd2; val1.push_back(str[0] - '0'); _for(i, 0, len - 1) &#123; if(sign[i] == 3) &#123; // add no operator if(val1.back() == 0) return 0; int x = val1.back() * 10 + str[i + 1] - '0'; val1.pop_back(); val1.push_back(x); &#125; else &#123; cmd1.push_back(sign[i]); val1.push_back(str[i + 1] - '0'); &#125; &#125; // then calculate * val2.push_back(val1[0]); _for(i, 0, cmd1.size()) &#123; if(cmd1[i] == 0) &#123; int x = val2.back() * val1[i + 1]; val2.pop_back(); val2.push_back(x); &#125; else &#123; cmd2.push_back(cmd1[i]); val2.push_back(val1[i + 1]); &#125; &#125; int ans = val2[0]; _for(i, 0, cmd2.size()) &#123; if(cmd2[i] == 1) ans += val2[i + 1]; else ans -= val2[i + 1]; &#125; return ans;&#125; 2D dfs和贪心优化POJ1011 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int used[maxn], len = 0;int a[maxn], n, cnt;void init() &#123; Set(a, 0); len = 0;&#125;void initVis() &#123; Set(used, 0);&#125;bool cmp(int lhs, int rhs) &#123; return lhs &gt; rhs;&#125;bool dfs(int d, int curlen, int last) &#123; // if(d &gt; cnt) return true; if(curlen == len) return dfs(d + 1, 0, 0); int fail = 0; _for(i, last, n) if(!used[i] &amp;&amp; a[i] != fail &amp;&amp; curlen + a[i] &lt;= len) &#123; used[i] = true; if(dfs(d, curlen + a[i], i + 1)) return true; fail = a[i]; used[i] = 0; if(curlen == 0 || curlen + a[i] == len) return false; &#125; return false;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; init(); int sum = 0, maxl = 0; _for(i, 0, n) &#123; scanf(\"%d\", &amp;a[i]); sum += a[i]; maxl = max(maxl, a[i]); &#125; // scanf finished sort(a, a + n, cmp); for(len = maxl; len &lt;= sum; len++) &#123; // if(sum % len) continue; cnt = sum / len; initVis(); if(dfs(1, 0, 0)) break; &#125; cout &lt;&lt; len &lt;&lt; endl; &#125;&#125; 矩形枚举(debug经历)UVA11846 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123char grid[maxn][maxn];char ans[maxn][maxn];int N, K;class DIR &#123;public: int w, h; DIR(int _w = 0, int _h = 0) : w(_w), h(_h) &#123;&#125;&#125;;void init() &#123; Set(grid, '.'); Set(ans, '.');&#125;void dbg() &#123; _for(i, 0, N) &#123; _for(j, 0, N) printf(\"%c\", grid[i][j]); printf(\"\\n\"); &#125; printf(\"\\n\");&#125;void findSZ(const int u, vector&lt;DIR&gt;&amp; dirs) &#123; int x = u / N, y = u % N; int ey = N; // int tmp = 0; // [x, x + h] and [y, y + w] for(int h = 0; x + h &lt; N; h++) for(int w = 0; y + w &lt; ey; w++) &#123; // find if valid through [x, x + h] [y, y + w] int nx = x + h, ny = y + w; if(ans[nx][ny] != '.') &#123; ey = ny; break; &#125; int valid = 1, val = inf; // find digit in [x, x + h] [y, y + w] _rep(i, x, nx) &#123; _rep(j, y, ny) &#123; if(isdigit(grid[i][j])) &#123; if(val != inf) &#123; valid = false; // tmp = j; break; &#125; else &#123; // val = grid[i][j] - '0'; // tmp = j; &#125; &#125; &#125; if(!valid) break; &#125; // [x, x + h] [y, y + w] find digit num int sz = (w + 1) * (h + 1); // debug(sz); // debug(val); if(valid &amp;&amp; sz == val) &#123; dirs.push_back(DIR(w, h)); // debug(w); // debug(h); // cout &lt;&lt; \"====\\n\"; // ey = tmp; // debug(tmp); &#125; if(!valid) continue; &#125;&#125;bool dfs(int u, int id) &#123; if(u == N * N) return true; if(ans[u / N][u % N] != '.') return dfs(u + 1, id); vector&lt;DIR&gt; dirs; findSZ(u, dirs); /* _for(i, 0, dirs.size()) &#123; printf(\"(%d, %d) =&gt; (%d, %d)\", u / N, u % N, dirs[i].h, dirs[i].w); printf(\"\\n\"); &#125; */ int x = u / N, y = u % N; _for(k, 0, dirs.size()) &#123; int w = dirs[k].w, h = dirs[k].h; _rep(i, x, x + h) _rep(j, y, y + w) &#123; ans[i][j] = 'A' + id; // printf(\"%c\", ans[i][j]); &#125; // printf(\"finished\\n\"); if(dfs(u + 1, id + 1)) return true; _rep(i, x, x + h) _rep(j, y, y + w) &#123; ans[i][j] = '.'; &#125; &#125; return false;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(scanf(\"%d%d\", &amp;N, &amp;K) &amp;&amp; (N || K)) &#123; init(); _for(i, 0, N) scanf(\"%s\", grid[i]); //dbg(); // input finished dfs(0, 0); _for(i, 0, N) &#123; _for(j, 0, N) printf(\"%c\", ans[i][j]); printf(\"\\n\"); &#125; &#125;&#125; 一些简单题(只需注意中间状态压缩)其实掌握了框架之后，很多问题都变得简单了复杂的问题，只需要注意中间状态的压缩比如当前grid变化，对next grid的影响用位运算setbit, getbit来压缩模拟状态转移 UVA10384 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118const int R = 4, C = 6;const string CH = \"WNES\";const int dx[] = &#123;0, -1, 0, 1&#125;;const int dy[] = &#123;-1, 0, 1, 0&#125;;const int rev[] = &#123;2, 3, 0, 1&#125;;int sx = 0, sy = 0;int vis[R][C];int grid[R][C];vector&lt;char&gt; paths;void init() &#123; Set(grid, 0);&#125;void initVis() &#123; paths.clear(); Set(vis, 0);&#125;void setbit(int&amp; x, int b, bool flag) &#123; if(flag) x |= (1 &lt;&lt; b); else x &amp;= ~(1 &lt;&lt; b);&#125;bool getbit(const int x, const int b) &#123; return (x &amp; (1 &lt;&lt; b)) &gt; 0;&#125;bool valid(int x, int y) &#123; return 0 &lt;= x &amp;&amp; x &lt; R &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; C;&#125;bool isExit(const int x, const int y, vector&lt;char&gt;&amp; paths) &#123; int p = grid[x][y]; if(x == 0 &amp;&amp; !getbit(p, 1)) &#123; paths.push_back(CH[1]); return true; &#125; if(x == R - 1 &amp;&amp; !getbit(p, 3)) &#123; paths.push_back(CH[3]); return true; &#125; if(y == 0 &amp;&amp; !getbit(p, 0)) &#123; paths.push_back(CH[0]); return true; &#125; if(y == C - 1 &amp;&amp; !getbit(p, 2)) &#123; paths.push_back(CH[2]); return true; &#125; return false;&#125;bool dfs(int x, int y, vector&lt;char&gt;&amp; paths, int d, const int maxd) &#123; if(isExit(x, y, paths)) return true; if(d &gt;= maxd) return false; int&amp; p = grid[x][y]; _for(dir, 0, 4) &#123; int nx = x + dx[dir], ny = y + dy[dir]; if(!valid(nx, ny) || vis[nx][ny]) continue; int&amp; np = grid[nx][ny]; paths.push_back(CH[dir]); vis[nx][ny] = 1; // dfs next position if(!getbit(p, dir)) &#123; if(dfs(nx, ny, paths, d + 1, maxd)) return true; &#125; else if(!getbit(np, dir)) &#123; // push the wall setbit(p, dir, 0); setbit(np, dir, 1); setbit(np, rev[dir], 0); // next next position will change because of the pushment int nnx = nx + dx[dir], nny = ny + dy[dir]; if(valid(nnx, nny)) setbit(grid[nnx][nny], rev[dir], 1); if(dfs(nx, ny, paths, d + 1, maxd)) return true; if(valid(nnx, nny)) setbit(grid[nnx][nny], rev[dir], 0); setbit(p, dir, 1); setbit(np, dir, 0); setbit(np, rev[dir], 1); &#125; paths.pop_back(); vis[nx][ny] = 0; &#125; return false;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;sy, &amp;sx) == 2 &amp;&amp; (sx || sy)) &#123; init(); _for(i, 0, R) _for(j, 0, C) scanf(\"%d\", &amp;grid[i][j]); sx--; sy--; int maxd = 1; for(maxd = 1; ; maxd++) &#123; initVis(); vis[sx][sy] = 1; if(dfs(sx, sy, paths, 0, maxd)) break; vis[sx][sy] = 0; &#125; _for(i, 0, paths.size()) cout &lt;&lt; paths[i]; cout &lt;&lt; endl; &#125;&#125; 一些简单题STL中有些好用，但是不常用的函数，比如copy_backward在两个vector拼接的时候用的比较多 UVA11882 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162const int maxr = 15 + 10;const int maxc = 15 + 10;int R, C;int walked[maxr][maxc];int vis[maxr][maxc];void initWalk() &#123; Set(walked, 0);&#125;void initVis() &#123; Set(vis, 0);&#125;char grid[maxr][maxc];void init() &#123; Set(grid, 0);&#125;const int dx[] = &#123;-1, 0, 1, 0&#125;;const int dy[] = &#123;0, -1, 0, 1&#125;;bool valid(int x, int y) &#123; return 0 &lt;= x &amp;&amp; x &lt; R &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; C &amp;&amp; isdigit(grid[x][y]);&#125;void dbg() &#123; _for(i, 0, R) &#123; _for(j, 0, C) printf(\"%c\", grid[i][j]); printf(\"\\n\"); &#125;&#125;class Data &#123;public: vector&lt;char&gt; buf; bool operator&lt; (const Data&amp; rhs) const &#123; if(buf.size() != rhs.buf.size()) return buf.size() &lt; rhs.buf.size(); return buf &lt; rhs.buf; &#125; inline void clear() &#123; buf.clear(); &#125; inline int size() const &#123; return buf.size(); &#125; Data&amp; operator+= (const char ch) &#123; buf.push_back(ch); return *this; &#125; void printAns() &#123; _for(i, 0, buf.size()) printf(\"%c\", buf[i]); printf(\"\\n\"); &#125;&#125;;Data cur, ans;bool cmp(const char a, const char b) &#123; return a &gt; b;&#125;bool Less(const Data&amp; l1, Data&amp; l2, const Data&amp; rhs) &#123; // int i = 0; for(i = 0; i &lt; l1.buf.size(); i++) &#123; int a = l1.buf[i], b = rhs.buf[i]; if(a &lt; b) return true; if(a &gt; b) return false; &#125; sort(l2.buf.begin(), l2.buf.end(), cmp); for(; i &lt; rhs.buf.size(); i++) &#123; int a = l2.buf[i - l1.buf.size()], b = rhs.buf[i]; if(a &lt; b) return true; if(a &gt; b) return false; &#125; return false;&#125;void bfs(int x, int y, Data&amp; rs) &#123; // get remain routes and data initVis(); queue&lt;int&gt; que; que.push(x * maxc + y); vis[x][y] = 1; while(!que.empty()) &#123; int t = que.front(); que.pop(); int nx = t / maxc, ny = t % maxc; _for(dir, 0, 4) &#123; int nnx = nx + dx[dir], nny = ny + dy[dir]; if(!valid(nnx, nny) || walked[nnx][nny] || vis[nnx][nny]) continue; vis[nnx][nny] = 1; rs += grid[nnx][nny]; que.push(nnx * maxc + nny); &#125; &#125;&#125;void dfs(int x, int y, Data&amp; cur, Data&amp; ans) &#123; // Data rs; bfs(x, y, rs); if(cur.size() + rs.size() &lt; ans.size()) return; if(cur.size() + rs.size() == ans.size() &amp;&amp; Less(cur, rs, ans)) return;; _for(dir, 0, 4) &#123; int nx = x + dx[dir], ny = y + dy[dir]; if(!valid(nx, ny) || walked[nx][ny]) continue; cur += grid[nx][ny]; walked[nx][ny] = 1; dfs(nx, ny, cur, ans); cur.buf.pop_back(); walked[nx][ny] = 0; &#125; // there is no way to forward if(ans &lt; cur) ans = cur;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(scanf(\"%d%d\", &amp;R, &amp;C) == 2 &amp;&amp; (R || C)) &#123; init(); initVis(); initWalk(); _for(i, 0, R) scanf(\"%s\", grid[i]); // dbg(); ans.clear(); _for(i, 0, R) _for(j, 0, C) &#123; if(!isdigit(grid[i][j])) continue; cur.clear(); // start from grid[i][j] cur += grid[i][j]; walked[i][j] = 1; dfs(i, j, cur, ans); walked[i][j] = 0; &#125; // then printf ans ans.printAns(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"搜索","slug":"搜索","permalink":"https://www.fogsail.net/tags/搜索/"}]},{"title":"暴力求解和IDA*(三)","slug":"20190723","date":"2019-07-23T09:09:30.000Z","updated":"2019-08-05T09:55:34.025Z","comments":true,"path":"2019/07/23/20190723/","link":"","permalink":"https://www.fogsail.net/2019/07/23/20190723/","excerpt":"状态空间搜索会遇到一些比较复杂的算法需要构建中间状态的转换，有时候算法实现会比较复杂","text":"状态空间搜索会遇到一些比较复杂的算法需要构建中间状态的转换，有时候算法实现会比较复杂 记一次快让我疯掉的优化经历POJ3131 这道题目的数据很强，对时间复杂度和空间复杂度要求都非常高 一开始想用bfs做先用朴素的bfs加上Hash计算出正确的答案和普通的八数码问题相比，就多了一些中间状态的转移 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289//// main.cpp// POJ3131//// Created by zhangmin chen on 2019/7/15.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;#include &lt;assert.h&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int N = 3;const int maxstate = 5000000;const int hashSZ = 5000003;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)const string CH = \"WRBE\";// const int BUFLEN = 4;const int W = 0, R = 1, B = 2, E = 3;const int DICE[3][3] = &#123; &#123;-1, B, R&#125;, &#123;B, -1, W&#125;, &#123;R, W, -1&#125;,&#125;;const int dx[] = &#123;-1, 0, 1, 0&#125;;const int dy[] = &#123;0, -1, 0, 1&#125;;const int UP = 0, LEFT = 1, DOWN = 2, RIGHT = 3;// usage: dx[LEFT], dy[LEFT]//const int revDir[] = &#123;DOWN, RIGHT, UP, LEFT&#125;;//const string DIR[] = &#123;\"UP\", \"LEFT\", \"DOWN\", \"RIGHT\"&#125;;// usage: revD = revDir[LEFT]class CUBE &#123;public: int top, face, bottom, back, left, right; // set DICE[top][face] = LEFT; void clear() &#123; top = face = bottom = back = left = right = 0; &#125; bool operator!= (const CUBE&amp; rhs) const &#123; return top != rhs.top || face != rhs.face || left != rhs.left; &#125;&#125;;typedef CUBE State[N][N];int dist[maxstate];State nodes[maxstate];int head[hashSZ], nxth[maxstate];void initHash() &#123; Set(head, 0); Set(nxth, 0); Set(dist, 0); _for(k, 0, maxstate) &#123; _for(i, 0, N) _for(j, 0, N) nodes[k][i][j].clear(); &#125;&#125;void setPos(CUBE&amp; cb, int _top, int _face) &#123; //assert(cb.top != E); cb.top = _top; cb.face = _face; cb.left = DICE[_top][_face]; cb.right = cb.left; cb.bottom = cb.top; cb.back = cb.face;&#125;void setEmpty(CUBE&amp; cb) &#123; cb.top = cb.bottom = cb.left = cb.right = cb.face = cb.back = E;&#125;CUBE Move(const CUBE&amp; cb, int dir) &#123; CUBE nxt; if(dir == UP) setPos(nxt, cb.face, cb.bottom); if(dir == DOWN) setPos(nxt, cb.back, cb.top); if(dir == LEFT) setPos(nxt, cb.right, cb.face); if(dir == RIGHT) setPos(nxt, cb.left, cb.face); return nxt;&#125;int _hash(const State&amp; st) &#123; int val = 0; _for(i, 0, N) _for(j, 0, N) &#123; val = val * 10 + st[i][j].top; &#125; return val % hashSZ;&#125;// h is hash valuevoid link(int id, int h) &#123; nxth[id] = head[h]; head[h] = id;&#125;int cmpr(State&amp; s1, State&amp; s2) &#123; _for(i, 0, N) _for(j, 0, N) &#123; if(s1[i][j] != s2[i][j]) return 1; &#125; return 0;&#125;bool tryInsert(int id) &#123; int h = _hash(nodes[id]); // debug(h); int u = head[h]; while (u) &#123; // if(cmpr(nodes[id], nodes[u]) == 0) return 0; u = nxth[u]; &#125; link(id, h); return true;&#125;bool inRange(int x, int l, int r) &#123; if(l &gt; r) return inRange(x, r, l); return l &lt;= x &amp;&amp; x &lt;= r;&#125;bool valid(int x, int y) &#123; return inRange(x, 0, 2) &amp;&amp; inRange(y, 0, 2);&#125;CUBE pan[N][N];void initPan() &#123; _for(i, 0, N) _for(j, 0, N) &#123; CUBE cur; // cur.setPos(W, R); setPos(cur, W, R); pan[i][j] = cur; &#125;&#125;char target[N][N];void initTar() &#123; Set(target, 0);&#125;void dbgPan(const CUBE pan[][N]) &#123; _for(i, 0, N) &#123; _for(j, 0, N) printf(\"%c \", CH[pan[i][j].top]); printf(\"\\n\"); &#125; printf(\"\\n\");&#125;void dbgTar() &#123; _for(i, 0, N) &#123; _for(j, 0, N) printf(\"%c \", target[i][j]); printf(\"\\n\"); &#125; printf(\"\\n\");&#125;void findEmpty(const CUBE pan[][N], int&amp; ex, int&amp; ey) &#123; _for(i, 0, N) _for(j, 0, N) &#123; const CUBE&amp; cur = pan[i][j]; if(CH[cur.top] == 'E') &#123; ex = i; ey = j; return; &#125; &#125; return;&#125;bool reach(const CUBE pan[][N], const char target[][N]) &#123; // _for(i, 0, N) _for(j, 0, N) &#123; // if(CH[pan[i][j].top] != target[i][j]) return 0; &#125; return 1;&#125;void assign(const CUBE pan[][N], State* nodes, int id) &#123; _for(i, 0, N) _for(j, 0, N) &#123; nodes[id][i][j] = pan[i][j]; &#125;&#125;int bfs() &#123; int front = 1, rear = 2; while (front &lt; rear) &#123; State&amp; cur = nodes[front]; if(reach(cur, target)) return front; int ex = -1, ey = -1; findEmpty(cur, ex, ey); assert(ex != -1 &amp;&amp; ey != -1); _for(dir, 0, 4) &#123; int nx = ex + dx[dir], ny = ey + dy[dir]; if(!valid(nx, ny)) continue; State&amp; to = nodes[rear]; Cpy(to, cur); CUBE nxt = Move(cur[nx][ny], dir); to[nx][ny] = cur[ex][ey]; to[ex][ey] = nxt; // dbgPan(to); dist[rear] = dist[front] + 1; if(tryInsert(rear)) rear++; &#125; front++; &#125; return 0;&#125;// ans init as inf// eCb is empty cube// remember the parent of empty blockint main() &#123; freopen(\"input.txt\", \"r\", stdin); int ex, ey; int kase = 1; while (scanf(\"%d%d\", &amp;ex, &amp;ey) == 2 &amp;&amp; ex &amp;&amp; ey) &#123; initHash(); initPan(); initTar(); setEmpty(pan[ey - 1][ex -1]); assign(pan, nodes, 1); _for(i, 0, N) _for(j, 0, N) &#123; cin &gt;&gt; target[i][j]; &#125; printf(\"Case: %d\\n\", kase++); // input finished() //dbgPan(nodes[1]); // dbgTar(); int ans = bfs(); if(dist[ans] &lt;= 30) printf(\"%d\\n\", dist[ans]); else printf(\"-1\\n\"); // cout &lt;&lt; \"========\" &lt;&lt; endl; &#125;&#125; 和朴素八数码问题比，就多了中间状态的转换用Move[][]数组来表示 但是时间复杂度非常之高并且耗内存，但是可以得到正确的结论 接下来进行优化 状态压缩编码和双向bfs优化用这种优化方法，是可以通过LA3618LA3618的数据并不是很强 具体的思路如下：终点状态已知top面的颜色，每一个top面对应的face面有2种可能每个位有2种编码，一共有$2^{8}=256$种编码方式用解答树填空法，把终点状态入队列que2 起点状态只有一种编码，也入队列 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278//// main.cpp// POJ3131-2//// Created by zhangmin chen on 2019/7/19.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;#include &lt;assert.h&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)const int BASE[] = &#123;1, 6, 36, 216, 1296, 7776, 46656, 279936, 1679616&#125;;const int maxn = 1679616 + 10;class Node &#123;public: int st[9]; int ep, dta, dist;&#125;;queue&lt;Node&gt; que1, que2;Node s1, s2;bool vis1[maxn][9];bool vis2[maxn][9];char tar[9];const int dx[] = &#123;-1, 0, 1, 0&#125;;const int dy[] = &#123;0, -1, 0, 1&#125;;void initVis() &#123; Set(vis1, 0); Set(vis2, 0);&#125;void initQue() &#123; while(!que1.empty()) que1.pop(); while(!que2.empty()) que2.pop();&#125;/* if(top == W &amp;&amp; face == R) return 0; if(top == W &amp;&amp; face == B) return 1; if(top == R &amp;&amp; face == W) return 2; if(top == R &amp;&amp; face == B) return 3; if(top == B &amp;&amp; face == W) return 4; if(top == B &amp;&amp; face == R) return 5; return -1; */// const int Move[0][dir]// const int Move[1][dir]// UP LEFT DOWN RIGHT// Move[0][UP] = (R, W) Move[0][LEFT] = (B, R) Move[0][DOWN] = (R, W) Move[0][RIGHT] = (B, R)// Move[1][UP] = (B, W) Move[1][LEFT] = (R, B)// Move[2][UP] = (W, R) Move[2][LEFT] = (B, W)// Move[3][UP] = (B, R) Move[3][LEFT] = (W, B)// Move[4][UP] = (W, B) Move[4][LEFT] = (R, W)// Move[5][UP] = (R, B) Move[5][LEFT] = (W, R)const int Move[6][4] = &#123; &#123;2, 5, 2, 5&#125;, &#123;4, 3, 4, 3&#125;, &#123;0, 4, 0, 4&#125;, &#123;5, 1, 5, 1&#125;, &#123;1, 2, 1, 2&#125;, &#123;3, 0, 3, 0&#125;&#125;;// usage: int newCode = Move[oldCode][dir]int cal(const Node x) &#123; int k = 0, ans = 0; _for(i, 0, 9) &#123; if(i != x.ep) ans = ans + x.st[i] * BASE[k++]; &#125; return ans;&#125;bool valid(int x, int y) &#123; if(0 &lt;= x &amp;&amp; x &lt; 3 &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; 3) return 1; return 0;&#125;void dfs(Node&amp; s2, int d) &#123; if(d == 9) &#123; s2.dist = 0; s2.dta = cal(s2); que2.push(s2); vis2[s2.dta][s2.ep] = true; return; &#125; if(tar[d] == 'W') &#123; s2.st[d] = 0; dfs(s2, d + 1); s2.st[d] = 1; dfs(s2, d + 1); &#125; else if(tar[d] == 'R') &#123; s2.st[d] = 2; dfs(s2, d + 1); s2.st[d] = 3; dfs(s2, d + 1); &#125; else if(tar[d] == 'B') &#123; s2.st[d] = 4; dfs(s2, d + 1); s2.st[d] = 5; dfs(s2, d + 1); &#125; else &#123; s2.st[d] = 6; dfs(s2, d + 1); &#125;&#125;bool bfs(int&amp; ans) &#123; const int DEP1 = 21, DEP2 = 9; int cnt1 = 0, cnt2 = 0, flag = 0; while (true) &#123; flag = 0; while (!que1.empty() &amp;&amp; que1.front().dist &lt;= cnt1) &#123; flag = 1; // Node x = que1.front(); que1.pop(); if(vis2[x.dta][x.ep]) &#123; ans = x.dist + cnt2; return true; &#125; if(x.dist &gt;= DEP1) continue; _for(dir, 0, 4) &#123; Node nxt = x; int ex = x.ep / 3, ey = x.ep % 3; int nx = ex + dx[dir], ny = ey + dy[dir]; if(!valid(nx, ny)) continue; int np = nx * 3 + ny; nxt.ep = np; nxt.st[x.ep] = Move[nxt.st[nxt.ep]][dir]; nxt.st[nxt.ep] = 6; nxt.dist = x.dist + 1; nxt.dta = cal(nxt); if(!vis1[nxt.dta][nxt.ep]) &#123; vis1[nxt.dta][nxt.ep] = true; que1.push(nxt); &#125; &#125; &#125; if(cnt1 &lt; DEP1) cnt1++; while (!que2.empty() &amp;&amp; que2.front().dist &lt;= cnt2) &#123; flag = 1; // Node x = que2.front(); que2.pop(); if(vis1[x.dta][x.ep]) &#123; ans = x.dist + cnt1; return true; &#125; if(x.dist &gt;= DEP2) continue; _for(dir, 0, 4) &#123; Node nxt = x; int ex = x.ep / 3, ey = x.ep % 3; int nx = ex + dx[dir], ny = ey + dy[dir]; if(!valid(nx, ny)) continue; int np = nx * 3 + ny; nxt.ep = np; nxt.st[x.ep] = Move[nxt.st[nxt.ep]][dir]; nxt.st[nxt.ep] = 6; nxt.dist = x.dist + 1; nxt.dta = cal(nxt); if(!vis2[nxt.dta][nxt.ep]) &#123; vis2[nxt.dta][nxt.ep] = true; que2.push(nxt); &#125; &#125; &#125; if(cnt2 &lt; DEP2) cnt2++; if(!flag) return false; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int ex, ey; while (scanf(\"%d%d\", &amp;ex, &amp;ey) != EOF &amp;&amp; ex &amp;&amp; ey) &#123; initVis(); ex--; ey--; int ep = ey * 3 + ex; initQue(); // get bfs s1 _for(i, 0, 9) &#123; if(i == ep) &#123; // s1.st[i] = 6; s1.ep = i; &#125; else s1.st[i] = 0; &#125; s1.dist = 0; s1.dta = cal(s1); vis1[s1.dta][s1.ep] = true; que1.push(s1); // s1 finished _for(i, 0, 9) &#123; char ch; cin &gt;&gt; ch; if(ch == 'E') s2.ep = i; tar[i] = ch; &#125; dfs(s2, 0); //debug(que1.size()); //debug(que2.size()); //printf(\"====\\n\"); int ans = 0; if(bfs(ans)) printf(\"%d\\n\", ans); else printf(\"-1\\n\"); &#125;&#125; 但是上面的优化还不足以通过POJ的数据需要进一步优化 状态压缩位运算，哈希，双向bfs面对类似的左右移动，穿插问题，可以想到位运算 哈希表先封装起来12345678910111213141516171819202122232425262728293031323334353637class HASH &#123;public: struct Node &#123; int nxt, val; &#125; nodes[HASHSZ]; int head[HASHSZ]; // head store the value of id int tot; void init() &#123; Set(head, -1); tot = 0; &#125; void insert(int hashV, int val) &#123; nodes[tot].val = val; nodes[tot].nxt = head[hashV]; head[hashV] = tot++; &#125; int find(int dta) &#123; int hashV = dta % HASHSZ; int i; for(i = head[hashV]; ~i; i = nodes[i].nxt) &#123; int val = nodes[i].val; if(val == dta) return i; &#125; insert(hashV, dta); return tot - 1; &#125;&#125;;HASH hashTb;void initHash() &#123; hashTb.init();&#125; 位运算模拟算法分析 双向bfs处理的时候，需要特判初始状态和末状态相等的情况这时候最小步数是0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327//// main.cpp// POJ3131-4//// Created by zhangmin chen on 2019/7/22.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;#include &lt;assert.h&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int HASHSZ = 5000007;const int maxn = 5000007;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)class HASH &#123;public: struct Node &#123; int nxt, val; &#125; nodes[HASHSZ]; int head[HASHSZ]; // head store the value of id int tot; void init() &#123; Set(head, -1); tot = 0; &#125; void insert(int hashV, int val) &#123; nodes[tot].val = val; nodes[tot].nxt = head[hashV]; head[hashV] = tot++; &#125; int find(int dta) &#123; int hashV = dta % HASHSZ; int i; for(i = head[hashV]; ~i; i = nodes[i].nxt) &#123; int val = nodes[i].val; if(val == dta) return i; &#125; insert(hashV, dta); return tot - 1; &#125;&#125;;HASH hashTb;void initHash() &#123; hashTb.init();&#125;bool vis1[maxn], vis2[maxn];void initVis() &#123; Set(vis1, 0); Set(vis2, 0);&#125;class StNode &#123;public: int state; int pos; int dist; StNode(int s = 0, int p = 0, int dist = 0) : state(s), pos(p), dist(dist) &#123;&#125;&#125;;const int dx[] = &#123;-1, 0, 1, 0&#125;;const int dy[] = &#123;0, -1, 0, 1&#125;;// const int UP = 0, LEFT = 1, DOWN = 2, RIGHT = 3;/* if(top == W &amp;&amp; face == R) return 1; if(top == W &amp;&amp; face == B) return 2; if(top == R &amp;&amp; face == W) return 3; if(top == R &amp;&amp; face == B) return 4; if(top == B &amp;&amp; face == W) return 5; if(top == B &amp;&amp; face == R) return 6; */// const int Move[0][dir]// const int Move[1][dir]// UP LEFT DOWN RIGHT// Move[1][UP] = (R, W) Move[1][LEFT] = (B, R) Move[0][DOWN] = (R, W) Move[0][RIGHT] = (B, R)// Move[2][UP] = (B, W) Move[2][LEFT] = (R, B)// Move[3][UP] = (W, R) Move[3][LEFT] = (B, W)// Move[4][UP] = (B, R) Move[4][LEFT] = (W, B)// Move[5][UP] = (W, B) Move[6][LEFT] = (R, W)// Move[6][UP] = (R, B) Move[6][LEFT] = (W, R)const int Move[7][4] = &#123; &#123;0, 0, 0, 0&#125;, &#123;3, 6, 3, 6&#125;, &#123;5, 4, 5, 4&#125;, &#123;1, 5, 1, 5&#125;, &#123;6, 2, 6, 2&#125;, &#123;2, 3, 2, 3&#125;, &#123;4, 1, 4, 1&#125;&#125;;// usage: int newCode = Move[oldCode][dir]queue&lt;StNode&gt; que1, que2;char tar[11];int tep;void initQue() &#123; while(!que1.empty()) que1.pop(); while(!que2.empty()) que2.pop();&#125;int getBit(int state, int k) &#123; return ( ( (state &gt;&gt; (3 * k + 2)) &amp; 1 ) &lt;&lt; 2 ) | ( ( (state &gt;&gt; (3 * k + 1)) &amp; 1 ) &lt;&lt; 1 ) | ( ( (state &gt;&gt; (3 * k)) &amp; 1 ));&#125;void dfs(int d, int state, int tep) &#123; if(d == 9) &#123; StNode cur(state, tep, 0); que2.push(cur); int dta2 = hashTb.find(state); vis2[dta2] = 1; return; &#125; if(tar[d] == 'E') &#123; dfs(d + 1, state &lt;&lt; 3, tep); return; &#125; int v1, v2; if(tar[d] == 'W') &#123; v1 = 1; v2 = 2; &#125; else if(tar[d] == 'R') &#123; v1 = 3; v2 = 4; &#125; else &#123; v1 = 5; v2 = 6; &#125; dfs(d + 1, (state &lt;&lt; 3) | v1, tep); dfs(d + 1, (state &lt;&lt; 3) | v2, tep);&#125;// const int UP = 0, LEFT = 1, DOWN = 2, RIGHT = 3;inline void update(StNode&amp; u, int dir) &#123; if(dir == 0) &#123; // int np = u.pos - 3; int bit = getBit(u.state, 8 - np); int nbit = Move[bit][dir]; u.state = (u.state ^ ( bit &lt;&lt; ((8 - np) * 3) )) | ( nbit &lt;&lt; ((8 - np - 3) * 3) ); u.dist++; u.pos = np; &#125; else if(dir == 1) &#123; int np = u.pos - 1; int bit = getBit(u.state, 8 - np); int nbit = Move[bit][dir]; u.state = (u.state ^ ( bit &lt;&lt; ((8 - np) * 3) )) | ( nbit &lt;&lt; ((8 - np - 1) * 3) ); u.dist++; u.pos = np; &#125; else if(dir == 2) &#123; int np = u.pos + 3; int bit = getBit(u.state, 8 - np); int nbit = Move[bit][dir]; u.state = (u.state ^ ( bit &lt;&lt; ((8 - np) * 3) )) | ( nbit &lt;&lt; ((8 - np + 3) * 3) ); u.dist++; u.pos = np; &#125; else if(dir == 3) &#123; int np = u.pos + 1; int bit = getBit(u.state, 8 - np); int nbit = Move[bit][dir]; u.state = (u.state ^ ( bit &lt;&lt; ((8 - np) * 3) )) | ( nbit &lt;&lt; ((8 - np + 1) * 3) ); u.dist++; u.pos = np; &#125;&#125;bool valid(int x, int y) &#123; if(0 &lt;= x &amp;&amp; x &lt; 3 &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; 3) return true; return false;&#125;int bfs() &#123; const int DEP1 = 20, DEP2 = 9; int lv1 = 0, lv2 = 0; for(lv1 = 0; lv1 &lt;= DEP1; lv1++) &#123; while (!que1.empty() &amp;&amp; que1.front().dist == lv1) &#123; // do something StNode x = que1.front(); que1.pop(); int ex = x.pos / 3, ey = x.pos % 3; _for(dir, 0, 4) &#123; int nx = ex + dx[dir], ny = ey + dy[dir]; if(!valid(nx, ny)) continue; StNode clone = x; update(clone, dir); int hashV = hashTb.find(clone.state); if(!vis1[hashV]) &#123; vis1[hashV] = true; if(vis2[hashV]) return lv1 + lv2 + 1; que1.push(clone); &#125; &#125; &#125; while(!que2.empty() &amp;&amp; que2.front().dist == lv2 &amp;&amp; lv2 &lt; DEP2) &#123; // do something StNode x = que2.front(); que2.pop(); int ex = x.pos / 3, ey = x.pos % 3; _for(dir, 0, 4) &#123; int nx = ex + dx[dir], ny = ey + dy[dir]; if(!valid(nx, ny)) continue; StNode clone = x; update(clone, dir); int hashV = hashTb.find(clone.state); if(!vis2[hashV]) &#123; vis2[hashV] = true; if(vis1[hashV]) return lv1 + lv2 + 2; que2.push(clone); &#125; &#125; &#125; if(lv2 &lt; DEP2) lv2++; &#125; return -1;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int ex, ey; while (scanf(\"%d%d\", &amp;ex, &amp;ey) != EOF &amp;&amp; ex &amp;&amp; ey) &#123; initVis(); initQue(); initHash(); ex--; ey--; int ep = ey * 3 + ex; StNode s(0, ep, 0); _for(i, 0, 9) &#123; s.state &lt;&lt;= 3; if(i == ep) continue; s.state |= 1; &#125; que1.push(s); int dta1 = hashTb.find(s.state); vis1[dta1] = 1; // get start state finished // then get end status char c[3]; _for(i, 0, 3) _for(j, 0, 3) &#123; scanf(\"%s\", c); tar[i * 3 + j] = c[0]; if(c[0] == 'E') tep = i * 3 + j; &#125; // judge 0 int i; for(i = 0; i &lt; 9; i++) &#123; if(tar[i] == 'W' &amp;&amp; i != s.pos) continue; if(tar[i] == 'E' &amp;&amp; i == s.pos) continue; else break; &#125; if(i == 9) &#123; printf(\"0\\n\"); continue; &#125; // then add all 256 situation to the end queue dfs(0, 0, tep); // printf(\"%d\\n\", que2.size()); // then double-way bfs printf(\"%d\\n\", bfs()); &#125;&#125; 八皇后的解答树填空从[cur, N * M]位置中任选一个位置填空代码如下 123456789101112bool dfs(int cur, int d, int maxd) &#123; if(d == maxd) &#123; return true or false; &#125; _for(i, cur, N * M) &#123; fill the blank in Chessboard[i] if(dfs(i + 1, d + 1, maxd)) return true; reset Chessboard[i] &#125; return false;&#125; 状态压缩搜索UVA12569 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217//// main.cpp// UVA12569//// Created by zhangmin chen on 2019/7/25.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;#include &lt;assert.h&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int maxn = 15 + 5;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)int read() &#123; int x; scanf(\"%d\", &amp;x); return x;&#125;template &lt;typename T&gt;class Mempool &#123;public: vector&lt;T*&gt; buf; T* create() &#123; buf.push_back(new T()); return buf.back(); &#125; void reset() &#123; _for(i, 0, buf.size()) delete buf[i]; buf.clear(); &#125;&#125;;class Node &#123;public: int from, to; Node* nxt;&#125;;class State &#123;public: Node* path; int st, dist; State(int s = 0, int d = 0, Node* p = NULL) : st(s), dist(d), path(p) &#123;&#125; inline void setOBS(int u) &#123; st |= (1 &lt;&lt; (4 + u)); &#125; inline void resetOBS(int u) &#123; st &amp;= ~(1 &lt;&lt; (4 + u)); &#125; inline bool existOB(int u) const &#123; return st &amp; (1 &lt;&lt; (4 + u)); &#125; inline void setROB(int ru) &#123; st = ((st &gt;&gt; 4) &lt;&lt; 4) | ru; &#125; inline int getROB() const &#123; // return st &amp; 0xf; &#125;&#125;;Mempool&lt;Node&gt; pools;Node* newNode(Node* nxt = NULL, int from = -1, int to = -1) &#123; Node* p = pools.create(); p-&gt;nxt = nxt; p-&gt;from = from; p-&gt;to = to; return p;&#125;vector&lt;int&gt; G[maxn];int vis[1 &lt;&lt; 19];int obs[maxn];queue&lt;State&gt; que;int N, M, S, T;void init() &#123; _for(i, 0, maxn) G[i].clear(); Set(vis, 0); Set(obs, 0); while(!que.empty()) que.pop();&#125;void initBFS() &#123; // State beg; _for(i, 0, M) beg.setOBS(obs[i]); beg.setROB(S); que.push(beg); // debug(beg.st); vis[beg.st] = 1;&#125;void Move(const State&amp; St, int u, queue&lt;State&gt;&amp; que) &#123; // Move from u -&gt; v int RPOS = St.getROB(); _for(i, 0, G[u].size()) &#123; // int v = G[u][i]; State cur = St; if(v == RPOS || cur.existOB(v)) continue; if(u == RPOS) &#123; // cur.st = ((St.st &gt;&gt; 4) &lt;&lt; 4) | v; // debug(cur.st); &#125; else &#123; // cur.st ^= (1 &lt;&lt; (4 + u)); cur.st |= (1 &lt;&lt; (4 + v)); &#125; if(vis[cur.st]) continue; vis[cur.st] = 1; State nxt(cur.st, St.dist + 1, newNode(St.path, u, v)); que.push(nxt); &#125;&#125;ostream&amp; operator&lt;&lt; (ostream&amp; os, Node* p) &#123; if(p == NULL) return os; os &lt;&lt; p-&gt;nxt &lt;&lt; p-&gt;from + 1 &lt;&lt; \" \" &lt;&lt; p-&gt;to + 1 &lt;&lt; endl; return os;&#125;void BFS() &#123; // initBFS(); while (!que.empty()) &#123; const State x = que.front(); // debug(x.getROB()); // debug(T); que.pop(); if(x.getROB() == T) &#123; printf(\"%d\\n\", x.dist); cout &lt;&lt; x.path; return; &#125; Move(x, x.getROB(), que); _for(i, 0, N) if(x.existOB(i)) Move(x, i, que); &#125; cout &lt;&lt; \"-1\" &lt;&lt; endl;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = read(); _rep(t, 1, kase) &#123; init(); scanf(\"%d%d%d%d\", &amp;N, &amp;M, &amp;S, &amp;T); S--; T--; printf(\"Case %d: \", t); _for(i, 0, M) obs[i] = read() - 1; _for(i, 0, N - 1) &#123; int u = read() - 1, v = read() - 1; G[u].push_back(v); G[v].push_back(u); &#125; // then we finished input // initBFS and BFS BFS(); pools.reset(); cout &lt;&lt; endl; &#125;&#125; 状态压缩搜索练习LA2093 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218//// main.cpp// LA2093//// Created by zhangmin chen on 2019/7/27.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;#include &lt;assert.h&gt;#include &lt;unordered_set&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)const int N = 15;const int D = 6;const int DIR[N + 1][D] = &#123; &#123;0, 0, 0, 0, 0, 0&#125;, // 0 &#123;0, 0, 0, 0, 2, 3&#125;, // 1 &#123;0, 1, 0, 3, 4, 5&#125;, // 2 &#123;1, 0, 2, 0, 5, 6&#125;, // 3 &#123;0, 2, 0, 5, 7, 8&#125;, // 4 &#123;2, 3, 4, 6, 8, 9&#125;, // 5 &#123;3, 0, 5, 0, 9, 10&#125;, // 6 &#123;0, 4, 0, 8, 11, 12&#125;, // 7 &#123;4, 5, 7, 9, 12, 13&#125;, // 8 &#123;5, 6, 8, 10, 13, 14&#125;, // 9 &#123;6, 0, 9, 0, 14, 15&#125;, // 10 &#123;0, 7, 0, 12, 0, 0&#125;, // 11 &#123;7, 8, 11, 13, 0, 0&#125;, // 12 &#123;8, 9, 12, 14, 0, 0&#125;, // 13 &#123;9, 10, 13, 15, 0, 0&#125;, // 14 &#123;10, 0, 14, 0, 0, 0&#125; // 15&#125;;template&lt;typename T&gt;ostream&amp; operator&lt;&lt; (ostream&amp; os, const vector&lt;T&gt;&amp; vec) &#123; _for(i, 0, vec.size()) &#123; if(i != 0) os &lt;&lt; \" \"; os &lt;&lt; vec[i]; &#125; return os;&#125;class Board &#123;public: int st, cnt; vector&lt;int&gt; path; Board() &#123; st = 0b1111111111111111; cnt = N; path.clear(); &#125; bool isEmpty(int i) const &#123; if((st &amp; (1 &lt;&lt; i)) != 0) return false; else return true; &#125; void clear(int i) &#123; assert(!isEmpty(i)); st ^= (1 &lt;&lt; i); cnt--; &#125; void put(int i) &#123; assert(isEmpty(i)); st |= (1 &lt;&lt; i); cnt++; &#125; int jumpTo(int i, int d) const &#123; // follow the direction d to jump to xxx int to = DIR[i][d]; if(!to || isEmpty(to)) return 0; // 0 is nil, means can not jump while(to &amp;&amp; !isEmpty(to)) to = DIR[to][d]; return to; &#125; void dbg() &#123; int len = 1, p = 1; cout &lt;&lt; \"cnt = \" &lt;&lt; cnt &lt;&lt; endl; _rep(i, 1, N) &#123; if(isEmpty(i)) cout &lt;&lt; \"_\"; else cout &lt;&lt; \"*\"; if(i == p) &#123; cout &lt;&lt; endl; len += 1; p += len; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; path.size() &lt;&lt; \" -&gt; \" &lt;&lt; path &lt;&lt; endl; &#125;&#125;;// Board bd;queue&lt;Board&gt; que;unordered_set&lt;int&gt; vis;void init() &#123; while(!que.empty()) que.pop(); vis.clear();&#125;void initBFS(int x) &#123; Board bd; bd.clear(x); que.push(bd); vis.insert(bd.st);&#125;void bfs(int x) &#123; // x is init empty place initBFS(x); while (!que.empty()) &#123; Board cur = que.front(); que.pop(); if(cur.cnt == 1 &amp;&amp; !cur.isEmpty(x)) &#123; // founded! print ans cout &lt;&lt; cur.path.size() / 2 &lt;&lt; endl; cout &lt;&lt; cur.path &lt;&lt; endl; return; &#125; // then find next _rep(i, 1, N) &#123; if(cur.isEmpty(i)) continue; _for(d, 0, D) &#123; // jump to the next int to = cur.jumpTo(i, d); if(!to) continue; // i --dir d--&gt; to Board nxtb = cur; assert(nxtb.isEmpty(i) == false); nxtb.clear(i); int j = DIR[i][d]; while(j != to) &#123; nxtb.clear(j); j = DIR[j][d]; &#125; // [i, to] in direction d, is all cleared // then put ball in hole to nxtb.put(to); if(vis.count(nxtb.st)) continue; vis.insert(nxtb.st); nxtb.path.push_back(i); nxtb.path.push_back(to); que.push(nxtb); &#125; &#125; &#125; cout &lt;&lt; \"IMPOSSIBLE\\n\";&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; // bfs(int x) // x is empty point init(); int x; scanf(\"%d\", &amp;x); bfs(x); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"搜索","slug":"搜索","permalink":"https://www.fogsail.net/tags/搜索/"}]},{"title":"实用数据结构","slug":"20190708","date":"2019-07-07T23:42:58.000Z","updated":"2019-09-15T14:34:26.082Z","comments":true,"path":"2019/07/08/20190708/","link":"","permalink":"https://www.fogsail.net/2019/07/08/20190708/","excerpt":"这里对开发中常用的数据结构做了补充包括但不限于treap树，并查集，树状数组等","text":"这里对开发中常用的数据结构做了补充包括但不限于treap树，并查集，树状数组等 优先队列UVA11997 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//// main.cpp// UVA11997//// Created by zhangmin chen on 2019/7/8.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int maxn = 750 + 10;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)int A[maxn][maxn];int n;void init() &#123; Set(A, 0);&#125;class Node &#123;public: int S, b; Node(int _S = 0, int _b = 0) : S(_S), b(_b) &#123;&#125; bool operator&lt; (const Node&amp; rhs) const &#123; return S &gt; rhs.S; &#125;&#125;;void _merge(int* A, int* B, int* C, int n) &#123; priority_queue&lt;Node&gt; pq; _for(i, 0, n) pq.push(Node(A[i] + B[0], 0)); _for(i, 0, n) &#123; Node x = pq.top(); pq.pop(); C[i] = x.S; if(x.b + 1 &lt; n) pq.push(Node(x.S - B[x.b] + B[x.b+1], x.b+1)); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) == 1) &#123; init(); _for(i, 0, n) _for(j, 0, n) scanf(\"%d\", &amp;A[i][j]); _for(i, 0, n) sort(A[i], A[i] + n); _for(i, 1, n) _merge(A[0], A[i], A[0], n); printf(\"%d\", A[0][0]); _for(i, 1, n) printf(\" %d\", A[0][i]); printf(\"\\n\"); &#125;&#125; 并查集按秩压缩LA3027 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//// main.cpp// LA3027//// Created by zhangmin chen on 2019/7/10.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int maxn = 20000 + 10;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)int pa[maxn], d[maxn];void initSet() &#123; _for(i, 0, maxn) &#123; pa[i] = i; d[i] = 0; &#125;&#125;int findSet(int x) &#123; if(pa[x] == x) return x; else &#123; int root = findSet(pa[x]); d[x] += d[pa[x]]; return pa[x] = root; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; initSet(); int n, u, v; char cmd[9]; scanf(\"%d\", &amp;n); while (scanf(\"%s\", cmd) &amp;&amp; cmd[0] != 'O') &#123; if(cmd[0] == 'E') &#123; scanf(\"%d\", &amp;u); findSet(u); cout &lt;&lt; d[u] &lt;&lt; endl; &#125; else if(cmd[0] == 'I') &#123; scanf(\"%d%d\", &amp;u, &amp;v); pa[u] = v; d[u] = abs(u - v) % 1000; &#125; &#125; &#125;&#125; 并查集按秩压缩处理传递性问题(xor)HDU3234 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163//// main.cpp// HDU3234//// Created by zhangmin chen on 2019/7/10.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int maxn = 20000 + 10;const int maxl = 40000 + 10;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)int n, q;int pa[maxn], d[maxn];int vis[maxn];int line[maxl][3];int data[maxn];void initSet() &#123; Set(line, 0); Set(data, 0); _for(i, 0, maxn) &#123; pa[i] = i; d[i] = 0; &#125;&#125;int findSet(int x) &#123; if(x == pa[x]) return x; else &#123; int root = findSet(pa[x]); d[x] ^= d[pa[x]]; return pa[x] = root; &#125;&#125;bool combine(int p, int q, int v) &#123; int rootp = findSet(p); int rootq = findSet(q); if(rootp == rootq) return (d[p] ^ d[q]) == v; //debug(nil); // union rootp and rootq, d[p] ^ d[q] = v // pa[rootp] = rootq if(rootp == n) swap(rootp, rootq); pa[rootp] = rootq; d[rootp] = (d[p] ^ d[q] ^ v); return true;&#125;int query(const int *data, int k) &#123; int ans = 0; Set(vis, 0); _for(i, 0, k) &#123; // d[data[i]] if(vis[i]) continue; int cnt = 0, root = findSet(data[i]); _for(j, i, k) &#123; if(!vis[j] &amp;&amp; root == findSet(data[j])) &#123; vis[j] = 1; cnt++; ans ^= d[data[j]]; &#125; &#125; if(root != n &amp;&amp; cnt % 2 == 1) return -1; &#125; return ans;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int cnt = 0; while (scanf(\"%d%d\", &amp;n, &amp;q) &amp;&amp; (n + q)) &#123; initSet(); printf(\"Case %d:\\n\", ++cnt); //debug(n); int ic = 0; bool bug = 0; _for(i, 0, q) &#123; string str; cin &gt;&gt; str; if(str[0] == 'I') &#123; // ic++; int sz = 0; while(cin &gt;&gt; line[i][sz++]) if(getchar() == '\\n') break; if(bug) continue; int p = 0, q = 0, v = 0; if(sz == 2) &#123; // I p v, data[0] = p, data[1] = v p = line[i][0]; v = line[i][1]; q = n; &#125; else if(sz == 3) &#123; // I p q v p = line[i][0]; q = line[i][1]; v = line[i][2]; &#125; if(!combine(p, q, v)) &#123; printf(\"The first %d facts are conflicting.\\n\", ic); bug = 1; &#125; &#125; else if(str[0] == 'Q') &#123; // k p1 p2 ... pk int k; scanf(\"%d\", &amp;k); // _for(i, 0, data.size()) cout &lt;&lt; data[i] &lt;&lt; \" \"; // cout &lt;&lt; endl; _for(i, 0, k) scanf(\"%d\", &amp;data[i]); if(bug) continue; int res = query(data, k); if(res == -1) printf(\"I don't know.\\n\"); else printf(\"%d\\n\", res); &#125; // _for(i, 0, data.size()) cout &lt;&lt; data[i] &lt;&lt; \" \"; // cout &lt;&lt; endl; &#125; puts(\"\"); &#125;&#125; 处理字符+数字混合输入的问题方法一, getline(cin, line)吃掉前面cin/scanf的回车 12345678910输入I 5 10string line;getline(cin, line);getline(cin, line);stringstream ss(line);int v;while(ss &gt;&gt; v) vec.push_back(v); 方法二 while(cin &gt;&gt; ), getchar() == ‘\\n’判断结束与否 123int len = 0;while(cin &gt;&gt; line[len++]) if(getchar() == '\\n') break; 带删除操作的并查集并查集带上删除操作比较麻烦直接的处理方法, 给每个节点一个新的id重新编号, x编号成id[x], 然后对id[]处理同一个节点x，通过id的变化, 相当于原来集合中的节点删除，新开了一个id[x] = ++tot节点原来集合中的点删除怎么体现? 其实是通过root = find(x), sum[root] -= x, cnt[root]—来完成的 12345678910del(int p) // 先从原来的集合删除p元素 int root = find(id[p]) sum[root] -= p; cnt[root]--; // p元素重新编号, 自成一个集合 id[p] = ++tot; sum[id[p]] = p; cnt[id[p]] = 1; pa[id[p]] = id[p]; UVA11987 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const int maxn = 100000 + 10;int n, m;int pa[maxn], cnt[maxn], id[maxn];llong sum[maxn];int tot;void init(int n) &#123; _rep(i, 0, n) &#123; pa[i] = i; id[i] = i; sum[i] = i; cnt[i] = 1; &#125; tot = n;&#125;int find(int x) &#123; return x == pa[x] ? x : (pa[x] = find(pa[x]));&#125;void Union(int p, int q) &#123; int rootp = find(p); int rootq = find(q); pa[rootp] = rootq; sum[rootq] += sum[rootp]; cnt[rootq] += cnt[rootp];&#125;void change(int p) &#123; int pre = find(id[p]); sum[pre] -= p; cnt[pre]--; id[p] = ++tot; pa[id[p]] = id[p]; sum[id[p]] = (llong)p; cnt[id[p]] = 1;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;n, &amp;m) != EOF) &#123; init(n); _for(i, 0, m) &#123; // int op; scanf(\"%d\", &amp;op); if(op == 1) &#123; // int p, q; scanf(\"%d%d\", &amp;p, &amp;q); if(find(id[p]) != find(id[q])) &#123; Union(id[p], id[q]); &#125; &#125; if(op == 2) &#123; // int p, q; scanf(\"%d%d\", &amp;p, &amp;q); if(find(id[p]) == find(id[q])) continue; change(p); Union(id[p], id[q]); &#125; if(op == 3) &#123; // print ans int p; scanf(\"%d\", &amp;p); int root = find(id[p]); printf(\"%d %lld\\n\", cnt[root], sum[root]); &#125; &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"暴力求解和IDA*(二)","slug":"20190707","date":"2019-07-07T10:43:26.000Z","updated":"2019-08-05T09:55:56.261Z","comments":true,"path":"2019/07/07/20190707/","link":"","permalink":"https://www.fogsail.net/2019/07/07/20190707/","excerpt":"状态空间搜索的很多问题需要自己建图，这篇博文是对上一篇的一些内容做了扩展","text":"状态空间搜索的很多问题需要自己建图，这篇博文是对上一篇的一些内容做了扩展 BFS和DFS在IDA*处理中的异同ZOJ2669 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212//// main.cpp// ZOJ2669//// Created by zhangmin chen on 2019/7/7.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 10;const int inf = 0x3f3f3f3f;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)const int dx[] = &#123;-1, 0, 1, 0&#125;;const int dy[] = &#123;0, -1, 0, 1&#125;;class Grid &#123;public: int x, y; Grid(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125; bool operator&lt; (const Grid&amp; rhs) const &#123; return x &lt; rhs.x || (x == rhs.x &amp;&amp; y &lt; rhs.y); &#125;&#125;;typedef set&lt;Grid&gt; Post;set&lt;Post&gt; depth[maxn + 1];// depth begin from [1, n]int ans[maxn + 5][maxn + 5][maxn + 5];int n, w, h;void init() &#123; Set(ans, 0); _for(i, 0, maxn) depth[i].clear();&#125;void init2() &#123; Post beg; beg.insert(Grid(0, 0)); depth[1].insert(beg);&#125;// from depth 1, then expand the solution treePost normalize(const Post&amp; p) &#123; Post p2; int minX = inf, minY = inf; for(auto&amp; grid : p) &#123; minX = min(minX, grid.x); minY = min(minY, grid.y); &#125; for(auto&amp; grid : p) &#123; p2.insert(Grid(grid.x - minX, grid.y - minY)); &#125; return p2;&#125;Post _rotate(const Post&amp; p) &#123; Post p2; for(auto&amp; grid : p) &#123; p2.insert(Grid(grid.y, -grid.x)); &#125; return normalize(p2);&#125;Post _flip(const Post&amp; p) &#123; Post p2; for(auto&amp; grid : p) &#123; p2.insert(Grid(grid.x, -grid.y)); &#125; return normalize(p2);&#125;// in dfs, if d == maxd, try to insert// posture to depth[d]bool tryInsert(Post p, int d) &#123; _for(i, 0, 4) &#123; p = _rotate(p); if(depth[d].count(p)) return false; &#125; p = _flip(p); _for(i, 0, 4) &#123; p = _rotate(p); if(depth[d].count(p)) return false; &#125; depth[d].insert(p); return true;&#125;//void dfs(Post p, int d, int maxd) &#123; if(d == maxd) &#123; tryInsert(p, d); return; &#125; for(auto grid : p) _for(dir, 0, 4) &#123; Grid nxtG(grid.x + dx[dir], grid.y + dy[dir]); if(!p.count(nxtG)) &#123; Post p2 = p; p2.insert(nxtG); dfs(p2, d+1, maxd); &#125; &#125;&#125;void bfs(int d, int maxd) &#123; queue&lt;Post&gt; que; for(auto p : depth[d]) que.push(p); while (!que.empty()) &#123; Post f = que.front(); que.pop(); if(f.size() == maxd) &#123; tryInsert(f, maxd); continue; &#125; for(auto grid : f) _for(dir, 0, 4) &#123; Grid nxtG(Grid(grid.x + dx[dir], grid.y + dy[dir])); if(!f.count(nxtG)) &#123; Post p2 = f; p2.insert(nxtG); if(p2.size() &lt;= maxd) que.push(p2); &#125; &#125; &#125;&#125;void printTable() &#123; // init(); init2(); /* _rep(maxd, 2, maxn) for(auto p : depth[maxd - 1]) dfs(p, maxd - 1, maxd); */ _rep(maxd, 2, maxn) bfs(maxd - 1, maxd); _rep(n, 2, maxn) _rep(w, 1, maxn) _rep(h, 1, maxn) &#123; int cnt = 0; for(auto p : depth[n]) &#123; int maxX = 0, maxY = 0; for(auto grid : p) &#123; maxX = max(maxX, grid.x); maxY = max(maxY, grid.y); &#125; if(min(maxX, maxY) &lt; min(w, h) &amp;&amp; max(maxX, maxY) &lt; max(w, h)) cnt++; &#125; ans[n][w][h] = cnt; //debug(ans[n][w][h]); &#125; //for(auto g : depth[1]) for(auto p : g) cout &lt;&lt; p.x &lt;&lt; \" \" &lt;&lt; p.y &lt;&lt; endl;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); printTable(); while (scanf(\"%d%d%d\", &amp;n, &amp;w, &amp;h) == 3) &#123; // solve() if(n == 1) &#123; printf(\"1\\n\"); continue; &#125; printf(\"%d\\n\", ans[n][w][h]); &#125; &#125; dfs处理方法IDA*外层循环for(auto p : depth[maxd - 1])遍历深度为maxd - 1的解答树，并且获取状态pdfs时候只针对p这单一状态，往下扩张 1234567891011121314151617181920void dfs(Post p, int d, int maxd) &#123; if(d == maxd) &#123; tryInsert(p, d); return; &#125; for(auto grid : p) _for(dir, 0, 4) &#123; Grid nxtG(grid.x + dx[dir], grid.y + dy[dir]); if(!p.count(nxtG)) &#123; Post p2 = p; p2.insert(nxtG); dfs(p2, d+1, maxd); &#125; &#125;&#125;int solve() &#123; _rep(maxd, 2, maxn) for(auto p : depth[maxd - 1]) dfs(p, maxd - 1, maxd);&#125; bfs处理方法bfs逐层扩展解答树解答树从d-&gt;maxd expand当前在解答树的d层，获取d层的状态进队列 值得注意的是，需要有一个flag标志或者是dist标志，来退出解答树的扩张 123456while(!que.empty()) &#123; int x = que.front(); que.pop(); if(x is the exist point) not expand x continue; &#125; 123456789101112131415161718192021222324252627void bfs(int d, int maxd) &#123; queue&lt;Post&gt; que; for(auto p : depth[d]) que.push(p); while (!que.empty()) &#123; Post f = que.front(); que.pop(); if(f.size() == maxd) &#123; tryInsert(f, maxd); continue; &#125; for(auto grid : f) _for(dir, 0, 4) &#123; Grid nxtG(Grid(grid.x + dx[dir], grid.y + dy[dir])); if(!f.count(nxtG)) &#123; Post p2 = f; p2.insert(nxtG); if(p2.size() &lt;= maxd) que.push(p2); &#125; &#125; &#125;&#125;int solve() &#123; _rep(maxd, 2, maxn) bfs(maxd - 1, maxd);&#125; IDA与图遍历的路径输出(sstream), 把路径看成IDA的状态LA5147 1/ 并查集的处理123456int findset(int x) &#123; return pa[x] == x ? x : pa[x] = findset(pa[x]);&#125;常见错误直接return findset(pa[x])正确的写法是pa[x] = findset(pa[x]) pa[x] = findset(pa[x])完成递归而不是findset(pa[x]) 2/ 图的路径打印，转成字符串输出stringstream的用法 1234567891011ostream&amp; operator&lt;&lt; (ostream&amp; os, const vector&lt;int&gt;&amp; path) &#123; _for(i, 0, path.size()) &#123; os &lt;&lt; ' '; os &lt;&lt; path[i]; &#125; return os;&#125;stringstream ss;ss &lt;&lt; path;pathstr.push_back(ss.str()); stringstream还有一种用法比较常见获取字符串流，字符串流中有空格，我们需要用空格分隔字串，然后依次读入字串 12345vector&lt;string&gt; words;stringstream ss(str);string tmp;while(ss &gt;&gt; tmp) words.push_back(tmp); 3/ dfs执行图的路径输出如果要输出所有路径，if(u == dest)时候不需要return这时候需要有穷遍历vector G[maxn]其中u-&gt;dest的连通性，保证了_for(i, 0, G[u].size()) v = G[u][i]是有穷的 123456789101112131415void dfs(int u, int dest, vector&lt;int&gt;&amp; path) &#123; path.push_back(u) if(u == dest) &#123; ... &#125; _for(i, 0, G[u].size()) &#123; int v = G[u][i]; ... dfs(v, dest, path); &#125; path.pop_back();&#125; path.push_back(u), path.pop_back()完成回溯 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//// main.cpp// LA5147//// Created by zhangmin chen on 2019/7/7.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int maxn = 20 + 5;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)int pa[maxn];set&lt;int&gt; G[maxn];int n, k;// Graph start from 1void init() &#123; // Set(pa, 0); _for(i, 0, maxn) G[i].clear();&#125;void initSet() &#123; _for(i, 0, maxn) pa[i] = i;&#125;int findSet(int x) &#123; return pa[x] == x ? x : (pa[x] = findSet(pa[x]));&#125;// regard path as status in IDA*// expand pathostream&amp; operator&lt;&lt; (ostream&amp; os, const vector&lt;int&gt;&amp; path) &#123; bool first = true; _for(i, 0, path.size()) &#123; if(first) first = false; else os &lt;&lt; ' '; os &lt;&lt; path[i]; &#125; return os;&#125;void dfs(int u, int dest, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; paths) &#123; path.push_back(u); if(u == dest) &#123; stringstream ss; ss &lt;&lt; path; paths.push_back(ss.str()); &#125; _forS(i, G[u].begin(), G[u].end()) &#123; int v = *i; if(find(path.begin(), path.end(), v) != path.end()) continue; dfs(v, dest, path, paths); &#125; path.pop_back();&#125;int main() &#123; // freopen(\"input.txt\", \"r\", stdin); for(int kase = 1, from, to; scanf(\"%d\", &amp;k) == 1 &amp;&amp; k; kase++) &#123; init(); initSet(); while(true) &#123; scanf(\"%d%d\", &amp;from, &amp;to); if(from == 0 || to == 0) break; G[from].insert(to); G[to].insert(from); int p1 = findSet(from); int p2 = findSet(to); if(p1 != p2) pa[p1] = p2; &#125; // finish build graph // then solve() vector&lt;int&gt; path; vector&lt;string&gt; paths; if(findSet(pa[1]) == findSet(pa[k])) dfs(1, k, path, paths); printf(\"CASE %d:\\n\", kase); _for(i, 0, paths.size()) cout &lt;&lt; paths[i] &lt;&lt; endl; printf(\"There are %lu routes from the firestation to streetcorner %d.\\n\", paths.size(), k); &#125;&#125; 图形路径输出(LA5164)LA5164 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167//// main.cpp// LA5164//// Created by zhangmin chen on 2019/7/9.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int maxn = 20 + 5;const int maxk = 50 + 5;const int MAX = 256;int N, K;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _forV(i, l, r) for(vector&lt;Pos&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)class Pos &#123;public: int x, y; Pos(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125;&#125;;const int dx[] = &#123;-1, 0, 1, 0&#125;;const int dy[] = &#123;0, -1, 0, 1&#125;;const char DIR[] = &#123;'w', 's', 'e', 'n'&#125;;// (dx[dir], dy[dir]) =&gt; DIR[dir]vector&lt;Pos&gt; blocks;int vis[MAX * 2][MAX * 2];bool inRange(int x, int left, int right) &#123; if(left &gt; right) return inRange(x, right, left); return left &lt;= x &amp;&amp; x &lt;= right;&#125;bool isBlock(const Pos&amp; src, const Pos&amp; dest) &#123; if(src.x == dest.x) &#123; for(auto b : blocks) &#123; if(src.x == b.x &amp;&amp; inRange(b.y, src.y, dest.y)) return true; &#125; &#125; else if(src.y == dest.y) &#123; for(auto b : blocks) &#123; if(src.y == b.y &amp;&amp; inRange(b.x, src.x, dest.x)) return true; &#125; &#125; return false;&#125;void init() &#123; blocks.clear(); Set(vis, 0);&#125;ostream&amp; operator&lt;&lt; (ostream&amp; os, const vector&lt;char&gt;&amp; path) &#123; for(const auto p : path) os &lt;&lt; p; return os;&#125;bool h(const Pos&amp; pos, const vector&lt;char&gt;&amp; path) &#123; int dist = abs(pos.x) + abs(pos.y); int d = (int)path.size(); int walk = (N + d + 1) * (N - d) / 2; return walk &lt; dist;&#125;// usage: if(h(pos, path)) dfs returnvoid dfs(const Pos&amp; pos, vector&lt;char&gt;&amp; path, vector&lt;string&gt;&amp; paths) &#123; if(path.size() == N) &#123; if(pos.x == 0 &amp;&amp; pos.y == 0) &#123; stringstream ss; ss &lt;&lt; path; paths.push_back(ss.str()); &#125; return; &#125; if(h(pos, path)) return; _for(dir, 0, 4) &#123; // find invalid move const char D = DIR[dir]; int len = (int)path.size() + 1; if(path.size()) &#123; const char last = path.back(); if(last == D) continue; if(last == 'w' &amp;&amp; D == 'e') continue; if(last == 'n' &amp;&amp; D == 's') continue; if(last == 'e' &amp;&amp; D == 'w') continue; if(last == 's' &amp;&amp; D == 'n') continue; &#125; Pos nxt(pos.x + dx[dir] * len, pos.y + dy[dir] * len); if(isBlock(pos, nxt)) continue; if(vis[nxt.x + MAX][nxt.y + MAX]) continue; vis[nxt.x + MAX][nxt.y + MAX] = 1; path.push_back(D); dfs(nxt, path, paths); path.pop_back(); vis[nxt.x + MAX][nxt.y + MAX] = 0; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; init(); scanf(\"%d%d\", &amp;N, &amp;K); Pos b; _for(i, 0, K) &#123; scanf(\"%d%d\", &amp;b.x, &amp;b.y); blocks.push_back(b); &#125; // finish input // solve the problem Pos src(0, 0); vector&lt;char&gt; path; vector&lt;string&gt; paths; dfs(src, path, paths); sort(paths.begin(), paths.end()); _for(i, 0, paths.size()) cout &lt;&lt; paths[i] &lt;&lt; endl; printf(\"Found %lu golygon(s).\\n\\n\", paths.size()); &#125;&#125; 网格问题: 一个状态占用多个格子(LA5150)数据处理: 行单向扩展123456789101112131415161718192021222324252627282930void init() &#123; int cnt = 0; _for(i, 0, ROW) _for(j, i, COL) &#123; Pos&amp; cur = cards[cnt]; cur.x = i; cur.y = j; getCard[i][j] = cnt++; &#125;&#125;bool nxt(Pos&amp; pos) &#123; int r = pos.x, c = pos.y; c++; r += c / COL; c %= COL; if(r &gt;= ROW) return false pos.x = r, pos.y = c; return true;&#125;usage: in grid_for(i, 0, R) _for(j, 0, C) const Card&amp; cur = cards[getCard[i][j]];int main() &#123; Pos st(0, 0); while(true) &#123; if(scanf(\"%d\", &amp;grid[st.x][st.y]) != 1) break; while(nxt(st)) cin &gt;&gt; grid[st.x][st.y]; &#125;&#125; 状态dfs求解的时候，对每一个节点，要给出预留的扩展空间 LA5150 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197//// main.cpp// LA5150//// Created by zhangmin chen on 2019/7/11.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int COL = 8;const int ROW = 7;const int dx[] = &#123;0, 1&#125;;const int dy[] = &#123;1, 0&#125;;const int maxn = 28;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)class Pips &#123;public: int x, y; Pips(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125;&#125;;int grid[ROW][COL], ans[ROW][COL];int getCard[ROW][ROW];Pips cards[maxn];// cards &lt;-&gt; getCard[][]// usage: cards[getCard[i][j]]// ID = getCard[i][j]void init() &#123; Set(grid, 0); Set(ans, -1); Set(cards, 0); Set(getCard, -1);&#125;int read() &#123; int x; scanf(\"%d\", &amp;x); return x;&#125;void initCards() &#123; int cnt = 0; _for(i, 0, ROW) _for(j, i, ROW) &#123; Pips&amp; cur = cards[cnt]; cur.x = i; cur.y = j; getCard[i][j] = cnt; cnt++; &#125;&#125;int getBone(int x, int y) &#123; if(x &gt; y) return getBone(y, x); return getCard[x][y];&#125;bool nxt(Pips&amp; pos) &#123; int pr = pos.x, pc = pos.y; pc++; pr += pc / COL; pc %= COL; if(pr &gt;= ROW) return false; pos.x = pr; pos.y = pc; return true;&#125;bool inRange(int x, int left, int right) &#123; if(left &gt;= right) return inRange(x, right, left); return left &lt;= x &amp;&amp; x &lt;= right;&#125;bool valid(int r, int c) &#123; return inRange(r, 0, ROW - 1) &amp;&amp; inRange(c, 0, COL - 1);&#125;void dfs(const Pips&amp; pos, set&lt;int&gt; cardID, int&amp; cnt) &#123; if(cardID.size() == maxn) &#123; cnt++; _for(i, 0, ROW) &#123; printf(\" \"); _for(j, 0, COL) printf(\"%4d\", ans[i][j] + 1); printf(\"\\n\"); &#125; printf(\"\\n\"); return; &#125; // then cut stretch // if cur position is been assigned // dfs from _nxt Pips _nxt = pos; if(ans[_nxt.x][_nxt.y] != -1) &#123; if(nxt(_nxt)) dfs(_nxt, cardID, cnt); return; &#125; // then assign the card _nxt = pos; if(!nxt(_nxt)) return; _for(dir, 0, 2) &#123; int px = pos.x, py = pos.y; int nx = px + dx[dir], ny = py + dy[dir]; if(!valid(nx, ny)) continue; if(ans[nx][ny] != -1) continue; int _bone = getBone(grid[px][py], grid[nx][ny]); if(_bone != -1 &amp;&amp; !cardID.count(_bone)) &#123; Pips _nxt = pos; nxt(_nxt); ans[px][py] = ans[nx][ny] = _bone; cardID.insert(_bone); dfs(_nxt, cardID, cnt); cardID.erase(_bone); ans[px][py] = ans[nx][ny] = -1; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); initCards(); int kase = 1; while (true) &#123; Pips st(0, 0); if(scanf(\"%d\", &amp;grid[st.x][st.y]) != 1) break; while(nxt(st)) grid[st.x][st.y] = read(); // finish input // then solve() if(kase &gt; 1) printf(\"\\n\\n\\n\"); printf(\"Layout #%d:\\n\\n\", kase); _for(i, 0, ROW) &#123; _for(j, 0, COL) printf(\"%4d\", grid[i][j]); printf(\"\\n\"); &#125; printf(\"\\nMaps resulting from layout #%d are:\\n\\n\", kase); int cnt = 0; set&lt;int&gt; cardID; dfs(Pips(), cardID, cnt); printf(\"There are %d solution(s) for layout #%d.\\n\", cnt, kase); kase++; init(); initCards(); &#125; &#125; 求解策略递推URAL1309 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//// main.cpp// URAL1309//// Created by zhangmin chen on 2019/7/11.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int M = 9973;const int maxn = 50000;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)int _pow(int x, int k) &#123; int ans = 1; _for(i, 0, k) ans = (ans * x) % M; return ans;&#125;void _mod(int&amp; x) &#123; x %= M; if(x &lt; 0) x += M;&#125;int _A(int x) &#123; int ans = 0; ans = (_pow(x, 5) - x + 7); _mod(ans); return ans;&#125;int _B(int x) &#123; int ans = 0; ans = -1 * _pow(x, 5) + _pow(x, 3) + 3 * x; _mod(ans); return ans;&#125;int f[maxn];void init() &#123; Set(f, 0);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int n; scanf(\"%d\", &amp;n); init(); int b = n % M; // recursive: [1, b] _rep(i, 1, b) &#123; int A0 = _A(i); int B0 = _B(i); f[i] = A0 * f[i - 1] + B0; _mod(f[i]); &#125; // coefficent: [b+1, b+M], get A(b+M)f(x) + B(b+M) int A = 1, B = 0; _rep(i, b+1, b+M) &#123; // int Ai = _A(i); int Bi = _B(i); f[i] = Ai * f[i - 1] + Bi; A *= Ai; B = B * Ai + Bi; _mod(A); _mod(B); _mod(f[i]); &#125; int ans = f[b]; while (b &lt; n) &#123; ans = ans * A + B; _mod(ans); b += M; &#125; printf(\"%d\\n\", ans); &#125; 搜索：位模拟，连通分量，开点C++ STL中的bitset头文件 1234567891011121314构造方法：string s = \"100101\";bitset&lt;MAXN&gt; bits(s)MAXN位，最低位是s，高位不足用0补齐bits.count()返回1的位数bits.set(3, 0) =&gt; bits[3] = 0bits.set(3) =&gt; bits[3] = 1bits.reset(3) =&gt; bits[3] = 0bits.test(2)bits[2] == 1, return truebits[2] == 0, return false LA5218 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140//// main.cpp// LA5218//// Created by zhangmin chen on 2019/7/11.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int maxn = 15;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)int n;int G[maxn][maxn];int vis[maxn];void init() &#123; Set(G, 0); Set(vis, 0);&#125;int deg(const int u, const bitset&lt;maxn&gt;&amp; opened) &#123; if(opened.test(u)) return 0; int ans = 0; _for(v, 0, n) if(G[u][v] &amp;&amp; !opened.test(v)) ans++; return ans;&#125;bool canDfs(const int u, const int pa, const bitset&lt;maxn&gt;&amp; opened) &#123; if(vis[u] == 1) return true; if(vis[u] == -1) return false; if(opened.test(u)) &#123; vis[u] = 1; return true; &#125; vis[u] = -1; // dfs v _for(v, 0, n) if(v != pa &amp;&amp; G[u][v]) if(!canDfs(v, u, opened)) return false; vis[u] = 1; return true;&#125;void initVis() &#123; Set(vis, 0);&#125;int solve() &#123; int ans = n; bitset&lt;maxn&gt; opened; _for(x, 0, 1 &lt;&lt; n) &#123; opened.reset(); bool ok = true; // check line _for(i, 0, n) if((1 &lt;&lt; i) &amp; x) opened.set(i); _for(i, 0, n) if(deg(i, opened) &gt; 2 &amp;&amp; !opened.test(i)) &#123; ok = false; break; &#125; if(!ok) continue; // check circle and component initVis(); int ti = 0; _for(u, 0, n) &#123; if(opened.test(u)) continue; if(!vis[u]) ti++; if(!canDfs(u, -1, opened)) &#123; ok = false; break; &#125; &#125; if(!ok) continue; int kc = (int)opened.count(); //debug(ti); if(ti &lt;= kc + 1) ans = min(ans, kc); &#125; return ans; &#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); for(int kase = 1; scanf(\"%d\", &amp;n) == 1 &amp;&amp; n; kase++) &#123; init(); int from, to; while (true) &#123; scanf(\"%d%d\", &amp;from, &amp;to); if(from == -1 || to == -1) break; from--; to--; G[from][to] = G[to][from] = 1; &#125; // input finished // then solve int ans = solve(); // cout &lt;&lt; ans &lt;&lt; endl; printf(\"Set %d: Minimum links to open is %d\\n\", kase, ans); &#125;&#125; Pipeline SchedulingLA5678 位模拟：右移动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//// main.cpp// LA5678//// Created by zhangmin chen on 2019/7/12.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int UNIT = 5;const int MAXN = 20 + 5;const int MAXTASK = 10;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)int units[UNIT];vector&lt;int&gt; skip;int N;void init() &#123; Set(units, 0); skip.clear();&#125;bool overlap(const int* tb, int dt) &#123; _for(i, 0, UNIT) if(units[i] &amp; (tb[i] &gt;&gt; dt)) return true; return false;&#125;void read() &#123; char line[MAXN]; _for(i, 0, UNIT) &#123; scanf(\"%s\", line); _for(j, 0, N) if(line[j] == 'X') units[i] |= (1 &lt;&lt; j); &#125; _rep(dt, 1, N) if(!overlap(units, dt)) skip.push_back(dt);&#125;void dfs(int* tb, int clock, int d, int&amp; ans) &#123; if(d == MAXTASK) &#123; ans = min(ans, clock); return; &#125; if( (clock + (MAXTASK - d) * skip[0]) &gt; ans) return; _for(i, 0, skip.size()) &#123; int dt = skip[i]; if(!overlap(tb, dt)) &#123; int nxt[UNIT]; Cpy(nxt, tb); _for(j, 0, UNIT) nxt[j] = ((nxt[j] &gt;&gt; dt) | units[j]); dfs(nxt, clock + dt, d + 1, ans); &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;N) &amp;&amp; N) &#123; // init(); read(); int ans = N * MAXTASK; dfs(units, N, 1, ans); printf(\"%d\\n\", ans); &#125;&#125; 位模拟：左移动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960bitset&lt;MAXN&gt; units[UNIT], MASK;vector&lt;int&gt; skip;int N;// units in overall scope means incoming task// parameter *tb is old taskvoid init() &#123; _for(i, 0, UNIT) units[i].reset(); // MASK.reset(); skip.clear();&#125;bool overlap(bitset&lt;MAXN&gt;* tb, int dt) &#123; _for(i, 0, UNIT) if( ((tb[i] &lt;&lt; dt) &amp; units[i]).any() ) return true; return false;&#125;void read() &#123; char line[MAXN]; _for(i, 0, UNIT) &#123; scanf(\"%s\", line); _for(j, 0, N) if(line[j] == 'X') units[i].set(j); &#125; _rep(dt, 1, N) if(!overlap(units, dt)) skip.push_back(dt); // MASK = (1 &lt;&lt; N) - 1;&#125;void dfs(bitset&lt;MAXN&gt;* tb, int clock, int d, int&amp; ans) &#123; if(d == MAXTASK) &#123; ans = min(ans, clock); return; &#125; if( (clock + (MAXTASK - d) * skip[0]) &gt; ans) return; _for(i, 0, skip.size()) &#123; int dt = skip[i]; if(!overlap(tb, dt)) &#123; bitset&lt;MAXN&gt; nxt[UNIT]; _for(j, 0, UNIT) nxt[j] = tb[j]; _for(j, 0, UNIT) nxt[j] = ((nxt[j] &lt;&lt; dt) | units[j]); dfs(nxt, clock + dt, d + 1, ans); &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;N) &amp;&amp; N) &#123; // init(); read(); int ans = N * MAXTASK; dfs(units, N, 1, ans); printf(\"%d\\n\", ans); &#125;&#125; Overlapping SquaresLA3790 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//// main.cpp// LA3790//// Created by zhangmin chen on 2019/7/12.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;#include &lt;assert.h&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;const int R = 5;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)int _hash(int r, int c) &#123; return r * R + c;&#125;void decode(const int x, int&amp; r, int&amp; c) &#123; c = x % R; r = x / R;&#125;class Grid &#123;public: int bitX, bitY; Grid(int _x = 0, int _y = 0) : bitX(_x), bitY(_y) &#123;&#125; inline void clear() &#123; bitX = bitY = 0; &#125; int getX(int r, int c) &#123; return bitX &amp; (1 &lt;&lt; _hash(r, c)); &#125; int getY(int r, int c) &#123; return bitY &amp; (1 &lt;&lt; _hash(r, c)); &#125; void setX(int r, int c) &#123; bitX |= (1 &lt;&lt; _hash(r, c)); &#125; void resetX(int r, int c) &#123; bitX &amp;= ~(1 &lt;&lt; _hash(r, c)); &#125; void setY(int r, int c) &#123; bitY |= (1 &lt;&lt; _hash(r, c)); &#125; void resetY(int r, int c) &#123; bitY &amp;= ~(1 &lt;&lt; _hash(r, c)); &#125; // usage: \"_\" setX(r, c) OR \"|\" setY(r, c) void fillGrid(int r, int c) &#123; assert(0 &lt;= r &amp;&amp; r &lt;= 2); // assert(\"green\"); setX(r, c); setY(r, c); setX(r, c+1); setX(r+2, c); setX(r+2, c+1); setY(r+1, c); setY(r, c+2); setY(r+1, c+2); resetX(r+1, c); resetX(r+1, c+1); resetY(r, c+1); resetY(r+1, c+1); &#125; bool operator== (const Grid&amp; rhs) const &#123; return bitX == rhs.bitX &amp;&amp; bitY == rhs.bitY; &#125;&#125;;Grid target;bool dfs(const Grid&amp; grid, int d) &#123; if(grid == target) return true; if(d &gt;= 6) return false; _rep(r, 0, 2) _rep(c, 0, 2) &#123; Grid nxt = grid; nxt.fillGrid(r, c); if(dfs(nxt, d+1)) return true; &#125; return false;&#125;void init() &#123; // target.clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string line; for(int kase = 1; ; kase++) &#123; init(); _for(i, 0, R) &#123; getline(cin, line); if(line == \"0\") return 0; _for(j, 0, 9) &#123; if(line[j] == ' ') continue; if(line[j] == '_') &#123; // (i, j/2) =&gt; bitX target.setX(i, j/2); &#125; if(line[j] == '|') &#123; // (i-1, j/2) =&gt; bitY target.setY(i-1, j/2); &#125; &#125; &#125; // finish input // then solve Grid st; bool ans = dfs(st, 0); printf(\"Case %d: \", kase); if(ans) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125;&#125; debug的技巧，assert的使用1/ 在预计程序不会到达的地方设置一个assert(false)2/ assert用于检查传递给私有方法的参数1234void fillGrid(int r, int c) &#123; assert(0 &lt;= r &amp;&amp; r &lt;= 2) assert(0 &lt;= c &amp;&amp; c &lt;= 2)&#125; 3/ 检查变量的属性，比如在dfs中给节点染色123456void dfs(int u) &#123; if(color[u] == GREEN) return assert(color[u] == GRAY); then visit node u&#125; 用一个断言来确定节点的执行 复杂搜索解答树填空法的综合应用LA3784 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218//// main.cpp// LA3784//// Created by zhangmin chen on 2019/7/13.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;#include &lt;assert.h&gt;using namespace std;typedef long long llong;typedef set&lt;int&gt;::iterator ssii;//const int maxn = 10 + 5;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _forS(i, l, r) for(set&lt;int&gt;::iterator i = (l); i != (r); i++)#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)const string buf = \"*0123456789\";const int BUFLEN = 11;int len[3];string data;void init() &#123; // data.clear(); Set(len, 0);&#125;/*void clearVis() &#123; Set(vis, 0);&#125; */// only one solution// check exp 0;// st3[i] == bit + '0' || str3[i] == '*'// ans is correctint cal(const string&amp; str, int from, int to) &#123; // [from, to] int ans = 0, base = 1; _rep(i, from, to) &#123; ans *= base; ans += str[i] - '0'; base *= 10; &#125; return ans;&#125;// find one and only one solution// return truebool _equal(const string&amp; str) &#123; // string lhs1 = lhs.substr(0, len1), lhs2 = lhs.substr(len1, len2); // assert(lhs1.length() == len1); // assert(lhs2.length() == len2); //if(lhs1[0] == '0' || lhs2[0] == '0' || rhs[0] == '0') return false; int a = cal(str, 0, len[0] - 1), b = cal(str, len[0], len[0] + len[1] - 1); int c = a * b; char ans[5]; /* stringstream ss; ss &lt;&lt; c; */ sprintf(ans, \"%d\", c); int ansL = (int)strlen(ans); assert(ansL &gt; 0); //debug(ans); if(ansL != len[2]) return false; else &#123; // bool ok = 1; _for(i, len[0] + len[1], str.length()) &#123; if(str[i] == '*') continue; // debug(ans[i]); if(ans[i - (len[0] + len[1])] != str[i]) return false; &#125; return true; &#125;&#125;void check(string&amp; str, int i, int&amp; cnt) &#123; if(cnt &gt; 1) return; if(i == len[0] + len[1]) &#123; if(_equal(str)) cnt++; return; &#125; if(str[i] != '*') check(str, i + 1, cnt); else &#123; _for(k, 1, BUFLEN) &#123; if(k == 1 &amp;&amp; (i == 0 || i == len[0])) continue; str[i] = buf[k]; check(str, i + 1, cnt); str[i] = '*'; &#125; &#125;&#125;// ans O(8100)bool dfs(string&amp; str, int i, int d, int maxd) &#123; if(d == maxd) &#123; int cnt = 0; check(str, 0, cnt); // debug(cnt); if(cnt == 1) return true; else return false; &#125; if(i == str.length()) return false; if(str.length() - i &lt; maxd - d) return false; // debug(len1); char old = str[i]; _for(k, 0, BUFLEN) &#123; if(k == 1 &amp;&amp; (i == 0 || i == len[0] || i == len[0] + len[1])) continue; if(old == buf[k]) &#123; // debug(old); if(dfs(str, i + 1, d, maxd)) return true; &#125; else &#123; str[i] = buf[k]; if(dfs(str, i + 1, d + 1, maxd)) return true; str[i] = old; &#125; &#125; // if(dfs(nxt)) return true return false;&#125;string solve() &#123; int maxd = 0; string clone = data; for(maxd = 0; ; maxd++) &#123; if(dfs(clone, 0, 0, maxd)) break; &#125; //debug(maxd); return clone;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string line; int kase = 1; while(getline(cin, line)) &#123; init(); if(line[0] == '0') return 0; // then line is the input data // line -&gt; Exp stringstream ss(line); string tmp; int k = 0; while (ss &gt;&gt; tmp) &#123; len[k++] = (int)tmp.length(); data += tmp; &#125; // cout &lt;&lt; data &lt;&lt; endl; string ans = solve(); // cout &lt;&lt; ans &lt;&lt; endl; printf(\"Case %d: \", kase++); cout &lt;&lt; ans.substr(0, len[0]) &lt;&lt; \" \" &lt;&lt; ans.substr(len[0], len[1]) &lt;&lt; \" \" &lt;&lt; ans.substr(len[0] + len[1]) &lt;&lt; endl; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"搜索","slug":"搜索","permalink":"https://www.fogsail.net/tags/搜索/"}]},{"title":"暴力求解和IDA*","slug":"20190620","date":"2019-06-20T11:05:14.000Z","updated":"2019-08-05T09:56:13.588Z","comments":true,"path":"2019/06/20/20190620/","link":"","permalink":"https://www.fogsail.net/2019/06/20/20190620/","excerpt":"主要针对常见的暴力枚举还有状态空间搜索写了一些自己的模版和解法","text":"主要针对常见的暴力枚举还有状态空间搜索写了一些自己的模版和解法 回溯求解位模拟枚举二叉树LA3403 算法分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//// main.cpp// LA3403//// Created by zhangmin chen on 2019/6/19.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 6;const int MAXN = (1 &lt;&lt; 6);#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;class Node &#123;public: double L, R; Node(double _L = 0, double _R = 0) : L(_L), R(_R) &#123;&#125;&#125;;int vis[MAXN];double sum[MAXN], weight[maxn + 5];vector&lt;Node&gt; nodes[MAXN];int s;double r;void init1() &#123; Set(vis, 0); Set(sum, 0); Set(weight, 0); _for(i, 0, MAXN) nodes[i].clear();&#125;int init2() &#123; int root = (1 &lt;&lt; s) - 1; _rep(i, 0, root) _for(k, 0, s) &#123; if( (1 &lt;&lt; k) &amp; i ) sum[i] += weight[k]; &#125; return root;&#125;void dfs(int u) &#123; if(vis[u]) return; vis[u] = true; bool haveChild = false; for(int left = (u - 1) &amp; u; left; left = (left - 1) &amp; u) &#123; haveChild = true; int right = u ^ left; double dl = sum[right] / sum[u]; double dr = sum[left] / sum[u]; dfs(left); dfs(right); _for(i, 0, nodes[left].size()) _for(j, 0, nodes[right].size()) &#123; Node cur; cur.L = max(nodes[left][i].L + dl, nodes[right][j].L - dr); cur.R = max(nodes[left][i].R - dl, nodes[right][j].R + dr); if(cur.L + cur.R &lt; r) nodes[u].push_back(cur); &#125; &#125; if(!haveChild) nodes[u].push_back(Node());&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; scanf(\"%lf%d\", &amp;r, &amp;s); init1(); _for(i, 0, s) scanf(\"%lf\", &amp;weight[i]); int root = init2(); dfs(root); double ans = -1; _for(i, 0, nodes[root].size()) &#123; ans = max(ans, nodes[root][i].L + nodes[root][i].R); &#125; printf(\"%.10lf\\n\", ans); &#125;&#125; n皇后问题 实现1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//// main.cpp// nQueens01//// Created by zhangmin chen on 2019/6/15.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 50;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;int col[maxn], tot = 0, n = 8;int nc = 0;void init() &#123; Set(col, 0); tot = 0; nc = 0;&#125;void search(int cur) &#123; nc++; if(cur == n) tot++; else &#123; _for(i, 0, n) &#123; int ok = 1; col[cur] = i; _for(j, 0, cur) &#123; if(col[j] == col[cur] || col[j] + j == col[cur] + cur || cur - col[cur] == j - col[j]) &#123; ok = 0; break; &#125; &#125; if(ok) search(cur + 1); &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) &amp;&amp; n) &#123; init(); search(0); printf(\"%d\\n\", tot); cout &lt;&lt; endl; &#125;&#125; 实现212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//// main.cpp// nQueens02//// Created by zhangmin chen on 2019/6/15.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 50;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;int vis[3][maxn], col[maxn], n = 8;int tot = 0;void init() &#123; Set(vis, 0); Set(col, 0); tot = 0;&#125;void search(int cur) &#123; if(cur == n) tot++; else &#123; _for(i, 0, n) &#123; if(!vis[0][i] &amp;&amp; !vis[1][cur+i] &amp;&amp; !vis[2][cur+ n-i]) &#123; col[cur] = i; vis[0][i] = vis[1][cur+i] = vis[2][cur+ n-i] = 1; search(cur+1); vis[0][i] = vis[1][cur+i] = vis[2][cur+ n-i] = 0; &#125; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; init(); // search(0); printf(\"%d\\n\", tot); &#125;&#125; 解答树填空法UVA524 解答树填空分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//// main.cpp// UVA524//// Created by zhangmin chen on 2019/6/18.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int inf = 0x3f3f3f3f;const int maxn = 50;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;int A[maxn + 5], vis[maxn + 5], n;int isPrime(int val) &#123; for(int i = 2; i * i &lt;= val; i++) &#123; if(val % i == 0) return 0; &#125; return 1;&#125;void init() &#123; Set(A, 0); Set(vis, 0);&#125;void dfs(int cur) &#123; if(cur == n &amp;&amp; isPrime(A[n-1] + A[0])) &#123; //debug(isPrime(A[n-1] + A[0])) _for(i, 0, n) &#123; if(i != 0) printf(\" \"); printf(\"%d\", A[i]); &#125; printf(\"\\n\"); &#125; else &#123; for(int x = 2; x &lt;= n; x++) &#123; if(!vis[x] &amp;&amp; isPrime(x + A[cur-1])) &#123; A[cur] = x; // debug(x); vis[x] = 1; dfs(cur + 1); vis[x] = 0; &#125; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n &gt; 0) &#123; // debug(n); if(kase &gt; 0) cout &lt;&lt; endl; printf(\"Case %d:\\n\", ++kase); init(); A[0] = 1; dfs(1); &#125;&#125; 简单字符串状态搜索：枚举后缀HDU1627 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//// main.cpp// HDU1627//// Created by zhangmin chen on 2019/6/20.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 100;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;int S[maxn], n, L;int cnt = 0;void init() &#123; Set(S, 0); cnt = 0;&#125;int OK(int cur) &#123; for(int len = 1; len*2 &lt;= cur+1; len++) &#123; int equal = 1; _for(i, 0, len) &#123; if(S[cur-i] != S[cur-i-len]) &#123; equal = 0; break; &#125; &#125; if(equal) return 0; &#125; return 1;&#125;int dfs(int cur) &#123; if(cnt++ == n) &#123; _for(i, 0, cur) &#123; if(i % 64 == 0 &amp;&amp; i &gt; 0) printf(\"\\n\"); else if(i % 4 == 0 &amp;&amp; i &gt; 0) printf(\" \"); printf(\"%c\", 'A' + S[i]); &#125; printf(\"\\n%d\\n\", cur); return 0; &#125; else &#123; _for(i, 0, L) &#123; S[cur] = i; if(OK(cur) &amp;&amp; !dfs(cur + 1)) return 0; &#125; &#125; return 1;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d%d\", &amp;n, &amp;L) == 2 &amp;&amp; n &gt; 0) &#123; // init(); dfs(0); &#125;&#125; 剪枝用到的STL函数1char *strchr(const char *str, int c) 在str字符串中搜索第一个c出现的位置返回值从第一个c出现的位置，截取字符串到结束 LA5570 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//// main.cpp// UVA140//// Created by zhangmin chen on 2019/6/20.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 10;const int maxc = 256;const int maxl = 1000 + 10;int letter[maxn], id[maxc];#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;vector&lt;int&gt; u;map&lt;int, vector&lt;int&gt; &gt; v;char str[maxl];int read() &#123; int n = 0; for(char c = 'A'; c &lt;= 'Z'; c++) &#123; if(strchr(str, c) != NULL) &#123; id[c] = n++; letter[id[c]] = c; &#125; &#125; int p = 0, q = 0; int len = (int)strlen(str); for(;;) &#123; while(p &lt; len &amp;&amp; str[p] != ':') p++; if(p == len) break; while(q &lt; len &amp;&amp; str[q] != ';') q++; u.push_back(id[str[p-1]]); _for(i, p+1, q) &#123; v[id[str[p-1]]].push_back(id[str[i]]); &#125; p++; q++; &#125; return n;&#125;int N, ans;// N = read()int P[maxn], bestP[maxn], pos[maxn];void init() &#123; Set(letter, 0); Set(id, 0); Set(P, 0); Set(bestP, 0); Set(pos, 0); u.clear(); v.clear();&#125;void solve() &#123; ans = N; _for(i, 0, N) P[i] = i; for(;;) &#123; _for(i, 0, N) pos[P[i]] = i; int bandwidth = 0; _for(i, 0, u.size()) &#123; int node = u[i]; for(auto&amp; x : v[node]) &#123; bandwidth = max(bandwidth, abs(pos[node] - pos[x])); &#125; &#125; if(bandwidth &lt; ans) &#123; ans = bandwidth; memcpy(bestP, P, sizeof(P)); &#125; if(!next_permutation(P, P + N)) break; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%s\", str) == 1 &amp;&amp; str[0] != '#') &#123; init(); N = read(); solve(); _for(i, 0, N) printf(\"%c \", letter[bestP[i]]); printf(\"-&gt; %d\\n\", ans); &#125;&#125; 隐式图路径寻找八数码问题求解：编码和解码思路分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//// main.cpp// eightCode//// Created by zhangmin chen on 2019/6/22.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxstate = 1000000;const int inf = 362880 + 5;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;typedef int State[9];State nodes[maxstate], goal;int dist[maxstate];const int dx[] = &#123;-1, 0, 1, 0&#125;;const int dy[] = &#123;0, -1, 0, 1&#125;;int vis[inf], fact[9];void init() &#123; // Set(vis, 0); Set(fact, 0); fact[0] = 1; _for(i, 1, 9) fact[i] = fact[i-1] * i;&#125;bool tryInsert(int id) &#123; // int code = 0; _for(i, 0, 9) &#123; int cnt = 0; _for(j, i+1, 9) &#123; if(nodes[id][i] &gt; nodes[id][j]) cnt++; &#125; code += cnt * fact[8-i]; &#125; // debug(code); if(vis[code]) return false; return vis[code] = 1;&#125;bool valid(int x, int y) &#123; if(x &gt;= 0 &amp;&amp; x &lt; 3 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 3) return true; return false;&#125;int bfs() &#123; init(); int front = 1, rear = 2; while(front &lt; rear) &#123; // solve: State&amp; cur = nodes[front]; if(Cmp(goal, cur) == 0) return front; int z; for(z = 0; z &lt; 9; z++) if(!cur[z]) break; int x = z / 3, y = z % 3; _for(dir, 0, 4) &#123; int nx = x + dx[dir]; int ny = y + dy[dir]; int nz = nx * 3 + ny; //debug(nz); if(valid(nx, ny)) &#123; //debug(nx); //debug(ny); State&amp; to = nodes[rear]; memcpy(&amp;to, &amp;cur, sizeof(cur)); to[nz] = cur[z]; to[z] = cur[nz]; dist[rear] = dist[front] + 1; if(tryInsert(rear)) rear++; &#125; &#125; front++; &#125; return 0;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); //init(); // scanf nodes[1][9] _for(i, 0, 9) scanf(\"%d\", &amp;nodes[1][i]); _for(i, 0, 9) scanf(\"%d\", &amp;goal[i]); int ans = bfs(); //debug(ans); if(ans &gt; 0) printf(\"%d\\n\", dist[ans]); else printf(\"-1\\n\"); return 0;&#125; 八数码问题求解： 哈希表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140//// main.cpp// eightCode2//// Created by zhangmin chen on 2019/6/24.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxstate = 1000000;const int inf = 362880 + 5;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;typedef int State[9];int dist[maxstate];State nodes[maxstate], goal;const int dx[] = &#123;-1, 0, 1, 0&#125;;const int dy[] = &#123;0, -1, 0, 1&#125;;int vis[inf], fact[9];bool valid(int x, int y) &#123; if(x &gt;= 0 &amp;&amp; x &lt; 3 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 3) return true; return false;&#125;const int hashSZ = 1000003;int head[hashSZ], nxt[maxstate];void init() &#123; Set(vis, 0); Set(fact, 0); Set(head, 0); Set(nxt, 0); fact[0] = 1; _for(i, 1, 9) fact[i] = fact[i-1] * i;&#125;int Hash(const State&amp; s) &#123; int val = 0; _for(i, 0, 9) val = val * 10 + s[i]; return val % hashSZ;&#125;void link(int id, int h) &#123; nxt[id] = head[h]; head[h] = id;&#125;bool tryInsert(int id) &#123; int h = Hash(nodes[id]); int u = head[h]; while(u) &#123; // if(Cmp(nodes[u], nodes[id]) == 0) return 0; u = nxt[u]; &#125; link(id, h); return true;&#125;int bfs() &#123; init(); int front = 1, rear = 2; while (front &lt; rear) &#123; State&amp; cur = nodes[front]; if(Cmp(goal, cur) == 0) return front; int z; for(z = 0; z &lt; 9; z++) if(!cur[z]) break; int x = z / 3, y = z % 3; _for(dir, 0, 4) &#123; int nx = x + dx[dir]; int ny = y + dy[dir]; int nz = nx * 3 + ny; if(valid(nx, ny)) &#123; State&amp; to = nodes[rear]; Cpy(to, cur); to[nz] = cur[z]; to[z] = cur[nz]; dist[rear] = dist[front] + 1; if(tryInsert(rear)) rear++; &#125; &#125; front++; &#125; return 0;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); _for(i, 0, 9) scanf(\"%d\", &amp;nodes[1][i]); _for(i, 0, 9) scanf(\"%d\", &amp;goal[i]); int ans = bfs(); if(ans &gt; 0) printf(\"%d\\n\", dist[ans]); else printf(\"-1\\n\"); return 0;&#125; 隐式图(Implicit Graph)相关问题终点状态未知：标签法UVA10603 分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//// main.cpp// Fill//// Created by zhangmin chen on 2019/6/26.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 200 + 5;const int inf = 362880 + 5;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;class Node &#123;public: int pour[3], dist; bool operator&lt; (const Node&amp; rhs) const &#123; return dist &gt; rhs.dist; &#125; Node() &#123; Set(pour, 0); dist = 0; &#125; Node(const Node&amp; rhs) &#123; // Cpy(pour, rhs.pour); dist = rhs.dist; &#125;&#125;;int vis[maxn][maxn], cap[3], ans[maxn];void init() &#123; Set(vis, 0); Set(cap, 0); Set(ans, -1);&#125;void update(const Node&amp; u) &#123; _for(i, 0, 3) &#123; int d = u.pour[i]; if(ans[d] &lt; 0 || u.dist &lt; ans[d]) ans[d] = u.dist; &#125;&#125;void solve(int a, int b, int c, int d) &#123; // cap[0] = a; cap[1] = b; cap[2] = c; priority_queue&lt;Node&gt; que; Node start; start.dist = 0; start.pour[0] = 0; start.pour[1] = 0; start.pour[2] = c; vis[0][0] = 1; que.push(start); while (!que.empty()) &#123; Node x = que.top(); que.pop(); update(x); if(ans[d] &gt;= 0) break; // then bfs and spread the node // pour i to j _for(i, 0, 3) _for(j, 0, 3) if(i != j) &#123; Node nxt(x); if(x.pour[i] == 0 || x.pour[j] == cap[j]) continue; int amount = min(cap[j], x.pour[i] + x.pour[j]) - x.pour[j]; nxt.pour[i] -= amount; nxt.pour[j] += amount; nxt.dist = x.dist + amount; if(!vis[nxt.pour[0]][nxt.pour[1]]) &#123; vis[nxt.pour[0]][nxt.pour[1]] = 1; que.push(nxt); &#125; &#125; &#125; while (d &gt;= 0) &#123; if(ans[d] &gt;= 0) &#123; printf(\"%d %d\\n\", ans[d], d); return; &#125; d--; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase, a, b, c, d; scanf(\"%d\", &amp;kase); //debug(kase); while (kase--) &#123; init(); scanf(\"%d%d%d%d\", &amp;a, &amp;b, &amp;c, &amp;d); solve(a, b, c, d); &#125;&#125; 双向BFSPOJ3523 算法分析： 注意的点：C 库函数 char fgets(char str, int n, FILE *stream)从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209//// main.cpp// POJ3523//// Created by zhangmin chen on 2019/6/26.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 200;const int maxs = 20;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;const int dx[] = &#123;-1, 0, 1, 0, 0&#125;;const int dy[] = &#123;0, -1, 0, 1, 0&#125;;class Node&#123;public: int x, y; Node(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125;&#125;;int from[3], to[3];int deg[maxn], G[maxn][5];Node nodes[maxn];char grid[maxs][maxs];int id[maxs][maxs];int dist[maxn][maxn][maxn];int color[maxn][maxn][maxn];void init() &#123; Set(from, 0); Set(to, 0); Set(deg, 0); Set(G, 0); Set(grid, 0); Set(id, 0); Set(dist, -1); Set(color, 0); _for(i, 0, maxn) &#123; nodes[i].x = nodes[i].y = 0; &#125;&#125;int ID(int p1, int p2, int p3) &#123; return (p1 &lt;&lt; 16) | (p2 &lt;&lt; 8) | p3;&#125;void decode(int x, int&amp; p1, int&amp; p2, int&amp; p3) &#123; p1 = (x &gt;&gt; 16) &amp; 0xff; p2 = (x &gt;&gt; 8) &amp; 0xff; p3 = x &amp; 0xff;&#125;bool conflicit(int p1, int p2, int p12, int p22) &#123; return p12 == p22 || (p1 == p22 &amp;&amp; p2 == p12);&#125;int bfs() &#123; queue&lt;int&gt; queF; queue&lt;int&gt; queB; dist[from[0]][from[1]][from[2]] = 0; dist[to[0]][to[1]][to[2]] = 1; color[from[0]][from[1]][from[2]] = 1; color[to[0]][to[1]][to[2]] = 2; queF.push(ID(from[0], from[1], from[2])); queB.push(ID(to[0], to[1], to[2])); while (!queF.empty() || !queB.empty()) &#123; int fSZ = (int)queF.size(), bSZ = (int)queB.size(); while (fSZ--) &#123; // int x = queF.front(); queF.pop(); int p1, p2, p3; decode(x, p1, p2, p3); _for(i, 0, deg[p1]) &#123; int p12 = G[p1][i]; _for(j, 0, deg[p2]) &#123; int p22 = G[p2][j]; if(conflicit(p1, p2, p12, p22)) continue; _for(k, 0, deg[p3]) &#123; int p32 = G[p3][k]; if(conflicit(p1, p3, p12, p32) || conflicit(p2, p3, p22, p32)) continue; if(color[p12][p22][p32] == 0) &#123; dist[p12][p22][p32] = dist[p1][p2][p3] + 1; color[p12][p22][p32] = 1; queF.push(ID(p12, p22, p32)); &#125; else if(color[p12][p22][p32] == 2) return dist[p12][p22][p32] + dist[p1][p2][p3]; &#125; &#125; &#125; &#125; while (bSZ--) &#123; // int x = queB.front(); queB.pop(); int p1, p2, p3; decode(x, p1, p2, p3); _for(i, 0, deg[p1]) &#123; int p12 = G[p1][i]; _for(j, 0, deg[p2]) &#123; int p22 = G[p2][j]; if(conflicit(p1, p2, p12, p22)) continue; _for(k, 0, deg[p3]) &#123; int p32 = G[p3][k]; if(conflicit(p1, p3, p12, p32) || conflicit(p2, p3, p22, p32)) continue; if(color[p12][p22][p32] == 0) &#123; dist[p12][p22][p32] = dist[p1][p2][p3] + 1; color[p12][p22][p32] = 2; queB.push(ID(p12, p22, p32)); &#125; else if(color[p12][p22][p32] == 1) return dist[p12][p22][p32] + dist[p1][p2][p3]; &#125; &#125; &#125; &#125; &#125; return -1;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int w, h, n; while(scanf(\"%d%d%d\\n\", &amp;w, &amp;h, &amp;n) == 3 &amp;&amp; n) &#123; init(); _for(i, 0, h) fgets(grid[i], 20, stdin); // debugArr(grid, h, w); int cnt = 0; _for(i, 0, h) _for(j, 0, w) &#123; if(grid[i][j] == '#') continue; nodes[cnt].x = i; nodes[cnt].y = j; id[i][j] = cnt; if(islower(grid[i][j])) from[grid[i][j] - 'a'] = cnt; else if(isupper(grid[i][j])) to[grid[i][j] - 'A'] = cnt; cnt++; &#125; // build graph: _for(i, 0, cnt) &#123; _for(d, 0, 5) &#123; int nx = nodes[i].x + dx[d]; int ny = nodes[i].y + dy[d]; if(grid[nx][ny] == '#') continue; G[i][deg[i]++] = id[nx][ny]; &#125; &#125; if(n &lt;= 2) &#123; deg[cnt] = 1; G[cnt][0] = cnt; from[2] = to[2] = cnt++; &#125; if(n &lt;= 1) &#123; deg[cnt] = 1; G[cnt][0] = cnt; from[1] = to[1] = cnt++; &#125; printf(\"%d\\n\", bfs()); &#125;&#125; 迭代加深搜索IDA*埃及分数问题Egyptian Fractions 算法分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//// main.cpp// UVA12558//// Created by zhangmin chen on 2019/6/27.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 100 + 10;const int maxv = 200000;const int inf = 0x3f3f3f3f;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;set&lt;llong&gt; vis;llong v[maxn], ans[maxn];int a, b, k;void init() &#123; vis.clear(); Set(v, 0); Set(ans, -1);&#125;llong gcd(llong a, llong b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;bool better(int d) &#123; _forDown(i, d, 0) &#123; if(v[i] != ans[i]) &#123; return ans[i] == -1 || v[i] &lt; ans[i]; &#125; &#125; return false;&#125;inline int getFrom(llong a, llong b) &#123; return (int)(b / a + 1);&#125;bool dfs(int d, int maxd, int from, llong a, llong b) &#123; // if(d == maxd) &#123; if(b % a) return false; if(vis.count(b / a)) return false; v[d] = b / a; if(better(d)) &#123; memcpy(ans, v, sizeof(llong) * (d + 1)); &#125; return true; &#125; bool ok = false; from = max(from, getFrom(a, b)); _for(i, from, inf) &#123; if(b * (maxd - d + 1) &lt;= a * i) break; if(vis.count(i)) continue; v[d] = i; llong a2 = i * a - b; llong b2 = i * b; llong g = gcd(a2, b2); // I made a bug here: if(dfs(d+1, maxd, i+1, a2/g, b2/g)) &#123; ok = true; &#125; &#125; return ok;&#125;bool solve(int&amp; maxd) &#123; // int ok = 0; for(maxd = 1; maxd &lt;= 100; maxd++) &#123; // Set(ans, -1); Set(v, 0); int f = getFrom(a, b); if(dfs(0, maxd, f, a, b)) &#123; ok = 1; break; &#125; &#125; return ok;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; int t; scanf(\"%d\", &amp;t); while (t--) &#123; init(); cin &gt;&gt; a &gt;&gt; b &gt;&gt; k; _for(i, 0, k) &#123; int v; cin &gt;&gt; v; vis.insert(v); &#125; // finished init // bool solve() int maxd; int ok = solve(maxd); cout &lt;&lt; \"Case \" &lt;&lt; ++kase &lt;&lt; \": \"; if(ok) &#123; cout &lt;&lt; a &lt;&lt; \"/\" &lt;&lt; b &lt;&lt; \"=\"; _for(i, 0, maxd) cout &lt;&lt; \"1/\" &lt;&lt; ans[i] &lt;&lt; \"+\"; cout &lt;&lt; \"1/\" &lt;&lt; ans[maxd] &lt;&lt; \"\\n\"; &#125; else cout &lt;&lt; \"No solution.\\n\"; &#125; return 0;&#125; 字符串：固定字符个数，有限次变换UVA11212 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//// main.cpp// UVA11212//// Created by zhangmin chen on 2019/6/29.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 9;const int MAXD = 10;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;int v[maxn], n;void init() &#123; Set(v, 0);&#125;bool sorted() &#123; _for(i, 0, n-1) &#123; if(v[i] &gt;= v[i+1]) return false; &#125; return true;&#125;int h() &#123; int cnt = 0; _for(i, 0, n-1) if(v[i] + 1 != v[i+1]) cnt++; if(v[n-1] != n) cnt++; return cnt;&#125;int dfs(int d, int maxd) &#123; // if( h() &gt; 3 * (maxd - d) ) return false; if(sorted()) return true; // then: try to dfs(d+1, maxd) int buf[maxn], oldv[maxn]; Cpy(oldv, v); _for(i, 0, n) _for(j, i, n) &#123; int cnt = 0; _for(k, 0, n) if(k &lt; i || k &gt; j) buf[cnt++] = v[k]; _for(p, 0, cnt) &#123; int cnt2 = 0; _rep(k, 0, p) v[cnt2++] = buf[k]; _rep(k, i, j) v[cnt2++] = oldv[k]; _for(k, p+1, cnt) v[cnt2++] = buf[k]; if(dfs(d+1, maxd)) return true; Cpy(v, oldv); &#125; &#125; return false;&#125;int solve() &#123; if(sorted()) return 0; int maxd; for(maxd = 1; maxd &lt; MAXD; maxd++) &#123; if(dfs(0, maxd)) return maxd; &#125; return MAXD;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; _for(i, 0, n) scanf(\"%d\", &amp;v[i]); // dfs and solve() printf(\"Case %d: %d\\n\", ++kase, solve()); &#125;&#125; 综合应用对仗工整的枚举LA5703 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//// main.cpp// LA5703//// Created by zhangmin chen on 2019/6/30.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int inf = 65536;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(llong i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(llong i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(llong i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); for(int kase = 1; kase &lt;= T; kase++) &#123; // solve the problem llong ans = 0; int n, s1, v1, s2, v2; scanf(\"%d%d%d%d%d\", &amp;n, &amp;s1, &amp;v1, &amp;s2, &amp;v2); if(s1 &gt; s2) &#123; swap(s1, s2); swap(v1, v2); &#125; if(n / s2 &gt;= inf) &#123; // _rep(i, 0, s1) ans = max(ans, v2 * i + (n - s2 * i) / s1 * v1); _rep(i, 0, s2) ans = max(ans, v1 * i + (n - s1 * i) / s2 * v2); &#125; else &#123; for(llong i = 0; s2 * i &lt;= n; i++) &#123; ans = max(ans, v2 * i + (n - s2 * i) / s1 * v1); &#125; &#125; printf(\"Case #%d: %lld\\n\", kase, ans); &#125;&#125; IDA*旋转游戏POJ2286 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144//// main.cpp// POJ2286//// Created by zhangmin chen on 2019/6/30.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 24;const int maxl = 2000;const int inf = 2400;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;/* 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 */const int revID[8] = &#123;5, 4, 7, 6, 1, 0, 3, 2&#125;;const int center[8] = &#123;6, 7, 8, 11, 12, 15, 16, 17&#125;;int line[8][7] = &#123; &#123;0, 2, 6, 11, 15, 20, 22&#125;, &#123;1, 3, 8, 12, 17, 21, 23&#125;, &#123;10, 9, 8, 7, 6, 5, 4&#125;, &#123;19, 18, 17, 16, 15, 14, 13&#125;&#125;;int v[maxn];char res[maxl];void addLine() &#123; _for(i, 4, 8) _for(j, 0, 7) &#123; line[i][j] = line[revID[i]][6-j]; &#125;&#125;void init() &#123; Set(v, 0); Set(res, 0);&#125;bool finish() &#123; _for(i, 0, 8) if(v[center[i]] != v[center[0]]) return false; return true;&#125;int diff(int t) &#123; int cnt = 0; _for(i, 0, 8) if(v[center[i]] != t) cnt++; return cnt;&#125;int h() &#123; int ans = inf; _rep(i, 1, 3) ans = min(ans, diff(i)); return ans;&#125;void mv(int dir) &#123; int tmp = v[line[dir][0]]; _for(i, 0, 6) v[line[dir][i]] = v[line[dir][i+1]]; v[line[dir][6]] = tmp;&#125;int dfs(int d, int maxd) &#123; if(finish()) &#123; res[d] = '\\0'; printf(\"%s\\n\", res); return true; &#125; if(h() + d &gt; maxd) return false; // then recurse: _for(dir, 0, 8) &#123; res[d] = 'A' + dir; mv(dir); if(dfs(d+1, maxd)) return true; mv(revID[dir]); &#125; return false;&#125;int main() &#123; // freopen(\"input.txt\", \"r\", stdin); addLine(); init(); while (scanf(\"%d\", &amp;v[0]) == 1 &amp;&amp; v[0]) &#123; //init(); _for(i, 1, maxn) scanf(\"%d\", &amp;v[i]); _for(i, 0, maxn) if(!v[i]) return 0; if(finish()) &#123; printf(\"No moves needed\\n\"); &#125; else &#123; int maxd = 1; for(maxd = 1; ; maxd++) &#123; if(dfs(0, maxd)) break; &#125; &#125; printf(\"%d\\n\", v[6]); init(); &#125;&#125; The art of IDA*POJ1084 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159//// main.cpp// POJ1084//// Created by zhangmin chen on 2019/7/2.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 60;const int maxs = 5 + 1;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)llong cell[maxs][maxs];llong bit[maxn];int n, tot, k;llong st;llong sqr[maxn];int sqrN;void init1() &#123; Set(cell, 0); Set(sqr, 0);&#125;void init2() &#123; bit[0] = 1; _rep(i, 1, maxn) bit[i] = (bit[i-1] &lt;&lt; 1);&#125;int getR(int x, int y) &#123; return (2 * n + 1) * x + y;&#125;int getC(int x, int y) &#123; return (2 * n + 1) * x + y + n;&#125;int build() &#123; int cnt = 0; // then cnt how many square _for(i, 0, n) _for(j, 0, n) &#123; cell[i][j] |= (bit[getR(i, j)] | bit[getR(i, j) + (2 * n + 1)]); cell[i][j] |= (bit[getC(i, j)] | bit[getC(i, j) + 1]); sqr[cnt] = cell[i][j]; cnt++; &#125; _rep(sz, 2, n) &#123; _forPlus(x, 0, sz - 1, n) _forPlus(y, 0, sz - 1, n) &#123; _for(dx, 0, sz) _for(dy, 0, sz) &#123; sqr[cnt] ^= cell[x + dx][y + dy]; &#125; cnt++; &#125; &#125; return cnt;&#125;int h(llong st) &#123; int cnt = 0; _for(i, 0, sqrN) if( (sqr[i] &amp; st) == sqr[i] ) &#123; cnt++; st ^= sqr[i]; &#125; return cnt;&#125;int dfs(int d, int maxd, llong st) &#123; // if(d == maxd) &#123; _for(i, 0, sqrN) if( (sqr[i] &amp; st) == sqr[i] ) return false; return true; &#125; if(h(st) + d &gt; maxd) return false; // then recurse: // del is the square to be destroyed llong del = 0; _for(i, 0, sqrN) if( (st &amp; sqr[i]) == sqr[i] ) &#123; if(!del) &#123; del = sqr[i]; break; &#125; &#125; _for(i, 0, tot) if( (bit[i] &amp; del) == bit[i]) &#123; if(dfs(d+1, maxd, st ^ bit[i])) return true; &#125; return false;&#125;int solve(llong st) &#123; int maxd = 1; for (maxd = 1; ; maxd++) &#123; if(dfs(0, maxd, st)) break; &#125; return maxd;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; init1(); init2(); scanf(\"%d%d\", &amp;n, &amp;k); tot = 2 * n * (n + 1); st = bit[tot] - 1; _for(i, 0, k) &#123; int a; scanf(\"%d\", &amp;a); st ^= bit[a-1]; &#125; // finish input, then build square sqrN = build(); printf(\"%d\\n\", solve(st)); &#125;&#125; 如果位运算面临数组开不下的问题使用普通解法，需要一个标记flag数组(contains)数组用来标记sqr[i]的边有没有number = k的火柴contains[i][k] =&gt; sqr[i] has number k edge 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//// main.cpp// POJ1084-2//// Created by zhangmin chen on 2019/7/4.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 60 + 5;int n, tot, k;int exist[maxn];int contains[maxn][maxn];int full[maxn], sqr[maxn];int sqrN;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)void init1() &#123; Set(exist, 0); Set(contains, 0); Set(sqr, 0); Set(full, 0);&#125;void initSqr(int k) &#123; _for(i, 0, tot) exist[i] = 1; // debug(tot); while (k--) &#123; int a; scanf(\"%d\", &amp;a); exist[a - 1] = 0; &#125;&#125;int getR(int x, int y) &#123; return (2 * n + 1) * x + y;&#125;int getC(int x, int y) &#123; return (2 * n + 1) * x + y + n;&#125;int build() &#123; int cnt = 0; _rep(sz, 1, n) &#123; _forPlus(x, 0, sz - 1, n) _forPlus(y, 0, sz - 1, n) &#123; full[cnt] = 4 * sz; sqr[cnt] = 0; _for(dl, 0, sz) &#123; int up = getR(x, y + dl); int down = getR(x + sz, y + dl); int left = getC(x + dl, y); int right = getC(x + dl, y + sz); contains[cnt][up] = 1; contains[cnt][down] = 1; contains[cnt][left] = 1; contains[cnt][right] = 1; sqr[cnt] += (exist[up] + exist[down] + exist[left] + exist[right]); &#125; cnt++; &#125; &#125; return cnt;&#125;int dfs(int d, int maxd) &#123; if(d == maxd) &#123; _for(i, 0, sqrN) if(sqr[i] == full[i]) return false; return true; &#125; //if(d + h() &gt; maxd) return false; int del = 0; // del is the id number of square to be destoryed _for(i, 0, sqrN) if(sqr[i] == full[i]) &#123; del = i; break; &#125; _for(i, 0, tot) &#123; // debug(tot); if(contains[del][i]) &#123; _for(k, 0, sqrN) if(contains[k][i]) sqr[k]--; if(dfs(d+1, maxd)) return true; _for(k, 0, sqrN) if(contains[k][i]) sqr[k]++; &#125; &#125; return false;&#125;int solve() &#123; int maxd = 1; for (maxd = 1; ; maxd++) &#123; if(dfs(0, maxd)) break; &#125; return maxd;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; init1(); scanf(\"%d%d\", &amp;n, &amp;k); tot = 2 * n * (n + 1); initSqr(k); sqrN = build(); printf(\"%d\\n\", solve()); &#125;&#125; 快速幂计算POJ3134 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//// main.cpp// POJ3134//// Created by zhangmin chen on 2019/7/4.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 1000 + 10;#define Cmp(a, b) memcmp(a, b, sizeof(b))#define Cpy(a, b) memcpy(a, b, sizeof(b))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define _forDown(i, l, r) for(int i = (l); i &gt;= r; i--)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;#define debugArr(arr, x, y) _for(i, 0, x) &#123; _for(j, 0, y) printf(\"%c\", arr[i][j]); printf(\"\\n\"); &#125;#define _forPlus(i, l, d, r) for(int i = (l); i + d &lt; (r); i++)int n;int v[maxn];void init() &#123; Set(v, 0); v[0] = 1;&#125;int h(int* v, int d, int maxd) &#123; int maxv = v[0]; _rep(i, 1, d) maxv = max(maxv, v[i]); return maxv &lt;&lt; (maxd - d);&#125;int dfs(int d, int maxd) &#123; if(d == maxd) &#123; if(v[d] == n) return true; return false; &#125; if(h(v, d, maxd) &lt; n) return false; // if(dfs(d+1, ...)) return true; _forDown(i, d, 0) &#123; v[d+1] = v[d] + v[i]; if(dfs(d+1, maxd)) return true; v[d+1] = v[d] - v[i]; if(dfs(d+1, maxd)) return true; &#125; return false;&#125;int solve() &#123; // if(n == 1) return 0; v[0] = 1; int maxd = 1; for(maxd = 1; ; maxd++) &#123; // if(dfs(0, maxd)) break; &#125; return maxd;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; init(); printf(\"%d\\n\", solve()); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"搜索","slug":"搜索","permalink":"https://www.fogsail.net/tags/搜索/"}]},{"title":"数据结构优化（二）","slug":"20190524","date":"2019-05-24T08:24:51.000Z","updated":"2019-05-29T20:42:02.885Z","comments":true,"path":"2019/05/24/20190524/","link":"","permalink":"https://www.fogsail.net/2019/05/24/20190524/","excerpt":"主要写一些数据结构模版以及综合应用 拓扑排序：有向环解决二阶矩阵","text":"主要写一些数据结构模版以及综合应用 拓扑排序：有向环解决二阶矩阵 矩阵问题，求方程式是否有解本质是用拓扑排序判断有向环，解决循环引用的问题 LA5154 题目分析： 1/ 表达式的表示12const int maxl = 128;char exp[maxr][maxc][maxl]; 2/ 读取表达式中的一串数字12345678910111213int read(const char* str, int&amp; len) &#123; len = 0; // len 初始化为多少，具体问题具体分析 int ans = 0, base = 1; while(str[len] &amp;&amp; isdigit(str[len])) &#123; ans *= base; ans += str[len] - '0'; base *= 10; len++; &#125; return ans;&#125; 3/ 二维拓扑排序程序结构 123456789101112131415161718192021222324252627282930313233int vis[maxr][maxc];Set(vis, 0);bool candfs(int r, int c) &#123; int&amp; ok = vis[r][c]; if(ok == -1) return false; else if(ok == 1) return true; ok = -1; /* read_from_exp(exp_); if(!candfs(nr, nc)) return false; */ ok = 1; return true;&#125; void dfs() &#123; bool cycle = false; _for(i, 0, R) _for(j, 0, c) &#123; bool ok = candfs(i, j); if(!ok) &#123; cycle = true; print_ans(); &#125; &#125; if(cycle) return;&#125; 4/ 表达式求解：读取表达式的值A7898787这样，从A+1开始，往后读取连续的值789878712345678910111213141516171819202122232425262728293031323334353637bool candfs(int r, int c) &#123; int&amp; val = value[r][c]; val = 0; int&amp; ok = vis[r][c]; .... .... // 代码同上 // read_from_exp(exp_): const char* exp_ = exp[r][c]; int sign = 1; _for(i, 0, strlen(exp_)) &#123; if(exp_[i] == '-') sign = -1; else if(exp_[i] == '+') sign = 1; else if(isdigit(exp_[i])) &#123; int elen, res; res = read(exp_+i, elen); val += res * sign; sign = 1; i += elen - 1; &#125; else if(isupper(exp_[i])) &#123; int elen; int row = exp_[i] - 'A'; int col = read(exp_+i+1, elen); if(!candfs(row, col)) return false; val += sign * value[row][col]; sign = 1; i += elen + 1 - 1; &#125; &#125;&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//// main.cpp// LA5154//// Created by zhangmin chen on 2019/4/18.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)const int maxr = 20 + 5;const int maxc = 10 + 5;int R, C;int vis[maxr][maxc], value[maxr][maxc];char exp[maxr][maxc][128];int read(const char* str, int&amp; len) &#123; // len = 0; int ans = 0, base = 1; while(str[len] &amp;&amp; isdigit(str[len])) &#123; // ans *= base; ans += str[len] - '0'; base *= 10; len++; &#125; return ans;&#125;int canDfs(int r, int c) &#123; // template of toposort() int&amp; ok = vis[r][c]; if(ok == -1) return false; else if(ok == 1) return true; ok = -1; // visit signed int&amp; val = value[r][c]; val = 0; const char* exp_ = exp[r][c]; int len = (int)strlen(exp_), sign = 1; for(int i = 0; i &lt; len; i++) &#123; if(exp_[i] == '-') sign = -1; else if(exp_[i] == '+') sign = 1; else if(isdigit(exp_[i])) &#123; // just digit, assign value int elen; int res = read(exp_+i, elen); val += res * sign; sign = 1; i += elen - 1; &#125; else if(isupper(exp_[i])) &#123; // A1+B2.... judge topo cycle? int elen; int row = exp_[i] - 'A'; int col = read(exp_+i+1, elen); if(!canDfs(row, col)) return false; val += sign * value[row][col]; sign = 1; i += elen - 1 + 1; // we add 'A', 'B', upper alpha &#125; &#125; // then is the true situation ok = 1; return true;&#125;void dfs() &#123; // memset(vis, 0, sizeof(vis)); bool cycle = false; for(int i = 0; i &lt; R; i++) for(int j = 0; j &lt; C; j++) &#123; bool ok = canDfs(i, j); if(!ok) &#123; cycle = true; printf(\"%c%d: %s\\n\", 'A'+i, j, exp[i][j]); &#125; &#125; if(cycle) return; // then we can explain the exp printf(\" \"); for(int i = 0; i &lt; C; i++) printf(\"%6d\", i); cout &lt;&lt; endl; for(int i = 0; i &lt; R; i++) &#123; printf(\"%c\", i+'A'); for(int j = 0; j &lt; C; j++) printf(\"%6d\", value[i][j]); cout &lt;&lt; endl; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(true) &#123; cin &gt;&gt; R &gt;&gt; C; if(R == 0 || C == 0) break; for(int i = 0; i &lt; R; i++) for(int j = 0; j &lt; C; j++) scanf(\"%s\", exp[i][j]); // then we run solve() dfs(); cout &lt;&lt; endl; &#125;&#125; 状态建图：内存池方法以骰子为例，程序结构如下： LA5210 1/ bfs：根据状态建图，类的属性以及成员函数分析如下因为要输出路径，所以需要保存prev信息骰子走在棋盘上，需要棋盘信息，和骰子的posture hash由棋盘位置+骰子posture共同决定hash值是用来判断这个状态是否vis过 bfs中， queue&lt; Statp &gt; que， 存储状态指针， 更方便判断是否存在最短路径set&lt; Statp &gt; vis, 用vis.count(nxt)， 判断下一步是否走过了？12345678910111213141516171819202122232425262728class Stat &#123;public: int r, c; // nr = r + dir[i], nc = c + dir[i] // 棋盘信息 int face, back, top, bottom, left, right; // 骰子自己的posture信息 Stat* prev; void Stat(int r_, int c_) : r(r_), c(c_) &#123;&#125; // 棋盘位置初始化 void init(int top, int face) &#123; this-&gt;top = top; this-&gt;face = face; // &#125; // 骰子posture初始化 int hash() const &#123; return 1000 * (r-1) + 100 * (c-1) + 10 * top + face; &#125; // 棋盘状态+骰子状态，确定状态hash // 用于set&lt;Statp, StatCmp&gt; vis, vis.count(nxt)判断下一步路径是否走过&#125;; 2/ bfs保存状态线程池，内存池技术保存指针，方便计算 12345678910111213141516171819202122232425typedef Stat* Statp;class Mempool &#123;public: vector&lt;Statp&gt; buf; void create() &#123; buf.push_back(new Stat()); return buf.back(); &#125; void fresh() &#123; _for(i, 0, buf.size()) delete buf[i]; buf.clear(); &#125;&#125;;Mempool pools;class StatCmp &#123;public: bool operator() (const Statp&amp; lhs, const Statp&amp; rhs) const &#123; return lhs-&gt;hash() &lt; rhs-&gt;hash(); &#125; &#125;; StatCmp用法：状态 = 棋盘位置 + 骰子posture是否访问过？我们用set &lt; Statp, StatCmp &gt; vis来存储 3/ bfs move信息，获取下一步的位置 12345678910111213141516171819202122bool Stat::canMove(int dir) &#123; int nr = r + dr[dir], nc = c + dc[dir]; if(nr &gt; R || nr &lt; 1 || nc &gt; C || nc &lt; 1) return false; int mv = grid[nr][nc]; return mv == right_pos;&#125;Statp Stat::move(int dir) &#123; Statp nxt = pools.create(); // init在棋盘上的位置 int nr = r + dr[dir], nc = c + dc[dir]; nxt-&gt;prev = this; nxt-&gt;r = nr; nxt-&gt;c = nc; // 骰子自身posture需要init if(dir == UP) nxt-&gt;init(face, bottom); // 模拟骰子翻滚的过程 return nxt;&#125; 4/ bfs主过程123456789101112131415161718192021222324Statp bfs(const Stat&amp; dest, Statp beg) &#123; queue&lt;Statp&gt; que; set&lt;Statp, StatCmp&gt; vis; que.push(beg); vis.insert(beg); while(!que.empty()) &#123; Statp cur = que.front(); que.pop(); if(cur-&gt;r == dest.r &amp;&amp; cur-&gt;c == dest.c) return cur; _for(i, 0, 4) &#123; if(cur-&gt;canMove(i)) &#123; Statp nxt = cur-&gt;move(i); if(vis.count(nxt)) continue; vis.insert(nxt); que.push(nxt); &#125; &#125; &#125; return null;&#125; 5/ 技巧：状态信息用Statp来表示queue&lt; Statp &gt; que, set&lt; Statp, StatCmp&gt; visclass Mempool { public: vector&lt; Statp &gt; buf; }; bfs无解的时候，可以很容易用if来判断 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226//// main.cpp// DiceyProblem//// Created by zhangmin chen on 2019/4/17.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)// dice[face][top] = left// check:// (1, 1) = null, (1, 2) = 3, (1, 3) = 5, (1, 4) = 2, (1, 5) = 4, (1, 6) = null// (2, 1) = 4, (2, 2) = null, (2, 3) = 1, (2, 4) = 6, (2, 5) = null, (2, 6) = 3// (3, 1) = 2, (3, 2) = 6, (3, 3) = null, (3, 4) = null, (3, 5) = 1, (3, 6) = 5// (4, 1) = 5, (4, 2) = 1, (4, 3) = null, (4, 4) = null, (4, 5) = 6, (4, 6) = 2// (5, 1) = 3, (5, 2) = null, (5, 3) = 6, (5, 4) = 1, (5, 5) = null, (5, 6) = 4// (6, 1) = null, (6, 2) = 4, (6, 3) = 2, (6, 4) = 5, (6, 5) = 3, (6, 6) = nullconst int maxn = 15;const int dice[6][6] = &#123; &#123;-1, 3, 5, 2, 4, -1&#125;, &#123;4, -1, 1, 6, -1, 3&#125;, &#123;2, 6, -1, -1, 1, 5&#125;, &#123;5, 1, -1, -1, 6, 2&#125;, &#123;3, -1, 6, 1, -1, 4&#125;, &#123;-1, 4, 2, 5, 3, -1&#125;&#125;;const int dr[4] = &#123;-1, 0, 1, 0&#125;;const int dc[4] = &#123;0, -1, 0, 1&#125;;// &#123;up, left, down, right&#125;const int UP = 0, LEFT = 1, DOWN = 2, RIGHT = 3;int R, C;int grid[maxn][maxn];class Stat &#123;public: int r, c; int face, back, top, bottom, left, right; Stat* prev; // why prev? did we need nxt? Stat() &#123; prev = NULL; &#125; Stat(int r, int c) : r(r), c(c) &#123;&#125; void init(int top, int face) &#123; this-&gt;top = top; this-&gt;face = face; back = 7 - face; bottom = 7 - top; left = dice[face - 1][top - 1]; right = 7 - left; &#125; bool canMove(int dir); Stat* move(int dir); // usage: if(canMove(i)) move(i) int hash() const &#123; return 1000 * (r-1) + 100 * (c-1) + 10 * top + face; &#125;&#125;;typedef Stat* Statp;class MemPool &#123;public: vector&lt;Statp&gt; buf; Statp create() &#123; // buf.push_back(new Stat()); return buf.back(); &#125; void fresh() &#123; for(int i = 0; i &lt; buf.size(); i++) delete buf[i]; buf.clear(); &#125;&#125;;struct StatCmp &#123; // bool operator() (const Statp&amp; lhs, const Statp&amp; rhs) const &#123; return lhs-&gt;hash() &lt; rhs-&gt;hash(); &#125;&#125;;MemPool pools;bool Stat::canMove(int dir) &#123; // int nr = r + dr[dir], nc = c + dc[dir]; if(nr &gt; R || nr &lt; 1 || nc &gt; C || nc &lt; 1) return false; int mv = grid[nr][nc]; if(mv == 0) return false; return mv == -1 || mv == top;&#125;Statp Stat::move(int dir) &#123; // // usage: // if(canMove(dir)) move(dir) Statp nxt = pools.create(); int nr = r + dr[dir], nc = c + dc[dir]; nxt-&gt;prev = this; nxt-&gt;r = nr; nxt-&gt;c = nc; if(dir == UP) nxt-&gt;init(face, bottom); if(dir == LEFT) nxt-&gt;init(right, face); if(dir == DOWN) nxt-&gt;init(back, top); if(dir == RIGHT) nxt-&gt;init(left, face); return nxt; &#125;Statp bfs(const Stat&amp; dest, Statp beg) &#123; // queue&lt;Statp&gt; que; set&lt;Statp, StatCmp&gt; vis; que.push(beg); vis.insert(beg); while(!que.empty()) &#123; Statp cur = que.front(); que.pop(); if(cur-&gt;r == dest.r &amp;&amp; cur-&gt;c == dest.c) return cur; for(int i = 0; i &lt; 4; i++) &#123; if(cur-&gt;canMove(i)) &#123; Statp nxt = cur-&gt;move(i); if(vis.count(nxt)) continue; vis.insert(nxt); que.push(nxt); &#125; &#125; &#125; return NULL;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string name; deque&lt;Statp&gt; res; while(cin &gt;&gt; name &amp;&amp; name != \"END\") &#123; memset(grid, 0, sizeof(grid)); cin &gt;&gt; R &gt;&gt; C; int tmpR, tmpC, tmpT, tmpF; cin &gt;&gt; tmpR &gt;&gt; tmpC &gt;&gt; tmpT &gt;&gt; tmpF; Stat st(tmpR, tmpC); st.prev = NULL; st.init(tmpT, tmpF); for(int i = 1; i &lt;= R; i++) for(int j = 1; j &lt;= C; j++) cin &gt;&gt; grid[i][j]; cout &lt;&lt; name &lt;&lt; endl; // finish init! then bfs() Statp ans = NULL; for(int i = 0; i &lt; 4; i++) &#123; if(st.canMove(i)) &#123; ans = bfs(st, st.move(i)); if(ans) break; &#125; &#125; if(ans) &#123; res.clear(); while(ans) &#123; res.push_front(ans); ans = ans-&gt;prev; &#125; for(int i = 0; i &lt; res.size(); i++) &#123; if(i) &#123; cout &lt;&lt; \",\"; if(i % 9 == 0) cout &lt;&lt; endl; &#125; if(i % 9 == 0) cout &lt;&lt; \" \"; cout &lt;&lt; \"(\" &lt;&lt; res[i]-&gt;r &lt;&lt; \",\" &lt;&lt; res[i]-&gt;c &lt;&lt; \")\"; &#125; cout &lt;&lt; endl; &#125; else cout &lt;&lt; \" No Solution Possible\" &lt;&lt; endl; pools.fresh(); &#125;&#125; 根据bfs和dfs序列重新建树Tree Reconstruction 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//// main.cpp// UVA10410//// Created by zhangmin chen on 2019/3/31.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)const int maxn = 1000 + 5;int pa[maxn];int n;vector&lt;int&gt; bseq, dseq[maxn];vector&lt;int&gt; G[maxn];int read() &#123; int x; scanf(\"%d\", &amp;x); return x;&#125;void init() &#123; bseq.clear(); for(int i = 0; i &lt; maxn; i++) dseq[i].clear(); for(int i = 0; i &lt; maxn; i++) G[i].clear(); memset(pa, 0, sizeof(pa));&#125;void dfs(int u, int&amp; bi) &#123; // find all sub_nodes // the we construct all sub-tree of node v // construct dseq[u] -&gt; desq[v] -&gt; dseq[vv] // i travel all sub node in dfs-seq //debug(dseq[u].size()); // bseq[bi] is a direct-child of node u // find v == bseq[bi] in dseq[u][] // construct child nodes of dseq[v] at the same time! _for(i, 0, (int)dseq[u].size()) &#123; int v = dseq[u][i]; if(bi &lt; n &amp;&amp; v == bseq[bi]) &#123; bi++; G[u].push_back(v); pa[v] = u; for(int j = i+1; j &lt; dseq[u].size() &amp;&amp; bi &lt; n; j++) &#123; int vv = dseq[u][j]; if(vv == bseq[bi]) break; // dseq[v+1] -&gt; vv, each node is sub-node of v // refresh dseq[v] dseq[v].push_back(vv); pa[vv] = v; &#125; &#125; &#125; while(bi &lt; n) dfs(pa[bseq[bi]], bi);&#125;int main() &#123; // freopen(\"input.txt\", \"r\", stdin); while(cin &gt;&gt; n &amp;&amp; n) &#123; // init(); for(int i = 0; i &lt; n; i++) bseq.push_back(read()); read(); for(int i = 1; i &lt; n; i++) dseq[bseq[0]].push_back(read()); // the we deal the problem int bi = 1; dfs(bseq[0], bi); for(int i = 1; i &lt;= n; i++) &#123; sort(G[i].begin(), G[i].end()); printf(\"%d:\", i); for(int k = 0; k &lt; G[i].size(); k++) &#123; printf(\" %d\", G[i][k]); &#125; printf(\"\\n\"); &#125; &#125;&#125; 链表模拟题环形链表处理模版LA5185 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192//// main.cpp// LA5185//// Created by zhangmin chen on 2019/3/30.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)const int CNT = 52;const int maxn = 7;int read() &#123; int x; scanf(\"%d\", &amp;x); return x;&#125;struct Pile &#123; deque&lt;int&gt; cards; Pile *left, *right; void init() &#123; cards.clear(); left = right = nullptr; &#125;&#125;;typedef Pile* Pilep;Pile piles[maxn+1], *nil;set&lt;string&gt; status;deque&lt;int&gt; hcards;void link(Pilep l, Pilep r) &#123; l-&gt;right = r; r-&gt;left = l;&#125;void start() &#123; // init hcards.clear(); status.clear(); for(int i = 0; i &lt;= maxn; i++) &#123; piles[i].init(); &#125;&#125;void deal(Pile&amp; p) &#123; int sz = (int)p.cards.size(); if(sz &lt; 3) return; if( (p.cards[0]+p.cards[1]+p.cards.back()) % 10 == 0 ) &#123; // hcards.push_back(p.cards[0]); hcards.push_back(p.cards[1]); hcards.push_back(p.cards.back()); p.cards.pop_front(); p.cards.pop_front(); p.cards.pop_back(); deal(p); return; &#125; if( (p.cards[0]+p.cards[sz-2]+p.cards[sz-1]) % 10 == 0 ) &#123; // hcards.push_back(p.cards[0]); hcards.push_back(p.cards[sz-2]); hcards.push_back(p.cards[sz-1]); p.cards.pop_front(); p.cards.pop_back(); p.cards.pop_back(); deal(p); return; &#125; if( (p.cards[sz-3]+p.cards[sz-2]+p.cards[sz-1]) % 10 == 0 ) &#123; hcards.push_back(p.cards[sz-3]); hcards.push_back(p.cards[sz-2]); hcards.push_back(p.cards[sz-1]); p.cards.pop_back(); p.cards.pop_back(); p.cards.pop_back(); deal(p); return; &#125;&#125;void encode(string&amp; ans) &#123; ans.clear(); Pilep first = nil-&gt;right; while(first != nil) &#123; for(int i = 0; i &lt; first-&gt;cards.size(); i++) ans += (char)first-&gt;cards[i]; ans += '|'; first = first-&gt;right; &#125; for(int i = 0; i &lt; hcards.size(); i++) ans += (char) hcards[i];&#125;void putCard() &#123; int cur = hcards.front(); hcards.pop_front(); Pilep first = nil-&gt;right; link(nil, first-&gt;right); link(nil-&gt;left, first); link(first, nil); first-&gt;cards.push_back(cur); deal(*first); if(first-&gt;cards.empty()) link(first-&gt;left, first-&gt;right);&#125;bool simulate(int times) &#123; if(nil-&gt;right == nil) &#123; cout &lt;&lt; \"Win : \" &lt;&lt; times &lt;&lt; endl; return false; &#125; if(hcards.empty()) &#123; cout &lt;&lt; \"Loss: \" &lt;&lt; times &lt;&lt; endl; return false; &#125; string st; encode(st); if(status.count(st)) &#123; // cout &lt;&lt; \"Draw: \" &lt;&lt; times &lt;&lt; endl; return false; &#125; else &#123; status.insert(st); &#125; putCard(); return true;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(true) &#123; // // start() start(); nil = &amp;(piles[0]); nil-&gt;init(); nil-&gt;right = &amp;(piles[1]); for(int i = 1; i &lt;= CNT; i++) &#123; int val = read(); if(val == 0) return 0; // get pile hcards.push_back(val); &#125; for(int i = 1; i &lt;= 7; i++) &#123; Pile&amp; p = piles[i]; p.init(); // get_link and get_data p.left = &amp;(piles[i-1]); if(i+1 &lt;= 7) p.right = &amp;(piles[i+1]); p.cards.push_back(hcards.front()); hcards.pop_front(); &#125; Pilep last = &amp;(piles[7]); link(last, nil); //debug(nil-&gt;right); // simulate() int t = 7; while(true) if(!simulate(t++)) break; &#125;&#125; 环形链表模拟：程序结构一般链表题的程序结构如下： 123456789101112131415161718192021222324252627282930class Pile &#123;public: stack&lt;Card&gt; cards; Pile *left, *right; void init() &#123; while(!cards.empty()) cards.pop(); left = right = nullptr; &#125;&#125;;typedef Pile* Pilep;void link(Pilep l, Pilep r) &#123; if(l) l-&gt;right = r; if(r) r-&gt;left = l;&#125;Pile piles[N + 1];Pilep nil;int main() &#123; _for(i, 1, N) &#123; Pile&amp; p = piles[i]; p.init(); p.left = &amp;(piles[i-1]); if(i+1 &lt; N) p.right = &amp;(piles[i+1]); &#125;&#125; 具体应用：UVA127 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158//// main.cpp// POJ1214//// Created by zhangmin chen on 2019/3/30.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)const int CNT = 52;struct Card &#123; // char suit, rank; Card(int s, int r) : suit(s), rank(r) &#123;&#125; bool operator == (const Card&amp; rhs) const &#123; return suit == rhs.suit || rank == rhs.rank; &#125;&#125;;struct Pile &#123; // Link-list stack&lt;Card&gt; cards; Pile *left, *right; void init() &#123; while(!cards.empty()) cards.pop(); left = right = nullptr; &#125;&#125;;typedef Pile* Pilep;void link(Pilep l, Pilep r) &#123; if(l) l-&gt;right = r; if(r) r-&gt;left = l;&#125;Pile piles[CNT+1];Pilep nil;// use Linklist to deal piles[CNT]Pilep getleft3(Pilep cur) &#123; for(int i = 0; i &lt; 3; i++) &#123; cur = cur-&gt;left; if(cur == nullptr) return nullptr; &#125; return cur;&#125;void solve() &#123; Pilep from, to, cur; while(true) &#123; from = to = nullptr; cur = nil-&gt;right; while(cur) &#123; // Pilep l3 = getleft3(cur); if(l3 != nullptr &amp;&amp; l3 != nil) &#123; // if(l3-&gt;cards.top() == cur-&gt;cards.top()) &#123; from = cur; to = l3; break; &#125; &#125; Pilep l1 = cur-&gt;left; if(l1 != nullptr &amp;&amp; l1 != nil) &#123; if(l1-&gt;cards.top() == cur-&gt;cards.top()) &#123; from = cur; to = l1; break; &#125; &#125; cur = cur-&gt;right; &#125; if(from == nullptr) break; to-&gt;cards.push(from-&gt;cards.top()); from-&gt;cards.pop(); if(from-&gt;cards.empty()) link(from-&gt;left, from-&gt;right); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string str; nil = &amp;(piles[0]); nil-&gt;init(); nil-&gt;right = &amp;(piles[1]); while(true) &#123; for(int i = 1; i &lt;= CNT; i++) &#123; // if(cin &gt;&gt; str &amp;&amp; str.size() == 2) &#123; // get str, and card Pile&amp; p = piles[i]; p.init(); p.left = &amp;(piles[i-1]); if(i+1 &lt;= CNT) p.right = &amp;(piles[i+1]); p.cards.push(Card(str[0], str[1])); &#125; else return 0; &#125; // get data // then we solve solve(); vector&lt;int&gt; ans; Pilep cur = nil-&gt;right; while(cur) &#123; ans.push_back((int)cur-&gt;cards.size()); cur = cur-&gt;right; &#125; printf(\"%d\", (int)ans.size()); printf(\" pile\"); if(ans.size() &gt; 1) printf(\"s\"); printf(\" remaining:\"); for(int i = 0; i &lt; ans.size(); i++) &#123; printf(\" %d\", ans[i]); &#125; printf(\"\\n\"); &#125;&#125; BFS常见模版题UVA1600 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//// main.cpp// LA3670//// Created by zhangmin chen on 2019/3/3.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define Set(x, v) memset(x, v, sizeof(x))#define REP(i, l, r) for(int i = (l); i &lt;= (r); i++)#define FOR(i, l, r) for(int i = (l); i &lt; (r); i++)using namespace std;const int maxn = 24;int read() &#123; int x; scanf(\"%d\", &amp;x); return x;&#125;bool inRange(int x, int l, int r) &#123; return l &gt; r ? inRange(x, r, l) : (l &lt;= x &amp;&amp; x &lt;= r);&#125;int grid[maxn][maxn];int dist[maxn][maxn][maxn];// dist(x, y, ob) = dist_pre + 1;// structint k, m, n;struct POS &#123; int x, y, ob; POS(int x, int y) : x(x), y(y) &#123;&#125;&#125;;bool operator== (const POS&amp; a, const POS&amp; b) &#123; return a.x == b.x &amp;&amp; a.y == b.y;&#125;const int dx[] = &#123;-1, 0, 1, 0&#125;;const int dy[] = &#123;0, -1, 0, 1&#125;;int bfs() &#123; // x: m y: n POS from(0, 0); POS to(m-1, n-1); from.ob = 0; Set(dist, -1); queue&lt;POS&gt; que; que.push(from); dist[from.x][from.y][from.ob] = 0; while(!que.empty()) &#123; POS&amp; f = que.front(); que.pop(); //debug(dist[f.x][f.y][f.ob]); if(f == to) return dist[f.x][f.y][f.ob]; int d = dist[f.x][f.y][f.ob]; for(int i = 0; i &lt; 4; i++) &#123; int nx = f.x + dx[i]; int ny = f.y + dy[i]; if(!inRange(nx, 0, m-1) || !inRange(ny, 0, n-1)) continue; if(grid[nx][ny] == 1 &amp;&amp; f.ob + 1 &gt; k) continue; int nob = (grid[nx][ny] == 1) ? f.ob + 1 : 0; // i made a bug here //debug(nob); //POS nxt(nx, ny); //nxt.ob = nob; if(dist[nx][ny][nob] == -1) &#123; dist[nx][ny][nob] = d+1; POS nxt(nx, ny); nxt.ob = nob; que.push(nxt); &#125; &#125; &#125; return -1;&#125;int main() &#123; // freopen(\"input.txt\", \"r\", stdin); int kase = read(); while(kase--) &#123; m = read(); n = read(); k = read(); // m lines, n cols for(int i = 0; i &lt; m; i++) for(int j = 0; j &lt; n; j++) grid[i][j] = read(); // then bfs() int ans = bfs(); printf(\"%d\\n\", ans); &#125;&#125; 欧拉路径和连通分量的综合应用LA4059 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//// main.cpp// LA4059//// Created by zhangmin chen on 2019/5/27.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;const int maxn = 1000 + 10;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)vector&lt;int&gt; G[maxn];int vis[maxn];int V, E, T;void init() &#123; _for(i, 0, maxn) G[i].clear(); Set(vis, 0);&#125;int dfs(int u) &#123; if(vis[u]) return 0; vis[u] = 1; int P = G[u].size() % 2; _for(i, 0, G[u].size()) &#123; int v = G[u][i]; P += dfs(v); &#125; return P;&#125;// cc:/* int main() _for(i, 0, N) if(vis[i] || G[i].empty()) continue; cc++; res += max(0, (dfs(i)-1) / 2) */int main() &#123; freopen(\"input.txt\", \"r\u0010\u0010\", stdin); //freopen(\"output.txt\", \"w\", stdout); for(int from, to, kase = 1; cin &gt;&gt; V &gt;&gt; E &gt;&gt; T &amp;&amp; V; kase++) &#123; init(); _for(i, 0, E) &#123; cin &gt;&gt; from &gt;&gt; to; G[from-1].push_back(to-1); G[to-1].push_back(from-1); &#125; int cc = 0, res = E; _for(i, 0, V) &#123; if(vis[i] || G[i].empty()) continue; cc++; res += max(0, (dfs(i) - 2) / 2); &#125; printf(\"Case %d: %d\\n\", kase, T*(res + max(0, cc-1))); &#125;&#125; 数据结构和算法的模版已经给出。接下来还有一些高级数据结构，以后再总结","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"数据结构优化","slug":"20190521","date":"2019-05-21T08:42:24.000Z","updated":"2019-05-24T07:57:56.940Z","comments":true,"path":"2019/05/21/20190521/","link":"","permalink":"https://www.fogsail.net/2019/05/21/20190521/","excerpt":"主要写一些算法竞赛中常用的模版和数据结构重点是图的DFS BFS和连通快计数 拓扑排序和欧拉回路算法 双向链表的模拟","text":"主要写一些算法竞赛中常用的模版和数据结构重点是图的DFS BFS和连通快计数 拓扑排序和欧拉回路算法 双向链表的模拟 Boxes in a Line 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151//// main.cpp// BoxesLine//// Created by zhangmin chen on 2019/4/18.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)const int maxn = 100000 + 5;class Node &#123;public: int data; Node *left, *right; Node() &#123; data = 0; left = right = NULL; &#125; bool operator== (const Node&amp; rhs) const &#123; return data == rhs.data; &#125;&#125;;typedef Node* Nodep;void link(Nodep l, Nodep r) &#123; l-&gt;right = r; r-&gt;left = l;&#125;Nodep nil;Node box[maxn];int N, M, OP;void init(int n) &#123; // box 0 is a nil nil = &amp;(box[0]); nil-&gt;right = &amp;(box[1]); nil-&gt;left = &amp;(box[n]); for(int i = 1; i &lt;= n; i++) &#123; // Node&amp; p = box[i]; p.data = i; p.left = &amp;(box[i-1]); p.right = &amp;(box[(i+1) % (n+1)]); &#125;&#125;int main() &#123; // freopen(\"input.txt\", \"r\", stdin); //freopen(\"output.txt\", \"w\", stdout); int kase = 0; while(scanf(\"%d%d\", &amp;N, &amp;M) == 2 &amp;&amp; N) &#123; // init(N); int x, y; int inv = 0; while(M--) &#123; scanf(\"%d\", &amp;OP); if(OP == 4) &#123; inv = 1 - inv; &#125; else &#123; if(inv &amp;&amp; OP != 3) OP = 3 - OP; if(OP == 1) &#123; // scanf(\"%d%d\", &amp;x, &amp;y); if(box[y].left-&gt;data == box[x].data) continue; link(box[x].left, box[x].right); link(box[y].left, &amp;box[x]); link(&amp;box[x], &amp;box[y]); &#125; else if(OP == 2) &#123; scanf(\"%d%d\", &amp;x, &amp;y); if(box[y].right-&gt;data == box[x].data) continue; link(box[x].left, box[x].right); link(&amp;box[x], box[y].right); link(&amp;box[y], &amp;box[x]); &#125; else if(OP == 3) &#123; scanf(\"%d%d\", &amp;x, &amp;y); if(box[y].right-&gt;data == box[x].data) &#123; // link(&amp;box[y], box[x].right); link(box[y].left, &amp;box[x]); link(&amp;box[x], &amp;box[y]); &#125; else if(box[x].right-&gt;data == box[y].data) &#123; // link(&amp;box[x], box[y].right); link(box[x].left, &amp;box[y]); link(&amp;box[y], &amp;box[x]); &#125; else &#123; // Nodep yl = box[y].left; Nodep yr = box[y].right; link(box[x].left, &amp;box[y]); link(&amp;box[y], box[x].right); link(yl, &amp;box[x]); link(&amp;box[x], yr); &#125; &#125; &#125; &#125; // finished! llong ans = 0; int cnt = 1; for(Nodep ptr = nil-&gt;right; ptr != nil; ptr = ptr-&gt;right, cnt++) &#123; if(cnt % 2 == 1) ans += ptr-&gt;data; &#125; if(inv &amp;&amp; N % 2 == 0) ans = (llong) (N)*(N+1) / 2 - ans; printf(\"Case %d: %lld\\n\", ++kase, ans); &#125;&#125; 树树的遍历：递归遍历，前序，中序转换Tree 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//// main.cpp// LA5266//// Created by zhangmin chen on 2019/3/3.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;sstream&gt;#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl;#define Set(x, v) memset(x, v, sizeof(x));using namespace std;const int maxn = 10000 + 10;const int maxv = 0x3f3f3f3f;struct Node &#123; Node* left; Node* right; int val; Node(int x) &#123; left = NULL; right = NULL; val = x; &#125;&#125;;typedef Node *nodep;int n;bool read(int* ans) &#123; string line; if(!getline(cin, line)) return false; stringstream ss(line); n = 0; int x; while(ss &gt;&gt; x) ans[n++] = x; return n &gt; 0;&#125;int inOrd[maxn], postOrd[maxn];void init() &#123; Set(inOrd, 0); Set(postOrd, 0);&#125;// inorder[l1...r1], left + root + right// postorder[l2...r2] left + right + rootnodep build(int l1, int r1, int l2, int r2) &#123; if(l1 &gt; r1) return 0; int val = postOrd[r2]; nodep root = new Node(val); int p = l1; for(; p &lt;= r1; p++) &#123; if(inOrd[p] == val) break; &#125; int cnt = p-l1; root-&gt;left = build(l1, p-1, l2, l2+cnt-1); root-&gt;right = build(p+1, r1, l2+cnt, r2-1); return root;&#125;int bestw, bestsum;void dfs(nodep u, int sum) &#123; sum += u-&gt;val; if(u-&gt;left == NULL &amp;&amp; u-&gt;right == NULL) &#123; if(sum &lt; bestsum || (sum == bestsum &amp;&amp; u-&gt;val &lt; bestw)) &#123; bestw = u-&gt;val; bestsum = sum; &#125; &#125; if(u-&gt;left != NULL) dfs(u-&gt;left, sum); if(u-&gt;right != NULL) dfs(u-&gt;right, sum);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (read(inOrd)) &#123; read(postOrd); // build: nodep tree = build(0, n-1, 0, n-1); bestsum = maxv; dfs(tree, 0); printf(\"%d\\n\", bestw); init(); &#125;&#125; 四分树根据树的信息进行递归输出 LA5206 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193//// main.cpp// LA5206-3//// Created by zhangmin chen on 2019/3/7.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)const int dx[] = &#123;0, 0, 1, 1&#125;;const int dy[] = &#123;0, 1, 0, 1&#125;;// nw, ne, sw, seconst int maxn = 64 + 10;typedef long long llong;typedef vector&lt;int&gt;::iterator VII;typedef map&lt;int, int&gt;::iterator MII;enum color&#123; White = 0, Black = 1, Gray = 2 &#125;;//char img[maxn][maxn];int grid[maxn][maxn];int N;struct POS &#123; int x, y; POS(int x, int y) : x(x), y(y) &#123;&#125;&#125;;/** draw tree **/vector&lt;int&gt; leafs;// locate blocks and drawvoid locate(int leaf, int&amp; len, POS&amp; pos) &#123; len = N; pos.x = 0; pos.y = 0; while(leaf) &#123; int dir = leaf % 5 - 1; len /= 2; //locate: pos.x += dx[dir]*len; pos.y += dy[dir]*len; leaf /= 5; &#125;&#125;void draw(vector&lt;int&gt;&amp; leafs) &#123; //Set(img, '.'); Set(grid, 0); for(int i = 0; i &lt; leafs.size(); i++) &#123; int cur = leafs[i]; int len; POS pos(0, 0); locate(cur, len, pos); _for(r, 0, len) _for(c, 0, len) grid[pos.x+r][pos.y+c] = 1; &#125;&#125;/** draw tree according to grid[][] **/struct Node &#123; int color; Node* cld[4]; Node() &#123; Set(cld, NULL); color = -1; &#125; void init() &#123; Set(cld, NULL); &#125;&#125;;typedef Node* Nodep;Nodep build(POS&amp; pos, int len) &#123; Nodep nd = new Node; int area = 0; _for(i, pos.x, pos.x+len) _for(j, pos.y, pos.y+len) area += grid[i][j]; if(area == 0) &#123; // nd-&gt;color = White; nd-&gt;init(); return nd; &#125; if(area == len*len) &#123; // nd-&gt;color = Black; nd-&gt;init(); return nd; &#125; nd-&gt;color = Gray; int len2 = len/2; _for(i, 0, 4) &#123; POS np(pos.x + dx[i]*len2, pos.y + dy[i]*len2); nd-&gt;cld[i] = build(np, len2); &#125; return nd;&#125;// tree = build()void cal(Nodep root, vector&lt;int&gt;&amp; path, vector&lt;int&gt;&amp; ans) &#123; if(root-&gt;color == White) return; if(root-&gt;color == Black) &#123; int base = 1, sum = 0; _for(i, 0, path.size()) &#123; sum += base * path[i]; base *= 5; &#125; ans.push_back(sum); return; &#125; _for(d, 0, 4) &#123; path.push_back(d+1); cal(root-&gt;cld[d], path, ans); path.pop_back(); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string line; for(int kase = 0; cin &gt;&gt; N &amp;&amp; N; kase++) &#123; // leafs.clear(); if(kase) printf(\"\\n\"); bool isGrid = N &gt; 0; N = abs(N); if(isGrid) &#123; // cin &gt;&gt; line _for(i, 0, N) &#123; cin &gt;&gt; line; _for(j, 0, N) grid[i][j] = line[j] - '0'; &#125; &#125; else &#123; // cin &gt;&gt; leaf int val; while(cin &gt;&gt; val &amp;&amp; val != -1) leafs.push_back(val); draw(leafs); // finished &#125; printf(\"Image %d\", kase+1); if(isGrid) &#123; // build grid[][] tree POS st(0, 0); Nodep tree = build(st, N); vector&lt;int&gt; path, ans; cal(tree, path, ans); sort(ans.begin(), ans.end()); _for(i, 0, ans.size()) &#123; if(i % 12) printf(\" \"); else printf(\"\\n\"); printf(\"%d\", ans[i]); &#125; printf(\"\\n\"); printf(\"Total number of black nodes = %d\\n\", (int)ans.size()); &#125; else &#123; // printf(\"\\n\"); _for(i, 0, N) &#123; _for(j, 0, N) printf(\"%c\", grid[i][j] ? '*' : '.'); printf(\"\\n\"); &#125; &#125; &#125;&#125; 图bfs与dfs这类问题的分析方法是dr[] = {-1, 0, 1, 0}dc[] = {0, -1, 0, 1} Ancient Messages 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221//// main.cpp// AncientMessage//// Created by zhangmin chen on 2019/4/19.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)const int maxh = 200 + 5;const int maxw = 50 * 4 + 5;int H, W;// H += 2, W = W * 4 + 2;char h2b[256][5];int data[maxh][maxw], ccid[maxh][maxw];char origin[maxh][maxw];void init() &#123; strcpy(h2b['0'], \"0000\"); strcpy(h2b['1'], \"0001\"); strcpy(h2b['2'], \"0010\"); strcpy(h2b['3'], \"0011\"); strcpy(h2b['4'], \"0100\"); strcpy(h2b['5'], \"0101\"); strcpy(h2b['6'], \"0110\"); strcpy(h2b['7'], \"0111\"); strcpy(h2b['8'], \"1000\"); strcpy(h2b['9'], \"1001\"); strcpy(h2b['a'], \"1010\"); strcpy(h2b['b'], \"1011\"); strcpy(h2b['c'], \"1100\"); strcpy(h2b['d'], \"1101\"); strcpy(h2b['e'], \"1110\"); strcpy(h2b['f'], \"1111\");&#125;void readData(const char h2b[][5], int maxr, int maxc) &#123; // for i = 0 to row // char ch = origin[row][col] memset(data, 0, sizeof(data)); //memset(origin, 0, sizeof(origin)); memset(ccid, 0, sizeof(ccid)); for(int r = 0; r &lt; maxr; r++) for(int c = 0; c &lt; maxc; c++) &#123; char ch = origin[r][c]; //debug(ch); // get h2b[ch][i]-'0' for(int i = 0; i &lt; 4; i++) &#123; // data restore value data[1..H][1..W] data[r+1][c * 4 + i + 1] = h2b[ch][i] - '0'; //debug(h2b[ch][i] - '0'); &#125; &#125; H += 2; W = W * 4 + 2; // Now data row [0, H) // col [0, W) &#125;const char* code = \"WAKJSD\";// count connected components// 1 is the background ccid// Message ccid start from [2...)// main: cnt = 0 dfs(++cnt);// ccid = 0, means have not visited!const int dr[] = &#123;-1, 0, 1, 0&#125;;const int dc[] = &#123;0, -1, 0, 1&#125;;bool valid(int r, int c) &#123; if(r &gt;= 0 &amp;&amp; r &lt; H &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; W) return true; else return false;&#125;void dfs(int r, int c, int cnt) &#123; ccid[r][c] = cnt; for(int i = 0; i &lt; 4; i++) &#123; int nr = r + dr[i]; int nc = c + dc[i]; if(valid(nr, nc) &amp;&amp; ccid[nr][nc] == 0 &amp;&amp; data[nr][nc] == data[r][c]) dfs(nr, nc, cnt); &#125;&#125;// then solve()// cnt = 0 -&gt; if ccid == 0 dfs(++cnt)// we solve black position, which is msg// we can't get the specified words directely, but we have ccid// regard ccid as words identityvector&lt;int&gt; msg;int msgID() &#123; int cnt = 0; for(int i = 0; i &lt; H; i++) for(int j = 0; j &lt; W; j++) &#123; if(ccid[i][j] != 0) continue; dfs(i, j, ++cnt); if(data[i][j] == 1) msg.push_back(cnt); &#125; return cnt;&#125;// for i = msg to msg.size()// msg[i] is the id of words, words[ccid[r][c]] point to the specified words// recogonize(msg[i])vector&lt;set&lt;int&gt; &gt; words;// if it is a msg position, then cntHole()void cntHole(int r, int c) &#123; for(int i = 0; i &lt; 4; i++) &#123; int nr = r + dr[i]; int nc = c + dc[i]; if(valid(nr, nc) &amp;&amp; data[nr][nc] == 0 &amp;&amp; ccid[nr][nc] != 1) &#123; // words[ccid[r][c]].insert(ccid[nr][nc]); &#125; &#125;&#125;void decode() &#123; int cnt = msgID(); //debug(cnt); words.clear(); words.resize(cnt+1); for(int i = 0; i &lt; H; i++) for(int j = 0; j &lt; W; j++) &#123; if(data[i][j] == 1) cntHole(i, j); &#125;&#125;char recognize(int id) &#123; int cnt = (int)words[id].size(); return code[cnt];&#125;// usage: for i = 0 to msg.size// int curid = msg[i]// recognize(curid)void fresh() &#123; msg.clear(); words.clear(); memset(origin, 0, sizeof(origin));&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); int kase = 0; while(scanf(\"%d%d\", &amp;H, &amp;W) &amp;&amp; H) &#123; for(int i = 0; i &lt; H; i++) scanf(\"%s\", origin[i]); readData(h2b, H, W); // then we finished init(); /* for(int i = 0; i &lt; H; i++) &#123; for(int j = 0; j &lt; W; j++) cout &lt;&lt; data[i][j]; cout &lt;&lt; endl; &#125; */ // try to solve() decode(); vector&lt;char&gt; ans; for(int i = 0; i &lt; msg.size(); i++) &#123; int curid = msg[i]; ans.push_back(recognize(curid)); //debug(ans.size()); &#125; sort(ans.begin(), ans.end()); printf(\"Case %d: \", ++kase); // print out Message for(int i = 0; i &lt; ans.size(); i++) printf(\"%c\", ans[i]); puts(\"\"); fresh(); ans.clear(); &#125; &#125; 复杂bfsHDU2771 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175//// main.cpp// HDU2771//// Created by zhangmin chen on 2019/3/4.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define Set(x, v) memset(x, v, sizeof(x))#define REP(i, l, r) for(int i = (l); i &lt;= (r); i++)#define FOR(i, l, r) for(int i = (l); i &lt; (r); i++)using namespace std;const int maxw = 1000 + 1;const int maxn = 50 + 10;const int dx[] = &#123;1, -1, 0, 0, 0, 0&#125;;const int dy[] = &#123;0, 0, 1, -1, 0, 0&#125;;const int dz[] = &#123;0, 0, 0, 0, 1, -1&#125;;int read() &#123; int x; scanf(\"%d\", &amp;x); return x;&#125;// get sculptureint x0[maxn], y0[maxn], z0[maxn], x1[maxn], y1[maxn], z1[maxn];int xs[maxn*2], ys[maxn*2], zs[maxn*2];int nx, ny, nz;// nx++, ny++, nz++int color[maxn*2][maxn*2][maxn*2];// discretize:// x[0] is the smallest, x[1] is the largest// x_from = getID(x, nx, x[0]) x_to = getID(x, nx, x[1])// vol: (xs[i+1]-xs[i]) * (ys[i+1]-ys[i]) * (zs[i+1]-zs[i])void discretize(int* x, int&amp; n) &#123; sort(x, x+n); n = unique(x, x+n) - x;&#125;int getID(int* x, int n, int v) &#123; return lower_bound(x, x+n, v) - x;&#125;void init() &#123; xs[0] = ys[0] = zs[0] = 0; xs[1] = ys[1] = zs[1] = maxw; nx = ny = nz = 2;&#125;struct POS &#123; int x, y, z; POS(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) &#123;&#125; bool inRange() const &#123; return x &gt;= 0 &amp;&amp; x &lt; nx-1 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; ny-1 &amp;&amp; z &gt;= 0 &amp;&amp; z &lt; nz-1; &#125; POS neighbor(int dir) &#123; return POS(x+dx[dir], y+dy[dir], z+dz[dir]); &#125; // POS np = pos.neighbor(), if(!np.inRange()) continue bool solid() const &#123; return color[x][y][z] == 1; &#125; void setVis() &#123; color[x][y][z] = 2; &#125; bool isVisted() const &#123; return color[x][y][z] == 2; &#125; // if (!np.isVisited()) que.push(np) int volume() const &#123; return (xs[x+1]-xs[x]) * (ys[y+1]-ys[y]) * (zs[z+1]-zs[z]); &#125; int area(int dir) const &#123; if(dx[dir] != 0) return (ys[y+1] - ys[y]) * (zs[z+1] - zs[z]); else if(dy[dir] != 0) return (xs[x+1] - xs[x]) * (zs[z+1] - zs[z]); return (xs[x+1] - xs[x]) * (ys[y+1] - ys[y]); &#125;&#125;;void bfs(int&amp; vm, int&amp; cm) &#123; vm = cm = 0; POS start; queue&lt;POS&gt; que; start.setVis(); que.push(start); while(!que.empty()) &#123; POS fr = que.front(); que.pop(); vm += fr.volume(); for(int i = 0; i &lt; 6; i++) &#123; POS np = fr.neighbor(i); if(!np.inRange()) continue; if(np.solid()) cm += np.area(i); else if(!np.isVisted()) &#123; np.setVis(); que.push(np); &#125; &#125; &#125; //debug(maxw*maxw*maxw); //debug(vm); vm = maxw * maxw * maxw - vm;&#125;int m;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; kase = read(); while(kase--) &#123; init(); m = read(); for(int i = 0; i &lt; m; i++) &#123; scanf(\"%d%d%d%d%d%d\", &amp;x0[i], &amp;y0[i], &amp;z0[i], &amp;x1[i], &amp;y1[i], &amp;z1[i]); // I made a bug here //debug(x0[i]); debug(y0[i]); debug(z0[i]); x1[i] += x0[i]; y1[i] += y0[i]; z1[i] += z0[i]; xs[nx++] = x0[i]; xs[nx++] = x1[i]; ys[ny++] = y0[i]; ys[ny++] = y1[i]; zs[nz++] = z0[i]; zs[nz++] = z1[i]; &#125; discretize(xs, nx); discretize(ys, ny); discretize(zs, nz); //debug(nx), debug(ny), debug(nz); // build sculpture\" Set(color, 0); for(int i = 0; i &lt; m; i++) &#123; int xbeg = getID(xs, nx, x0[i]), xend = getID(xs, nx, x1[i]); //debug(xbeg), debug(xend); int ybeg = getID(ys, ny, y0[i]), yend = getID(ys, ny, y1[i]); int zbeg = getID(zs, nz, z0[i]), zend = getID(zs, nz, z1[i]); FOR(px, xbeg, xend) FOR(py, ybeg, yend) FOR(pz, zbeg, zend) color[px][py][pz] = 1; &#125; // bfs(): int cm, vm; bfs(vm, cm); printf(\"%d %d\\n\", cm, vm); &#125;&#125; Topo排序topo排序的核心：必须是有向无环图1、通过bool dfs(int u)判断是否存在环2、判断是否可以进行toposort: bool toposort() 模版： 12345678910111213141516171819202122init();bool dfs(int u) &#123; vis[u] = -1; _for(v, 0, n) &#123; if(G[u][v]) &#123; if(vis[v] &lt; 0) return false; else if(!vis[v] &amp;&amp; !dfs(v)) return false; &#125; &#125; vis[u] = 1; topo.push_back(u); return true;&#125;bool toposort() &#123; _for(u, 0, n) &#123; if(!vis[u]) if(!dfs[u]) return false; &#125; reverse(topo.begin(), topo.end()); return true;&#125; UVA10305 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//// main.cpp// UVA10305//// Created by zhangmin chen on 2019/5/21.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 1000;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;int G[maxn][maxn], n, m;int vis[maxn];vector&lt;int&gt; topo;void init() &#123; Set(G, 0); Set(vis, 0); topo.clear();&#125;bool dfs(int u) &#123; vis[u] = -1; _for(v, 0, n) &#123; if (G[u][v]) &#123; if(vis[v] &lt; 0) return false; // circle else if(!vis[v]) dfs(v); &#125; &#125; vis[u] = 1; topo.push_back(u); return true;&#125;bool toposort() &#123; _for(u, 0, n) &#123; if(!vis[u]) if(!dfs(u)) return false; &#125; reverse(topo.begin(), topo.end()); return true;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n) &#123; // init(); _for(i, 0, m) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; u--; v--; G[u][v] = 1; &#125; if(toposort()) &#123; // _for(i, 0, n-1) printf(\"%d \", topo[i]+1); printf(\"%d\\n\", topo[n-1]+1); &#125; else printf(\"No\\n\"); &#125;&#125; 欧拉回路问题分析： HDU1116dfs判断连通 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//// main.cpp// HDU1116//// Created by zhangmin chen on 2019/5/22.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 100;const int maxl = 2000 + 10;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;int kase, G[maxn][maxn], vis[maxn];int ideg[maxn], odeg[maxn];int m, u, v;const int N = 26;void init() &#123; Set(G, 0); Set(vis, 1); Set(ideg, 0); Set(odeg, 0);&#125;void dfs(int u) &#123; vis[u] = 1; _for(i, 0, N) &#123; if(G[u][i] &amp;&amp; !vis[i]) dfs(i); &#125;&#125;// find which node has been visitedint main() &#123; freopen(\"input.txt\", \"r\", stdin); char str[maxl]; cin &gt;&gt; kase; while(kase--) &#123; init(); cin &gt;&gt; m; _for(i, 0, m) &#123; scanf(\"%s\", str); int u = str[0] - 'a'; int v = str[strlen(str) - 1] - 'a'; G[u][v] = 1; vis[u] = vis[v] = 0; ideg[v]++; odeg[u]++; &#125; bool exist = 0; int root = 0, fromN = 0, toN = 0, odd = 0; _for(i, 0, N) &#123; if(ideg[i] == odeg[i]) continue; else if(ideg[i] == odeg[i] + 1) toN++; else if(odeg[i] == ideg[i] + 1) &#123; fromN++; root = i; &#125; else odd++; &#125; if(odd &gt; 0) &#123; printf(\"The door cannot be opened.\\n\"); continue; &#125; if( (fromN == 1 &amp;&amp; toN == 1) || (fromN == 0 &amp;&amp; toN == 0) ) exist = 1; else exist = 0; dfs(root); _for(i, 0, N) if(!vis[i]) exist = 0; if(exist) printf(\"Ordering is possible.\\n\"); else printf(\"The door cannot be opened.\\n\"); &#125;&#125; 欧拉回路：使用并查集求连通分量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//// main.cpp// HDU1116-2//// Created by zhangmin chen on 2019/5/22.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 256;const int maxl = 2000 + 10;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;int deg[maxn], vis[maxn];int pa[maxn];int m, u, v;void init() &#123; Set(deg, 0); Set(vis, 0); Set(pa, 0);&#125;void init_pa() &#123; _rep(u, 'a', 'z') pa[u] = u;&#125;int findset(int u) &#123; return pa[u] != u ? pa[u] = findset(pa[u]) : u; &#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; cin &gt;&gt; kase; while(kase--) &#123; init(); init_pa(); scanf(\"%d\", &amp;m); int cc = 26; char word[maxl]; scanf(\"%d\", &amp;m); _for(i, 0, m) &#123; scanf(\"%s\", word); char u = word[0], v = word[strlen(word) - 1]; deg[u]++; deg[v]--; vis[u] = vis[v] = 1; int s1 = findset(u), s2 = findset(v); if(s1 != s2) &#123; pa[s1] = s2; cc--; &#125; &#125; vector&lt;int&gt; pNode; _rep(ch, 'a', 'z') &#123; if(!vis[ch]) cc--; else if(deg[ch] != 0) pNode.push_back(deg[ch]); &#125; bool exist = false; if(cc == 1 &amp;&amp; ( (pNode.empty()) || (pNode.size() == 2 &amp;&amp; (pNode[0] == 1 || pNode[0] == -1)) ) ) exist = true; if(exist) printf(\"Ordering is possible.\\n\"); else printf(\"The door cannot be opened.\\n\"); &#125;&#125; 数据结构综合应用有向环：图形粘合问题LA6393 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//// main.cpp// LA6393//// Created by zhangmin chen on 2019/5/23.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 52 + 5;const int maxl = 10;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;int G[maxn][maxn], vis[maxn];void init() &#123; Set(G, 0); Set(vis, 0);&#125;int ID(char a, char b) &#123; return (a - 'A') * 2 + (b == '+' ? 0 : 1);&#125;void connect(char a1, char a2, char b1, char b2) &#123; if(a1 == '0' || b1 == '0') return; int u = ID(a1, a2), v = ID(b1, b2) ^ 1; G[u][v] = 1;&#125;bool dfs(int u) &#123; vis[u] = -1; _for(v, 0, maxn) &#123; if(G[u][v]) &#123; if(vis[v] &lt; 0) return false; else if(!vis[v] &amp;&amp; !dfs(v)) return false; &#125; &#125; vis[u] = 1; return true;&#125;bool toposort() &#123; _for(u, 0, maxn) &#123; if(!vis[u]) if(!dfs(u)) return false; &#125; return true;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int n; while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; init(); while(n--) &#123; char cube[maxl]; scanf(\"%s\", cube); _for(i, 0, 4) _for(j, 0, 4) &#123; if(i != j) connect(cube[i * 2], cube[i * 2 + 1], cube[j * 2], cube[j * 2 + 1]); &#125; &#125; // we get data // then find cycle by topo sort if(!toposort()) cout &lt;&lt; \"unbounded\" &lt;&lt; endl; else cout &lt;&lt; \"bounded\" &lt;&lt; endl; &#125;&#125; 双向bfs求最短路和边相关最值HDU3760 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152//// main.cpp// HDU3760//// Created by zhangmin chen on 2019/5/23.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 100000 + 10;const int inf = 1000000000;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;class Edge &#123;public: int from, to, w; Edge(int f = 0, int t = 0, int w_ = 0) : from(f), to(t), w(w_) &#123;&#125;&#125;;vector&lt;int&gt; G[maxn];int vis[maxn], d[maxn];vector&lt;Edge&gt; edges;int n;void clearVis() &#123; Set(vis, 0);&#125;void init() &#123; _for(i, 0, maxn) G[i].clear(); clearVis(); edges.clear(); Set(d, 0);&#125;void addEdge(int from, int to, int w) &#123; edges.push_back((Edge)&#123;from, to, w&#125;); G[from].push_back((int)edges.size() - 1);&#125;void revbfs() &#123; d[n-1] = 0; vis[n-1] = true; queue&lt;int&gt; que; que.push(n-1); while(!que.empty()) &#123; int u = que.front(); que.pop(); _for(i, 0, G[u].size()) &#123; Edge&amp; e = edges[G[u][i]]; if(!vis[e.to]) &#123; vis[e.to] = true; d[e.to] = d[u] + 1; que.push(e.to); &#125; &#125; &#125;&#125;void bfs() &#123; clearVis(); vector&lt;int&gt; ans; ans.clear(); vis[0] = true; vector&lt;int&gt; nodes; nodes.push_back(0); _for(level, 0, d[0]) &#123; int minColor = inf; _for(i, 0, nodes.size()) &#123; int u = nodes[i]; _for(v, 0, G[u].size()) &#123; Edge&amp; e = edges[G[u][v]]; if(d[u] == d[e.to] + 1) minColor = min(minColor, e.w); &#125; &#125; ans.push_back(minColor); vector&lt;int&gt; nodes2; _for(i, 0, nodes.size()) &#123; int u = nodes[i]; _for(v, 0, G[u].size()) &#123; Edge&amp; e = edges[G[u][v]]; if(!vis[e.to] &amp;&amp; d[u] == d[e.to] + 1 &amp;&amp; minColor == e.w) &#123; vis[e.to] = true; nodes2.push_back(e.to); &#125; &#125; &#125; nodes = nodes2; &#125; printf(\"%d\\n\", (int)ans.size()); printf(\"%d\", ans[0]); _for(i, 1, ans.size()) printf(\" %d\", ans[i]); printf(\"\\n\");&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while(kase--) &#123; int from, to, w, m; init(); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; scanf(\"%d%d%d\", &amp;from, &amp;to, &amp;w); addEdge(from-1, to-1, w); addEdge(to-1, from-1, w); &#125; //get all graph data revbfs(); bfs(); &#125;&#125; Linux系统软件包的依赖关系UVA506 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149//// main.cpp// UVA506//// Created by zhangmin chen on 2019/5/24.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 10000 + 10;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;vector&lt;int&gt; depends[maxn];vector&lt;int&gt; pa[maxn];int status[maxn];int cnt = 0;map&lt;string, int&gt; str2id;string id2str[maxn];vector&lt;int&gt; installed;int ID(const string&amp; item) &#123; if(!str2id.count(item)) &#123; // id2str[++cnt] = item; str2id[item] = cnt; &#125; return str2id[item];&#125;void init() &#123; Set(status, 0); cnt = 0;&#125;void list() &#123; _for(i, 0, installed.size()) &#123; int u = installed[i]; cout &lt;&lt; \" \" &lt;&lt; id2str[u] &lt;&lt; endl; &#125;&#125;void install(int id, bool explicity) &#123; // if(!status[id]) &#123; // install id _for(i, 0, depends[id].size()) &#123; int u = depends[id][i]; install(u, false); &#125; // dependencity has already been installed cout &lt;&lt; \" Installing \" &lt;&lt; id2str[id] &lt;&lt; endl; status[id] = explicity ? 1 : 2; installed.push_back(id); &#125;&#125;bool needed(int id) &#123; // _for(i, 0, pa[id].size()) &#123; int u = pa[id][i]; if(status[u]) return true; &#125; return false;&#125;void rmv(int id, bool explicity) &#123; // if( (explicity || status[id] == 2) &amp;&amp; !needed(id) ) &#123; status[id] = 0; installed.erase(find(installed.begin(), installed.end(), id)); cout &lt;&lt; \" Removing \" &lt;&lt; id2str[id] &lt;&lt; endl; _for(i, 0, depends[id].size()) &#123; int u = depends[id][i]; rmv(u, false); &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); init(); string line, cmd; while (getline(cin, line)) &#123; cout &lt;&lt; line &lt;&lt; endl; stringstream ss(line); ss &gt;&gt; cmd; if(cmd[0] == 'E') break; if(cmd[0] == 'L') list(); else &#123; // string item1, item2; ss &gt;&gt; item1; int id1 = ID(item1); if(cmd[0] == 'D') &#123; while (ss &gt;&gt; item2) &#123; int id2 = ID(item2); depends[id1].push_back(id2); pa[id2].push_back(id1); &#125; &#125; else if(cmd[0] == 'I') &#123; // if(status[id1]) cout &lt;&lt; \" \" &lt;&lt; item1 &lt;&lt; \" is already installed.\" &lt;&lt; endl; else install(id1, true); &#125; else &#123; if(!status[id1]) cout &lt;&lt; \" \" &lt;&lt; item1 &lt;&lt; \" is not installed.\" &lt;&lt; endl; else if(needed(id1)) cout &lt;&lt; \" \" &lt;&lt; item1 &lt;&lt; \" is still needed.\" &lt;&lt; endl; else rmv(id1, true); &#125; &#125; &#125;&#125; DFS与几何：游戏战场穿越HDU3767 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//// main.cpp// HDU3767//// Created by zhangmin chen on 2019/5/24.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int maxn = 1000 + 10;const double width = 1000.0;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;class Circle &#123;public: double x, y, r; Circle(double x_ = 0.0, double y_ = 0.0, double r_ = 0.0) : x(x_), y(y_), r(r_) &#123;&#125;&#125;;Circle circles[maxn];bool vis[maxn];void init() &#123; Set(vis, 0);&#125;bool intersect(int id1, int id2) &#123; double dist = sqrt( (circles[id1].x - circles[id2].x) * (circles[id1].x - circles[id2].x) + (circles[id1].y - circles[id2].y) * (circles[id1].y - circles[id2].y) ); return dist &lt; (circles[id1].r + circles[id2].r);&#125;int n;double l, r;void border(int u) &#123; if(circles[u].x - circles[u].r &lt; 0) &#123; double dist = sqrt( (circles[u].r * circles[u].r) - (circles[u].x * circles[u].x) ); l = min(l, circles[u].y - dist); &#125; if(circles[u].x + circles[u].r &gt; width) &#123; double dist = sqrt( (circles[u].r * circles[u].r) - (width - circles[u].x) * (width - circles[u].x) ); r = min(r, circles[u].y - dist); &#125;&#125;bool dfs(int u) &#123; // if(vis[u]) return false; vis[u] = true; if(circles[u].y - circles[u].r &lt; 0) return true; _for(i, 0, n) &#123; if(i == u) continue; if(intersect(u, i) &amp;&amp; dfs(i)) return true; &#125; border(u); return false;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(scanf(\"%d\", &amp;n) == 1) &#123; init(); bool ok = true; l = r = width; _for(i, 0, n) &#123; scanf(\"%lf%lf%lf\", &amp;circles[i].x, &amp;circles[i].y, &amp;circles[i].r); &#125; _for(i, 0, n) &#123; if(circles[i].y + circles[i].r &gt;= width &amp;&amp; dfs(i)) &#123; ok = false; break; &#125; &#125; if(ok) printf(\"0.00 %.2lf %.2lf %.2lf\\n\", l, width, r); else printf(\"IMPOSSIBLE\\n\"); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"高效算法设计(一)","slug":"20190519","date":"2019-05-19T00:15:13.000Z","updated":"2019-08-05T11:07:05.021Z","comments":true,"path":"2019/05/19/20190519/","link":"","permalink":"https://www.fogsail.net/2019/05/19/20190519/","excerpt":"这里主要实现了一些和算法有关的问题先介绍一下最基本的算法分析模版然后图解一些思维的技巧 分治算法，快速排序MergeSort","text":"这里主要实现了一些和算法有关的问题先介绍一下最基本的算法分析模版然后图解一些思维的技巧 分治算法，快速排序MergeSort 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//// main.cpp// mergeSort//// Created by zhangmin chen on 2019/5/3.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;const int maxn = 100000000;int A[maxn];int T[maxn];int n;int cnt = 0;void init() &#123; // static int cnt = 0; cnt = 0; memset(A, 0, sizeof(A)); memset(T, 0, sizeof(T));&#125;void mergeSort(int* A, int x, int y, int* T) &#123; if(y - x &gt; 1) &#123; int mid = x + (y-x) / 2; int p = x, q = mid; int i = x; mergeSort(A, x, mid, T); mergeSort(A, mid, y, T); while(p &lt; mid || q &lt; y) &#123; if( (q &gt;= y) || (p &lt; mid &amp;&amp; A[p] &lt;= A[q]) ) T[i++] = A[p++]; else &#123; T[i++] = A[q++]; cnt += mid-p; &#125; &#125; for(int i = x; i &lt; y; i++) A[i] = T[i]; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); // static int n; // init(); cin &gt;&gt; n; init(); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; A[i]; &#125; // mergeSort mergeSort(A, 0, n, T); for(int i = 0; i &lt; n; i++) cout &lt;&lt; A[i] &lt;&lt; \" \"; cout &lt;&lt; endl; cout &lt;&lt; \"cnt: \" &lt;&lt; cnt &lt;&lt; endl;&#125; QuickSort 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//// main.cpp// quicksort//// Created by zhangmin chen on 2019/5/3.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;const int maxn = 1000000;int n;int A[maxn];void init() &#123; memset(A, 0, sizeof(A));&#125;void quicksort(int* A, int lo, int hi) &#123; if(lo &gt; hi) return; int pivot = A[lo]; int i = lo, j = hi; while(i != j) &#123; while(A[j] &gt;= pivot &amp;&amp; i &lt; j) j--; while(A[i] &lt;= pivot &amp;&amp; i &lt; j) i++; if(i &lt; j) swap(A[i], A[j]); &#125; A[lo] = A[i]; A[i] = pivot; quicksort(A, lo, i-1); quicksort(A, i+1, hi);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n; init(); for(int i = 0; i &lt; n; i++) cin &gt;&gt; A[i]; quicksort(A, 0, n-1); for(int i = 0; i &lt; n; i++) cout &lt;&lt; A[i] &lt;&lt; \" \"; cout &lt;&lt; endl;&#125; 反转子序列：类快排思想UVA120 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//// main.cpp// UVA120//// Created by zhangmin chen on 2019/5/19.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int inf = 0x3f3f3f3f;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;const int maxn = 100;int A[maxn];int n;void init() &#123; Set(A, 0);&#125;void flip(int p) &#123; for(int i = 0; i &lt; p-i; i++) &#123; swap(A[i], A[p-i]); &#125; printf(\"%d \", n-p);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string line; while (getline(cin, line)) &#123; init(); stringstream ss(line); n = 0; while(ss &gt;&gt; A[n]) n++; _for(i, 0, n) printf(\"%d \", A[i]); printf(\"\\n\"); for(int i = n-1; i &gt; 0; i--) &#123; // i is the position of top // [begin, end) max element long ith = max_element(A, A+i+1) - A; if((int)ith == i) continue; if(ith &gt; 0) flip((int)ith); flip(i); &#125; printf(\"0\\n\"); &#125;&#125; 贪心算法：若干区间选出n个点UVA11134 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//// main.cpp// UVA11134//// Created by zhangmin chen on 2019/5/19.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int inf = 0x3f3f3f3f;const int maxn = 5000 + 5;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;bool inRange(int lo, int hi, int x) &#123; if(lo &gt; hi) return inRange(hi, lo, x); return lo &lt;= x &amp;&amp; x &lt;= hi;&#125;int xl[maxn], xr[maxn], yl[maxn], yr[maxn];int x[maxn], y[maxn];void init() &#123; Set(xl, 0); Set(xr, 0); Set(yl, 0); Set(yr, 0); Set(x, 0); Set(y, 0);&#125;bool solve(int* l, int* r, int* res, int n) &#123; fill(res, res+n, -1); _rep(val, 1, n) &#123; int p = -1, minr = n+1; // choose min interval for each val _for(i, 0, n) &#123; if(val &gt;= l[i]) &#123; if(res[i] &lt; 0 &amp;&amp; r[i] &lt; minr) &#123; minr = r[i]; p = i; &#125; &#125; &#125; if(val &gt; minr || p &lt; 0) return false; res[p] = val; &#125; return true;&#125;int n;int main() &#123; //freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; init(); _for(i, 0, n) cin &gt;&gt; xl[i] &gt;&gt; yl[i] &gt;&gt; xr[i] &gt;&gt; yr[i]; // then solve() if(solve(xl, xr, x, n) &amp;&amp; solve(yl, yr, y, n)) _for(i, 0, n) printf(\"%d %d\\n\", x[i], y[i]); else printf(\"IMPOSSIBLE\\n\"); // while finished &#125;&#125; 二分lower_bound()和upper_bound()LA3506 123456789101112131415161718192021222324252627282930313233343536373839404142const int inf = 0x3f3f3f3f;const int maxn = 4000 + 5;int n;int A[maxn], B[maxn], C[maxn], D[maxn];int sum[maxn*maxn];void init() &#123; Set(A, 0); Set(B, 0); Set(C, 0); Set(D, 0); Set(sum, 0);&#125;int main() &#123; //freopen(\"input.txt\", \"r\", stdin); int kase; scanf(\"%d\", &amp;kase); while (kase--) &#123; init(); scanf(\"%d\", &amp;n); _for(i, 0, n) &#123; cin &gt;&gt; A[i] &gt;&gt; B[i] &gt;&gt; C[i] &gt;&gt; D[i]; &#125; int k = 0; _for(i, 0, n) _for(j, 0, n) sum[k++] = A[i] + B[j]; sort(sum, sum+k); llong cnt = 0; _for(i, 0, n) _for(j, 0, n) &#123; cnt += upper_bound(sum, sum+k, -C[i]-D[j]) - lower_bound(sum, sum+k, -C[i]-D[j]); &#125; printf(\"%lld\\n\", cnt); if(kase) printf(\"\\n\"); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"https://www.fogsail.net/tags/贪心/"}]},{"title":"STL和常用的数据结构（二）","slug":"20190514","date":"2019-05-14T13:27:07.000Z","updated":"2019-07-07T23:20:06.210Z","comments":true,"path":"2019/05/14/20190514/","link":"","permalink":"https://www.fogsail.net/2019/05/14/20190514/","excerpt":"这里继续讲一些STL中常用的算法与数据结构针对实际开发中的一些业务进行模拟 简易搜索引擎","text":"这里继续讲一些STL中常用的算法与数据结构针对实际开发中的一些业务进行模拟 简易搜索引擎 Searching the Web 算法分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;using namespace std;typedef set&lt;int&gt; intSet;vector&lt;string&gt; all;intSet emptySet;struct Doc &#123; // map&lt;string, intSet&gt; index; intSet lineID; void addline(const string&amp; str, int idx) &#123; // string buf; lineID.insert(idx); for(int i = 0; i &lt; str.size(); i++) &#123; char c = str[i]; if(isalpha(c)) &#123; buf.push_back(tolower(c)); &#125; else if(!buf.empty()) &#123; // index[tmp] = idx; index[buf].insert(idx); buf.clear(); &#125; &#125; if(!buf.empty()) &#123; index[buf].insert(idx); buf.clear(); &#125; &#125; // when query: for(auto&amp; id : index[buf]) cout &lt;&lt; all[id] &lt;&lt; endl; const intSet&amp; findWord(const string&amp; w) &#123; if(!index.count(w)) return emptySet; return index[w]; &#125;&#125;;vector&lt;Doc&gt; article;void getword(const string&amp; str, vector&lt;string&gt;&amp; qwords) &#123; qwords.clear(); stringstream ss(str); string tmp; while(ss &gt;&gt; tmp) &#123; qwords.push_back(tmp); &#125;&#125;void printAns(const intSet&amp; ans) &#123; for(auto&amp; p : ans) cout &lt;&lt; all[p] &lt;&lt; endl;&#125;void query(const vector&lt;string&gt;&amp; qwords) &#123; // const string&amp; one = qwords.front(); const string&amp; two = qwords.back(); bool match, first = true; bool flag = true; if(qwords.size() == 1) &#123; for(int i = 0; i &lt; article.size(); i++) &#123; Doc&amp; atc = article[i]; // check atc.index const intSet&amp; bufID = atc.findWord(one); if(bufID.empty()) match = false; else match = true; if(!match) continue; if(first) first = false; else cout &lt;&lt; \"----------\" &lt;&lt; endl; printAns(bufID); flag = false; &#125; &#125; if(qwords.size() == 2) &#123; for(int i = 0; i &lt; article.size(); i++) &#123; Doc&amp; atc = article[i]; const intSet&amp; bufID = atc.findWord(two); if(bufID.empty()) match = true; else match = false; if(!match) continue; if(first) first = false; else cout &lt;&lt; \"----------\" &lt;&lt; endl; printAns(atc.lineID); flag = false; &#125; &#125; if(qwords.size() == 3) &#123; for(int i = 0; i &lt; article.size(); i++) &#123; Doc&amp; atc = article[i]; const intSet&amp; ans1 = atc.findWord(one); const intSet&amp; ans2 = atc.findWord(two); if(qwords[1] == \"AND\") &#123; // if(!ans1.empty() &amp;&amp; !ans2.empty()) match = true; else match = false; &#125; else if(qwords[1] == \"OR\") &#123; // if(!ans1.empty() || !ans2.empty()) match = true; else match = false; &#125; if(!match) continue; vector&lt;int&gt; ans(ans1.size() + ans2.size()); vector&lt;int&gt;::iterator last = set_union(ans1.begin(), ans1.end(), ans2.begin(), ans2.end(), ans.begin()); if(first) first = false; else cout &lt;&lt; \"----------\" &lt;&lt; endl; for(auto p = ans.begin(); p != last; p++) cout &lt;&lt; all[*p] &lt;&lt; endl; flag = false; &#125; &#125; if(flag) cout &lt;&lt; \"Sorry, I found nothing.\" &lt;&lt; endl; cout &lt;&lt; \"==========\" &lt;&lt; endl;&#125;int main() &#123; int N, M; string line; cin &gt;&gt; N; getline(cin, line); article.resize(N); // fresh string cout &lt;&lt; line; for(int i = 0; i &lt; N; i++) &#123; while(true) &#123; Doc&amp; atc = article[i]; getline(cin, line); if(line == \"**********\") break; // atc.addline() all.push_back(line); atc.addline(line, all.size()-1); &#125; &#125; // get all articles /* for(int i = 0; i &lt; N; i++) &#123; Doc&amp; atc = article[i]; for(auto it = atc.index.begin(); it != atc.index.end(); it++) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; \": \" &lt;&lt; endl; for(auto p : it-&gt;second) cout &lt;&lt; all[p] &lt;&lt; endl; &#125; cout &lt;&lt; \"---------\" &lt;&lt; endl; &#125; */ cin &gt;&gt; M; getline(cin, line); vector&lt;string&gt; qwords; for(int i = 0; i &lt; M; i++) &#123; getline(cin, line); getword(line, qwords); query(qwords); &#125;&#125; 重复元素的模拟：队列法printer queue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//// main.cpp// LA3638//// Created by zhangmin chen on 2019/5/18.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;// we need to deal with the same priorityclass Task &#123;public: int id, num; Task(int id_ = 0, int num_ = 0) : id(id_), num(num_) &#123;&#125;&#125;;queue&lt;Task&gt; tasks;priority_queue&lt;int&gt; pq;void init() &#123; while(!tasks.empty()) tasks.pop(); while(!pq.empty()) pq.pop();&#125;int n, m;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; cin &gt;&gt; kase; while(kase--) &#123; // init(); cin &gt;&gt; n &gt;&gt; m; _for(i, 0, n) &#123; int val; cin &gt;&gt; val; pq.push(val); tasks.push(Task(i, val)); &#125; int ans = 0; while(true) &#123; if(pq.empty()) break; int v = pq.top(); Task t = tasks.front(); tasks.pop(); if(t.num == v) &#123; pq.pop(); ans++; if(t.id == m) &#123; // cout &lt;&lt; ans &lt;&lt; endl; break; &#125; &#125; else tasks.push(t); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; STL set实现边插入边排序Borrowers 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//// main.cpp// LA5169//// Created by zhangmin chen on 2019/5/18.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;typedef set&lt;int&gt;::iterator si;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;class Book &#123;public: string title, author; Book(string title_ = \"\", string author_ = \"\") : title(title_), author(author_) &#123;&#125; bool operator&lt; (const Book&amp; rhs) const &#123; return author &lt; rhs.author || (author == rhs.author &amp;&amp; title &lt; rhs.title); &#125;&#125;;map&lt;string, int&gt; idx;vector&lt;Book&gt; books;class Cmp &#123;public: bool operator() (const int&amp; lhs, const int&amp; rhs) const &#123; return books[lhs] &lt; books[rhs]; &#125;&#125;;set&lt;int, Cmp&gt; libs, pools;void borrow(const string&amp; bKName) &#123; int id = idx[bKName]; if(libs.count(id)) libs.erase(id); else pools.erase(id);&#125;void retBook(const string&amp; bkName) &#123; int id = idx[bkName]; pools.insert(id);&#125;void shelve() &#123; // for(si i = pools.begin(); i != pools.end(); i++) &#123; // int id = *i; si p = libs.insert(id).first; if(p == libs.begin()) &#123; // first cout &lt;&lt; \"Put \" &lt;&lt; books[id].title &lt;&lt; \" first\" &lt;&lt; endl; &#125; else &#123; p--; int pid = *p; cout &lt;&lt; \"Put \" &lt;&lt; books[id].title &lt;&lt; \" after \" &lt;&lt; books[pid].title &lt;&lt; endl; &#125; &#125; pools.clear(); cout &lt;&lt; \"END\" &lt;&lt; endl;&#125;void init() &#123; idx.clear(); books.clear(); pools.clear(); libs.clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string line; init(); while (true) &#123; getline(cin, line); if(line == \"END\") break; int p = (int)line.find(\" by \"); string title = line.substr(0, p); string author = line.substr(p+4); int id = (int)books.size(); idx[title] = id; books.push_back(Book(title, author)); &#125; // then we finished get all books _for(i, 0, books.size()) libs.insert(i); string cmd, title; while(true) &#123; getline(cin, line); if(line == \"END\") break; cmd = line.substr(0, 6); if(cmd[0] == 'S') shelve(); else &#123; title = line.substr(cmd.size()+1); if(cmd[0] == 'B') borrow(title); else retBook(title); &#125; &#125;&#125; 编译器语法检查POJ3524 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141//// main.cpp// POJ3524//// Created by zhangmin chen on 2019/5/18.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int inf = 0x3f3f3f3f;const int maxn = 256;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;class Array &#123;public: int len; map&lt;int, int&gt; val; void remove() &#123; len = -1; val.clear(); &#125; Array() &#123; remove(); &#125; void resz(int sz) &#123; len = sz; val.clear(); &#125; bool declare() &#123; return len &gt;= 0; &#125; bool exist(int id) &#123; if(val.count(id)) return true; else return false; &#125; bool assign(int idx, int v) &#123; if(idx &gt;= len) return false; val[idx] = v; return true; &#125;&#125;;Array arr[maxn];// string a[] = xxxint IDX(const string&amp; str, int p, bool&amp; bugfree) &#123; if(isdigit(str[p])) &#123; int ans = 0; while(isdigit(str[p])) &#123; ans = ans * 10 + str[p] - '0'; p++; &#125; return ans; &#125; else if(isalpha(str[p])) &#123; // str[p]: name char c = str[p]; int id = IDX(str, p+2, bugfree); Array&amp; ar = arr[c]; if(ar.declare()) &#123; // // if exist arr[c].val[idx], return value of val[idx] // else bugfree = false if(id &lt; ar.len &amp;&amp; ar.exist(id)) return ar.val[id]; else bugfree = 0; &#125; else bugfree = 0; &#125; return 0;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int bugL = 0, L = 0; string line; while(getline(cin, line)) &#123; if(line[0] == '.') &#123; if(L) printf(\"%d\\n\", bugL); _for(i, 0, maxn) arr[i].remove(); bugL = 0; L = 0; continue; &#125; if(bugL) continue; int p = (int)line.find('='); if(p != string::npos) &#123; // bool bugfree = true; string lhs = line.substr(0, p); int idx = IDX(lhs, 2, bugfree); int rhs = IDX(line, p+1, bugfree); Array&amp; ar = arr[line[0]]; if(bugfree &amp;&amp; ar.declare() &amp;&amp; ar.assign(idx, rhs)) L++; else bugL = L + 1; &#125; else &#123; // declare but not init char name; int idx; sscanf(line.c_str(), \"%c[%d]\", &amp;name, &amp;idx); arr[name].resz(idx); L++; &#125; &#125;&#125; 数据结构过滤器UVA11995 数据结构过滤器可能只进数据，不出数据这是潜在的bugint tot = 0, 在出数据的时候统计个数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465queue&lt;int&gt; que;priority_queue&lt;int&gt; pq;stack&lt;int&gt; stk;int n;void init() &#123; while(!que.empty()) que.pop(); while(!pq.empty()) pq.pop(); while(!stk.empty()) stk.pop();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) != EOF) &#123; init(); int cmd, v; int tot = 0; int cntPQ = 0, cntS = 0, cntQ = 0; _for(i, 0, n) &#123; scanf(\"%d%d\", &amp;cmd, &amp;v); if(cmd == 1) &#123; que.push(v); pq.push(v); stk.push(v); &#125; else if(cmd == 2) &#123; tot++; int xPQ = 0, xQ = 0, xS = 0; if(!que.empty()) &#123; xQ = que.front(); que.pop(); &#125; if(!pq.empty()) &#123; xPQ = pq.top(); pq.pop(); &#125; if(!stk.empty()) &#123; xS = stk.top(); stk.pop(); &#125; if(xQ == v) cntQ++; if(xS == v) cntS++; if(xPQ == v) cntPQ++; &#125; &#125; if( (cntPQ == tot &amp;&amp; cntS == tot) || (cntPQ == tot &amp;&amp; cntQ == tot) || (cntS == tot &amp;&amp; cntQ == tot) ) printf(\"not sure\\n\"); else if(cntQ == tot) printf(\"queue\\n\"); else if(cntS == tot) printf(\"stack\\n\"); else if(cntPQ == tot) printf(\"priority queue\\n\"); else printf(\"impossible\\n\"); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"tries树和stl中常用的数据结构","slug":"20190503","date":"2019-05-02T17:33:10.000Z","updated":"2019-05-18T09:17:03.496Z","comments":true,"path":"2019/05/03/20190503/","link":"","permalink":"https://www.fogsail.net/2019/05/03/20190503/","excerpt":"刘汝佳的算法书中，有一些关于模拟的题目比较典型，代码量也比较大同时叶比较考验代码的组织能力具体题目请参阅《算法竞赛入门经典（第二版）》 第五章这里对一些复杂的习题予以解答","text":"刘汝佳的算法书中，有一些关于模拟的题目比较典型，代码量也比较大同时叶比较考验代码的组织能力具体题目请参阅《算法竞赛入门经典（第二版）》 第五章这里对一些复杂的习题予以解答 小型订单系统的设计Exchange 设计思路： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179//// main.cpp// UVA1598//// Created by zhangmin chen on 2019/5/4.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;class Order &#123;public: string cmd; int price, size; Order(string str, int p, int s) : cmd(str), price(p), size(s) &#123;&#125;&#125;;map&lt;int, set&lt;int&gt; &gt; buypq, sellpq;map&lt;int, int&gt; buytab, selltab;vector&lt;Order&gt; books;void init() &#123; // books.clear(); buypq.clear(); sellpq.clear(); buytab.clear(); selltab.clear();&#125;void trade(int flag) &#123; // // flag 0 for buy, flag 1 for sell // buy -&gt; match books[sell] // sell -&gt; match books[buy] while (!buypq.empty() &amp;&amp; !sellpq.empty()) &#123; int bidP = buypq.rbegin()-&gt;first, askP = sellpq.begin()-&gt;first; if(bidP &gt;= askP) &#123; // trade set&lt;int&gt;&amp; bitem = buypq.rbegin()-&gt;second; set&lt;int&gt;&amp; sitem = sellpq.begin()-&gt;second; // bitem = &#123;id1, id2....&#125;, sitem = &#123;id1, id2,...&#125; int bi = *bitem.begin(), si = *sitem.begin(); int sz = min(books[bi].size, books[si].size); // then print trade information printf(\"TRADE %d %d\\n\", sz, flag ? books[bi].price : books[si].price); // trade begin books[bi].size -= sz; books[si].size -= sz; buytab[books[bi].price] -= sz; selltab[books[si].price] -= sz; if(books[bi].size == 0) bitem.erase(bi); if(bitem.size() == 0) buypq.erase(books[bi].price); if(books[si].size == 0) sitem.erase(si); if(sitem.size() == 0) sellpq.erase(books[si].price); &#125; else &#123; return; &#125; &#125;&#125;void quote() &#123; // while(buytab.size() &amp;&amp; buytab.rbegin()-&gt;second &lt;= 0) buytab.erase(buytab.rbegin()-&gt;first); while(selltab.size() &amp;&amp; selltab.begin()-&gt;second &lt;= 0) selltab.erase(selltab.begin()-&gt;first); printf(\"QUOTE \"); if(buytab.size()) &#123; // print (size, price) = (second, first) printf(\"%d %d\", buytab.rbegin()-&gt;second, buytab.rbegin()-&gt;first); &#125; else &#123; printf(\"0 0\"); &#125; cout &lt;&lt; \" - \"; if(selltab.size()) &#123; printf(\"%d %d\", selltab.begin()-&gt;second, selltab.begin()-&gt;first); &#125; else &#123; printf(\"0 99999\"); &#125; cout &lt;&lt; endl;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); // freopen(\"output.txt\", \"w\", stdout); int n = 0, kase = 0; string cmd; while(scanf(\"%d\", &amp;n) == 1) &#123; // if(kase++) cout &lt;&lt; endl; init(); int size, price; int id; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; cmd; if(cmd == \"BUY\") &#123; cin &gt;&gt; size &gt;&gt; price; books.push_back(Order(cmd, price, size)); buypq[price].insert(i); buytab[price] += size; trade(0); &#125; else if(cmd == \"SELL\") &#123; cin &gt;&gt; size &gt;&gt; price; books.push_back(Order(cmd, price, size)); sellpq[price].insert(i); selltab[price] += size; trade(1); &#125; else if(cmd == \"CANCEL\") &#123; cin &gt;&gt; id; id--; books.push_back(Order(cmd, 0, id)); // 0 is illegal if(books[id].cmd == \"BUY\") &#123; // int p = books[id].price, q = books[id].size; buypq[p].erase(id); if(buypq[p].size() == 0) buypq.erase(p); buytab[p] -= q; books[id].size = 0; &#125; else if(books[id].cmd == \"SELL\") &#123; // int p = books[id].price, q = books[id].size; sellpq[p].erase(id); if(sellpq[p].size() == 0) sellpq.erase(p); selltab[p] -= q; books[id].size = 0; &#125; &#125; // one cmd finished quote(); &#125; &#125;&#125; 优先队列与面向对象思想Use of Hospital Facilities 具体实现如下： 维护一个优先队列，先pq = priority_queue.pop()，出队的时候同时维护next进队元素的信息then priority_queue.push(next) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//// main.cpp// UVA212//// Created by zhangmin chen on 2019/5/7.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;class Room &#123;public: int beg, id; Room(int beg, int id) : beg(beg), id(id) &#123;&#125; bool operator &lt; (const Room&amp; rhs) const &#123; if(beg != rhs.beg) return beg &gt; rhs.beg; return id &gt; rhs.id; &#125;&#125;;// we use priority queue;// room --&gt; bedclass Patient &#123;public: char name[105]; int opT, bedT; int id, roomID, bedID; int opS, opEnd; int bedS, bedEnd;&#125;;bool cmp(Patient&amp; lhs, Patient&amp; rhs) &#123; if(lhs.opEnd != rhs.opEnd) return lhs.opEnd &lt; rhs.opEnd; return lhs.roomID &lt; rhs.roomID;&#125;bool cmp2(Patient&amp; lhs, Patient&amp; rhs) &#123; return lhs.id &lt; rhs.id;&#125;// n opRooms, m beds, H start hours// t1 trans-time, t2 pre-opTime, t3 pre-bedTime// k paitientsint main() &#123; freopen(\"input.txt\", \"r\", stdin); int n, m, H, t1, t2, t3, k; while(~ (scanf(\"%d%d%d%d%d%d%d\", &amp;n, &amp;m, &amp;H, &amp;t1, &amp;t2, &amp;t3, &amp;k)) ) &#123; // init vector&lt;Patient&gt; pents(k); priority_queue&lt;Room&gt; rooms; vector&lt;int&gt; rUsed(n+1, 0); for(int i = 1; i &lt;= n; i++) rooms.push(Room(H*60, i)); // then we get all rooms for(int i = 0; i &lt; k; i++) &#123; Patient&amp; p = pents[i]; cin &gt;&gt; p.name &gt;&gt; p.opT &gt;&gt; p.bedT; p.id = i+1; // then we get each patient Room r = rooms.top(); rooms.pop(); p.opS = r.beg; p.opEnd = p.opS + p.opT; p.bedS = p.opEnd + t1; p.bedEnd = p.bedS + p.bedT; p.roomID = r.id; rUsed[r.id] += p.opT; rooms.push(Room(p.opEnd + t2, r.id)); &#125; // we arrange op-Room for each patient sort(pents.begin(), pents.end(), cmp); // then arrange bed for each patient int END = 0; vector&lt;int&gt; bUsed(m+1, 0); vector&lt;int&gt; Beds(m+1, H*60); for(int i = 0; i &lt; k; i++) &#123; Patient&amp; p = pents[i]; int j; for(j = 1; j &lt;= m; j++) &#123; if(Beds[j] &lt;= p.opEnd) break; &#125; // &amp;p: get into Beds[j]; p.bedID =j; Beds[j] = p.bedEnd + t3; bUsed[j] += p.bedT; END = max(END, p.bedEnd); &#125; // we arrange beds for each patient sort(pents.begin(), pents.end(), cmp2); puts(\" Patient Operating Room Recovery Room\"); puts(\" # Name Room# Begin End Bed# Begin End\"); puts(\" ------------------------------------------------------\"); for(int i = 0; i &lt; k; i++) &#123; const Patient&amp; p = pents[i]; printf(\"%2d %-9s \", p.id, p.name); printf(\"%2d %3d:%02d %3d:%02d \", p.roomID, p.opS/60, p.opS%60, p.opEnd/60, p.opEnd%60); printf(\"%2d %3d:%02d %3d:%02d\\n\", p.bedID, p.bedS/60, p.bedS%60, p.bedEnd/60, p.bedEnd%60); &#125; printf(\"\\n\"); puts(\"Facility Utilization\"); puts(\"Type # Minutes % Used\"); puts(\"-------------------------\"); for(int i = 1; i &lt;= n; i++) printf(\"Room %2d %7d %7.2f\\n\", i, rUsed[i], rUsed[i] * 100.0 / (END - H*60)); for(int i = 1; i &lt;= m; i++) printf(\"Bed %2d %7d %7.2f\\n\", i, bUsed[i], bUsed[i] * 100.0 / (END - H*60)); printf(\"\\n\"); &#125;&#125; Trie树Trie树的实现 代码实现如下： TrieST.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181//// Created by zhangmin chen on 2019/2/12.//#ifndef TRIEST_TRIEST_H#define TRIEST_TRIEST_H#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stdexcept&gt;#include &lt;cassert&gt;#include &lt;algorithm&gt;using namespace std;class TrieST &#123;private: class Node &#123; public: Node() : next(256, nullptr), val(0), flag(false) &#123;&#125; ~Node() &#123; for(int i = 0; i &lt; R; i++) if(next[i]) delete(next[i]); &#125; int val; bool flag; vector&lt;Node *&gt; next; &#125;;public: // int main() to create! TrieST() : n(0), root(nullptr) &#123;&#125; ~TrieST() &#123; delete(root); &#125; int get(string key) &#123; if(key.empty()) throw invalid_argument(\"argument to get() is null\"); Node* x = get(root, key, 0); if(x == nullptr) throw runtime_error(\"Without this key\"); return x-&gt;val; &#125; void put(string key, int val) &#123; if(key.empty()) throw invalid_argument(\"first argument to put() is null\"); else root = put(this-&gt;root, key, val, 0); &#125; string longestPrefixOf(string query) &#123; if(query.empty()) throw invalid_argument(\"argument to longestPrefixOf() is null\"); int length = longestPrefixOf(root, query, 0, -1); if(length == -1) return \"\"; else return query.substr(0, length); &#125; queue&lt;string&gt; keysWithPrefix(string pre) &#123; queue&lt;string&gt; res; Node* x = get(root, pre, 0); collect(x, pre, res); return res; &#125; queue&lt;string&gt; keysMatch(string pat) &#123; queue&lt;string&gt; res; collect(root, \"\", pat, res); return res; &#125; void delete_(string key) &#123; if(key.empty()) throw invalid_argument(\"argument to delete() is null\"); root = delete_(root, key, 0); &#125; int size() &#123; return n; &#125; bool isempty() &#123; return size() == 0; &#125; queue&lt;string&gt; keys() &#123; return keysWithPrefix(\"\"); &#125; bool contains(string key) &#123; if(key.empty()) throw invalid_argument(\"argument to contains() is null\"); return get(root, key, 0) != nullptr; &#125;private: Node* get(Node* x, string key, int d) &#123; if(x == nullptr) return nullptr; if(d == key.length()) return x; char c = key[d]; return get(x-&gt;next[c], key, d+1); // c = key[0] begin searching // start: get(key[0], key, 1) // root is just a node without message &#125; Node* put(Node* x, string key, int val, int d) &#123; if(x == nullptr) x = new Node(); if(d == key.length()) &#123; x-&gt;val = val; x-&gt;flag = true; return x; &#125; char c = key[d]; x-&gt;next[c] = put(x-&gt;next[c], key, val, d+1); return x; &#125; void collect(Node* x, string pre, queue&lt;string&gt;&amp; res) &#123; if(x == nullptr) return; if(x-&gt;flag) res.push(pre); for(unsigned char c = 0; ; c++) &#123; pre.push_back(c); collect(x-&gt;next[c], pre, res); pre.pop_back(); if(c == R-1) break; &#125; &#125; void collect(Node* x, string pre, string pat, queue&lt;string&gt;&amp; res) &#123; if(x == nullptr) return; int d = pre.length(); if(d == pat.length() &amp;&amp; x-&gt;flag) res.push(pre); // 遇到x-&gt;flag, 进队列 if(d == pat.length()) return; char c = pat[d]; if(c == '.') &#123; // for(unsigned char ch = 0; ; ch++) &#123; pre.push_back(ch); collect(x-&gt;next[ch], pre, pat, res); pre.pop_back(); if(ch == R-1) break; &#125; &#125; else &#123; pre.push_back(c); collect(x-&gt;next[c], pre, pat, res); pre.pop_back(); &#125; &#125; int longestPrefixOf(Node* x, string query, int d, int length) &#123; if(x == nullptr) return length; if(x-&gt;flag) length = d; if(d == query.length()) return length; char c = query[d]; return longestPrefixOf(x-&gt;next[c], query, d+1, length); &#125; Node* delete_(Node* x, string key, int d) &#123; if(x == nullptr) return nullptr; if(d == key.length()) &#123; if(x-&gt;flag) n--; x-&gt;flag = false; &#125; else &#123; char c = key[d]; x-&gt;next[c] = delete_(x-&gt;next[c], key, d+1); &#125; // remove subtrie rooted at x if it is completely empty if(x-&gt;flag) return x; for(int c = 0; c &lt; R; c++) if(x-&gt;next[c] != nullptr) return x; return nullptr; // in recur, x-&gt;next[c] = nullptr, fix the bug of Leaking memory &#125;private: static const int R; Node* root; // root of trie int n; // number of keys in trie&#125;;const int TrieST::R = 256;#endif //TRIEST_TRIEST_H main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include \"./cmake-build-debug/TrieST.h\"#include &lt;fstream&gt;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string tmp; int cnt = 0; TrieST st; while(cin &gt;&gt; tmp) &#123; // cout &lt;&lt; tmp &lt;&lt; endl; st.put(tmp, cnt++); &#125; if(st.size() &lt; 100) &#123; cout &lt;&lt; \"keys(\\\"\\\"):\" &lt;&lt; endl; auto res = st.keys(); while(!res.empty()) &#123; cout &lt;&lt; res.front() &lt;&lt; \" \" &lt;&lt; st.get(res.front()) &lt;&lt; endl; res.pop(); &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; \"longestPrefixOf(\\\"shellsort\\\"):\" &lt;&lt; endl; cout &lt;&lt; st.longestPrefixOf(\"shellsort\") &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; \"longestPrefixOf(\\\"quicksort\\\"):\" &lt;&lt; endl; cout &lt;&lt; st.longestPrefixOf(\"quicksort\") &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; \"keyWithPrefix(\\\"shor\\\"):\" &lt;&lt; endl; auto res = st.keysWithPrefix(\"shor\"); while(!res.empty()) &#123; cout &lt;&lt; res.front() &lt;&lt; endl; res.pop(); &#125; cout &lt;&lt; endl; cout &lt;&lt; \"keysThatMatch(\\\".he.l.\\\"):\" &lt;&lt; endl; auto res2 = st.keysMatch(\".he.l.\"); while(!res2.empty()) &#123; cout &lt;&lt; res2.front() &lt;&lt; endl; res2.pop(); &#125; cout &lt;&lt; endl;&#125; 三向单词查找树TST.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175//// Created by zhangmin chen on 2019/2/13.//#ifndef TST_TST_H#define TST_TST_H#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;stdexcept&gt;#include &lt;queue&gt;using namespace std;class TST &#123;private: class Node &#123; public: // construction Node() : left(nullptr), mid(nullptr), right(nullptr), isString(false) &#123;&#125; ~Node() &#123; if(left) delete(left); if(right) delete(right); if(mid) delete(mid); &#125; unsigned char c; bool isString; Node *left, *mid, *right; int val; &#125;;public: // construction TST() : n(0), root(nullptr) &#123;&#125; ~TST() &#123; delete(root); &#125; int size() &#123; return n; &#125; bool contains(string key) &#123; if(key.empty()) &#123; throw invalid_argument(\"argument to contains() is null!\"); &#125; return get(root, key, 0) != nullptr; &#125; int get(string key) &#123; if(key.empty()) throw invalid_argument(\"calls get() with null argument\"); Node *x = get(root, key, 0); if(x == nullptr) throw runtime_error(\"This key not int this table\"); return x-&gt;val; &#125; void put(string key, int val) &#123; if(key.empty()) throw invalid_argument(\"calls put() with null key\"); if(!contains(key)) n++; root = put(root, key, val, 0); &#125; string longestPrefixOf(string query) &#123; if(query.length() == 0) return \"\"; int len = 0; Node* x = root; int i = 0; while(i &lt; query.length() &amp;&amp; x != nullptr) &#123; char ch = query[i]; if(ch &lt; x-&gt;c) x = x-&gt;left; else if(ch &gt; x-&gt;c) x = x-&gt;right; else &#123; i++; if(x-&gt;isString) len = i; x = x-&gt;mid; &#125; &#125; return query.substr(0, len); &#125; queue&lt;string&gt; keys() &#123; queue&lt;string&gt; que1; string tmp = \"\"; collect(root, tmp, que1); return que1; &#125; queue&lt;string&gt; keysWithPrefix(string pre) &#123; if(pre.empty()) throw invalid_argument(\"calls keysWithPrefix() with null argumemnt\"); queue&lt;string&gt; que2; Node *x = get(root, pre, 0); if(x == nullptr) return que2; if(x-&gt;isString) que2.push(pre); collect(x-&gt;mid, pre, que2); return que2; &#125; queue&lt;string&gt; keysThatMatch(string pat) &#123; queue&lt;string&gt; que; string pre = \"\"; collect(root, pre, 0, pat, que); return que; &#125;private: Node *get(Node *x, string key, int d) &#123; if(x == nullptr) return nullptr; if(key.length() == 0) throw invalid_argument(\"key must have length &gt;= 1\"); unsigned char ch = key[d]; if(ch &lt; x-&gt;c) return get(x-&gt;left, key, d); else if(ch &gt; x-&gt;c) return get(x-&gt;right, key, d); else if (d &lt; key.length()-1) return get(x-&gt;mid, key, d+1); else return x; &#125; Node *put(Node *x, string key, int val, int d) &#123; char ch = key[d]; if(x == nullptr) &#123; x = new Node(); x-&gt;c = ch; &#125; if(ch &lt; x-&gt;c) x-&gt;left = put(x-&gt;left, key, val, d); else if(ch &gt; x-&gt;c) x-&gt;right = put(x-&gt;right, key, val, d); else if(d &lt; key.length()-1) x-&gt;mid = put(x-&gt;mid, key, val, d+1); else &#123; x-&gt;val = val; x-&gt;isString = true; &#125; return x; &#125; void collect(Node *x, string&amp; pre, queue&lt;string&gt;&amp; res) &#123; if(x == nullptr) return; collect(x-&gt;left, pre, res); if(x-&gt;isString) &#123; pre.push_back(x-&gt;c); res.push(pre); pre.pop_back(); // find prefix &#125; pre.push_back(x-&gt;c); collect(x-&gt;mid, pre, res); pre.pop_back(); collect(x-&gt;right, pre, res); &#125; void collect(Node *x, string&amp; pre, int d, const string&amp; pat, queue&lt;string&gt;&amp; res) &#123; if(x == nullptr) return; char ch = pat[d]; if(ch == '.' || ch &lt; x-&gt;c) collect(x-&gt;left, pre, d, pat, res); if(ch == '.' || ch == x-&gt;c) &#123; if(d == pat.length()-1 &amp;&amp; x-&gt;isString) &#123; pre.push_back(x-&gt;c); res.push(pre); &#125; if(d &lt; pat.length()-1) &#123; pre.push_back(x-&gt;c); collect(x-&gt;mid, pre, d+1, pat, res); pre.pop_back(); &#125; &#125; if(ch == '.' || ch &gt; x-&gt;c) collect(x-&gt;right, pre, d, pat, res); &#125;private: int n; Node* root;&#125;;#endif //TST_TST_H main.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include \"./cmake-build-debug/TST.h\"#include &lt;fstream&gt;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string tmp; int cnt = 0; TST tst; while(cin &gt;&gt; tmp) &#123; // tst.put(tmp, cnt++); &#125; if(tst.size() &lt; 100) &#123; cout &lt;&lt; \"keys(\\\"\\\"):\" &lt;&lt; endl; auto res = tst.keys(); while(!res.empty()) &#123; cout &lt;&lt; res.front() &lt;&lt; endl; res.pop(); &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; \"longestPrefixOf(\\\"shellsort\\\"):\" &lt;&lt; endl; cout &lt;&lt; tst.longestPrefixOf(\"shellsort\") &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; \"longestPrefixOf(\\\"quicksort\\\"):\" &lt;&lt; endl; cout &lt;&lt; tst.longestPrefixOf(\"quicksort\") &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; \"keysWithPrefix(\\\"shor\\\"):\" &lt;&lt; endl; auto res = tst.keysWithPrefix(\"shor\"); while(!res.empty()) &#123; cout &lt;&lt; res.front() &lt;&lt; endl; res.pop(); &#125; cout &lt;&lt; endl; cout &lt;&lt; \"keysThatMatch(\\\".he.l.\\\"):\" &lt;&lt; endl; auto res2 = tst.keysThatMatch(\".he.l.\"); while(!res2.empty()) &#123; cout &lt;&lt; res2.front() &lt;&lt; endl; res2.pop(); &#125; cout &lt;&lt; endl;&#125; Trie树的优化使用memset(ch[sz], 0, sizeof(ch[sz])), ch[u][c] = sz++来开辟一个子节点如果没到字符串末尾，val[sz] = 0只有到达字符串末尾，才保存val值 123456789101112131415161718192021222324252627282930template&lt;maxnode, sigmaSize&gt;class Trie &#123;public: int ch[maxnode][sigmaSize]; int val[maxnode]; int sz; Trie() &#123; sz = 1; memset(ch, 0, sizeof(ch[0])) // 相当于new Node(root) &#125; void insert(const string&amp; str, int v) &#123; int u = 0; for(int i = 0; i &lt; str.length(); i++) &#123; int c = idx(str[i]); if(!ch[u][c]) &#123; // 开辟一个子节点, 值为sz memset(ch[sz], 0, sizeof(ch[sz])); val[sz] = 0; //没到str结尾，所有的val都为0，只在str结尾保存值 ch[u][c] = sz++; &#125; u = ch[u][c]; &#125; // str结尾了，保存字符串的值 val[u] = v; &#125;&#125;; Trie树解决大整数问题Revenge of Fibonacci 涉及到的一些stl函数 123456int myints[] = &#123;10, 20, 30, 40, 50, 60, 70&#125;;vector&lt;int&gt; myvector(7);copy(myints, myints+7, myvector.begin())// 把myints[0]往后7个元素复制到myvector中 相似的用法 12345string str = \"abcdefg\"string tmp;tmp.append(str, 0, 3);// tmp后面附加上从str[0]往后3个字符 Trie树在BigInt上的优势完美解决前导0比如一个数是0067由于trie树只会在字符串末尾保存0067的val，这个val可以是真实值，也可以是索引，也可以是哈希所以保证node u扫完整个字符串，看val[u]的值就可以 stringstream用于string类和其他值类型的转换1234567stringstream ss;char buf[maxn];for(i = 0; i &lt; maxn; i++) sprintf(buf, \"%d\", arr[i]);ss &lt;&lt; buf;cout &lt;&lt; ss.str() &lt;&lt; endl; 基本思想 本例和一般单词查找树的异同123456if(ch[u][c] == -1) &#123; memset(ch[sz], -1, sizeof(ch[sz])); val[sz] = v; // 一般单词查找树val[sz] = 0; ch[u][c] = sz++;&#125; 一般单词查找树，val[sz] = 0，只在字符串末尾保存相应的值本例中，因为是根据前缀（斐波那契数的前几个部分数字），来猜到是第几个斐波那契数所以所有的前缀都必须保存v信息，val[sz] = v 代码实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204//// main.cpp// UVA12333//// Created by zhangmin chen on 2019/5/7.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int BASE = 10000;const int MAXLEN = 6000;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;template &lt;int maxn&gt;class BigInt &#123;public: int len, s[maxn]; BigInt() &#123; Set(s, 0); len = 1; &#125; BigInt&amp; operator= (int num) &#123; if(num == 0) &#123; len = 1; return *this; &#125; len = 0; while(num &gt; 0) &#123; s[len++] = num % BASE; num /= BASE; &#125; return *this; &#125; BigInt&amp; operator= (const BigInt&amp; rhs) &#123; len = rhs.len; copy(rhs.s, rhs.s + rhs.len, s); return *this; &#125; BigInt(int num) &#123; *this = num; &#125;&#125;;typedef BigInt&lt;MAXLEN&gt; fBig;string Reverse(const fBig&amp; fi) &#123; int tot = 0; char buf[8]; stringstream ss; bool first = true; for(int i = 0; i &lt; fi.len; i++) &#123; if(first) &#123; first = false; sprintf(buf, \"%d\", fi.s[fi.len - 1 - i]); &#125; else sprintf(buf, \"%04d\", fi.s[fi.len - 1 - i]); ss &lt;&lt; buf; tot += strlen(buf); if(tot &gt;= 41) break; &#125; return ss.str();&#125;template &lt;int maxNode, int sigmaSize&gt;class Trie &#123;public: int ch[maxNode][sigmaSize], val[maxNode]; int sz; Trie() &#123; Set(ch[0], -1); Set(val, 0); sz = 1; &#125; int idx(char c) const &#123; return c - '0'; &#125; void insert(const string&amp; str, int v) &#123; int u = 0; for(int i = 0; i &lt; str.length(); i++) &#123; // int c = idx(str[i]); if(ch[u][c] == -1) &#123; // Set(ch[sz], -1); val[sz] = v; ch[u][c] = sz++; &#125; u = ch[u][c]; &#125; val[u] = v; &#125; int getVal(const string&amp; str) const &#123; int v = -1, u = 0; for(int i = 0; i &lt; str.length(); i++) &#123; // int c = idx(str[i]); if(ch[u][c] == -1) return v; u = ch[u][c]; &#125; if(val[u]) v = val[u]; return v; &#125; &#125;;void Add(const fBig&amp; f1, const fBig&amp; f2, fBig&amp; f3) &#123; int len = max(f1.len, f2.len); int p = 0; for(int i = 0, carry = 0; ; i++) &#123; if(carry == 0 &amp;&amp; i &gt;= len) break; int x = carry; if(i &lt; f1.len) x += f1.s[i]; if(i &lt; f2.len) x += f2.s[i]; f3.s[p++] = x % BASE; carry = x / BASE; &#125; f3.len = p;&#125;/*ostream&amp; operator&lt;&lt; (ostream&amp; os, const fBig&amp; fi) &#123; char buf[8]; stringstream ss; bool first = true; for(int i = fi.len - 1; i &gt;= 0; i--) &#123; if(first) &#123; first = false; ss &lt;&lt; fi.s[i]; &#125; else &#123; sprintf(buf, \"%04d\", fi.s[i]); ss &lt;&lt; buf; &#125; &#125; const string&amp; str = ss.str(); if(str.empty()) return os &lt;&lt; 0; return os &lt;&lt; str;&#125; */Trie&lt;4000000, 10&gt; trie;fBig f0 = 0, f1 = 1, f;const int MAXF = 100000;int main() &#123; freopen(\"input.txt\", \"r\", stdin); for(int i = 2; i &lt; MAXF; i++) &#123; Add(f0, f1, f); string rev = Reverse(f); trie.insert(rev, i-1); f0 = f1; f1 = f; &#125; int kase; scanf(\"%d\", &amp;kase); char buf[60]; for(int k = 1; k &lt;= kase; k++) &#123; scanf(\"%s\", buf); int ans = 0; string str(buf); if(str != \"1\") ans = trie.getVal(str); printf(\"Case #%d: %d\\n\", k, ans); &#125;&#125; 模拟操作系统：多线程处理流水线时间 — 取出任务放入缓存表 — 更新缓存表 — 判断任务进行情况 Queue and A 分析 solution 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201//// main.cpp// LA5222//// Created by zhangmin chen on 2019/5/8.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;const int MAXTIME = 500000;class Topic &#123;public: int tid, num, t0, t, dt; int tot;&#125;;class Cust &#123;public: int pid, k; vector&lt;int&gt; cTopics; int dtime, handle, last; bool busy; Cust() &#123; pid = -1; k = 0; cTopics.clear(); dtime = 0; handle = -1; last = 0; busy = 0; &#125; bool operator&lt; (const Cust&amp; rhs) const &#123; if(last == rhs.last) return pid &gt; rhs.pid; return last &gt; rhs.last; &#125;&#125;;vector&lt;Topic&gt; topics;vector&lt;Cust&gt; custs;map&lt;int, int&gt; idxT;map&lt;int, int&gt; idxC;map&lt;int, vector&lt;Cust&gt; &gt; buf;typedef map&lt;int, vector&lt;Cust&gt; &gt;::iterator mv;bool can_assign(int tID, int timing) &#123; // if(timing &lt; topics[tID].t0) return 0; if(topics[tID].dt == 0) return topics[tID].num &gt; 0; if(topics[tID].num == 0) return 0; int arriving = (timing - topics[tID].t0) / topics[tID].dt; int already_assigned = topics[tID].tot - topics[tID].num; if(arriving &lt; already_assigned) return 0; return 1;&#125;void init() &#123; topics.clear(); custs.clear(); idxT.clear(); idxC.clear(); buf.clear();&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int n, m, kase = 0; // n topics, m custs while(cin &gt;&gt; n &amp;&amp; n) &#123; init(); int timing = 0; for(int i = 0; i &lt; n; i++) &#123; Topic tp; cin &gt;&gt; tp.tid &gt;&gt; tp.num &gt;&gt; tp.t0 &gt;&gt; tp.t &gt;&gt; tp.dt; tp.tot = tp.num; idxT[tp.tid] = i; topics.push_back(tp); &#125; cin &gt;&gt; m; for(int i = 0; i &lt; m; i++) &#123; Cust cst; cin &gt;&gt; cst.pid &gt;&gt; cst.k; idxC[cst.pid] = i; for(int j = 0; j &lt; cst.k; j++) &#123; int x; cin &gt;&gt; x; cst.cTopics.push_back(idxT[x]); &#125; custs.push_back(cst); &#125; // finished input data for(timing = 0; timing &lt; MAXTIME; timing++) &#123; buf.clear(); // check busy of each custs for(int i = 0; i &lt; m; i++) &#123; if(!custs[i].busy) &#123; for(int j = 0; j &lt; custs[i].k; j++) &#123; int tp = custs[i].cTopics[j]; if(can_assign(tp, timing)) &#123; // assign tp to custs[i] if(!buf.count(tp)) buf[tp] = vector&lt;Cust&gt; (); buf[tp].push_back(custs[i]); break; &#125; &#125; &#125; &#125; // check buf for(mv it = buf.begin(); it != buf.end(); it++) &#123; sort(it-&gt;second.begin(), it-&gt;second.end()); int c = idxC[it-&gt;second[0].pid]; custs[c].busy = 1; custs[c].last = timing; custs[c].handle = it-&gt;first; topics[it-&gt;first].num--; &#125; // update custs dtime for(int i = 0; i &lt; m; i++) &#123; if(custs[i].busy) custs[i].dtime++; int tp = custs[i].handle; if(custs[i].busy &amp;&amp; custs[i].dtime == topics[tp].t) &#123; custs[i].busy = 0; custs[i].dtime = 0; &#125; &#125; // check finished int finished = 1; for(int i = 0; i &lt; n; i++) &#123; if(topics[i].num &gt; 0) &#123; finished = 0; break; &#125; &#125; for(int i = 0; i &lt; m; i++) &#123; if(custs[i].busy &gt; 0) &#123; finished = 0; break; &#125; &#125; if(finished) break; // timing loop finished! &#125; printf(\"Scenario %d: All requests are serviced within %d minutes.\\n\", ++kase, timing + 1); // while finished! &#125;&#125; solution 2：离散跳转 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180//// main.cpp// LA5222B//// Created by zhangmin chen on 2019/5/10.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const int inf = 0x3f3f3f3f;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;class Topic &#123;public: int t; queue&lt;int&gt; table; Topic(int t_) &#123; t = t_; while (!table.empty()) &#123; table.pop(); &#125; &#125; Topic() &#123; t = 0; while (!table.empty()) &#123; table.pop(); &#125; &#125;&#125;;class Person &#123;public: int pid, k; vector&lt;int&gt; tids; int last, endT; bool operator&lt; (const Person&amp; rhs) const &#123; if(last != rhs.last) return last &lt; rhs.last; return pid &lt; rhs.pid; &#125;&#125;;int N, M;map&lt;int, Topic&gt; topics;vector&lt;Person&gt; persons;void init() &#123; topics.clear(); persons.clear();&#125;/* * int timing = min &#123;all_t0&#125; while(N) &#123; int jump = inf; // update jump through nxt for(p = all persons) int nxt = inf update(nxt) jump = min(jump, nxt) timing = jump &#125; */void assign(Person&amp; p, int&amp; nxt, int&amp; ans, int timing) &#123; // default: p.endT &lt; timing _for(i, 0, p.k) &#123; // id = p.tids[i] Topic&amp; tp = topics[p.tids[i]]; if(tp.table.empty()) continue; // nxt = latest topic time nxt = min(nxt, tp.table.front()); if(tp.table.front() &lt;= timing) &#123; // assign the topic nxt = timing + tp.t; ans = max(ans, nxt); p.last = timing; tp.table.pop(); if(tp.table.empty()) N--; break; &#125; &#125; p.endT = nxt;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 1; while (cin &gt;&gt; N &amp;&amp; N) &#123; init(); int timing = inf, ans = 0; _for(i, 0, N) &#123; int tid, num, t0, t, dt; cin &gt;&gt; tid &gt;&gt; num &gt;&gt; t0 &gt;&gt; t &gt;&gt; dt; timing = min(timing, t0); Topic tp(t); while(num--) &#123; // tp.table.push(t0); t0 += dt; &#125; topics[tid] = tp; &#125; cin &gt;&gt; M; persons.resize(M); _for(i, 0, M) &#123; cin &gt;&gt; persons[i].pid &gt;&gt; persons[i].k; persons[i].tids.resize(persons[i].k); _for(j, 0, persons[i].k) &#123; cin &gt;&gt; persons[i].tids[j]; &#125; &#125; // we get all data while(N) &#123; int jump = inf; sort(persons.begin(), persons.end()); for(auto&amp; p : persons) &#123; int nxt = inf; // update(nxt), assigned the project // if can assign? else ? if(p.endT &gt; timing) &#123; nxt = p.endT; &#125; else &#123; assign(p, nxt, ans, timing); &#125; jump = min(jump, nxt); // for p loop finished; &#125; timing = jump; // while N loop finished &#125; printf(\"Scenario %d: All requests are serviced within %d minutes.\\n\", kase++, ans); &#125;&#125; STL高级排序：地图的放大和缩小有的时候我们需要根据外关键字，对结构体排序 1234class Map &#123;&#125;;Map mp;vector&lt;Map&gt; maps;mps.push_back(mp); 我们需要根据外部的location，和mp.center的相对距离进行排序其中location并不是Map的成员函数这个时候cmp的写法 123456789101112131415161718192021222324252627for i = 0 to maps.size() if Area in map[i] mapID.push_back(i);check:for i = 0 to mapID.size() get maps[mapID[i]]; class Cmp &#123;public: Point loc; bool operator() (int lhs, int rhs) &#123; const Map&amp; m1 = maps[lhs]; const Map&amp; m2 = maps[rhs]; int d = Minus(dist(loc, m1.center), dist(loc, m2.center)) // |loc - map.center| 值大的放在前面，默认m1 &gt; m2 // 如果m1 &gt; m2, 不改变位置 if(d &gt; 0) return true; if(d &lt; 0) return false; &#125;&#125;;Cmp cmp;sort(mapID.begin(), mapID.end(), cmp); 其中cmp结构体，重载了()运算符operator() 返回true，不换位置，返回false，互换位置 另外一般意义的写法：123456bool cmp(Student&amp; s1, Student&amp; s2) &#123; if(s1.score != s2.score) return s1.score &gt; s2.score; else return strcmp(s1.name, s2.name);&#125;// 默认s1在s2前面 并列情况的处理先获取一个排名vector&amp; rankif score[i-1] &lt; score[i], rank[i]++ 然后把排名转换成索引, 查找rk对应的idint p = upper_bound(rank.begin(), rank.end(), rk) - rank.begin()Map&amp; res = maps[mapID[p-1]] 最后关于排名转换成索引的问题见level和id的图如下所示 代码实现方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245//// main.cpp// LA5197//// Created by zhangmin chen on 2019/5/11.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;const double eps = 1e-7;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;class Point &#123;public: double x, y; Point(double x_ = 0.0, double y_ = 0.0) : x(x_), y(y_) &#123;&#125; &#125;;Point operator+ (const Point&amp; lhs, const Point&amp; rhs) &#123; return Point(lhs.x + rhs.x, lhs.y + rhs.y);&#125;Point operator- (const Point&amp; lhs, const Point&amp; rhs) &#123; return Point(lhs.x - rhs.x, lhs.y - rhs.y);&#125;Point operator* (const Point&amp; lhs, double p) &#123; return Point(lhs.x * p, lhs.y * p);&#125;istream&amp; operator&gt;&gt; (istream&amp; is, Point&amp; rhs) &#123; return is &gt;&gt; rhs.x &gt;&gt; rhs.y;&#125;double dist(const Point&amp; lhs, const Point&amp; rhs) &#123; double tmp = (lhs.x - rhs.x) * (lhs.x - rhs.x) + (lhs.y - rhs.y) * (lhs.y - rhs.y); return sqrt(tmp);&#125;int Minus_(double x) &#123; // if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;int Minus(double x, double y) &#123; return Minus_(x - y);&#125;bool inRange(double x, double left, double right) &#123; // if(Minus(left, right) &gt; 0) return inRange(x, right, left); return Minus(left, x) &lt;= 0 &amp;&amp; Minus(x, right) &lt;= 0;&#125;bool inArea(const Point&amp; p, const Point&amp; lhs, const Point&amp; rhs) &#123; return inRange(p.x, lhs.x, rhs.x) &amp;&amp; inRange(p.y, rhs.y, lhs.y); // made a bug here&#125;class Map &#123;public: string name; Point p1, p2, center, corner; double width, height, area, ratio, minx; Map(string name_, Point p1_, Point p2_) &#123; name = name_; p1 = p1_; p2 = p2_; center = (p1 + p2) * .5; width = fabs(p1.x - p2.x); height = fabs(p1.y - p2.y); ratio = fabs(height / width - 0.75); area = width * height; corner = Point(center.x + width / 2, center.y - height / 2); minx = center.x - width / 2; &#125;&#125;;vector&lt;Map&gt; map_s;map&lt;string, Point&gt; locats;class Cmp &#123;public: Point loc; bool operator() (int lhs, int rhs) &#123; // const Map&amp; m1 = map_s[lhs]; const Map&amp; m2 = map_s[rhs]; int d; d = Minus(m1.area, m2.area); if(d &gt; 0) return true; if(d &lt; 0) return false; d = Minus(dist(m1.center, loc), dist(m2.center, loc)); if(d &gt; 0) return true; if(d &lt; 0) return false; d = Minus(m1.ratio, m2.ratio); if(d &gt; 0) return true; if(d &lt; 0) return false; d = Minus(dist(loc, m1.corner), dist(loc, m2.corner)); if(d &lt; 0) return true; if(d &gt; 0) return false; d = Minus(m1.minx, m2.minx); if(d &gt; 0) return true; if(d &lt; 0) return false; return false; &#125;&#125;;void getMapLevel(const Point pt, vector&lt;int&gt;&amp; level, vector&lt;int&gt;&amp; id) &#123; // id.clear(); Cmp cmp; cmp.loc = pt; _for(i, 0, map_s.size()) &#123; const Map&amp; mp = map_s[i]; if(inArea(pt, mp.p1, mp.p2)) &#123; id.push_back(i); // debug(inArea(pt, mp.p1, mp.p2)); &#125; &#125; sort(id.begin(), id.end(), cmp); level.clear(); level.assign(id.size(), 1); _for(i, 1, id.size()) &#123; const Map&amp; m1 = map_s[id[i-1]]; const Map&amp; m2 = map_s[id[i]]; level[i] = level[i-1]; int d = Minus(m2.area, m1.area); if(d &lt; 0) level[i]++; &#125;&#125;void solve(const string&amp; name, int lv) &#123; // // vector&lt;int&gt; levels; cout &lt;&lt; name &lt;&lt; \" at detail level \" &lt;&lt; lv; if(!locats.count(name)) &#123; cout &lt;&lt; \" unknown location\" &lt;&lt; endl; return; &#125; vector&lt;int&gt; ID, levels; getMapLevel(locats[name], levels, ID); if(ID.empty()) &#123; cout &lt;&lt; \" no map contains that location\" &lt;&lt; endl; return; &#125; int maxlv = levels.back(); // debug(maxlv); if(maxlv &lt; lv) &#123; // cout &lt;&lt; \" no map at that detail level; using \" &lt;&lt; map_s[ID.back()].name &lt;&lt; endl; &#125; else &#123; // int p = (int)(upper_bound(levels.begin(), levels.end(), lv) - levels.begin()); cout &lt;&lt; \" using \" &lt;&lt; map_s[ID[p-1]].name &lt;&lt; endl; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string buf; getline(cin, buf); while (true) &#123; string name; cin &gt;&gt; name; if(name == \"LOCATIONS\") break; Point p1_, p2_; cin &gt;&gt; p1_ &gt;&gt; p2_; // cout &lt;&lt; p1_.x &lt;&lt; \" \" &lt;&lt; p1_.y &lt;&lt; \" \" &lt;&lt; p2_.x &lt;&lt; \" \" &lt;&lt; p2_.y &lt;&lt; endl; Map mp(name, p1_, p2_); map_s.push_back(mp); &#125; while(true) &#123; string name; cin &gt;&gt; name; if(name == \"REQUESTS\") break; Point pt; cin &gt;&gt; pt; locats[name] = pt; &#125; //_for(i, 0, map_s.size()) cout &lt;&lt; map_s[i].name &lt;&lt; \" \" &lt;&lt; map_s[i].p1.x &lt;&lt; endl; while (true) &#123; string name; cin &gt;&gt; name; if(name == \"END\") break; int lv; cin &gt;&gt; lv; solve(name, lv); &#125; return 0;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"算法竞赛中常用的c++ stl技巧","slug":"20190421","date":"2019-04-21T13:23:37.000Z","updated":"2019-07-18T07:47:11.412Z","comments":true,"path":"2019/04/21/20190421/","link":"","permalink":"https://www.fogsail.net/2019/04/21/20190421/","excerpt":"这篇文章主要针对一些复杂的模拟题，给出stl处理模拟题的一些思路以及一部分模版","text":"这篇文章主要针对一些复杂的模拟题，给出stl处理模拟题的一些思路以及一部分模版 栈，队列与优先队列求抽象数据结构的ID(), 并且构建map映射策略1：线程池MemPool策略2：用vector.size()值作为哈希 相关的实现如下： The SetStack Computer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//// main.cpp// LA3634//// Created by zhangmin chen on 2019/4/21.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)template &lt;typename T&gt;class MemPool &#123;public: vector&lt;T*&gt; buf; T* create() &#123; buf.push_back(new T()); return buf.back(); &#125; void dispose() &#123; for(int i = 0; i &lt; buf.size(); i++) delete buf[i]; buf.clear(); &#125;&#125;;map&lt;set&lt;int&gt;, int&gt; IDCache;vector&lt;set&lt;int&gt; &gt; setCache;MemPool&lt;set&lt;int&gt; &gt; pool;void fresh() &#123; IDCache.clear(); setCache.clear();&#125;int ID(const set&lt;int&gt;&amp; st) &#123; if(IDCache.count(st)) return IDCache[st]; setCache.push_back(st); return IDCache[st] = (int)setCache.size() - 1;&#125;// importantvoid solve() &#123; stack&lt;int&gt; stk; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; string cmd; cin &gt;&gt; cmd; if(cmd[0] == 'P') &#123; set&lt;int&gt; cur = *(pool.create()); int pid = ID(cur); stk.push(pid); &#125; else if (cmd[0] == 'D') &#123; stk.push(stk.top()); &#125; else &#123; set&lt;int&gt; st1 = setCache[stk.top()]; stk.pop(); set&lt;int&gt; st2 = setCache[stk.top()]; stk.pop(); set&lt;int&gt; combine; if(cmd[0] == 'U') set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(combine, combine.begin())); if(cmd[0] == 'I') set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(combine, combine.begin())); if(cmd[0] == 'A') &#123; combine = st2; combine.insert(ID(st1)); &#125; stk.push(ID(combine)); &#125; cout &lt;&lt; setCache[stk.top()].size() &lt;&lt; endl; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; cin &gt;&gt; kase; while(kase--) &#123; solve(); printf(\"***\\n\"); pool.dispose(); &#125;&#125; 大整数类BigIntegerA + B Problem II 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string.h&gt;using namespace std;typedef long long llong;struct BigInteger&#123; static const int BASE = 100000000; static const int WIDTH = 8; vector&lt;int&gt; bit; BigInteger(llong num = 0) &#123; *this = num; &#125; BigInteger operator= (llong num)&#123; bit.clear(); do&#123; bit.push_back(num % BASE); num /= BASE; &#125;while(num &gt; 0); return *this; &#125; BigInteger operator= (const string&amp; str)&#123; bit.clear(); int x; int len = (str.length()-1)/WIDTH + 1; for(int i = 0; i &lt; len; i++)&#123; int end = str.length()-i*WIDTH; //end :[start..end-1] end empty int start = max(0,end-WIDTH); sscanf(str.substr(start,end-start).c_str(),\"%d\",&amp;x); bit.push_back(x); &#125; return *this; &#125; BigInteger operator+ (const BigInteger&amp; b) const&#123; BigInteger sum; sum.bit.clear(); for(int i = 0, carry = 0; ;i++)&#123; if(carry == 0 &amp;&amp; i &gt;= bit.size() &amp;&amp; i &gt;= b.bit.size()) break; int x = carry; if(i &lt; bit.size()) x += bit[i]; if(i &lt; b.bit.size()) x += b.bit[i]; sum.bit.push_back(x % BASE); carry = x / BASE; &#125; return sum; &#125; BigInteger operator+= (const BigInteger&amp; b)&#123; *this = *this + b; return *this; &#125; bool operator &lt; (const BigInteger&amp; b) const &#123; if(bit.size() != b.bit.size()) return bit.size() &lt; b.bit.size(); for(int i = bit.size()-1; i &gt;= 0; i--)&#123; if(bit[i] != b.bit[i]) return bit[i] &lt; b.bit[i]; &#125; return false; &#125;&#125;;ostream&amp; operator&lt;&lt; (ostream &amp;out, const BigInteger&amp; x)&#123; out &lt;&lt; x.bit.back(); for(int i = x.bit.size()-2; i &gt;= 0; i--)&#123; char buffer[20]; sprintf(buffer,\"%08d\",x.bit[i]); for(int j = 0; j &lt; strlen(buffer); j++) out &lt;&lt; buffer[j]; &#125; return out;&#125;istream&amp; operator&gt;&gt; (istream &amp;in, BigInteger&amp; x)&#123; string s; if(!(in &gt;&gt; s)) return in; x = s; return in;&#125;int main()&#123; int kase, pid = 0; cin &gt;&gt; kase; while(kase--)&#123; BigInteger a,b; cin &gt;&gt; a &gt;&gt; b; printf(\"Case %d:\\n\",++pid); cout &lt;&lt; a &lt;&lt; \" + \" &lt;&lt; b &lt;&lt; \" = \" &lt;&lt; a+b &lt;&lt; endl; if(kase != 0) printf(\"\\n\"); &#125;&#125; 大整数的加减乘除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337//// main.cpp// week4V7//// Created by zhangmin chen on 2019/5/1.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;class BigInt &#123; string val; bool flag; inline int cmp(string s1, string s2) &#123; if(s1.size() &lt; s2.size()) return -1; else if(s1.size() &gt; s2.size()) return 1; else return s1.compare(s2); &#125; public: BigInt() : val(\"0\"), flag(true) &#123;&#125; BigInt(string str) &#123; val = str; flag = true; &#125; friend ostream&amp; operator&lt;&lt; (ostream&amp; os, const BigInt&amp; rhs); friend istream&amp; operator&gt;&gt; (istream&amp; is, BigInt&amp; rhs); BigInt operator+ (const BigInt&amp; rhs); BigInt operator- (const BigInt&amp; rhs); BigInt operator* (const BigInt&amp; rhs); BigInt operator/ (const BigInt&amp; rhs);&#125;;ostream&amp; operator&lt;&lt; (ostream&amp; os, const BigInt&amp; rhs) &#123; if(!rhs.flag) os &lt;&lt; \"-\"; os &lt;&lt; rhs.val; return os;&#125;istream&amp; operator&gt;&gt; (istream&amp; is, BigInt&amp; rhs) &#123; string str; is &gt;&gt; str; rhs.flag = true; rhs.val = str; return is;&#125;BigInt BigInt::operator+ (const BigInt&amp; rhs) &#123; BigInt ret; ret.flag = true; string lval(val), rval(rhs.val); if(lval == \"0\") &#123; ret.val = rval; return ret; &#125; if(rval == \"0\") &#123; ret.val = lval; return ret; &#125; int lsize = (int) lval.size(); int rsize = (int) rval.size(); if(lsize &lt; rsize) &#123; // for(int i = 0; i &lt; rsize - lsize; i++) &#123; lval = \"0\" + lval; &#125; &#125; else &#123; for(int i = 0; i &lt; lsize - rsize; i++) &#123; rval = \"0\" + rval; &#125; &#125; // then we finished alignment int bit, carry = 0; string res = \"\"; reverse(lval.begin(), lval.end()); reverse(rval.begin(), rval.end()); for(int i = 0; i &lt; lval.size(); i++) &#123; // bit = (carry + lval[i] - '0' + rval[i] - '0') % 10; carry = (carry + lval[i] - '0' + rval[i] - '0') / 10; res = res + char(bit + '0'); &#125; if(carry == 1) res = res + \"1\"; reverse(res.begin(), res.end()); ret.val = res; return ret;&#125;BigInt BigInt::operator-(const BigInt &amp;rhs) &#123; // BigInt ret; string lval(val), rval(rhs.val); if(rval == \"0\") &#123; ret.val = lval; ret.flag = true; return ret; &#125; if(lval == \"0\") &#123; ret.val = rval; ret.flag = false; return ret; &#125; int lsize = (int) lval.size(); int rsize = (int) rval.size(); if(lsize &lt; rsize) &#123; for(int i = 0; i &lt; rsize - lsize; i++) &#123; lval = \"0\" + lval; &#125; &#125; else &#123; for(int i = 0; i &lt; lsize - rsize; i++) &#123; rval = \"0\" + rval; &#125; &#125; // then we finished alignment int t = lval.compare(rval); // lval &lt; rval, -1 // lval &gt; rval, 1 if(t &lt; 0) &#123; ret.flag = false; string tmp = lval; lval = rval; rval = tmp; &#125; else if(t == 0) &#123; ret.val = \"0\"; ret.flag = true; return ret; &#125; else &#123; ret.flag = true; &#125; // default: lval &gt; rval reverse(lval.begin(), lval.end()); reverse(rval.begin(), rval.end()); string res = \"\"; int load; for(int i = 0; i &lt; lval.size(); i++) &#123; if(lval[i] &lt; rval[i]) &#123; load = 1; while (lval[i+load] == '0') &#123; lval[i+load] = '9'; load++; &#125; lval[i+load]--; res = res + char(lval[i] - rval[i] + ':'); &#125; else &#123; res = res + char(lval[i] - rval[i] + '0'); &#125; &#125; reverse(res.begin(), res.end()); res.erase(0, res.find_first_not_of('0')); ret.val = res; return ret;&#125;BigInt BigInt::operator* (const BigInt&amp; rhs) &#123; BigInt ret; string lval(val), rval(rhs.val); if(lval == \"0\" || rval == \"0\") &#123; ret.val = \"0\"; ret.flag = true; return ret; &#125; int lsize = (int)lval.size(); int rsize = (int)rval.size(); // default : lval.size() &gt; rval.size() if(lval &lt; rval) &#123; string tmp = lval; lval = rval; rval = tmp; lsize = (int)lval.size(); rsize = (int)rval.size(); &#125; reverse(lval.begin(), lval.end()); reverse(rval.begin(), rval.end()); string ans; BigInt res, tmp; for(int i = 0; i &lt; rval.size(); i++) &#123; // ans = \"\"; int carry = 0, bt = 0, rv = 0; for(int j = 0; j &lt; i; j++) ans = ans + \"0\"; rv = rval[i] - '0'; for(int k = 0; k &lt; lval.size(); k++) &#123; int t = (rv * (lval[k] - '0') + carry); carry = t / 10; bt = t % 10; ans = ans + char(bt + '0'); &#125; if(carry) ans = ans + char(carry + '0'); reverse(ans.begin(), ans.end()); tmp.val = ans; res = res + tmp; &#125; ret = res; return ret;&#125;BigInt BigInt::operator/ (const BigInt &amp;rhs) &#123; // BigInt ret; string lval(val), rval(rhs.val); string quat; if(rval == \"0\") &#123; ret.val = \"error\"; ret.flag = true; return ret; &#125; if(lval == \"0\") &#123; ret.val = \"0\"; ret.flag = true; return ret; &#125; if(cmp(lval, rval) &lt; 0) &#123; // ret.val = \"0\"; ret.flag = true; return ret; &#125; else if(cmp(lval, rval) == 0) &#123; ret.val = \"1\"; ret.flag = true; return ret; &#125; else &#123; // // default: lval &gt; rval int lsize = (int)lval.size(); int rsize = (int)rval.size(); string tmp; if(rsize &gt; 1) tmp.append(lval, 0, rsize-1); for(int i = rsize - 1; i &lt; lsize; i++) &#123; tmp = tmp + lval[i]; for(char c = '9'; c &gt;= '0'; c--) &#123; // BigInt t = (BigInt) rval * (BigInt)string(1, c); BigInt mod = (BigInt) tmp - t; if(mod.flag == true) &#123; quat = quat + c; tmp = mod.val; break; &#125; &#125; &#125; &#125; quat.erase(0, quat.find_first_not_of('0')); ret.val = quat; ret.flag = true; return ret;&#125;int main() &#123; // freopen(\"input.txt\", \"r\", stdin); BigInt a, b, result; char op; cin &gt;&gt; a &gt;&gt; op &gt;&gt; b; switch(op) &#123; case '+': result = a + b; break; case '-': result = a - b; break; case '*': result = a * b; break; case '/': result = a / b; break; default: break; &#125; cout &lt;&lt; result &lt;&lt; endl;&#125; map等stl高级用法Database 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//// main.cpp// LA4592//// Created by zhangmin chen on 2019/4/24.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)typedef pair&lt;int, int&gt; pii;int m, n;map&lt;string, int&gt; idx;const int maxr = 10000 + 10;const int maxc = 100 + 10;int db[maxr][maxc], cnt = 0;void init() &#123; memset(db, 0, sizeof(db)); idx.clear();&#125;int getID(const string&amp; str) &#123; if(!idx.count(str)) return idx[str] = ++cnt; return idx[str];&#125;void solve() &#123; for(int c1 = 0; c1 &lt; m; c1++) for(int c2 = c1+1; c2 &lt; m; c2++) &#123; map&lt;pii, int&gt; group; // group[c1, c2] = ith row // const pii&amp; pr = make_pair(); for(int i = 0; i &lt; n; i++) &#123; // group[(i,c1), (i,c2)] = ith row const pii&amp; pr = make_pair(db[i][c1], db[i][c2]); if(group.count(pr)) &#123; // printf(\"NO\\n\"); printf(\"%d %d\\n\", group[pr]+1, i+1); printf(\"%d %d\\n\", c1+1, c2+1); return; &#125; group[pr] = i; &#125; &#125; printf(\"YES\\n\"); return;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(cin &gt;&gt; n &gt;&gt; m) &#123; init(); string str; getline(cin, str); for(int i = 0; i &lt; n; i++) &#123; getline(cin, str); // cout &lt;&lt; str &lt;&lt; endl; // split by ',' int k = -1; for(int j = 0; j &lt; m; j++) &#123; int p = (int)str.find(',', k+1); if(p == string::npos) p = (int)str.length(); int hashv = getID(str.substr(k+1, p-k-1)); db[i][j] = hashv; k = p; // db[i][j] = hash(substr) &#125; &#125; // get data finished! // then we solve the problem solve(); &#125;&#125; 复杂模拟：比赛排名，并列情况有一类模拟题比较复杂，涉及以下情形1、比赛成绩有并列情况；2、比赛涉及到奖金发放，业余选手不得奖金 PGA Tour Prize Money 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329//// main.cpp// PGA//// Created by zhangmin chen on 2019/4/26.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)// const int maxn = 145;const int przn = 70;class Player &#123;public: string name; double prize; bool amat; bool t; int rnd[4]; int dq; int rank; int pre, tot; // pre used to decide which one can be in round[3, 4], make the cut // tot used to divide money // only made the cut plyer can get money // divide prize: // 1 parallel // 2 amt don't get prize // 3 get prize? Not amter &amp;&amp; rank[1,70] // DQ: // 1 DQ &gt; 2, plyer can make the cut // 2 but not rank in rnd[3,4] // make the cut: // DQ == 0 || DQ &gt; 2 ---&gt; make the cut // rank: // only DQ == 0 rank Player() &#123; name.clear(); prize = 0.0; amat = t = false; memset(rnd, 0, sizeof(rnd)); dq = 4; rank = 0; pre = tot = 0; &#125; void init() &#123; prize = 0.0; amat = t = false; memset(rnd, 0, sizeof(rnd)); dq = 4; rank = 0; pre = tot = 0; &#125;&#125;;int n;vector&lt;Player&gt; plyers;double priz[przn];double sum;int str2num(const string&amp; str) &#123; int val = 0; for(int i = 0; i &lt; str.length(); i++) &#123; val = val * 10 + str[i] - '0'; &#125; //debug(val); return val;&#125;void init() &#123; // //for(int i = 0; i &lt; n; i++) plyers[i].init(); plyers.clear(); memset(priz, 0, sizeof(priz)); scanf(\"%lf\", &amp;sum); for(int i = 0; i &lt; 70; i++) &#123; scanf(\"%lf\", &amp;priz[i]); priz[i] = priz[i] / 100.0 * sum; &#125;&#125;void initPlyer() &#123; //scanf(\"%d\", &amp;n); cin &gt;&gt; n; plyers.resize(n+1); string str; getline(cin, str); for(int i = 0; i &lt; n; i++) &#123; plyers[i].tot = 0; getline(cin, str); plyers[i].name = str.substr(0, 20); str = str.substr(20); if(plyers[i].name.find('*') != string::npos) &#123; plyers[i].amat = true; &#125; stringstream ss(str); //string data; // is &gt;&gt; data for(int j = 0; j &lt; 4; j++) &#123; string data; ss &gt;&gt; data; if(data == \"DQ\") &#123; plyers[i].dq = j; break; &#125; else &#123; plyers[i].rnd[j] = str2num(data); &#125; if(j &lt; 2) &#123; plyers[i].pre += str2num(data); &#125; plyers[i].tot += str2num(data); &#125; // debug(\"----\"); &#125;&#125;bool cmp1(const Player&amp; lhs, const Player&amp; rhs) &#123; if(lhs.dq &gt; 1 &amp;&amp; rhs.dq &gt; 1) return lhs.pre &lt; rhs.pre; return lhs.dq &gt; rhs.dq;&#125;int makeCut() &#123; sort(plyers.begin(), plyers.begin() + n, cmp1); int pos = 0; while (pos &lt; min(70, n) &amp;&amp; plyers[pos].dq &gt; 1) &#123; pos++; &#125; // [0, 69] --&gt; 70 while (plyers[pos].dq &gt; 1 &amp;&amp; plyers[pos].pre == plyers[pos-1].pre) &#123; pos++; &#125; return pos;&#125;// usage: int pos = makeCut// getRank(pos)bool cmp2(const Player&amp; lhs, const Player&amp; rhs) &#123; if(lhs.dq != rhs.dq) return lhs.dq &gt; rhs.dq; if(lhs.tot != rhs.tot) return lhs.tot &lt; rhs.tot; return lhs.name &lt; rhs.name;&#125;// important!// difficult: parallel situationvoid getRank(int num) &#123; // sort(plyers.begin(), plyers.begin() + num, cmp2); // divide money // 1. parallel // 2. amte cannot get money // no amte and rank from [0, 70] // now: plyers[0...num-1] int k = 0, rkp = 0; int rk = 0; while(k &lt; num) &#123; if(plyers[k].dq &lt; 4) break; // parallel: [k, p) rank: rk int p = k, cnt = 0; double sum = 0.0; int prll = 0; while(plyers[p].dq == 4 &amp;&amp; plyers[p].tot == plyers[k].tot) &#123; // if(!plyers[p].amat) &#123; // sum += priz[rkp + cnt]; cnt++; // &#125; p++; prll++; &#125; sum /= cnt; // assign prize: for(int i = k; i &lt; p; i++) &#123; plyers[i].rank = rk + 1; // prize is not enough if(rkp &gt; 69) &#123; plyers[i].amat = true; plyers[i].t = false; &#125; if(!plyers[i].amat) &#123; plyers[i].prize = sum; plyers[i].t = cnt &gt; 1; &#125; &#125; // [k, p) rank: rk // rk [0, 70) // [p, ...) rank: rk += cnt // plyers[].rank = rk + 1; k = p; rkp += cnt; rk += prll; &#125; &#125;void printAns(int num) &#123; // printf(\"Player Name Place RD1 RD2 RD3 RD4 TOTAL Money Won\\n\"); printf(\"-----------------------------------------------------------------------\\n\"); for(int i = 0; i &lt; num; i++) &#123; printf(\"%-21s\", plyers[i].name.c_str()); if(plyers[i].dq &lt; 4) printf(\" \"); else &#123; char t[5]; sprintf(t, \"%d%c\", plyers[i].rank, plyers[i].t ? 'T' : ' '); printf(\"%-10s\", t); &#125; for(int j = 0; j &lt; plyers[i].dq; j++) printf(\"%-5d\", plyers[i].rnd[j]); for(int j = plyers[i].dq; j &lt; 4; j++) printf(\" \"); if(plyers[i].dq &lt; 4) printf(\"DQ\"); else if(!plyers[i].amat) printf(\"%-10d\", plyers[i].tot); else printf(\"%d\", plyers[i].tot); if(plyers[i].dq &lt; 4 || plyers[i].amat) &#123; printf(\"\\n\"); continue; &#125; printf(\"$%9.2lf\\n\", plyers[i].prize); //int ans = floor((plyers[i].prize + 0.0050001) * 100); //plyers[i].prize = ans / 100.0; //cout.setf(ios::right); //cout &lt;&lt; \"$\" &lt;&lt; setw(9) &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; plyers[i].prize &lt;&lt; endl; //int ans = (int)((plyers[i].prize + 0.0005) * 10000); //printf(\"$%9.2lf\\n\", ans / 1000.0); &#125; &#125;// attend rnd[3,4], we need plyer.dq &gt; 2int main() &#123; freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout); int kase; scanf(\"%d\", &amp;kase); while(kase--) &#123; init(); // get prize data initPlyer(); int num = makeCut(); getRank(num); printAns(num); if(kase) printf(\"\\n\"); &#125;&#125; map和vector联用：邮件接收系统The Letter Carrier’s Rounds scanf之后把回车“吃掉”的几种方法推荐方法： 1234scanf(\"%d%*c\", &amp;kase);while(kase--) &#123; getline(cin, line);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//// main.cpp// MTA//// Created by zhangmin chen on 2019/4/30.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;typedef set&lt;string&gt;::iterator ssii;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)#define debugS(str) cout &lt;&lt; \"dbg: \" &lt;&lt; str &lt;&lt; endl;void getAddr(const string&amp; str, string&amp; user, string&amp; mta) &#123; int k = (int)str.find('@'); user = str.substr(0, k); mta = str.substr(k+1);&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string str; string mta; int k; string to; string mtaF, mtaT, userF, userT; set&lt;string&gt; emails; while(cin &gt;&gt; str &amp;&amp; str[0] != '*') &#123; cin &gt;&gt; mta &gt;&gt; k; // string to; while (k--) &#123; // add all address cin &gt;&gt; to; emails.insert(to + \"@\" + mta); &#125; &#125; // then get all mta // for(auto&amp; i : emails) cout &lt;&lt; i &lt;&lt; endl; // for(ssii i = emails.begin(); i != emails.end(); i++) cout &lt;&lt; *i &lt;&lt; endl; // we finished all mta input while(cin &gt;&gt; str &amp;&amp; str != \"*\") &#123; getAddr(str, userF, mtaF); set&lt;string&gt; vis; map&lt;string, vector&lt;string&gt; &gt; clents; // clents: clients[mtaT] = &#123;usr1, usr2,...&#125; vector&lt;string&gt; mtaWt; while(cin &gt;&gt; to &amp;&amp; to != \"*\") &#123; // get All mta // cout &lt;&lt; \"dbg: \" &lt;&lt; to &lt;&lt; endl; //debugS(to); getAddr(to, userT, mtaT); if(vis.count(to)) continue; vis.insert(to); if(!clents.count(mtaT)) &#123; mtaWt.push_back(mtaT); clents[mtaT] = vector&lt;string&gt;(); &#125; clents[mtaT].push_back(to); &#125; // get all clients // connection between mtaF --&gt; &#123;mtaWt[0], mtaWt[1]...&#125; getline(cin, to); string data; while (getline(cin, to) &amp;&amp; to[0] != '*') &#123; data += \" \" + to + \"\\n\"; // cout &lt;&lt; data &lt;&lt; endl; &#125; // cout &lt;&lt; data; // msg finished! // send msg: mails from str // send to: // for all mtaWt // vector&lt;stirng&gt; usr = clents[mtaWt[i]] // str -&gt; &#123; usr[0], usr[1]...&#125; for(int i = 0; i &lt; mtaWt.size(); i++) &#123; string mta2 = mtaWt[i]; vector&lt;string&gt; usrs = clents[mta2]; cout &lt;&lt; \"Connection between \" &lt;&lt; mtaF &lt;&lt; \" and \" &lt;&lt; mta2 &lt;&lt; endl; cout &lt;&lt; \" HELO \" &lt;&lt; mtaF &lt;&lt; endl; cout &lt;&lt; \" 250\\n\"; cout &lt;&lt; \" MAIL FROM:&lt;\" &lt;&lt; str &lt;&lt; \"&gt;\\n\"; cout &lt;&lt; \" 250\\n\"; bool canSend = false; for(int j = 0; j &lt; usrs.size(); j++) &#123; cout &lt;&lt; \" RCPT TO:&lt;\" &lt;&lt; usrs[j] &lt;&lt; \"&gt;\\n\"; if(emails.count(usrs[j])) &#123; canSend = true; cout &lt;&lt; \" 250\\n\"; &#125; else cout &lt;&lt; \" 550\\n\"; &#125; if(canSend) &#123; // cout &lt;&lt; \" DATA\\n\"; cout &lt;&lt; \" 354\\n\"; cout &lt;&lt; data; cout &lt;&lt; \" .\\n\"; cout &lt;&lt; \" 250\\n\"; &#125; cout &lt;&lt; \" QUIT\\n\"; cout &lt;&lt; \" 221\\n\"; &#125; // we get all msg, then close connection &#125;&#125; 坐标的离散化Urban Elevations 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//// main.cpp// UrbanElevations//// Created by zhangmin chen on 2019/4/19.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)const int maxn = 100 + 5;int n;class Building &#123;public: int id; double x, y, w, d, h; bool operator &lt; (const Building&amp; rhs) const &#123; // return x &lt; rhs.x || (x == rhs.x &amp;&amp; y &lt; rhs.y); &#125;&#125;;Building blds[maxn];double xv[maxn*2+1];bool buiding_exist(int i, double pos) &#123; if(blds[i].x &lt;= pos &amp;&amp; blds[i].x + blds[i].w &gt;= pos) return true; else return false;&#125;bool visible(int i, double pos) &#123; if(!buiding_exist(i, pos)) return false; for(int k = 0; k &lt; n; k++) &#123; // check other buidings if(!buiding_exist(k, pos)) continue; if(blds[k].y &lt; blds[i].y &amp;&amp; blds[k].h &gt;= blds[i].h) return false; &#125; return true;&#125;int main() &#123; //freopen(\"input.txt\", \"r\", stdin); int kase = 0; while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; for(int i = 0; i &lt; n; i++) &#123; scanf(\"%lf%lf%lf%lf%lf\", &amp;blds[i].x, &amp;blds[i].y, &amp;blds[i].w, &amp;blds[i].d, &amp;blds[i].h); xv[i*2] = blds[i].x; xv[i*2+1] = blds[i].x + blds[i].w; blds[i].id = i+1; &#125; // finished all building data sort(blds, blds+n); sort(xv, xv+n*2); int mx = (int)(unique(xv, xv+n*2) - xv); // check xv[0...mx] if(kase++) printf(\"\\n\"); printf(\"For map #%d, the visible buildings are numbered as follows:\\n\", kase); printf(\"%d\", blds[0].id); for(int i = 1; i &lt; n; i++) &#123; bool ok = false; for(int k = 0; k &lt; mx-1; k++) &#123; // xv[k] int avg = (xv[k] + xv[k+1]) / 2; if(visible(i, avg)) &#123; ok = true; break; &#125; &#125; if(ok) printf(\" %d\", blds[i].id); &#125; printf(\"\\n\"); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"csapp实践（五）：存储器层次结构","slug":"20190403","date":"2019-04-03T11:28:31.000Z","updated":"2019-04-03T11:57:48.131Z","comments":true,"path":"2019/04/03/20190403/","link":"","permalink":"https://www.fogsail.net/2019/04/03/20190403/","excerpt":"存储器层次结构的部分难理解的内容总结如下","text":"存储器层次结构的部分难理解的内容总结如下 存储技术","categories":[{"name":"csapp","slug":"csapp","permalink":"https://www.fogsail.net/categories/csapp/"}],"tags":[{"name":"csapp","slug":"csapp","permalink":"https://www.fogsail.net/tags/csapp/"}]},{"title":"csapp实践（二）：程序的机器级表示","slug":"20190402","date":"2019-04-02T07:28:31.000Z","updated":"2019-04-09T07:02:29.267Z","comments":true,"path":"2019/04/02/20190402/","link":"","permalink":"https://www.fogsail.net/2019/04/02/20190402/","excerpt":"csapp第三章中，对汇编指令的要求比较高这里把常见的指令整理一下","text":"csapp第三章中，对汇编指令的要求比较高这里把常见的指令整理一下 1g++ -Og -S -masm=intel xxx.cpp 得到反汇编文件查阅 程序编码代码示例和解释： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;long mult2(long a, long b) &#123; return a*b;&#125;void multstore(long x, long y, long* des) &#123; long t = mult2(x, y); *des = t;&#125;int main() &#123; long a = 100, b = 150; long dest; multstore(a, b, &amp;dest); cout &lt;&lt; dest &lt;&lt; endl;&#125; 反汇编代码示例：1234567891011121314151617181920212223__Z9multstorellPl: ## @_Z9multstorellPl .cfi_startproc## %bb.0: ## rdx第三个参数，rsi第2个参数，rdi第一个参数 push rbp ## rbp为基指针寄存器(base pointer),存取调用堆栈中的数据 .cfi_def_cfa_offset 16 .cfi_offset rbp, -16 mov rbp, rsp ## rsp为堆栈指针(stack pointer)寄存器，只可访问堆栈顶 .cfi_def_cfa_register rbp push rbx ## rbx操作数寄存器，用来存放运算结果 push rax ## 用来临时存放函数mult2()的返回值，rax一般都是来存放返回值的 .cfi_offset rbx, -24 mov rbx, rdx ## rdx是第三个参数，copy dest to rbx, 最后*dest = mult2(x, y), 要先把dest存储在寄存器中，稍后访问 call __Z5mult2ll mov qword ptr [rbx], rax ## 运行的结果，将mult2(x, y)存入[rbx]即*dest中 add rsp, 8 pop rbx ## 可以这么理解: rbx = rax, rbx may be the left value, rax may be the right value, 一般来说， rax是返回值 pop rbp ## restore rbp ret .cfi_endproc ## -- End function .globl _main ## -- Begin function main .p2align 4, 0x90_main: ## @main 数据传输寄存器第一个参数：rdi， 第二个参数：rsi， 第三个参数：rdx， 第四个参数：rcx 汇编器常见的错误 12movl %rax, %(rsp) ## wrong, it is moveq %rax, %(rsp)movl %eax, %rdx ## 原来应该是movzlq，但是并没有这样的指令，rdx应该对应movq 数据传送示例 1234567char -&gt; intchar类型4字，转int需要符号扩展，4字用movl，这里需要符号扩展用movsblmovsbl (%rdi), %eaxmovl %eax, (%rsi) 123456char -&gt; unsigned同样4字对4字，需要符号扩展movsblmovsbl (%rdi), %eaxmovl %eax, (%rsi) 1234567unsigned char -&gt; long0扩展，转成8字存储，操作的是unsigned char，本来用的是movl, 需要0扩展用movzblmovzbl (%rdi), %eax;movq %rax, (%rsi) 123456int -&gt; char操作数是int, 直接用movl即可, int是4字，存放到eax中movl (%rdi), %eaxmovb %al, (%rsi)char只需要低位的，所以用movb %al, (%rsi) 12345unsigned -&gt; unsigned char操作数unsigned，4字，movl存放在eax中movl (%rdi), %eaxmovb %al, (%rsi) 1234567char -&gt; short需要做符号扩展，并且char要截断，取低位，存放在ax中，本来用movw这里涉及到符号扩展，用movsbwmovsbw (%rdi), %axmovw %ax, (%rsi) 移位操作移位量是由%cl寄存器的低m位决定的，高位会被忽略 1234567891011long shift_left4_rightn(long x, long n) &#123; x &lt;&lt;= 4; x &gt;&gt;= n; return x;&#125;shift_left4_rightn: movq %rdi, %rax salq $4, %rax movl %esi, %ecx ## get n (4 bytes) sarq %cl, %rax ## 本来应该是sarq %ecx, %rax, 因为移位操作取的是低位%cl 特殊的算术操作乘法，乘积低位放在%rax中，高位放在%rdx中除法，需要用到%rdx寄存器来存放参数，商放在%rax中，余数放在%rdx中 控制条件控制实现条件分支1setnle D &lt;-- ~(SF ^ OF) &amp; ~ZF 溢出的处理，用xor，看作是不进位的加法如果有符号溢出，相应的值要变化，比如SF: t &lt; 0溢出的话，要xor OF实际上SF 0-&gt;1 注意跳转指令前面有符号，f8表示符号位是-1，所以是0xd-0x8 1234560xffffff73所代表的跳转值，首先最高位为负值为8位16进制数所以最高位为-16^7-16^7 + 0xfffff73 = -141即为跳转偏移量 跳转指令翻译123456789cmpq xxx1, xxx2jge .L2code....means:if(xxx2 &lt; xxx1) code...else .L2 用条件传送来实现条件分支12345678testq %rdi, %rdicmovns %rdi, %rax## 实现方法：cmovns表示非负数## if( &gt;= 0) rax &lt;-- rdi## 条件中的值为testq %rdi的值，即if(x &gt;= 0) v = x; 用循环来实现条件分支for循环1234567891011fun_a: movl $0, %eax jmp .L5.L6: xorq %rdi, %rax shrq %rdi.L5: testq %rdi, %rdi jne .L6 andl $1, %eax ret 转换成c语言代码，可以发现L5是循环的主体12345678while(%rdi != 0) &#123; .L6&#125;return %eax &amp; 0x1.L6的实现如下val ^= xx &gt;&gt;= 1 该实现如下：12345678long fun_a(unsigned long x) &#123; long val = 0; while(x) &#123; val ^= x; x &gt;&gt;= 1; &#125; return val &amp; 0x1;&#125; 代码功能：奇数个1， 每一位取出来xor，其值还是1偶数个1，每一位取出来，其值是0如果有奇数个1，返回1，偶数个1，返回0 123456789101112fun_b: movl $64, %edx movl $0, %eax.L10: movq $rdi, %rcx andl $1, %ecx addq %rax, %rax orq %rcx, %rax shrq %rdi subq $1, %rdx jne .L10 rep; ret for循环主体12345678910111213subq $1, %rdxeax = val = 0;for(edx = 64; edx != 0; edx--) &#123; .L10&#125;.L10: val in rax tmp = x; tmp &amp;= 1; (tmp in rcx) val &lt;&lt; 1; val |= tmp x &gt;&gt; = 1 综上：123456789long fun_b(unsigned long x) &#123; long val = 0; long i; for(i = 64; i != 0; i--) &#123; val = (x &amp; 0x1) | (val &lt;&lt; 1) x &gt;&gt;= 1; &#125; return val;&#125; 这个代码的作用很有意思如图所示，创造x的镜像 switch语句 12345switch2: addq $1, %rdi cmpq $8, %rdi ja .L2 jmp *.L4(, %rdi, 8) start: rdi+1 $ x+1 = 0 $$ x+1 &gt; 8 \\quad (default) $$ x+1 &lt; 8 $$ x = -1, 0, 1, 2, 3, 4, 5, 6, 7 $ 函数调用过程转移控制函数调用的具体分析如下 stack上的局部存储 寄存器中的局部存储空间 数组的分配和访问定长数组 异质的数据结构，联合，结构体联合123456789101112131415161718typedef union &#123; struct &#123; long u; short v; char w; &#125; t1; struct &#123; int a[2]; char* p; &#125; t2;&#125; u_type;void get(u_type *up, type* dest) &#123; *dest = expr;&#125;// up in %rdi, dest in %rsi 具体的内存分配如下： 数据对齐 数据对齐的时候，start位置必须是类型的整数倍如果不满足，则会填充 这里又一个优化技巧结构体对数据类型进行降序排列 12345678struct P &#123; char* x1; long x2; float x3; int x4; short x5; ...&#125;; 指针与缓冲区溢出 对抗缓冲区溢出攻击 支持变长栈帧123long vframe(long n, long idx, long *q) &#123; long *p[n];&#125;","categories":[{"name":"csapp","slug":"csapp","permalink":"https://www.fogsail.net/categories/csapp/"}],"tags":[{"name":"csapp","slug":"csapp","permalink":"https://www.fogsail.net/tags/csapp/"}]},{"title":"字符串算法：后缀数组与后缀自动机","slug":"20190306","date":"2019-03-06T14:28:31.000Z","updated":"2019-03-06T15:42:26.031Z","comments":true,"path":"2019/03/06/20190306/","link":"","permalink":"https://www.fogsail.net/2019/03/06/20190306/","excerpt":"字符串算法非常常见，并且在一般的算法竞赛中，往往都是以压轴题的形式出现这里先研究字符串和它的子串的一些关系 常用的字符串和它的子串的处理工具主要有后缀数组和后缀自动机","text":"字符串算法非常常见，并且在一般的算法竞赛中，往往都是以压轴题的形式出现这里先研究字符串和它的子串的一些关系 常用的字符串和它的子串的处理工具主要有后缀数组和后缀自动机 后缀数组初步算法思想概述后缀数组的思想理解起来并不复杂具体的见下图： 其中精妙的地方在于：比如后缀$ { a, abra, abracadabra } $都存在a这个前缀，这个时候用基数排序，把频次转换成索引然后跟高考成绩排名一样，依次对字符串排序下来 然后接着处理第二个字符 具体的程序实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//// main.cpp// suffixArray//// Created by zhangmin chen on 2019/2/14.// Copyright © 2019 zhangmin chen. All rights reserved.#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;stdexcept&gt;using namespace std;/* string sort test:int main() &#123; freopen(\"input.txt\", \"r\", stdin); string tmp; vector&lt;string&gt; ans; while(getline(cin, tmp)) &#123; ans.push_back(tmp); &#125; sort(ans.begin(), ans.end()); for(auto&amp; i : ans) cout &lt;&lt; i &lt;&lt; endl;&#125;*/class suffixArray &#123;private: string* str; int N; int lcp(string s, string t) &#123; int len = (int) min(s.length(), t.length()); for(int i = 0; i &lt; len; i++) if(s[i] != t[i]) return i; return len; &#125; public: suffixArray(string text) &#123; // N = (int)text.length(); str = new string[N+1]; for(int i = 0; i &lt; N; i++) str[i] = text.substr(i); sort(str, str+N); &#125; ~suffixArray() &#123; delete[] str; &#125; int length() &#123; return N; &#125; string select(int i) &#123; return str[i]; &#125; int index(int i) &#123; return (int) (N - str[i].length()); &#125; int lcp(int i) &#123; return lcp(str[i], str[i-1]); &#125; int rank(string key) &#123; int lo = 0, hi = N-1; while(lo &lt;= hi) &#123; int mid = lo + (hi-lo)/2; int cmp = strcmp(key.c_str(), str[mid].c_str()); if(cmp &lt; 0) hi = mid-1; else if(cmp &gt; 0) lo = mid+1; else return mid; &#125; return lo; &#125;&#125;;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string tmp; cin &gt;&gt; tmp; suffixArray sa(tmp); printf(\" i ind lcp rnk select\\n\"); printf(\"---------------------------\\n\"); for(int i = 0; i &lt; tmp.length(); i++) &#123; int idx = sa.index(i); string ith = \"\\\"\" + tmp.substr(idx) + \"\\\"\"; assert(tmp.substr(idx) == sa.select(i)); // most important! int rk = sa.rank(tmp.substr(idx)); if(i == 0) printf(\"%3d %3d %3s %3d %s\\n\", i, idx, \"-\", rk, ith.c_str()); else &#123; int lcp = sa.lcp(i); printf(\"%3d %3d %3d %3d %s\\n\", i, idx, lcp, rk, ith.c_str()); &#125; &#125; &#125; 后缀数组Manber-Myers算法思想概述上述朴素算法，效率是比较低的我们每一次都对字符串从头到尾扫描一遍最坏情况下，算法的效率是$O(n^2/2)$ 如何改进呢？能不能在基数排序str[0]完成之后，利用str[0]的信息，来接着处理str[1], str[2]…呢先这样想，我们把第一位的结果，当成是第二位的可以不可以呢？字符串右移一位，会是什么情况呢？ 具体的算法图解如下： 其实就相当于把串整体下移一位利用第一次的结果排序第二次这样前缀的值就可以确定下来，我们可以尝试求解LCP LCP求解最后的结果是： UVA11107来看一道题目 Life Forms 分析： 实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159//// main.cpp// uva11107//// Created by zhangmin chen on 2019/2/16.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1001 * 100 + 10;struct suffixArray &#123; int str[maxn], sa[maxn], rank[maxn], lcp[maxn]; int c[maxn], t1[maxn], t2[maxn]; int n; void init() &#123; n = 0; memset(sa, 0, sizeof(sa)); &#125; void buildSa(int Rdx) &#123; int i, *x = t1, *y = t2; for(i = 0; i &lt; Rdx; i++) c[i] = 0; for(i = 0; i &lt; n; i++) c[x[i] = str[i]]++; for(i = 1; i &lt; Rdx; i++) c[i] += c[i-1]; for(i = n-1; i &gt;= 0; i--) sa[--c[x[i]]] = i; for(int offset = 1; offset &lt;= n; offset &lt;&lt;= 1) &#123; int p = 0; for(i = n-offset; i &lt; n; i++) y[p++] = i; for(i = 0; i &lt; n; i++) if(sa[i] &gt;= offset) y[p++] = sa[i] - offset; // radix sort for(i = 0; i &lt; Rdx; i++) c[i] = 0; for(i = 0; i &lt; n; i++) c[x[y[i]]]++; for(i = 1; i &lt; Rdx; i++) c[i] += c[i-1]; for(i = n-1; i &gt;= 0; i--) &#123; sa[--c[x[y[i]]]] = y[i]; y[i] = 0; &#125; // rebuild x and y swap(x, y); x[sa[0]] = 0; p = 1; for(i = 1; i &lt; n; i++) x[sa[i]] = y[sa[i-1]] == y[sa[i]] &amp;&amp; y[sa[i-1]+offset] == y[sa[i]+offset] ? p-1 : p++; if(p &gt;= n) break; Rdx = p; &#125; &#125; void getLcp() &#123; int k = 0; for(int i = 0; i &lt; n; i++) rank[sa[i]] = i; for(int i = 0; i &lt; n; i++) &#123; if(rank[i] == 0) continue; if(k) k--; int j = sa[rank[i] - 1]; while(str[i+k] == str[j+k]) k++; lcp[rank[i]] = k; &#125; &#125;&#125;;const int maxl = 1000 + 10;const int maxc = 100 + 10;suffixArray sa;int n;char word[maxl];int flag[maxc];int idx[maxn];void add(int ch, int wid) &#123; // add alpha in sa idx[sa.n] = wid; sa.str[sa.n++] = ch;&#125;bool judge(int left, int right) &#123; memset(flag, 0, sizeof(flag)); if(right-left &lt;= n/2) return false; int cnt = 0; for(int i = left; i &lt; right; i++) &#123; int wid = idx[sa.sa[i]]; if(wid != n &amp;&amp; flag[wid] == 0) &#123; flag[wid] = 1; cnt++; &#125; &#125; return cnt &gt; n/2;&#125;void printSub(int l, int r) &#123; for(int i = l; i &lt; r; i++) &#123; printf(\"%c\", sa.str[i]-1+'a'); &#125; printf(\"\\n\");&#125;bool okForLength(int len, bool print) &#123; // binary search int left = 0; for(int right = 1; right &lt;= sa.n; right++) if(right == sa.n || sa.lcp[right] &lt; len) &#123; // a new block if(judge(left, right)) &#123; if(print) printSub(sa.sa[left], sa.sa[left]+len); // is sa.sa[left], printout original str[] else return true; &#125; left = right; &#125; return false;&#125;void solve(int maxlen) &#123; // if(!okForLength(1, false)) printf(\"?\\n\"); else &#123; int l = 1, r = maxlen, mid; while(l &lt; r) &#123; mid = l + (r-l+1)/2; if(okForLength(mid, false)) l = mid; else r = mid-1; &#125; okForLength(l, true); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; if(kase++ &gt; 0) printf(\"\\n\"); int maxlen = 0; sa.init(); for(int i = 0; i &lt; n; i++) &#123; scanf(\"%s\", word); int sz = (int)strlen(word); maxlen = max(maxlen, sz); for(int j = 0; j &lt; sz; j++) add(word[j]-'a'+1, i); add(100+i, n); &#125; add(0, n); if(n == 1) printf(\"%s\\n\", word); else &#123; sa.buildSa(100+n); sa.getLcp(); solve(maxlen); &#125; &#125; return 0;&#125; 这道题目的后缀数组模版比较常用 后缀自动机理论后缀自动机则是比后缀数组更为强大的工具它能够在线性时间内求出子串 后缀自动机的构造方式endpos()函数 后缀链接 实现中重复添加字符的处理方法 hihocoder1445具体的题目见后缀自动机二·重复旋律5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//// main.cpp// hiho1445//// Created by zhangmin chen on 2019/2/22.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define REP(i, l, r) for(int i = (l); i &lt;= (r); i++)#define FOR(i, l, r) for(int i = (l); i &lt; (r); i++)typedef long long llong;using namespace std;const int maxl = 1000000 + 10;const int maxn = 2 * maxl;struct SAM &#123; int maxlen[maxn], trans[maxn][26], link[maxn], size, last; SAM() &#123; Set(maxlen, 0); Set(trans, 0); Set(link, 0); size = last = 1; &#125; void extend(int ch) &#123; // int cur = ++size, p = last; maxlen[cur] = maxlen[p] + 1; for(; p &amp;&amp; !trans[p][ch]; p = link[p]) trans[p][ch] = cur; // then, we try to change the link of cur, link[cur] = ? if(!p) link[cur] = 1; else &#123; int q = trans[p][ch]; if(maxlen[p] + 1 == maxlen[q]) link[cur] = q; else &#123; int clone = ++size; maxlen[clone] = maxlen[p] + 1; Cpy(trans[clone], trans[q]); link[clone] = link[q]; for(; p &amp;&amp; trans[p][ch] == q; p = link[p]) trans[p][ch] = clone; link[q] = link[cur] = clone; &#125; &#125; last = cur; &#125;&#125;;SAM sam;char str[maxl];int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%s\", str); for(int i = 0; str[i]; i++) sam.extend(str[i] - 'a'); llong ans = 0; for(int i = 1; i &lt;= sam.size; i++) &#123; if(i == 1) continue; ans += sam.maxlen[i] - sam.maxlen[sam.link[i]]; &#125; cout &lt;&lt; ans;&#125; 求任意的长度为k的子串出现的次数 hihocoder1449后缀自动机三·重复旋律6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//// main.cpp// hiho1449//// Created by zhangmin chen on 2019/2/22.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define REP(i, l, r) for(int i = (l); i &lt;= (r); i++)#define FOR(i, l, r) for(int i = (l); i &lt; (r); i++)typedef long long llong;using namespace std;const int maxl = 1000000 + 10;const int maxn = 2 * maxl;llong cnt[maxn];struct SAM &#123; int maxlen[maxn], trans[maxn][26], link[maxn], size, last; SAM() &#123; Set(maxlen, 0); Set(trans, 0); Set(link, 0); size = last = 1; &#125; void extend(int ch) &#123; // int cur = ++size, p = last; maxlen[cur] = maxlen[p] + 1; cnt[cur] = 1; for(; p &amp;&amp; !trans[p][ch]; p = link[p]) trans[p][ch] = cur; if(!p) link[cur] = 1; else &#123; int q = trans[p][ch]; if(maxlen[p] + 1 == maxlen[q]) link[cur] = q; else &#123; int clone = ++size; maxlen[clone] = maxlen[p] + 1; Cpy(trans[clone], trans[q]); link[clone] = link[q]; for(; p &amp;&amp; trans[p][ch] == q; p = link[p]) trans[p][ch] = clone; link[cur] = link[q] = clone; &#125; &#125; last = cur; &#125;&#125;;SAM sam;char str[maxl];vector&lt;int&gt; G[maxn];int indeg[maxn];llong ans[maxn];void build() &#123; REP(i, 1, sam.size) &#123; G[i].push_back(sam.link[i]); indeg[sam.link[i]]++; &#125;&#125;void topo() &#123; queue&lt;int&gt; que; build(); REP(i, 0, sam.size) if(!indeg[i]) que.push(i); while(!que.empty()) &#123; int u = que.front(); que.pop(); for(int v : G[u]) &#123; // ans[sam.maxlen[u]] = max(ans[sam.maxlen[u]], cnt[u]); cnt[v] += cnt[u]; if(!(--indeg[v])) que.push(v); &#125; &#125; REP(i, 1, sam.size) ans[sam.maxlen[i]] = max(ans[sam.maxlen[i]], cnt[i]); // FOR(i, 1, sam.size) debug(cnt[i]);&#125;int main() &#123; // freopen(\"input.txt\", \"r\", stdin); string str; cin &gt;&gt; str; for(int i = 0; i &lt; str.length(); i++) sam.extend(str[i] - 'a'); topo(); for(int i = (int)str.length(); i &gt;= 1; i--) ans[i] = max(ans[i], ans[i+1]); for(int i = 1; i &lt;= str.length(); i++) cout &lt;&lt; ans[i] &lt;&lt; endl;&#125; 连接不同的子串，标识符分隔，再拓扑排序这样可以把所有不同的串整合到一起 hihocoder1457后缀自动机四·重复旋律7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//// main.cpp// hiho1457//// Created by zhangmin chen on 2019/2/23.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define REP(i, l, r) for(int i = (l); i &lt;= (r); i++)#define FOR(i, l, r) for(int i = (l); i &lt; (r); i++)typedef long long llong;using namespace std;const int maxl = 1000000 + 10;const int maxn = 2 * maxl;const llong MOD = 1000000007;struct SAM &#123; int maxlen[maxn], trans[maxn][26], link[maxn], size, last; SAM() &#123; Set(maxlen, 0); Set(trans, 0); Set(link, 0); size = last = 1; &#125; void extend(int ch) &#123; int cur = ++size, p = last; maxlen[cur] = maxlen[p] + 1; for(; p &amp;&amp; !trans[p][ch]; p = link[p]) trans[p][ch] = cur; if(!p) link[cur] = 1; else &#123; int q = trans[p][ch]; if(maxlen[p] + 1 == maxlen[q]) link[cur] = q; else &#123; int clone = ++size; maxlen[clone] = maxlen[p] + 1; Cpy(trans[clone], trans[q]); link[clone] = link[q]; for(; p &amp;&amp; trans[p][ch] == q; p = link[p]) trans[p][ch] = clone; link[cur] = link[q] = clone; &#125; &#125; last = cur; &#125;&#125;;SAM sam;const int spc = 10;int indeg[maxn];llong cnt[maxn], val[maxn];int main() &#123; freopen(\"input.txt\", \"r\", stdin); // llong ans = 0; Set(cnt, 0); Set(val, 0); Set(indeg, 0); int n; scanf(\"%d\", &amp;n); string str; while(n--) &#123; cin &gt;&gt; str; for(int i = 0; i &lt; str.length(); i++) sam.extend(str[i]-'0'); if(n != 0) sam.extend(10); &#125; queue&lt;int&gt; que; que.push(1); cnt[1] = 1; REP(i, 1, sam.size) REP(j, 0, spc) ++indeg[sam.trans[i][j]]; while(!que.empty()) &#123; int u = que.front(); que.pop(); REP(i, 0, spc) &#123; int v = sam.trans[u][i]; if(!v) continue; if(i != 10) &#123; (cnt[v] += cnt[u]) %= MOD; (val[v] += val[u] * 10 % MOD + (llong)(i * cnt[u] % MOD)) %= MOD; &#125; if(!(--indeg[v])) que.push(v); &#125; &#125; llong ans = 0; for(int i = 1; i &lt;= sam.size; i++) ans = (ans + val[i]) % MOD; printf(\"%lld\\n\", ans);&#125; 串T在串S中的出现次数这个简单，如果是循环同构串，就比较复杂了 hihocoder1465后缀自动机五·重复旋律8 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//// main.cpp// hiho1465-2//// Created by zhangmin chen on 2019/2/25.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define REP(i, l, r) for(int i = (l); i &lt;= (r); i++)#define FOR(i, l, r) for(int i = (l); i &lt; (r); i++)typedef long long llong;const int maxl = 1000000 + 10;const int maxn = 2 * maxl;struct SAM &#123; int maxlen[maxn], trans[maxn][26], link[maxn], size, last; int tag[maxn], indeg[maxn], endpos[maxn]; SAM() &#123; Set(maxlen, 0); Set(trans, 0); Set(link, 0); Set(tag, 0); Set(indeg, 0); Set(endpos, 0); size = last = 1; &#125; void extend(int ch) &#123; int cur = ++size, p = last; tag[cur] = 1; maxlen[cur] = maxlen[p] + 1; for(; p &amp;&amp; !trans[p][ch]; p = link[p]) trans[p][ch] = cur; // relink cur if(!p) link[cur] = 1; else &#123; int q = trans[p][ch]; if(maxlen[p] + 1 == maxlen[q]) link[cur] = q; else &#123; int clone = ++size; tag[clone] = 0; maxlen[clone] = maxlen[p] + 1; Cpy(trans[clone], trans[q]); link[clone] = link[q]; for(; p &amp;&amp; trans[p][ch] == q; p = link[p]) trans[p][ch] = clone; link[cur] = link[q] = clone; &#125; &#125; last = cur; &#125; void build() &#123; for(int i = 1; i &lt;= size; i++) ++indeg[link[i]]; queue&lt;int&gt; que; for(int i = 1; i &lt;= size; i++) if(indeg[i] == 0) &#123; que.push(i); endpos[i] = 1; &#125; while(!que.empty()) &#123; int x = que.front(); que.pop(); if(x == 0) continue; int y = link[x]; indeg[y]--; endpos[y] += endpos[x]; if(indeg[y] == 0) &#123; if(tag[y]) endpos[y]++; que.push(y); &#125; &#125; &#125;&#125;;SAM sam;int version[maxn];llong solve(string&amp; str, int num) &#123; int len = (int)str.length(); int base = len; string str2 = str.substr(0, len-1); str += str2; len = 2*len - 1; int u = 1, lcs = 0; llong ans = 0; for(int i = 0; i &lt; len; i++) &#123; int ch = str[i] - 'a'; if(sam.trans[u][ch]) &#123; u = sam.trans[u][ch]; lcs++; &#125; else &#123; for(; u &amp;&amp; !sam.trans[u][ch]; u = sam.link[u]); if(!u) &#123; u = 1; lcs = 0; &#125; else &#123; lcs = sam.maxlen[u] + 1; u = sam.trans[u][ch]; &#125; &#125; if(lcs &gt; base) &#123; while(sam.maxlen[sam.link[u]] &gt;= base) &#123; u = sam.link[u]; lcs = sam.maxlen[u]; &#125; &#125; if(lcs &gt;= base &amp;&amp; version[u] != num) &#123; version[u] = num; ans += sam.endpos[u]; &#125; &#125; return ans;&#125;string str;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; str; for(int i = 0; i &lt; str.length(); i++) sam.extend(str[i] - 'a'); sam.build(); int kase; scanf(\"%d\", &amp;kase); for(int k = 1; k &lt;= kase; k++) &#123; cin &gt;&gt; str; llong res = solve(str, k); printf(\"%lld\\n\", res); &#125;&#125; 后缀自动机+SG函数这个题目难度比较大，和博弈论综合 hihocoder1466后缀自动机六·重复旋律9 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224//// main.cpp// hiho1466//// Created by zhangmin chen on 2019/2/28.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define REP(i, l, r) for(int i = (l); i &lt;= (r); i++)#define FOR(i, l, r) for(int i = (l); i &lt; (r); i++)const int maxl = 100000 + 10;const int maxn = 2*maxl;const int N = 27;// cnt(pre, SG())struct SAM &#123; int len[maxn], trans[maxn][26], link[maxn], size, last; // other arr[] int sg[maxn]; llong cnt[maxn][N+1]; SAM() &#123; Set(len, 0); Set(trans, 0); Set(link, 0); Set(sg, -1); size = 1; last = 1; &#125; void extend(int ch) &#123; int cur = ++size, p = last; // 1 is the \" \" len[cur] = len[p] + 1; //debug(cur); for(; p &amp;&amp; !trans[p][ch]; p = link[p]) trans[p][ch] = cur; // relink cur if(!p) link[cur] = 1; else &#123; int q = trans[p][ch]; if(len[p] + 1 == len[q]) link[cur] = q; else &#123; int clone = ++size; len[clone] = len[p] + 1; Cpy(trans[clone], trans[q]); link[clone] = link[q]; for(; p &amp;&amp; trans[p][ch] == q; p = link[p]) trans[p][ch] = clone; link[cur] = link[q] = clone; &#125; &#125; last = cur; &#125; int SG(int x) &#123; if(sg[x] != -1) return sg[x]; bool flag[28]; for(int i = 0; i &lt; 27; i++) flag[i] = 0; for(int i = 0; i &lt; 26; i++) &#123; int to = trans[x][i]; //debug(to); if(to == 0) continue; flag[SG(to)] = 1; for(int j = 0; j &lt; 27; j++) cnt[x][j] += cnt[to][j]; // I made a bug here, is j &#125; for(int i = 0; i &lt; 27; i++) if(!flag[i]) &#123; sg[x] = i; break; &#125; cnt[x][sg[x]]++; for(int i = 0; i &lt; 27; i++) cnt[x][27] += cnt[x][i]; return sg[x]; &#125; void Debug() &#123; for(int i = 0; i &lt;= size; i++) &#123; printf(\"i: %d:\\n\", i); for(int j = 0; j &lt; 28; j++) /*printf(\"%lld \", cnt[i][j]);*/ debug(cnt[i][j]); printf(\"sg:: %d\\n\", sg[i]); /* for(int j = 0; j &lt; 26; j++) debug(trans[i][j]); */ &#125; &#125; &#125;;SAM A, B;char res[2][maxn];llong k;// cntA[u][sg()] cntB[v][sg()]// (sa_u, sb_v)llong cost(int u, int v) &#123; llong ans = 0; for(int i = 0; i &lt; 27; i++) ans += 1LL * A.cnt[u][i] * (B.cnt[v][27] - B.cnt[v][i]); return ans;&#125;// p is the item of resA[p]// A.sg[x] x = &#123;_, a, b, ab&#125;int dfsA(int p, int x) &#123; llong ct = B.cnt[1][27] - B.cnt[1][A.sg[x]]; //debug(ct); //debug(k); //cout &lt;&lt; endl; // B from 0 to match if(k &lt;= ct) return x; else &#123; k -= ct; for(int i = 0; i &lt; 26; i++) &#123; int to = A.trans[x][i]; if(to == 0) continue; //debug(to); llong ct2 = cost(to, 1); if(ct2 &lt; k) k -= ct2; else &#123; res[0][p] = 'a' + i; return dfsA(p+1, to); // return dfsA(next) &#125; &#125; return -1; &#125; /* // follow the path in SAM for(int i = 0; i &lt; 26; i++) &#123; int to = A.trans[x][i]; if(to == 0) continue; llong ct2 = cost(to, 1); if(ct2 &lt; k) k -= ct2; else &#123; // ct2 &gt;= k, we follow the path and extend char // to reduce ct2 res[0][p] = 'a' + i; debug(res[0]); dfsA(p+1, to); &#125; &#125; if(k &gt; ct) return -1; else return x; */&#125;void dfsB(int p, int x, int T) &#123; k -= A.sg[T] != B.sg[x]; if(k == 0) return; for(int i = 0; i &lt; 26; i++) &#123; int to = B.trans[x][i]; if(to == 0) continue; llong ct = B.cnt[to][27] - B.cnt[to][A.sg[T]]; if(ct &lt; k) k -= ct; else &#123; // reduce ct res[1][p] = 'a' + i; dfsB(p+1, to, T); return; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string a, b; cin &gt;&gt; k; cin &gt;&gt; a &gt;&gt; b; //debug(a[0]); for(int i = 0; i &lt; a.length(); i++) A.extend(a[i] - 'a'); A.SG(1); //A.Debug(); for(int i = 0; i &lt; b.length(); i++) B.extend(b[i] - 'a'); B.SG(1); //B.Debug(); int T = dfsA(0, 1); //debug(T); if(T == -1) &#123; printf(\"NO\\n\"); return 0; &#125; dfsB(0, 1, T); puts(res[0]); puts(res[1]);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"c++ STL一些小技巧(int和string的相互转换)","slug":"20181024","date":"2018-10-24T12:42:35.000Z","updated":"2019-05-30T21:21:44.581Z","comments":true,"path":"2018/10/24/20181024/","link":"","permalink":"https://www.fogsail.net/2018/10/24/20181024/","excerpt":"c++中的STL在企业的笔试，面试中有一些常见的技巧，string和int的相互转换用的比较多","text":"c++中的STL在企业的笔试，面试中有一些常见的技巧，string和int的相互转换用的比较多 int转stringto_string()12345678910int main() &#123; string pi = \"pi is \" + to_string(3.1415926); float val = 8.967; string num = to_string(val); string perfect = to_string(1+2+4+7+14) + \" is a perfect number\"; cout &lt;&lt; pi &lt;&lt; \"\\n\"; cout &lt;&lt; num &lt;&lt; \"\\n\"; cout &lt;&lt; perfect &lt;&lt; \"\\n\";&#125; 输出结果： 123pi is 3.1415938.96700028 is a perfect number sstream12345678910111213#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;using namespace std;int main() &#123; ostringstream os; int i = 12; os &lt;&lt; i; cout &lt;&lt; \"the data is \" + os.str() &lt;&lt; endl;&#125; 输出结果： 1the data is 12 string转int使用stoi/stol/stoll123456789101112int stoi (const string&amp; str, size_t* idx = 0, int base = 10);idx:Pointer to an object of type size_t, whose value is set by the function to position of the next character in str after the numerical value.This parameter can also be a null pointer, in which case it is not used.idx获取string中，isdigit(str[i])所在位置的next位置值 方法如下：123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; string str_dec = \"2001, A Space Odyssey\"; string str_hex = \"40c3\"; string str_bin = \"-10010110001\"; string str_auto = \"0x7f\"; string::size_type sz; // intention: 解引用 // int *p = &amp;a; int i_dec = stoi(str_dec, &amp;sz); int i_hex = stoi(str_dec, nullptr, 16); int i_bin = stoi(str_bin, nullptr, 2); int i_auto = stoi(str_auto, nullptr, 0); cout &lt;&lt; str_dec &lt;&lt; \": \" &lt;&lt; i_dec &lt;&lt; \"and [ \" &lt;&lt; str_dec.substr(sz) &lt;&lt; \"]\\n\"; cout &lt;&lt; str_hex &lt;&lt; \": \" &lt;&lt; i_hex &lt;&lt; \"\\n\"; cout &lt;&lt; str_bin &lt;&lt; \": \" &lt;&lt; i_bin &lt;&lt; \"\\n\"; cout &lt;&lt; str_auto &lt;&lt; \": \" &lt;&lt; i_auto &lt;&lt; \"\\n\";&#125; 结果： 12342001, A Space Odyssey: 2001and [ , A Space Odyssey]40c3: 8193-10010110001: -12010x7f: 127 atoi()1234567891011#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; string s = \"12\"; int a = atoi(s.c_str()); cout &lt;&lt; a &lt;&lt; endl;&#125; sstream12345678910111213#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;using namespace std;int main() &#123; istringstream is(\"12\"); int i; is &gt;&gt; i; cout &lt;&lt; i &lt;&lt; endl;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://www.fogsail.net/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://www.fogsail.net/tags/c/"}]},{"title":"TCP/IP实践(一)：Internet地址结构","slug":"20181008","date":"2018-10-08T10:28:39.000Z","updated":"2018-10-18T17:16:38.111Z","comments":true,"path":"2018/10/08/20181008/","link":"","permalink":"https://www.fogsail.net/2018/10/08/20181008/","excerpt":"目前Internet的地址涉及到IPv4、IPv6和MAC地址这里重点介绍一下IPv6地址的构成，以及和相关地址的转换。","text":"目前Internet的地址涉及到IPv4、IPv6和MAC地址这里重点介绍一下IPv6地址的构成，以及和相关地址的转换。 IPv6地址和接口标识符EUI是唯一扩展标识符，EUI-48和EUI-64由IEEE定义。这些都是用于IPv6的地址，它们是通过将接口标识符取反u位来形成的。 如下图所示： 1234567891011121314step1: 00:30:48:2A:19:89转换为EUI-64，在第三子节后加入ff:fe形成00:30:48:ff:fe:2a:19:89step2: u位被取反0x00 -&gt; 0b 0000 0000 -&gt; 0b 0000 0010即为0x0202:30:48:ff:fe:2a:19:89step3: 完成链路本地的IPv6地址使用保留链路的本地前缀fe80::/10形成完整地址fe80::230:48ff:fe2a:1989(每2个字节为1组，最高位0不写) 获取本机的IPv4/IPv6/MAC地址具体的实现方法如下：mac os获取MAC地址的方法和Linux不同我这里写的是mac os版的Linux更简单了，参见注释就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289//// main.c// GetLocalMAC-IP//// Created by zhangmin chen on 2018/10/8.// Copyright © 2018年 zhangmin chen. All rights reserved.//#include &lt;sys/types.h&gt;#include &lt;ifaddrs.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;net/if.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;//------------now we try to Get MAC Address------#include &lt;CoreFoundation/CoreFoundation.h&gt;#include &lt;IOKit/IOKitLib.h&gt;#include &lt;IOKit/network/IOEthernetInterface.h&gt;#include &lt;IOKit/network/IONetworkInterface.h&gt;#include &lt;IOKit/network/IOEthernetController.h&gt;static kern_return_t FindEthernetInterfaces(io_iterator_t *matchingServices);static kern_return_t GetMACAddress(io_iterator_t intfIterator, UInt8 *MACAddress, UInt8 bufferSize);// Returns an iterator containing the primary (built-in) Ethernet interface. The caller is responsible for// releasing the iterator after the caller is done with it.static kern_return_t FindEthernetInterfaces(io_iterator_t *matchingServices)&#123; kern_return_t kernResult; CFMutableDictionaryRef matchingDict; CFMutableDictionaryRef propertyMatchDict; // Ethernet interfaces are instances of class kIOEthernetInterfaceClass. // IOServiceMatching is a convenience function to create a dictionary with the key kIOProviderClassKey and // the specified value. matchingDict = IOServiceMatching(kIOEthernetInterfaceClass); // Note that another option here would be: // matchingDict = IOBSDMatching(\"en0\"); // but en0: isn't necessarily the primary interface, especially on systems with multiple Ethernet ports. if (NULL == matchingDict) &#123; printf(\"IOServiceMatching returned a NULL dictionary.\\n\"); &#125; else &#123; // Each IONetworkInterface object has a Boolean property with the key kIOPrimaryInterface. Only the // primary (built-in) interface has this property set to TRUE. // IOServiceGetMatchingServices uses the default matching criteria defined by IOService. This considers // only the following properties plus any family-specific matching in this order of precedence // (see IOService::passiveMatch): // // kIOProviderClassKey (IOServiceMatching) // kIONameMatchKey (IOServiceNameMatching) // kIOPropertyMatchKey // kIOPathMatchKey // kIOMatchedServiceCountKey // family-specific matching // kIOBSDNameKey (IOBSDNameMatching) // kIOLocationMatchKey // The IONetworkingFamily does not define any family-specific matching. This means that in // order to have IOServiceGetMatchingServices consider the kIOPrimaryInterface property, we must // add that property to a separate dictionary and then add that to our matching dictionary // specifying kIOPropertyMatchKey. propertyMatchDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); if (NULL == propertyMatchDict) &#123; printf(\"CFDictionaryCreateMutable returned a NULL dictionary.\\n\"); &#125; else &#123; // Set the value in the dictionary of the property with the given key, or add the key // to the dictionary if it doesn't exist. This call retains the value object passed in. CFDictionarySetValue(propertyMatchDict, CFSTR(kIOPrimaryInterface), kCFBooleanTrue); // Now add the dictionary containing the matching value for kIOPrimaryInterface to our main // matching dictionary. This call will retain propertyMatchDict, so we can release our reference // on propertyMatchDict after adding it to matchingDict. CFDictionarySetValue(matchingDict, CFSTR(kIOPropertyMatchKey), propertyMatchDict); CFRelease(propertyMatchDict); &#125; &#125; // IOServiceGetMatchingServices retains the returned iterator, so release the iterator when we're done with it. // IOServiceGetMatchingServices also consumes a reference on the matching dictionary so we don't need to release // the dictionary explicitly. kernResult = IOServiceGetMatchingServices(kIOMasterPortDefault, matchingDict, matchingServices); if (KERN_SUCCESS != kernResult) &#123; printf(\"IOServiceGetMatchingServices returned 0x%08x\\n\", kernResult); &#125; return kernResult;&#125;// Given an iterator across a set of Ethernet interfaces, return the MAC address of the last one.// If no interfaces are found the MAC address is set to an empty string.// In this sample the iterator should contain just the primary interface.static kern_return_t GetMACAddress(io_iterator_t intfIterator, UInt8 *MACAddress, UInt8 bufferSize)&#123; io_object_t intfService; io_object_t controllerService; kern_return_t kernResult = KERN_FAILURE; // Make sure the caller provided enough buffer space. Protect against buffer overflow problems. if (bufferSize &lt; kIOEthernetAddressSize) &#123; return kernResult; &#125; // Initialize the returned address bzero(MACAddress, bufferSize); // IOIteratorNext retains the returned object, so release it when we're done with it. while ((intfService = IOIteratorNext(intfIterator))) &#123; CFTypeRef MACAddressAsCFData; // IONetworkControllers can't be found directly by the IOServiceGetMatchingServices call, // since they are hardware nubs and do not participate in driver matching. In other words, // registerService() is never called on them. So we've found the IONetworkInterface and will // get its parent controller by asking for it specifically. // IORegistryEntryGetParentEntry retains the returned object, so release it when we're done with it. kernResult = IORegistryEntryGetParentEntry(intfService, kIOServicePlane, &amp;controllerService); if (KERN_SUCCESS != kernResult) &#123; printf(\"IORegistryEntryGetParentEntry returned 0x%08x\\n\", kernResult); &#125; else &#123; // Retrieve the MAC address property from the I/O Registry in the form of a CFData MACAddressAsCFData = IORegistryEntryCreateCFProperty(controllerService, CFSTR(kIOMACAddress), kCFAllocatorDefault, 0); if (MACAddressAsCFData) &#123; CFShow(MACAddressAsCFData); // for display purposes only; output goes to stderr // Get the raw bytes of the MAC address from the CFData CFDataGetBytes(MACAddressAsCFData, CFRangeMake(0, kIOEthernetAddressSize), MACAddress); CFRelease(MACAddressAsCFData); &#125; // Done with the parent Ethernet controller object so we release it. (void) IOObjectRelease(controllerService); &#125; // Done with the Ethernet interface object so we release it. (void) IOObjectRelease(intfService); &#125; return kernResult;&#125;//print Hex datavoid pHx(unsigned char* p, int len) &#123; printf(\"Hex: \"); for(int i = 0; i &lt; len; i++) &#123; printf(\"%02X:\", p[i]); &#125; printf(\"\\b\\n\");&#125;// get local mac// For Linux/* * for linux * * char* getMac(char* mac, char* dv) &#123; struct ifreq ifr; int sock; if(!mac || dv) return mac; if( (sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0 ) &#123; perror(\"socket \"); return mac; &#125; strcpy(ifr.ifr_name, dv); if(ioctl(sock, SIOCGIFHWADDR, &amp;ifr) &lt; 0) &#123; //SIOCGIFHWADDR perror(\"ioctl \"); return mac; &#125; pHx( (unsigned char*)ifr.ifr_ifru.ifru_addr.sa_data, sizeof(ifr.ifr_ifru.ifru_addr.sa_data) ); //eth length of MAC is 48bits sprintf(mac, \"%02X:%02X:%02X:%02X:%02X:%02X\", (unsigned char)ifr.ifr_ifru.ifru_addr.sa_data[0], (unsigned char)ifr.ifr_ifru.ifru_addr.sa_data[1], (unsigned char)ifr.ifr_ifru.ifru_addr.sa_data[2], (unsigned char)ifr.ifr_ifru.ifru_addr.sa_data[3], (unsigned char)ifr.ifr_ifru.ifru_addr.sa_data[4], (unsigned char)ifr.ifr_ifru.ifru_addr.sa_data[5]); return mac; &#125; */int main(int argc, const char* argv[]) &#123; char hostname[128]; struct hostent* hostent1; // int i; gethostname(hostname, sizeof(hostname)); hostent1 = gethostbyname(hostname); printf(\"Hostname: %s\\n\", hostent1-&gt;h_name); printf(\"\\n\"); // char mac[30]; struct ifaddrs* ifap0 = NULL, *ifap = NULL; void* addPtr = NULL; getifaddrs(&amp;ifap0); ifap = ifap0; while(ifap != NULL) &#123; if(ifap-&gt;ifa_addr-&gt;sa_family == AF_INET) &#123; // is a valid IPv4 address addPtr = &amp; ((struct sockaddr_in *)ifap-&gt;ifa_addr)-&gt;sin_addr; char addressBuffer[INET_ADDRSTRLEN]; inet_ntop(AF_INET, addPtr, addressBuffer, INET_ADDRSTRLEN); if(strcmp(addressBuffer, \"127.0.0.1\") != 0) &#123; printf(\"%s IPv4: %s\\n\", ifap-&gt;ifa_name, addressBuffer); &#125; &#125; else if(ifap-&gt;ifa_addr-&gt;sa_family == AF_INET6) &#123; // is a valid IPv6 address addPtr = &amp; ((struct sockaddr_in *)ifap-&gt;ifa_addr)-&gt;sin_addr; char addressBuffer[INET6_ADDRSTRLEN]; inet_ntop(AF_INET6, addPtr, addressBuffer, INET6_ADDRSTRLEN); if(strcmp(addressBuffer, \"::\") != 0) &#123; printf(\"%s IPv6: %s\\n\", ifap-&gt;ifa_name, addressBuffer); &#125; &#125; ifap = ifap-&gt;ifa_next; &#125; if(ifap0) &#123; freeifaddrs(ifap0); ifap0 = NULL; &#125; printf(\"\\n\\n\"); printf(\"--------Now we try to get MAC address----------------\\n\"); printf(\"\\n\"); kern_return_t kernResult = KERN_SUCCESS; io_iterator_t intfIterator; UInt8 MACAddress[kIOEthernetAddressSize]; kernResult = FindEthernetInterfaces(&amp;intfIterator); if(KERN_SUCCESS != kernResult) &#123; printf(\"FindEthernetInterfaces returned 0x%08x\\n\", kernResult); &#125; else &#123; kernResult = GetMACAddress(intfIterator, MACAddress, sizeof(MACAddress)); if(KERN_SUCCESS != kernResult) &#123; printf(\"GetMACAddress return 0x%08x\\n\", kernResult); &#125; else &#123; printf(\"This system's built-in MAC address is %02x:%02x:%02x:%02x:%02x:%02x.\\n\", MACAddress[0], MACAddress[1], MACAddress[2], MACAddress[3], MACAddress[4], MACAddress[5]); &#125; &#125; (void) IOObjectRelease(intfIterator); return kernResult; &#125; IPv4组播地址常见的组播地址： 123224.0.0.0 - 224.0.0.255本地网络控制，不转发，相当于是组播的范围边界发送到这些地址的数据报不被转发 12224.0.1.0 - 224.0.1.255例：NTP(网络时间协议)组播组(224.0.1.1) 123224.0.2.0 - 224.0.255.255Ad hoc块1保留一些地址 1234224.2.0.0 - 224.2.255.255SDP/SAP会话描述工具 12345232.0.0.0 - 232.255.255.255源特定组播(SSM)例：某些应用使用SSM块实现SSM结合自己的单源地址形成一个SSM信道 123456233.0.0.0 - 233.251.255.255GLOP块，组播地址基于主机的AS号将AS号放入IPv4地址的第2、3字节中例: 233.__.__.255__填充的是16bits的AS number 12345678910234.0.0.0 - 234.255.255.255235.0.0.0 - 238.255.255.255基于单播前缀的IPv4组播地址保留什么意思呢？就是给单播地址分配一个相关的UBM地址例: 192.0.2.0/24 --&gt; 234.192.0.2看下图，如果我们知道组播地址234.128.32.0/24去掉前缀234，然后左移8位，128.32.0.0/16分配给加州大学伯克利分校 IPv6组播 123456789一个组织分配了单播前缀3ffe:ffff:1::/48前缀长度: 48 = 0b110000 = 0011 0000第2字段的值为：0000 0000 0011 0000 -&gt; 0x0030 -&gt; 30ff3x:30:3ff3:fff:1::/96(96 = 128-32) 12345678可以根据IID(接口标识符)形成自己的组播地址IID = 02-11-22-33-44-55-66-77使用前缀形式ff3x:0011/32组播地址为：ff3x:0011:0211:2233:4455:6677:gggg:gggg(gggg:gggg为32位组组播组ID的16进制表示 RP的单播IPv6地址嵌入IPv6组播地址 12345678910111、取出64位前缀2、取出RIID字段3、获取RP地址组播地址ff75:940:2001:db8:dead:beef:f00d:face前缀 - 2001:db8:dead:beefRIID - 0x9前缀长度 - 0x40(64)RP地址 - 2001:db8:dead:beef::9 单播地址分配单个供应商/无网络/单个地址这里介绍一些特殊的地址 1、IPv4回送地址：127.0.0.0/8主机和IP堆栈内部的地址，主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回之，不进行任何网络传输。 2、IPv6组播地址: ff02::1ff02表示同一链路/子网中所有的NTP服务器","categories":[{"name":"computer networks","slug":"computer-networks","permalink":"https://www.fogsail.net/categories/computer-networks/"}],"tags":[{"name":"computer networks","slug":"computer-networks","permalink":"https://www.fogsail.net/tags/computer-networks/"}]},{"title":"实现操作系统：BootLoader引导程序(一)","slug":"20180828","date":"2018-08-27T13:08:22.000Z","updated":"2018-08-27T14:06:16.919Z","comments":true,"path":"2018/08/27/20180828/","link":"","permalink":"https://www.fogsail.net/2018/08/27/20180828/","excerpt":"目前国内的很多计算机资料，大多都是讲述《操作系统原理》，涉及到具体操作系统的实现，能够找到的参考资料非常少。 这里我尝试自己独立实现一个操作系统这篇文章主要介绍了操作系统的环境配置并且独立实现一个hello world!","text":"目前国内的很多计算机资料，大多都是讲述《操作系统原理》，涉及到具体操作系统的实现，能够找到的参考资料非常少。 这里我尝试自己独立实现一个操作系统这篇文章主要介绍了操作系统的环境配置并且独立实现一个hello world! Bochs虚拟机的安装官网下载解压什么的，不赘述。 我安装在/opt/bochs-2.6.9下面 1sudo ./configure --with-x11 --with-wx --enable-debugger --enable-disasm 12sudo makesudo make install 安装完成后，在terminal输入bochs如下第一次输入bochs的结果如下： 很显然是因为.bochsrc文件没有配置成功。不过这个问题先放一放，我们稍后解决 往Bochs虚拟机内装软盘用专业一点的话说，就是创建虚拟软盘镜像文件。但实际上就是往虚拟机里面插入一张软盘。 具体的方法1bximage 其实这个一步一步就可以不再赘述，看下图 编程实现引导程序boot.asm123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 org 0x7c00 //start from 0x7c00BaseOfStack equ 0x7c00Label_Start: mov ax, cs mov ds, ax mov es, ax mov ss, ax mov sp, BaseOfStack;======= clear screen mov ax, 0600h mov bx, 0700h mov cx, 0 mov dx, 0184fh int 10h;======= set focus mov ax, 0200h mov bx, 0000h mov dx, 0000h int 10h;======= display on screen : Start Booting...... mov ax, 1301h mov bx, 000fh mov dx, 0000h mov cx, 10 push ax mov ax, ds mov es, ax pop ax mov bp, StartBootMessage int 10h;======= reset floppy xor ah, ah xor dl, dl int 13h jmp $StartBootMessage: db \"Start Boot\" //can be changed, such as \"I love you\";======= fill zero until whole sector times 510 - ($ - $$) db 0 dw 0xaa55 编译上一步的asm文件1sudo dd if=boot.bin of=/opt/bochs-2.6.9/boot.img bs=512 count=1 conv=notrunc 其实，上一步就做了一件事情，我们把引导文件写入软盘镜像传输块的大小为512B，参数count=1指定写入到目标文件的块数量conv=notrunc表示写入数据后不截断输出文件尺寸的大小 启动bochs虚拟机配置bochsrc文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# configuration file generated by Bochsplugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1, iodebug=1config_interface: textconfigdisplay_library: x#memory: host=2048, guest=2048romimage: file=\"/usr/local/share/bochs/BIOS-bochs-latest\"vgaromimage: file=\"/usr/local/share/bochs/VGABIOS-lgpl-latest\"boot: floppyfloppy_bootsig_check: disabled=0floppya: type=1_44, 1_44=\"boot.img\", status=inserted, write_protected=0# no floppybata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14ata0-master: type=noneata0-slave: type=noneata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15ata1-master: type=noneata1-slave: type=noneata2: enabled=0ata3: enabled=0pci: enabled=1, chipset=i440fxvga: extension=vbe, update_freq=5print_timestamps: enabled=0debugger_log: -magic_break: enabled=0port_e9_hack: enabled=0private_colormap: enabled=0clock: sync=none, time0=local, rtc_sync=0# no cmosimage# no loaderlog: -logprefix: %t%e%ddebug: action=ignoreinfo: action=reporterror: action=reportpanic: action=askkeyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=nonemouse: type=ps2, enabled=0, toggle=ctrl+mbuttonspeaker: enabled=1, mode=systemparport1: enabled=1, file=noneparport2: enabled=0com1: enabled=1, mode=nullcom2: enabled=0com3: enabled=0com4: enabled=0megs: 2048 启动文件这里注意一下必须在/opt/bochs-2.6.9目录下执行 12cd /opt/bochs-2.6.9sudo bochs -f '/home/fogsail/Software/os-boot/bochsrc' 最后按下c键，自然出现了start boot，表示操作系统启动啦～","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.fogsail.net/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.fogsail.net/tags/操作系统/"}]},{"title":"用vscode打造macOS下c/c++编译利器","slug":"20180827","date":"2018-08-26T16:04:05.000Z","updated":"2018-08-26T16:26:45.569Z","comments":true,"path":"2018/08/27/20180827/","link":"","permalink":"https://www.fogsail.net/2018/08/27/20180827/","excerpt":"在macOS环境下写c/c++， 如果是大型项目的话，可以考虑用IDE比如xcode等等但是如果仅仅是写一些小型的模块，或者说是研究一些算法，刷leetcode等等，用vscode就足够方便了。","text":"在macOS环境下写c/c++， 如果是大型项目的话，可以考虑用IDE比如xcode等等但是如果仅仅是写一些小型的模块，或者说是研究一些算法，刷leetcode等等，用vscode就足够方便了。 测试程序Hello world123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int result; int a = 2; int b = 3; result = a + b; cout &lt;&lt; result&lt;&lt; endl; return 0;&#125; 写配置文件tasks.json用快捷键shift+command+p打开Tasks: Configure Tasks选择Create tasks.json file from templates此时会蹦出一个下拉列表，在下拉列表中选择Others 自动生成一个task.json文件 配置如下： 12345678910111213141516171819202122&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ &#123; \"label\": \"helloworld\", \"type\": \"shell\", \"command\": \"g++\", \"args\": [ \"$&#123;file&#125;\", \"-o\", \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out\", \"-g\" ], \"group\": &#123; \"kind\": \"build\", \"isDefault\": true &#125; &#125; ]&#125; launch.json找到虫子的图标，如下图所示 简单修改之后，配置launch.json如下 1234567891011121314151617181920&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"(lldb) Launch\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"$&#123;workspaceFolder&#125;\", \"environment\": [], \"externalConsole\": true, \"MIMode\": \"lldb\" &#125; ]&#125; 设置断点，F5调试切换到helloworld.cpp快捷键command+shift+b对源文件进行编译编译成功后，F5调试 调试成功的图案如下：","categories":[{"name":"杂乱的技术","slug":"杂乱的技术","permalink":"https://www.fogsail.net/categories/杂乱的技术/"}],"tags":[{"name":"杂乱的技术","slug":"杂乱的技术","permalink":"https://www.fogsail.net/tags/杂乱的技术/"},{"name":"c/c++","slug":"c-c","permalink":"https://www.fogsail.net/tags/c-c/"}]},{"title":"算法竞赛入门：基础算法(二)","slug":"20180824","date":"2018-08-24T13:46:16.000Z","updated":"2019-04-11T20:57:37.265Z","comments":true,"path":"2018/08/24/20180824/","link":"","permalink":"https://www.fogsail.net/2018/08/24/20180824/","excerpt":"这里介绍几种非常有意思的技巧，比如剥洋葱法。","text":"这里介绍几种非常有意思的技巧，比如剥洋葱法。 Image is Everything剥洋葱，k from 1 to 6, means k view123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define REP(i,n) for(int i = 0; i &lt; (n); i++)const int maxn = 10;int n;char pos[maxn][maxn][maxn];char view[maxn][maxn][maxn];char read_char()&#123; char ch; for(;;)&#123; ch = getchar(); if( (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || ch == '.' ) return ch; &#125;&#125;void getxyz(int k, int i, int j, int depth, int&amp; x, int&amp; y, int&amp; z)&#123; if(k == 0)&#123; x = depth; y = j; z = i; &#125; if(k == 1)&#123; x = n-1-j; y = depth; z = i; &#125; if(k == 2)&#123; x = n-1-depth; y = n-1-j; z = i; &#125; if(k == 3)&#123; x = j; y = n-1-depth; z = i; &#125; if(k == 4)&#123; x = n-1-i; y = j; z = depth; &#125; if(k == 5)&#123; x = i; y = j; z = n-1-depth; &#125;&#125;void init(int n)&#123; REP(i,n) REP(k,6) REP(j,n)&#123; view[k][i][j] = read_char(); &#125; //k视图 REP(i,n) REP(j,n) REP(l,n)&#123; pos[i][j][l] = '#'; &#125;&#125;int cntempty()&#123; int ans = 0; REP(i,n) REP(j,n) REP(k,n)&#123; if(pos[i][j][k] != '.') ans++; &#125; return ans;&#125;int cal() &#123; REP(k,6) REP(i,n) REP(j,n)&#123; if(view[k][i][j] == '.')&#123; REP(dep,n)&#123; int x,y,z; getxyz(k,i,j,dep,x,y,z); pos[x][y][z] = '.'; &#125; &#125; &#125; // finished clean position // //循环一层一层删除，到最后不能删除为止 //每次删除一层，就得到一个新的立方体 //新的立方体作为start，继续执行删除，直到不能删除为止 for(;;)&#123; bool finished = true; REP(k,6) REP(i,n) REP(j,n)&#123; if(view[k][i][j] != '.')&#123; REP(dep,n)&#123; //一层一层检查，一层一层剥开你的心 int x,y,z; getxyz(k,i,j,dep,x,y,z); if(pos[x][y][z] == '.') continue; if(pos[x][y][z] == '#')&#123; pos[x][y][z] = view[k][i][j]; break; &#125; if(pos[x][y][z] == view[k][i][j]) break; pos[x][y][z] = '.'; finished = false; //所有视图删除完之后，作为一个新的立方体 //重新进入循环 //删除！一直删到不能删为止 &#125; &#125; &#125; if(finished) break; &#125; return cntempty();&#125;int main()&#123; while(scanf(\"%d\",&amp;n) == 1 &amp;&amp; n)&#123; memset(pos,0, sizeof(pos)); memset(view,0, sizeof(view)); init(n); int ans = cal(); printf(\"Maximum weight: %d gram(s)\\n\",ans); &#125;&#125; graveyard 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n,m; while(scanf(\"%d%d\",&amp;n,&amp;m) == 2)&#123; double ans = 0.0; for(int i = 0; i &lt; n; i++)&#123; double pos = (double) i / n * (n+m); ans += fabs(pos-floor(pos+0.5)) / (n+m); &#125; printf(\"%.4lf\\n\",ans*10000); &#125;&#125; even-parity算法分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;const int maxn = 20;int data[maxn][maxn], buffer[maxn][maxn];int n;int check(int val)&#123; memset(buffer,0, sizeof(buffer)); for(int c = 0; c &lt; n; c++)&#123; if(val &amp; (1&lt;&lt;c)) buffer[0][c] = 1; //enumerate else&#123; // the number in high bits is 0 if(data[0][c] == 1) // not 0，contradict with default // enumerate default --&gt; binary bits return INF; &#125; &#125; for(int r = 1; r &lt; n; r++)&#123; for(int c = 0; c &lt; n; c++)&#123; int sum = 0; if(r &gt; 1) sum += buffer[r-2][c]; if(c &gt; 0) sum += buffer[r-1][c-1]; if(c+1 &lt; n) sum += buffer[r-1][c+1]; buffer[r][c] = sum % 2; if(data[r][c] == 1 &amp;&amp; buffer[r][c] == 0) return INF; &#125; &#125; int cnt = 0; for(int r = 0; r &lt; n; r++)&#123; for(int c = 0; c &lt; n; c++)&#123; if(data[r][c] != buffer[r][c]) cnt++; &#125; &#125; return cnt;&#125;int main()&#123; int kase; int k = 0; scanf(\"%d\",&amp;kase); while(kase--)&#123; scanf(\"%d\",&amp;n); for(int r = 0; r &lt; n; r++)&#123; for(int c = 0; c &lt; n; c++) scanf(\"%d\",&amp;data[r][c]); &#125; int ans = INF; for(int v = 0; v &lt; (1 &lt;&lt; n); v++)&#123; ans = min(ans,check(v)); &#125; if(ans == INF) ans = -1; printf(\"Case %d: %d\\n\",++k,ans); &#125;&#125; RAID算法分析图解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 6500;char data[8][maxn];bool parity;int d,s,b,w;char type;bool fix()&#123; w = s*b; for(int i = 0; i &lt; w; i++)&#123; int sum = 0; int bro_cnt = 0, bro_id = 0; for(int j = 0; j &lt; d; j++)&#123; if(data[j][i] == '1')&#123; sum++; &#125; if(data[j][i] == 'x')&#123; bro_cnt++; bro_id = j; &#125; &#125; sum %= 2; if(bro_cnt &gt;= 2) return false; else if(bro_cnt == 1)&#123; if(sum)&#123; if(parity) data[bro_id][i] = '0'; else data[bro_id][i] = '1'; &#125;else&#123; if(parity) data[bro_id][i] = '1'; else data[bro_id][i] = '0'; &#125; &#125;else if(bro_cnt == 0)&#123; if(parity == 0 &amp;&amp; sum == 1) return false; if(parity == 1 &amp;&amp; sum == 0) return false; &#125; &#125; return true;&#125;void printdata()&#123; int sum = 0; int bit_cnt = 0; for(int i = 0; i &lt; b; i++)&#123; int except = i % d; for(int j = 0; j &lt; d; j++)&#123; if(j == except) continue; for(int k = i*s; k &lt; i*s+s; k++)&#123; bit_cnt = (bit_cnt+1) % 4; if(data[j][k] == '0') sum = sum &lt;&lt; 1; if(data[j][k] == '1') sum = (sum &lt;&lt; 1) + 1; if(bit_cnt == 0)&#123; // bit finish! printf(\"%X\",sum); sum = 0; &#125; &#125; &#125; &#125; if(bit_cnt)&#123; // complete 0 int add_0 = 4 - bit_cnt; sum = sum &lt;&lt; add_0; printf(\"%X\",sum); &#125; printf(\"\\n\");&#125;int main()&#123; int kase = 0; while(cin &gt;&gt; d &amp;&amp; d)&#123; memset(data, 0, sizeof(data)); cin &gt;&gt; s &gt;&gt; b &gt;&gt; type; parity = type == 'O'; for(int i = 0; i &lt; d; i++) cin &gt;&gt; data[i]; if(!fix()) printf(\"Disk set %d is invalid.\\n\",++kase); else&#123; printf(\"Disk set %d is valid, contents are: \",++kase); printdata(); &#125; &#125; return 0;&#125; 非常重要的一种枚举思想: Colored Cubes枚举的核心，在于相对位置的变化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240//// main.cpp// coloredCubes//// Created by zhangmin chen on 2019/4/11.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)/*int Left[6] = &#123;4, 0, 2, 3, 5, 1&#125;;int Up[6] = &#123;2, 1, 5, 0, 4, 3&#125;;void rot(int* trans, int* pos) &#123; int q[6]; memcpy(q, pos, sizeof(q)); for(int i = 0; i &lt; 6; i++) &#123; pos[i] = trans[q[i]]; &#125;&#125;void enumerate() &#123; int p0[6] = &#123;0, 1, 2, 3, 4, 5&#125;; printf(\"dice24[24][6]: \\n\"); for(int i = 0; i &lt; 6; i++) &#123; int q[6]; memcpy(q, p0, sizeof(q)); if(i == 0) rot(Up, q); if(i == 1) &#123; rot(Left, q); rot(Up, q); &#125; if(i == 3) &#123; rot(Up, q); rot(Up, q); &#125; if(i == 4) &#123; rot(Left, q); rot(Left, q); rot(Left, q); rot(Up, q); &#125; if(i == 5) &#123; rot(Left, q); rot(Left, q); rot(Up, q); &#125; for(int k = 0; k &lt; 4; k++) &#123; printf(\"&#123;%d, %d, %d, %d, %d, %d&#125;,\\n\", q[0], q[1], q[2], q[3], q[4], q[5]); rot(Left, q); &#125; &#125; cout &lt;&lt; endl;&#125;int main() &#123; enumerate();&#125; *//* * dice24[24][6]: &#123;2, 1, 5, 0, 4, 3&#125;, &#123;2, 0, 1, 4, 5, 3&#125;, &#123;2, 4, 0, 5, 1, 3&#125;, &#123;2, 5, 4, 1, 0, 3&#125;, &#123;4, 2, 5, 0, 3, 1&#125;, &#123;5, 2, 1, 4, 3, 0&#125;, &#123;1, 2, 0, 5, 3, 4&#125;, &#123;0, 2, 4, 1, 3, 5&#125;, &#123;0, 1, 2, 3, 4, 5&#125;, &#123;4, 0, 2, 3, 5, 1&#125;, &#123;5, 4, 2, 3, 1, 0&#125;, &#123;1, 5, 2, 3, 0, 4&#125;, &#123;5, 1, 3, 2, 4, 0&#125;, &#123;1, 0, 3, 2, 5, 4&#125;, &#123;0, 4, 3, 2, 1, 5&#125;, &#123;4, 5, 3, 2, 0, 1&#125;, &#123;1, 3, 5, 0, 2, 4&#125;, &#123;0, 3, 1, 4, 2, 5&#125;, &#123;4, 3, 0, 5, 2, 1&#125;, &#123;5, 3, 4, 1, 2, 0&#125;, &#123;3, 4, 5, 0, 1, 2&#125;, &#123;3, 5, 1, 4, 0, 2&#125;, &#123;3, 1, 0, 5, 4, 2&#125;, &#123;3, 0, 4, 1, 5, 2&#125;, */const int dice24[24][6] = &#123; // &#123;2, 1, 5, 0, 4, 3&#125;, &#123;2, 0, 1, 4, 5, 3&#125;, &#123;2, 4, 0, 5, 1, 3&#125;, &#123;2, 5, 4, 1, 0, 3&#125;, &#123;4, 2, 5, 0, 3, 1&#125;, &#123;5, 2, 1, 4, 3, 0&#125;, &#123;1, 2, 0, 5, 3, 4&#125;, &#123;0, 2, 4, 1, 3, 5&#125;, &#123;0, 1, 2, 3, 4, 5&#125;, &#123;4, 0, 2, 3, 5, 1&#125;, &#123;5, 4, 2, 3, 1, 0&#125;, &#123;1, 5, 2, 3, 0, 4&#125;, &#123;5, 1, 3, 2, 4, 0&#125;, &#123;1, 0, 3, 2, 5, 4&#125;, &#123;0, 4, 3, 2, 1, 5&#125;, &#123;4, 5, 3, 2, 0, 1&#125;, &#123;1, 3, 5, 0, 2, 4&#125;, &#123;0, 3, 1, 4, 2, 5&#125;, &#123;4, 3, 0, 5, 2, 1&#125;, &#123;5, 3, 4, 1, 2, 0&#125;, &#123;3, 4, 5, 0, 1, 2&#125;, &#123;3, 5, 1, 4, 0, 2&#125;, &#123;3, 1, 0, 5, 4, 2&#125;, &#123;3, 0, 4, 1, 5, 2&#125;&#125;;const int maxn = 4;int colors[maxn][6];int n;int dice[maxn][6];int posD[maxn];int ans;// posD[i] = val, means No.i dice choose posture// dice24[val][...]void painting(int colors[][6], int dice[][6]) &#123; // posD[i] = val, means No.i dice choose posture // dice24[val][..] for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; 6; j++) &#123; // No.i dice surface j // dice[i][j] changed to position p = posD[i][j]; // subscript is postion p // color[i][p] = dice[i][j] int p = dice24[posD[i]][j]; colors[i][p] = dice[i][j]; &#125;&#125;void solve() &#123; // posD[i] = val, means No.i dice choose posture // dice24[val][..] painting(colors, dice); int tot = 0; for(int k = 0; k &lt; 6; k++) &#123; int cnt[maxn * 6]; memset(cnt, 0, sizeof(cnt)); int maxface = 0; for(int i = 0; i &lt; n; i++) &#123; maxface = max(maxface, ++cnt[colors[i][k]]); //debug(maxface); &#125; tot += n-maxface; &#125; ans = min(ans, tot); //debug(ans);&#125;vector&lt;string&gt; nColor;int getID(const char* name) &#123; // string str(name); int id = (int)nColor.size(); for(int i = 0; i &lt; nColor.size(); i++) &#123; if(nColor[i] == str) return i; &#125; nColor.push_back(str); return id;&#125;void dfs(int d) &#123; if(d == n) solve(); else &#123; for(int i = 0; i &lt; 24; i++) &#123; // dice[24][..] // choose one posture of dice[24][..] // depth d cubes choose posture dice[i] posD[d] = i; //_for(i, 0, maxn) debug_(posD, i); dfs(d+1); &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; // nColor.clear(); //memset(posD, 0, sizeof(posD)); //memset(colors, 0, sizeof(colors)); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; 6; j++) &#123; char name[30]; scanf(\"%s\", name); dice[i][j] = getID(name); //debug(dice[i][j]); &#125; // solve() //posD[0] = 0; ans = n*6; dfs(1); printf(\"%d\\n\", ans); &#125;&#125; IP地址与二进制 IP Networks具体涉及到二进制的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;assert.h&gt;using namespace std;#define _for(i,a,b) for( int i = (a); i &lt; (b); i++ )#define _rep(i,a,b) for( int i = (a); i &lt;= (b); i++ )const int W = 8, IPW = 4*W;bool inrange(int val, int a, int b)&#123; if(a &gt; b) return inrange(val, b, a); return a &lt;= val &amp;&amp; val &lt;= b;&#125;void toBinary(int val, int* bin, int pos)&#123; assert(inrange(val,0,255)); _for(i,0,W)&#123; bin[pos+W-1-i] = val % 2; val /= 2; &#125;&#125;void printip(const int* bin)&#123; bool first = true; for(int i = 0; i &lt; 4; i++)&#123; int x = 0; for(int k = i*W; k &lt; (i+1)*W; k++)&#123; x = (x &lt;&lt; 1) | bin[k]; &#125; if(first) first = false; else printf(\".\"); printf(\"%d\",x); &#125; puts(\"\");&#125;const int maxn = 1024;int subip[maxn][IPW+5];int main()&#123; int subNet[IPW]; int n, ip[4]; while(scanf(\"%d\",&amp;n) == 1)&#123; _for(i,0,n)&#123; scanf(\"%d.%d.%d.%d\",&amp;ip[0],&amp;ip[1],&amp;ip[2],&amp;ip[3]); _for(j,0,4)&#123; toBinary(ip[j],subip[i],j*W); &#125; &#125; //finished! Get ip binary presentation memset(subNet,0,sizeof(subNet)); //enumerate int len; for(len = 0; len &lt; IPW; len++)&#123; bool same = true; //erogodic for(int p = 1; p &lt; n; p++)&#123; if(subip[p-1][len] != subip[p][len])&#123; same = false; break; &#125; &#125; if(!same) break; &#125; //len: position-&gt; the first different element //len start from 0, it means the longest length fill_n(subNet,len,1); fill_n(subip[0]+len,IPW-len,0); printip(subip[0]); printip(subNet); &#125;&#125; Morse Mismatches表的建立： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;unordered_map&lt;char, string&gt; morse;unordered_map&lt;string, vector&lt;string&gt; &gt; context;bool isprefix(const string&amp; A, const string&amp; B)&#123; return A.size() &lt; B.size() &amp;&amp; B.compare(0,A.size(),A) == 0;&#125;void solve(const string&amp; m)&#123; if(context.count(m))&#123; const auto&amp; word_v = context[m]; cout &lt;&lt; word_v.front(); if(word_v.size() &gt; 1)&#123; cout &lt;&lt; \"!\"; &#125; cout &lt;&lt; endl; return; &#125; map&lt;int, string&gt; ans; for(const auto&amp; it: context)&#123; const string&amp; m_ext = it.first; if(isprefix(m, m_ext)) ans[m_ext.size()-m.size()] = it.second.front(); else if(isprefix(m_ext, m)) ans[m.size()-m_ext.size()] = it.second.front(); &#125; cout &lt;&lt; ans.begin() -&gt; second &lt;&lt; \"?\" &lt;&lt; endl;&#125;int main()&#123; string alpha,M; while(cin &gt;&gt; alpha &amp;&amp; alpha != \"*\")&#123; cin &gt;&gt; M; morse[alpha[0]] = M; &#125; while(cin &gt;&gt; alpha &amp;&amp; alpha != \"*\")&#123; M.clear(); for(auto p : alpha)&#123; M += morse[p]; &#125; context[M].push_back(alpha); &#125; while(cin &gt;&gt; M &amp;&amp; M != \"*\")&#123; solve(M); &#125; return 0;&#125; extraordinarily tired students 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;struct stu&#123; int a; int b; int c;&#125;;#define MAX_TIME 1000000int n;istream&amp; operator&gt;&gt; (istream&amp; is, stu&amp; s) &#123; return is &gt;&gt; s.a &gt;&gt; s.b &gt;&gt; s.c;&#125;stu stus[10+5];bool action(int kase,int t)&#123; int wake = 0, sleep = 0; for(int i = 0; i &lt; n; i++)&#123; if(stus[i].c &lt;= stus[i].a) wake++; &#125; sleep = n-wake; if(sleep == 0)&#123; cout &lt;&lt; \"Case \" &lt;&lt; kase &lt;&lt; \": \" &lt;&lt; t &lt;&lt; endl; return true; &#125; for(int i = 0; i &lt; n; i++)&#123; stu&amp; s = stus[i]; s.c++; if(s.c == s.a + s.b + 1) s.c = 1; if(s.c == s.a + 1 &amp;&amp; wake &gt;= sleep) s.c = 1; &#125; return false;&#125;int main()&#123; int kase = 1; while(scanf(\"%d\",&amp;n) &amp;&amp; n)&#123; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; stus[i]; &#125; int t; for(t = 1; t &lt; MAX_TIME; t++)&#123; if(action(kase, t)) break; &#125; if(t == MAX_TIME) cout &lt;&lt; \"Case \" &lt;&lt; kase &lt;&lt; \": \" &lt;&lt; \"-1\" &lt;&lt; endl; kase++; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"算法竞赛入门：基础算法(一)","slug":"20180823","date":"2018-08-23T12:18:00.000Z","updated":"2019-03-07T03:58:14.441Z","comments":true,"path":"2018/08/23/20180823/","link":"","permalink":"https://www.fogsail.net/2018/08/23/20180823/","excerpt":"函数的嵌套，加上递归处理，能够解决非常多生活背景下的模拟问题","text":"函数的嵌套，加上递归处理，能够解决非常多生活背景下的模拟问题 Ancient Cipher核心算法图解： 实现方法：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;int cmp(const void *a,const void *b)&#123; return *(int *)a - *(int *)b;&#125;int main()&#123; char s1[200], s2[200]; while((scanf(\"%s%s\",s1,s2)==2)) &#123; int n = strlen(s1); int cnt1[26]=&#123;0&#125;, cnt2[26]=&#123;0&#125;; for(int i = 0; i &lt; n; i++) cnt1[ s1[i]-'A' ]++; for(int i = 0; i &lt; n; i++) cnt2[ s2[i]-'A' ]++; qsort(cnt1,26,sizeof(int),cmp); qsort(cnt2,26,sizeof(int),cmp); int flag = 1; for(int i = 0 ; i &lt; 26; i++) &#123; if(cnt1[i] != cnt2[i]) flag = 0; &#125; if(flag) printf(\"YES\\n\"); else printf(\"NO\\n\"); &#125; return 0;&#125; message-decoding算法图解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;stdio.h&gt;#include &lt;string.h&gt;int code[8][1&lt;&lt;8];//二进制编码//code[len][val]，len表示编码长度//val表示二进制编码所对应的十进制的值//code[len][val]表示这个编码所对应的字符‘//处理换行读入问题int readchar()&#123; for(;;) &#123; int ch = getchar(); if(ch != '\\n' &amp;&amp; ch != '\\r') return ch; &#125;&#125;//执行功能：一个一个字母读入//绕过'\\n' '\\r'执行输出//按位读入二进制数并且转换为十进制整数int getint(int bits)&#123; int val = 0; while(bits--) &#123; // v = v * 2 means v &lt;&lt; 1 val = val * 2 + readchar() - '0'; &#125; return val;&#125;int readcodes()&#123; memset(code,0,sizeof(code)); code[1][0] = readchar(); //用来储存编码头代表的译码 for(int len = 2; len &lt;= 7; len++) &#123; for(int v = 0; v &lt; (1&lt;&lt;len)-1; v++) &#123; int ch = getchar(); if(ch == EOF) return 0; if(ch == '\\n' || ch == '\\r') return 1; code[len][v] = ch; &#125; &#125; return 1;&#125;//对编码头信息的解码//表示编码内容读取的长度void printcodes()&#123; for(int len = 1; len &lt;= 7; len++) &#123; for(int v = 0; v &lt; (1&lt;&lt;len)-1; v++) &#123; if(code[len][v] == 0) return; //printf(\"code[%d][%d] = %c\\n\",len,v,code[len][v]); &#125; &#125;&#125;int main()&#123; while(readcodes()) //input codes，输入第一行的编码 &#123; printcodes(); for(;;) &#123; int len = getint(3); if(len == 0) break; // 000 quit //printf(\"len = %d\\n\",len); for(;;) &#123; int val = getint(len); if(val == (1&lt;&lt;len)-1 ) break; putchar(code[len][val]); //printf(\" \"); &#125; &#125; putchar('\\n'); &#125; return 0;&#125; spreadsheet-tracking 用2种方法，用flag简化计算直接模拟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;string.h&gt;#define maxd 100#define BIG 10000using namespace std;int sh[maxd][maxd], sh_buf[maxd][maxd], ans[maxd][maxd];int row, col;int begr, begc;int change[maxd];// int oldr,oldc;// int newr,newc;void init()&#123; for(int i = 1; i &lt;= row; i++) &#123; for(int j = 1; j &lt;= col; j++) sh[i][j] = i*BIG+j; &#125;&#125;void movesh(char type,int fresh,int old)&#123; if(type == 'R') &#123; for(int i = 1; i &lt;= col; i++) sh[fresh][i] = sh_buf[old][i]; &#125; else &#123; for(int i = 1; i &lt;= row; i++) sh[i][fresh] = sh_buf[i][old]; &#125;&#125;//算法处理一：用type=='R'，选择的方式，来把行变换和列变换统一起来void del(char type)&#123; // memset(sh_buf,0,sizeof(sh_buf)); //memset(change,0,sizeof(change)); memcpy(sh_buf,sh,sizeof(sh)); int cnt = 0; int way = (type == 'R' ? row : col); for(int i = 1; i &lt;= way; i++) &#123; if(change[i] == 0) movesh(type,++cnt,i); &#125; if(type == 'R') &#123; row = cnt; for(int i = row+1; i &lt;= way; i++) for(int j = 1; j &lt;= col; j++) sh[i][j] = 0; &#125; else &#123; col = cnt; for(int i = 1; i &lt;= row; i++) for(int j = col+1; j &lt;= way; j++) sh[i][j] = 0; &#125;&#125;void printsheet()&#123; for(int i = 0; i &lt;= row+2; i++) &#123; for(int j = 0; j &lt;= col+2; j++) cout &lt;&lt; sh[i][j] &lt;&lt;\" \"; cout &lt;&lt; endl; &#125;&#125;void insert(char type)&#123; // memset(sh_buf,0,sizeof(sh_buf)); memcpy(sh_buf,sh,sizeof(sh)); int cnt = 0; int way = (type == 'R' ? row : col); for(int i = 1; i &lt;= way; i++) &#123; if(change[i] == 1) movesh(type,++cnt,0); movesh(type,++cnt,i); //这一步卡住了 &#125; if(type == 'R') row = cnt; else col = cnt;&#125;// void reset()// &#123;// memcpy(sh_buf,sh,sizeof(sh));// for(int i = 1; i &lt;= maxd; i++)// &#123;// for(int j = 1; j &lt;= maxd; j++)// &#123;// if(i &gt; row || j &gt; col)// sh_buf[i][j] = 0;// &#125;// &#125;// &#125;int main()&#123; // cin &gt;&gt; row &gt;&gt; col; // // begr = row, begc = col; // init(); // memset(change,0,sizeof(change)); // printsheet(); // // string cmd; // cin &gt;&gt; cmd; // // int op_row; // cin &gt;&gt; op_row; // change[op_row] = 1; // del(cmd[1]); // // reset(); // printsheet(); // memset(change,0,sizeof(change)); // cmd.clear(); // // cin &gt;&gt; cmd; // int op_col; // cin &gt;&gt; op_col; // change[op_col] = 1; // insert(cmd[1]); // // reset(); // printsheet(); // 操作数必须和原来的值保持一致 int kase; char cmd[10]; int sit = 0; memset(sh,0,sizeof(sh)); while(scanf(\"%d%d%d\",&amp;row,&amp;col,&amp;kase)==3 &amp;&amp; row) &#123; init(); while (kase--) &#123; scanf(\"%s\",cmd); int r1,c1,r2,c2; if(cmd[0] == 'E') &#123; scanf(\"%d%d%d%d\",&amp;r1,&amp;c1,&amp;r2,&amp;c2); swap(sh[r1][c1],sh[r2][c2]); // printsheet(); &#125; else &#123; int oper; scanf(\"%d\",&amp;oper); memset(change,0,sizeof(change)); //算法处理二：用change[]来标记需要处理的行/列 //把要操作的数全部选出来 for(int i = 0; i &lt; oper; i++) &#123; //memset(change,0,sizeof(change)); int cur; // int r1,c1,r2,c2; scanf(\"%d\",&amp;cur); change[cur] = 1; &#125; //将change标记预先选出来 if(cmd[0] == 'D') &#123; //change[cur] = 1; del(cmd[1]); &#125; if(cmd[0] == 'I') &#123; //change[cur] = 1; insert(cmd[1]); &#125; // printsheet(); // printsheet(); &#125; &#125; memset(ans,0,sizeof(ans)); //这是一个好习惯！ //所有全局变量在赋值之前需要初始化 for(int i = 0; i &lt;= row; i++) &#123; for(int j = 0; j &lt;= col; j++) &#123; ans[sh[i][j]/BIG][sh[i][j]%BIG] = i*BIG+j; //算法处理三：ans相当于一个hash map //将原来的坐标ans[sh[r]/BIG][sh[c]%BIG] --&gt; newr*BIG+newc //这样最后查询(qr,qc),直接用ans[qr][qc]就可以了 //ans[qr][qc]/BIG --- ans[qr][qc]%BIG就是最后的结论 &#125; &#125; if(sit &gt; 0) printf(\"\\n\"); printf(\"Spreadsheet #%d\\n\",++sit); int query; int rq,cq; scanf(\"%d\",&amp;query); while(query--) &#123; if(scanf(\"%d%d\",&amp;rq,&amp;cq) == 2 &amp;&amp; rq) &#123; printf(\"Cell data in (%d,%d) \",rq,cq); int data = ans[rq][cq]; if(data == 0) printf(\"GONE\\n\"); else printf(\"moved to (%d,%d)\\n\",data/BIG,data%BIG); &#125; &#125; &#125;&#125; 使用结构体简化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;cstring&gt;#define maxd 10000using namespace std;struct Command&#123; char c[5]; int r1, c1, r2, c2; int op_n, change[20];&#125; cmd[maxd];int row, col, cn;int oldr, oldc;int rq,cq;// int flag = 1;bool operation(int* rq, int* cq)&#123; for(int i = 0; i &lt; cn; i++) &#123; if(cmd[i].c[0] == 'E') &#123; if(cmd[i].r1 == *rq &amp;&amp; cmd[i].c1 == *cq) &#123; *rq = cmd[i].r2; *cq = cmd[i].c2; &#125; else if(cmd[i].r2 == *rq &amp;&amp; cmd[i].c2 == *cq) &#123; *rq = cmd[i].r1; *cq = cmd[i].c1; &#125; &#125; //other Command else &#123; int dr = 0, dc = 0; if(cmd[i].c[0] == 'I') //INSERT &#123; for(int j = 0; j &lt; cmd[i].op_n; j++) &#123; if(cmd[i].c[1] == 'R' &amp;&amp; cmd[i].change[j] &lt;= *rq) //cmd[i].change[j] --&gt; row insert dr++; if(cmd[i].c[1] == 'C' &amp;&amp; cmd[i].change[j] &lt;= *cq) //col insert; dc++; &#125; &#125; if(cmd[i].c[0] == 'D') //delete &#123; for(int j = 0; j &lt; cmd[i].op_n; j++) &#123; if(cmd[i].c[1] == 'R' &amp;&amp; cmd[i].change[j] == *rq) return 0; if(cmd[i].c[1] == 'C' &amp;&amp; cmd[i].change[j] == *cq) return 0; if(cmd[i].c[1] == 'R' &amp;&amp; cmd[i].change[j] &lt; *rq) dr--; if(cmd[i].c[1] == 'C' &amp;&amp; cmd[i].change[j] &lt; *cq) dc--; &#125; &#125; *rq += dr; *cq += dc; &#125; &#125; return 1;&#125;int main()&#123; // int row,col,cn; // int rq, cq; int kase = 0; while(scanf(\"%d%d%d\",&amp;row,&amp;col,&amp;cn) == 3 &amp;&amp; row) &#123; for(int i = 0; i &lt; cn; i++) &#123; scanf(\"%s\",cmd[i].c); // cout &lt;&lt; cmd[i].c[0] &lt;&lt; endl; if(cmd[i].c[0] == 'E') &#123; scanf(\"%d%d%d%d\",&amp;cmd[i].r1,&amp;cmd[i].c1,&amp;cmd[i].r2,&amp;cmd[i].c2); &#125; else &#123; scanf(\"%d\",&amp;cmd[i].op_n); for(int j = 0; j &lt; cmd[i].op_n; j++) scanf(\"%d\",&amp;cmd[i].change[j]); &#125; &#125; //QUERY: if(kase &gt; 0) printf(\"\\n\"); printf(\"Spreadsheet #%d\\n\",++kase); int query; scanf(\"%d\",&amp;query); while(query--) &#123; scanf(\"%d%d\",&amp;rq,&amp;cq); oldr = rq; oldc = cq; printf(\"Cell data in (%d,%d) \",oldr,oldc); int flag = operation(&amp;rq,&amp;cq); if(flag == 0) printf(\"GONE\\n\"); else printf(\"moved to (%d,%d)\\n\",rq,cq); &#125; &#125;&#125; A Typical Homework这题目我AC了整整十几次！ 记录一下自己弄错的地方 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define EPS 1e-5#define maxs 105//105 students#define maxid 105//15 digitsusing namespace std;//int n;//int removed[maxs] = &#123;0&#125;;int subject[6];//subject[1] pass subject 1 --&gt; subject[2] pass subject 2int lastid = 0;typedef struct Students&#123; bool removed; char sid[maxid]; int cid; char name[maxid]; int chinese; int math; int english; int coding;// int rank; int totscore; bool operator &lt; (const Students&amp; s) const&#123; return totscore &gt; s.totscore; &#125; Students() &#123; memset(this,0,sizeof(Students)); &#125;&#125;students;typedef struct Klass&#123; int totstu; int score[4]; int pass[4]; Klass() &#123; memset(this,0,sizeof(Klass)); &#125;&#125;klass;//vector&lt;klass&gt; kl(maxs);klass kl[maxs + 5];vector&lt;students&gt; stu;bool valid(students fresh)&#123; vector&lt;students&gt;::iterator it; for(it = stu.begin(); it != stu.end(); it++) &#123; if(! (*it).removed ) &#123; if(strcmp((*it).sid, fresh.sid) == 0) return 0; &#125; &#125; return 1;&#125;void add()&#123; for(;;) &#123; students fresh; printf(\"Please enter the SID, CID, name and four scores. Enter 0 to finish.\\n\"); scanf(\"%s\",fresh.sid); if(strcmp(fresh.sid, \"0\") == 0) break; scanf(\"%d%s%d%d%d%d\",&amp;fresh.cid,fresh.name,&amp;fresh.chinese,&amp;fresh.math,&amp;fresh.english,&amp;fresh.coding); if(valid(fresh)) &#123; fresh.totscore = fresh.chinese + fresh.math + fresh.english + fresh.coding; fresh.removed = 0; int k = fresh.cid; kl[k].score[0] += fresh.chinese; kl[k].score[1] += fresh.math; kl[k].score[2] += fresh.english; kl[k].score[3] += fresh.coding; if(fresh.chinese &gt;= 60) kl[k].pass[0]++; if(fresh.math &gt;= 60) kl[k].pass[1]++; if(fresh.english &gt;= 60) kl[k].pass[2]++; if(fresh.coding &gt;= 60) kl[k].pass[3]++; kl[k].totstu++; stu.push_back(fresh); &#125; else printf(\"Duplicated SID.\\n\"); &#125;&#125;//add() finished!int getrank(students cur)&#123; int r = 0; vector&lt;students&gt;::iterator it; for(it = stu.begin(); ((*it).sid != cur.sid) &amp;&amp; it != stu.end(); it++) &#123; if(!((*it).removed) &amp;&amp; (*it).totscore &gt; cur.totscore) r++; &#125; return r+1;&#125;//rank() finishedvoid DQ(int isq)&#123; for(;;) &#123; char choose[maxs]; printf(\"Please enter SID or name. Enter 0 to finish.\\n\"); scanf(\"%s\",choose); if(strcmp(choose,\"0\") == 0) break; int cal = 0; vector&lt;students&gt;::iterator it; for(it = stu.begin(); it != stu.end(); it++) &#123; if(!(*it).removed) &#123;// cout &lt;&lt; stu[i].sid &lt;&lt; \"--&gt;\" &lt;&lt; choose &lt;&lt; endl;// cout &lt;&lt; stu[i].name &lt;&lt; \"--&gt;\" &lt;&lt; choose &lt;&lt; endl; if(strcmp((*it).sid,choose) == 0 || strcmp((*it).name,choose) == 0 ) &#123; if(isq) //printf(\"%d %s %d %s %d %d %d %d %d %.2f\\n\", stu[i].rank, stu[i].sid, stu[i].cid, stu[i].name,stu[i].chinese,stu[i].math,stu[i].english,stu[i].coding,stu[i].totscore,stu[i].totscore/4.0+EPS); printf(\"%d %s %d %s %d %d %d %d %d %.2f\\n\",getrank(*it),(*it).sid, (*it).cid, (*it).name,(*it).chinese,(*it).math,(*it).english,(*it).coding,(*it).totscore,(*it).totscore/4.0+EPS); else &#123; (*it).removed = 1; //removed students also infect klass int rid = (*it).cid; kl[rid].totstu--; kl[rid].score[0] -= (*it).chinese; kl[rid].score[1] -= (*it).math; kl[rid].score[2] -= (*it).english; kl[rid].score[3] -= (*it).coding; if((*it).chinese &gt;= 60) kl[rid].pass[0]--; if((*it).math &gt;= 60) kl[rid].pass[1]--; if((*it).english &gt;= 60) kl[rid].pass[2]--; if((*it).coding &gt;= 60) kl[rid].pass[3]--; cal++; &#125; &#125;// if(!isq)// printf(\"%d student(s) removed.\\n\",cal); &#125; &#125; if(!isq) printf(\"%d student(s) removed.\\n\",cal); &#125;&#125;//DQ test finished!void overall_stat(int check)&#123; memset(subject, 0, sizeof(subject)); vector&lt;students&gt;::iterator it; for(it = stu.begin(); it != stu.end(); it++) &#123; if(!(*it).removed &amp;&amp; (check == 0 || (*it).cid == check)) &#123; int k = 0; if((*it).chinese &gt;= 60) k++; if((*it).math &gt;= 60) k++; if((*it).english &gt;= 60) k++; if((*it).coding &gt;= 60) k++; subject[k]++; &#125; &#125;// for(int i = 0; i &lt; 6; i++)// printf(\"pass %d : %d \", i , subject[i]);&#125;//test finishedvoid stat()&#123; int check; printf(\"Please enter class ID, 0 for the whole statistics.\\n\"); scanf(\"%d\",&amp;check); if(check != 0) &#123; printf(\"Chinese\\n\"); printf(\"Average Score: %.2f\\n\",(double)kl[check].score[0]/(double)kl[check].totstu+EPS); printf(\"Number of passed students: %d\\n\",kl[check].pass[0]); printf(\"Number of failed students: %d\\n\",kl[check].totstu-kl[check].pass[0]); printf(\"\\n\"); printf(\"Mathematics\\n\"); printf(\"Average Score: %.2f\\n\",(double)kl[check].score[1]/(double)kl[check].totstu+EPS); printf(\"Number of passed students: %d\\n\",kl[check].pass[1]); printf(\"Number of failed students: %d\\n\",kl[check].totstu-kl[check].pass[1]); printf(\"\\n\"); printf(\"English\\n\"); printf(\"Average Score: %.2f\\n\",(double)kl[check].score[2]/(double)kl[check].totstu+EPS); printf(\"Number of passed students: %d\\n\",kl[check].pass[2]); printf(\"Number of failed students: %d\\n\",kl[check].totstu-kl[check].pass[2]); printf(\"\\n\"); printf(\"Programming\\n\"); printf(\"Average Score: %.2f\\n\",(double)kl[check].score[3]/(double)kl[check].totstu+EPS); printf(\"Number of passed students: %d\\n\",kl[check].pass[3]); printf(\"Number of failed students: %d\\n\",kl[check].totstu-kl[check].pass[3]); printf(\"\\n\"); &#125; else &#123; int s1=0, s2=0, s3=0, s4=0; int p1=0, p2=0, p3=0, p4=0; int m = 0; vector&lt;students&gt;::iterator it; for(it = stu.begin(); it != stu.end(); it++) &#123; if(!(*it).removed ) &#123; m++; s1 += (*it).chinese; s2 += (*it).math; s3 += (*it).english; s4 += (*it).coding; if((*it).chinese &gt;= 60) p1++; if((*it).math &gt;= 60) p2++; if((*it).english &gt;= 60) p3++; if((*it).coding &gt;= 60) p4++; &#125; &#125; printf(\"Chinese\\n\"); printf(\"Average Score: %.2f\\n\",(double)s1/(double)m+EPS); printf(\"Number of passed students: %d\\n\",p1); printf(\"Number of failed students: %d\\n\",m-p1); printf(\"\\n\"); printf(\"Mathematics\\n\"); printf(\"Average Score: %.2f\\n\",(double)s2/(double)m+EPS); printf(\"Number of passed students: %d\\n\",p2); printf(\"Number of failed students: %d\\n\",m-p2); printf(\"\\n\"); printf(\"English\\n\"); printf(\"Average Score: %.2f\\n\",(double)s3/(double)m+EPS); printf(\"Number of passed students: %d\\n\",p3); printf(\"Number of failed students: %d\\n\",m-p3); printf(\"\\n\"); printf(\"Programming\\n\"); printf(\"Average Score: %.2f\\n\",(double)s4/(double)m+EPS); printf(\"Number of passed students: %d\\n\",p4); printf(\"Number of failed students: %d\\n\",m-p4); printf(\"\\n\"); &#125; overall_stat(check); printf(\"Overall:\\n\"); printf(\"Number of students who passed all subjects: %d\\n\",subject[4]); printf(\"Number of students who passed 3 or more subjects: %d\\n\",subject[3]+subject[4]); printf(\"Number of students who passed 2 or more subjects: %d\\n\",subject[2]+subject[3]+subject[4]); printf(\"Number of students who passed 1 or more subjects: %d\\n\",subject[1]+subject[2]+subject[3]+subject[4]); printf(\"Number of students who failed all subjects: %d\\n\",subject[0]); printf(\"\\n\");&#125;void print_menu()&#123; printf(\"Welcome to Student Performance Management System (SPMS).\\n\"); printf(\"\\n\"); printf(\"1 - Add\\n\"); printf(\"2 - Remove\\n\"); printf(\"3 - Query\\n\"); printf(\"4 - Show ranking\\n\"); printf(\"5 - Show Statistics\\n\"); printf(\"0 - Exit\\n\"); printf(\"\\n\");&#125;//void printdata(int n)//&#123;// for(int i = 0; i &lt; n; i++)// &#123;// printf(\"%s %d %s %d %d %d %d %d rank: %d\\n\",stu[i].sid,stu[i].cid,stu[i].name,stu[i].chinese,stu[i].math,stu[i].english,stu[i].coding,stu[i].totscore,stu[i].rank);// &#125;//&#125;int main()&#123; for( ; ; ) &#123; int choice; print_menu(); scanf(\"%d\",&amp;choice); if(choice == 0) break; if(choice == 1) &#123; add();// cout &lt;&lt; stucnt;// getrank(cnt);// getklass(cnt);// cout &lt;&lt; cnt &lt;&lt; \" students \"&lt;&lt; endl; &#125;// for(int i = 0; i &lt; cnt; i++)// printf(\"students %s \",stu[i].name);// printf(\"\\n removed: \");// for(int i = 0; i &lt; cnt; i++)// printf(\"%d \",removed[i]);// sort(stu,stu+cnt);// printdata(cnt);// printf(\"\\n\");// printf(\"enter check : \");// int check;// scanf(\"%d\",&amp;check);// overall_stat(cnt,check,subject); if(choice == 2) DQ(0); if(choice == 3) DQ(1); if(choice == 4) printf(\"Showing the ranklist hurts students' self-esteem. Don't do that.\\n\"); if(choice == 5) stat(); &#125;&#125; Xiangqi这个题我也纠结了好久，就是判断是否将军，这很关键 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef struct Points&#123; int x; int y; Points(int x = 0, int y = 0): x(x), y(y) &#123;&#125;&#125;points;points operator+ (const points&amp; A, const points&amp; B) &#123; return points(A.x+B.x,A.y+B.y); &#125;points operator- (const points&amp; A, const points&amp; B) &#123; return points(A.x+B.x,A.y+B.y); &#125;points operator* (const points&amp; A, int m) &#123; return points(A.x*m,A.y*m); &#125;points operator/ (const points&amp; A, int m) &#123; return points(A.x/m,A.y/m); &#125;//运算符重载，判断马腿，容易写错bool operator== (const points&amp; A, const points&amp; B) &#123; return (A.x == B.x &amp;&amp; A.y == B.y); &#125;bool operator&lt; (const points&amp; A, const points&amp; B) &#123; return (A.x &lt; B.x) || (A.x == B.x &amp;&amp; A.y &lt; B.y) ; &#125;char grid[16][16] = &#123;0&#125;;points dirs[4] = &#123;points(-1,0),points(0,1),points(1,0),points(0,-1)&#125;;points hdirs[8] = &#123;points(2,1),points(1,2),points(-1,2),points(-2,1),points(2,-1),points(1,-2),points(-1,-2),points(-2,-1)&#125;;//红子吃掉黑子的情况要单独判断//要把原来的那个位置放置什么类型的棋子给放到buffer中//每判断一种情况后进行复原，再进行新一轮棋子的判断points blackG, redG;vector &lt;points&gt; redcheck;bool valid(const points&amp; p)&#123; bool flagx = (p.x&gt;=1 &amp;&amp; p.x&lt;=3); bool flagy = (p.y&gt;=4 &amp;&amp; p.y&lt;=6); return (flagx &amp;&amp; flagy);&#125;bool straight(const points&amp; p1,const points&amp; p2, int between)// chariot and cannon&#123; int lx = min(p1.x,p2.x); int hx = max(p1.x,p2.x); int ly = min(p1.y,p2.y); int hy = max(p1.y,p2.y); int cnt = 0; if(p1.x == p2.x) &#123; for(int y = ly+1; y &lt; hy; y++) &#123; if(grid[p1.x][y]) cnt++; if(cnt &gt; between) return false; &#125; return cnt == between; &#125; if(p1.y == p2.y) &#123; for(int x = lx+1; x &lt; hx; x++) &#123; if(grid[x][p1.y]) cnt++; if(cnt &gt; between) return false; &#125; return cnt == between; &#125; return false;&#125;bool checkmate(const points&amp; r, const points&amp; b)&#123; switch(grid[r.x][r.y]) &#123; case 'G': return r.y == b.y &amp;&amp; straight(r,b,0); case 'R': return (r.y == b.y || r.x == b.x) &amp;&amp; straight(r,b,0); case 'C': return (r.x == b.x || r.y == b.y) &amp;&amp; straight(r,b,1); case 'H': for(int i = 0; i &lt; 8; i++) &#123; points hnext = r + hdirs[i]; points leg = r + hdirs[i]/2; if(hnext == b &amp;&amp; grid[leg.x][leg.y] == 0) return true; &#125; return false; default: return false; &#125;&#125;//将军的判断，是否完成了一次成功的将军bool canwin()&#123; if(blackG.y == redG.y &amp;&amp; straight(blackG,redG,0)) return false;// bool live = true; for(int i = 0; i &lt; 4; i++) &#123; points bnext = blackG + dirs[i]; bool live = true; if(!valid(bnext)) continue; char buffer = grid[bnext.x][bnext.y]; grid[bnext.x][bnext.y] = 0; //红子吃掉黑子的情况要单独判断 //要把原来的那个位置放置什么类型的棋子给放到buffer中 //每判断一种情况后进行复原，再进行新一轮棋子的判断 //这里是特别需要注意的 for(vector&lt;points&gt;::iterator it = redcheck.begin(); it != redcheck.end(); it++) &#123; points rcur = *it; if(grid[rcur.x][rcur.y] &amp;&amp; checkmate(rcur,bnext)) &#123; live = false; break; &#125; &#125; grid[bnext.x][bnext.y] = buffer; if(live) return false; &#125; return true;&#125;int main()&#123; int kase; while(scanf(\"%d%d%d\",&amp;kase,&amp;(blackG.x),&amp;(blackG.y))==3 &amp;&amp; kase) &#123; redcheck.clear(); memset(grid,0,sizeof(grid)); char type; int x,y; while(kase) &#123;// cout &lt;&lt; \"kase: \" &lt;&lt; kase &lt;&lt; endl; cin &gt;&gt; type &gt;&gt; x &gt;&gt; y; points p(x,y); redcheck.push_back(p); grid[p.x][p.y] = type; if(type == 'G') redG = p; kase--; &#125; if(canwin()) printf(\"YES\\n\"); if(!canwin()) printf(\"NO\\n\"); &#125;&#125; othello这是我当时最快速度ac的题目，纪念一下 特别注意一下优先队列和一些排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;typedef struct points&#123; int row; int col; points(int row = 0, int col = 0):row(row),col(col) &#123;&#125;&#125;pos;bool operator&lt; (const pos&amp; A,const pos&amp; B) &#123;return (A.row&lt;B.row) || (A.row==B.row &amp;&amp; A.col&lt;B.col);&#125;bool operator== (const pos&amp; A,const pos&amp; B) &#123;return (A.row==B.row) &amp;&amp; (A.col==B.col);&#125;bool operator!= (const pos&amp; A,const pos&amp; B) &#123;return (A.row!=B.row) || (A.col!=B.col);&#125;pos operator+ (const pos&amp; A,const pos&amp; B) &#123;return pos(A.row+B.row,A.col+B.col);&#125;pos operator- (const pos&amp; A,const pos&amp; B) &#123;return pos(A.row-B.row,A.col-B.col);&#125;char board[16][16];bool mark[16][16];char player;pos dr1[4] = &#123;pos(-1,0),pos(-1,1),pos(0,1),pos(1,1)&#125;;pos dr2[4] = &#123;pos(1,0),pos(1,-1),pos(0,-1),pos(-1,-1)&#125;;pos walk[8] = &#123;pos(-1,0),pos(-1,1),pos(0,1),pos(1,1),pos(1,0),pos(1,-1),pos(0,-1),pos(-1,-1)&#125;;set&lt;pos&gt; res;map&lt;pos,int&gt; dir;//remember clear()!bool valid(const pos&amp; p)&#123; bool flag1 = p.row &gt;= 1 &amp;&amp; p.row &lt;= 8; bool flag2 = p.col &gt;= 1 &amp;&amp; p.col &lt;= 8; return flag1 &amp;&amp; flag2;&#125;bool empty(const pos&amp; p)&#123; return board[p.row][p.col] == '-';&#125;char getboard()&#123; for(int i = 1; i &lt;= 8; i++)&#123; for(int j = 1; j &lt;= 8; j++)&#123; cin &gt;&gt; board[i][j]; &#125; &#125; cin &gt;&gt; player; return player;&#125;void printboard(int kase)&#123; for(int i = 1; i &lt;= 8; i++)&#123; for(int j = 1; j &lt;= 8; j++)&#123; cout &lt;&lt; board[i][j]; &#125; cout &lt;&lt; endl; &#125; if(kase) cout &lt;&lt; endl;&#125;void checkdisk(char opp,char curp)&#123; for(int i = 1; i &lt;= 8; i++)&#123; for(int j = 1; j &lt;= 8; j++)&#123; if(board[i][j] == opp)&#123; pos cur(i,j);// pos up = cur, down = cur; for(int k = 0; k &lt; 4; k++)&#123; pos up = cur, down = cur; do&#123; up = up + dr1[k]; if(!valid(up)) break; &#125;while(board[up.row][up.col] == opp); do&#123; down = down + dr2[k]; if(!valid(down)) break; &#125;while(board[down.row][down.col] == opp); if(!valid(up) || !valid(down)) continue; char flag1 = board[up.row][up.col]; char flag2 = board[down.row][down.col]; if(flag1 == '-' &amp;&amp; flag2 == curp)&#123; res.insert(up); dir[up] = k; &#125; if(flag1 == curp &amp;&amp; flag2 == '-')&#123; res.insert(down); dir[down] = k; &#125; &#125; &#125; &#125; &#125;&#125;void printpos()&#123; set&lt;pos&gt;::iterator it; int cnt = 0; if(!res.size())&#123; printf(\"No legal move.\"); &#125; else&#123; for(it = res.begin(); it != res.end(); it++)&#123; cnt++; printf(\"(%d,%d)\",(*it).row,(*it).col); if(cnt!=res.size()) printf(\" \"); &#125; &#125; printf(\"\\n\");&#125;void change(const pos&amp; p, char opp, char curp)&#123; pos start = p; mark[start.row][start.col] = 1; for(int i = 0; i &lt; 8; i++)&#123; pos next = p + walk[i]; if(empty(next)) continue; while(board[next.row][next.col] == opp)&#123; next = next + walk[i]; &#125; if(board[next.row][next.col] == curp)&#123; for(next = next-walk[i]; next!=start; next = next-walk[i])&#123; if(!mark[next.row][next.col])&#123; mark[next.row][next.col] = 1; &#125; &#125; &#125; &#125; for(int i = 1; i &lt;= 8; i++)&#123; for(int j = 1; j &lt;= 8; j++)&#123; if(mark[i][j] == 1)&#123; board[i][j] = curp; &#125; &#125; &#125;&#125;pos getmove()&#123; int row,col; cin &gt;&gt; row &gt;&gt; col; return pos(row,col);&#125;void list()&#123; int w = 0,b = 0; for(int i = 1; i &lt;= 8; i++)&#123; for(int j = 1; j &lt;= 8; j++)&#123; if(board[i][j] == 'W') w++; if(board[i][j] == 'B') b++; &#125; &#125; printf(\"Black - %2d White - %2d\\n\",b,w);&#125;int main()&#123; /*char curp = getboard(); char opp; if(curp == 'B') opp = 'W'; if(curp == 'W') opp = 'B'; checkdisk(opp,curp);// printdir(); printpos(); pos disk = getmove(); change(disk,opp,curp); printboard();// char cmd;// cin &gt;&gt; cmd;//// if(cmd == 'L')// printpos();*/ int kase; scanf(\"%d\",&amp;kase); while(kase--)&#123; memset(board,0, sizeof(board)); memset(mark,0, sizeof(mark)); res.clear(); dir.clear(); char gamer[2]; gamer[0] = getboard();//cur if(gamer[0] == 'B') gamer[1] = 'W'; //another if(gamer[0] == 'W') gamer[1] = 'B'; int flag = 0; char cmd[5]; for(;;)&#123; scanf(\"%s\",cmd); if(cmd[0] == 'Q')&#123; printboard(kase); break; &#125; if(cmd[0] == 'L')&#123; checkdisk(gamer[1-flag],gamer[flag]); printpos(); if(!res.size())&#123;// memset(mark,0, sizeof(mark)); flag = 1-flag; checkdisk(gamer[1-flag],gamer[flag]); &#125; res.clear(); &#125; if(cmd[0] == 'M')&#123; int x = cmd[1]-'0'; int y = cmd[2]-'0'; pos move = pos(x,y); memset(mark,0,sizeof(mark)); change(move,gamer[1-flag],gamer[flag]); list();// printboard(); flag = 1-flag; &#125;// flag = 1-flag; &#125; &#125;&#125; squares 这里重点了解一下方形网格的结构体设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string.h&gt;using namespace std;const int MAXN = 16;int vexp[MAXN][MAXN],hexp[MAXN][MAXN];int hstart[MAXN][MAXN], vstart[MAXN][MAXN];int square[MAXN];int min(int a, int b)&#123; return a &lt; b ? a : b;&#125;void getdata(int&amp; kase)&#123; while(kase--) &#123; char type; int x,y; cin &gt;&gt; type &gt;&gt; x &gt;&gt; y; if(type == 'H') hstart[x][y] = 1; if(type == 'V') vstart[y][x] = 1; &#125;&#125;void stretch(int n)&#123; for(int i = n; i &gt;= 1; i--)&#123; for(int j = n; j &gt;= 1; j--)&#123; if(hstart[i][j])&#123; hexp[i][j] = hexp[i][j+1] + 1; &#125; if(vstart[i][j])&#123; vexp[i][j] = vexp[i+1][j] + 1; &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; int mins = min(hexp[i][j],vexp[i][j]); for(int len = 1; len &lt;= mins; len++)&#123; if(hexp[i+len][j] &gt;= len &amp;&amp; vexp[i][j+len] &gt;= len)&#123; square[len]++; &#125; &#125; &#125; &#125;&#125;int main()&#123; int n; for(int t = 1; scanf(\"%d\",&amp;n)==1; t++) &#123; if(t &gt; 1) printf(\"\\n**********************************\\n\\n\"); memset(vexp,0,sizeof(vexp)); memset(hexp,0,sizeof(hexp)); memset(hstart,0,sizeof(hstart)); memset(vstart,0,sizeof(vstart)); memset(square,0, sizeof(square)); int kase; scanf(\"%d\",&amp;kase); getdata(kase); stretch(n);// for(int i = 0; i &lt;= n; i++)&#123;// for(int j = 0; j &lt;= n; j++)// cout &lt;&lt; hexp[i][j] &lt;&lt; \" \";// cout &lt;&lt; endl;// &#125;// for(int i = 0; i &lt;= n; i++)&#123;// for(int j = 0; j &lt;= n; j++)// cout &lt;&lt; vexp[i][j] &lt;&lt; \" \";// cout &lt;&lt; endl;// &#125; printf(\"Problem #%d\\n\\n\",t); bool flag = false; for(int i = 1; i &lt;= n; i++)&#123; if(square[i])&#123; flag = true; printf(\"%d square (s) of size %d\\n\",square[i],i); &#125; &#125; if(!flag) printf(\"No completed squares can be found.\\n\"); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"hexo个人站点收录百度熊掌号","slug":"20180303","date":"2018-03-02T21:42:47.000Z","updated":"2018-03-02T22:07:32.000Z","comments":true,"path":"2018/03/03/20180303/","link":"","permalink":"https://www.fogsail.net/2018/03/03/20180303/","excerpt":"百度熊掌号是内容和服务提供者入驻百度生态的实名账号，致力于帮助内容和服务提供者方便、快捷、高效地连接百度用户，并充分利用搜索生态开放的优势，获得流量和沉淀用户，实现自身价值的快速增长。","text":"百度熊掌号是内容和服务提供者入驻百度生态的实名账号，致力于帮助内容和服务提供者方便、快捷、高效地连接百度用户，并充分利用搜索生态开放的优势，获得流量和沉淀用户，实现自身价值的快速增长。 粉丝关注改造粉丝关注改造中有两个功能，一是添加熊掌号ID声明，而是添加关注功能代码。 添加熊掌号ID声明的时候，只需要在页面&lt;/head&gt;标签前添加代码1&lt;script src=\"//msite.baidu.com/sdk/c.js?appid=1593711792635024\"&gt;&lt;/script&gt; 在本地的路径为1blog/themes/next/layout/_layout.swig 找到如下代码： 12345678910&lt;html class=\"&#123;&#123; html_class | lower &#125;&#125;\" lang=\"&#123;&#123; config.language &#125;&#125;\"&gt;&lt;head&gt; &#123;&#123; partial('_partials/head/head.swig', &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125; &#123;% include '_partials/head/head-unique.swig' %&#125; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &#123;% include '_third-party/analytics/index.swig' %&#125; &#123;% include '_scripts/noscript.swig' %&#125; &lt;script src=\"//msite.baidu.com/sdk/c.js?appid=1593711792635024\"&gt;&lt;/script&gt; &lt;/head&gt; 在&lt;/head&gt;前加上去就可以了。 添加关注功能代码这里为添加的是底部bar 1&lt;script&gt;cambrian.render('tail')&lt;/script&gt; 在路径：1&lt;script&gt;cambrian.render('tail')&lt;/script&gt; 1234567891011121314&lt;main id=\"main\" class=\"main\"&gt; &lt;div class=\"main-inner\"&gt; &lt;div class=\"content-wrap\"&gt; &lt;div id=\"content\" class=\"content\"&gt; &#123;% block content %&#125;&#123;% endblock %&#125; &lt;script&gt;cambrian.render('tail')&lt;/script&gt; &lt;/div&gt; &#123;% include '_partials/comments.swig' %&#125; &lt;/div&gt; &#123;% if theme.sidebar.display !== 'remove' %&#125; &#123;% block sidebar %&#125;&#123;% endblock %&#125; &#123;% endif %&#125; &lt;/div&gt;&lt;/main&gt; 结构化改造添加canonical标签只要在12345/themes/next/_config.yml``` 令```bashcanonical=true 添加JSON_LD数据注意，这里站点的路径名称不能出现中文所以我后来在写文章的时候，1hexo new EN-title/Num-title 找到路径1/themes/next/layout/_macro/post.swig 123456789101112131415161718192021&lt;span hidden itemprop=\"author\" itemscope itemtype=\"http://schema.org/Person\"&gt; &lt;meta itemprop=\"name\" content=\"&#123;&#123; theme.author &#125;&#125;\"&gt; &lt;meta itemprop=\"description\" content=\"&#123;&#123; theme.signature &#125;&#125;\"&gt; &lt;meta itemprop=\"image\" content=\"&#123;&#123; url_for( theme.avatar | default(theme.images + '/avatar.gif') ) &#125;&#125;\"&gt;&lt;/span&gt; &lt;!--baidu-ldjson--&gt; &lt;!--问题容易出在@id上--&gt; &lt;!--以下是新添加的内容--&gt; &lt;script type=\"application/ld+json\"&gt; &#123; \"@context\":\"https://ziyuan.baidu.com/contexts/cambrian.jsonld\", \"@id\":\"&#123;&#123; config.url &#125;&#125;&#123;&#123; url_for(post.path) &#125;&#125;\", \"appid\":\"1593711792635024\", \"title\":\"&#123;&#123; post.title &#125;&#125;\", \"images\":[ \"&#123;&#123; config.url &#125;&#125;&#123;&#123; url_for(post.path) &#125;&#125;01.jpg\" ], \"pubDate\":\"&#123;&#123; moment(post.date).format('YYYY-MM-DD') &#125;&#125;T&#123;&#123; moment(post.date).format('HH:mm:ss') &#125;&#125;\" &#125; &lt;/script&gt; 值得注意的是，这里post为变量，变量参数的调用方法，有1234post.pathpost.datepost.title特别注意url_for(post.path)不能有中文","categories":[{"name":"杂乱的技术","slug":"杂乱的技术","permalink":"https://www.fogsail.net/categories/杂乱的技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.fogsail.net/tags/hexo/"},{"name":"杂乱的技术","slug":"杂乱的技术","permalink":"https://www.fogsail.net/tags/杂乱的技术/"}]},{"title":"hexo博客部署到腾讯云服务器上","slug":"20180222","date":"2018-02-22T13:20:00.000Z","updated":"2018-03-02T21:32:22.000Z","comments":true,"path":"2018/02/22/20180222/","link":"","permalink":"https://www.fogsail.net/2018/02/22/20180222/","excerpt":"这里主要讲一下云服务器端的配置。我使用的是腾讯云CVM服务器。操作系统使用的是centOS 7.3 64位。因为ubuntu给的并不是root权限，所以改成centOS 7.3，给的是root权限。","text":"这里主要讲一下云服务器端的配置。我使用的是腾讯云CVM服务器。操作系统使用的是centOS 7.3 64位。因为ubuntu给的并不是root权限，所以改成centOS 7.3，给的是root权限。 云服务器端的配置Nginx配置ssh连接服务器。安装Nginx 1yum install -y nginx 启动Nginx服务1service nginx start 测试Nginx服务器1wget http://127.0.0.1 能够正常获取欢迎页面说明Nginx安装成功。1234567--2013-02-20 17:07:26-- http://127.0.0.1/Connecting to 127.0.0.1:80... connected.HTTP request sent, awaiting response... 200 OKLength: 151 [text/html]Saving to: `index.html'100%[===================================&gt;] 151 --.-K/s in 0s2013-02-20 17:07:26 (37.9 MB/s) - `index.html' saved [151/151] 以上表示安装配置成功。 在浏览器中输入服务器ip地址我的是123.207.245.97 建立仓库我这里是把项目仓库放在git中新建了一个git用户 1adduser git 建立代码仓库12345678cd /home/git //nginx网站指向/home/git中mkdir hexo.gitgit init --bare hexo.git //这一步是建立裸仓库chown -R 755 git:git hexo.gitchown 755 git:git hexo.gitchown 755 /home/git//755表示赋予权限访问 将本地机器的ssh公钥填入/home/git/.ssh/authorized_keys文件在服务器端123cd /home/gitmkdir .sshnano /home/git/.ssh/authorized_keys 1ctrl+x保存，输入y，然后回车 配置Nginx查找Nginx配置文件1nginx -t 我的配置文件位于1/etc/nginx/nginx.conf 如下图： 12345678910server&#123; listen 80 default_server; listen [::]:80 default_server; server_name localhost; root /home/git; location / &#123; index index.html index.htm; &#125;&#125; 注意一定要给1chown -R 755 /home/git 给予/home/git权限这样才可以访问。 最后保存后重启Nginx服务器1service nginx restart 实现自动部署自动部署是通过Git钩子实现的接下来，在服务器上的裸仓库 hexo.git 创建一个钩子，在满足特定条件时将静态 HTML 文件传送到 Web 服务器的目录下，即 /home/git。 在第二步建立的裸仓中（即hexo.git文件夹中），找到hooks目录下的post-update.sample,重命名为post-update 1git --work-tree=/home/git --git-dir=/home/git/hexo.git checkout -f 修改权限让其可执行1chmod +x post-update 部署hexo本地站点配置文件中修改： 12345deploy: type: git repo: git@123.207.245.97:/home/git/hexo.git branch: master 就可以成功地把github博客迁移到腾讯云啦～别忘了备案！","categories":[{"name":"杂乱的技术","slug":"杂乱的技术","permalink":"https://www.fogsail.net/categories/杂乱的技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.fogsail.net/tags/hexo/"},{"name":"杂乱的技术","slug":"杂乱的技术","permalink":"https://www.fogsail.net/tags/杂乱的技术/"}]},{"title":"《csapp》实践：信息的表示和处理","slug":"20180206","date":"2018-02-06T03:00:00.000Z","updated":"2019-03-06T10:04:55.726Z","comments":true,"path":"2018/02/06/20180206/","link":"","permalink":"https://www.fogsail.net/2018/02/06/20180206/","excerpt":"阅读深入理解计算机系统，书中的很多实践的练习值得尝试。","text":"阅读深入理解计算机系统，书中的很多实践的练习值得尝试。 show bytes1234void show_bytes(byte_pointer start, size_t len)//这里的len表示从start开始//包括start，例如ab ed 这样，每2个数字为一个单位//总共有几个单位？ show_bytes的使用，具体能够打印类型为short、long和double的c语言对象的字节表示：具体实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169/* $begin show-bytes */#include &lt;stdio.h&gt;/* $end show-bytes */#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;/* $begin show-bytes */using namespace std;typedef unsigned char *byte_pointer;//unsigned char * 显示一位void show_bytes(byte_pointer start, size_t len) &#123; size_t i; //int k=0; for (i = 0; i &lt; len; i++) printf(\" %.2x\", start[i]); //line:data:show_bytes_printf //buf[k++]=start[i]; printf(\"\\n\");&#125;void show_int(int x) &#123; show_bytes((byte_pointer) &amp;x, sizeof(int)); //line:data:show_bytes_amp1&#125;void show_float(float x) &#123; show_bytes((byte_pointer) &amp;x, sizeof(float)); //line:data:show_bytes_amp2&#125;void show_pointer(void *x) &#123; show_bytes((byte_pointer) &amp;x, sizeof(void *)); //line:data:show_bytes_amp3&#125;void show_short(short x)&#123; show_bytes((byte_pointer) &amp;x, sizeof(short));&#125;void show_long(long x)&#123; show_bytes((byte_pointer) &amp;x, sizeof(long));&#125;void show_double(double x)&#123; show_bytes((byte_pointer) &amp;x, sizeof(double));&#125;/* $end show-bytes *//* $begin test-show-bytes */void test_show_bytes(int val) &#123; int ival = val; float fval = (float) ival; int *pval = &amp;ival; show_int(ival); show_float(fval); show_pointer(pval);&#125;/* $end test-show-bytes */void simple_show_a() &#123;/* $begin simple-show-a */int val = 0x87654321;byte_pointer valp = (byte_pointer) &amp;val;show_bytes(valp, 1); /* A. */show_bytes(valp, 2); /* B. */show_bytes(valp, 3); /* C. */show_bytes(valp, 4);/* $end simple-show-a */&#125;void simple_show_b() &#123;/* $begin simple-show-b */int val = 0x12345678;byte_pointer valp = (byte_pointer) &amp;val;show_bytes(valp, 1); /* A. */show_bytes(valp, 2); /* B. */show_bytes(valp, 3); /* C. *//* $end simple-show-b */&#125;void float_eg() &#123; int x = 3490593; float f = (float) x; printf(\"For x = %d\\n\", x); show_int(x); show_float(f); x = 3510593; f = (float) x; printf(\"For x = %d\\n\", x); show_int(x); show_float(f);&#125;void string_ueg() &#123;/* $begin show-ustring */const char *s = \"ABCDEF\";show_bytes((byte_pointer) s, strlen(s));/* $end show-ustring */&#125;void string_leg() &#123;/* $begin show-lstring */const char *s = \"abcdef\";show_bytes((byte_pointer) s, strlen(s));/* $end show-lstring */&#125;void show_twocomp()&#123;/* $begin show-twocomp */ short x = 12345; short mx = -x; show_bytes((byte_pointer) &amp;x, sizeof(short)); show_bytes((byte_pointer) &amp;mx, sizeof(short));/* $end show-twocomp */&#125;//check is_litter_endianbool is_litter_endian()&#123; int a = 0x123456; if( *((char*)&amp;a) == 0x56) return 1; else return 0;&#125;int main(int argc, char *argv[])&#123; int val = 12345; if (argc &gt; 1) &#123; if (argc &gt; 1) &#123; val = strtol(argv[1], NULL, 0); &#125; printf(\"calling test_show_bytes\\n\"); test_show_bytes(val); &#125; else &#123; printf(\"calling show_twocomp\\n\"); show_twocomp(); printf(\"Calling simple_show_a\\n\"); simple_show_a(); printf(\"Calling simple_show_b\\n\"); simple_show_b(); printf(\"Calling float_eg\\n\"); float_eg(); printf(\"Calling string_ueg\\n\"); string_ueg(); printf(\"Calling string_leg\\n\"); string_leg(); //exercise 2.59 if(is_litter_endian()) cout&lt;&lt;\"litter endian\"&lt;&lt;endl; else cout&lt;&lt;\"big endian\"&lt;&lt;endl; &#125; return 0;&#125; 结果见图： 可以发现，我的电脑是小端法机器，浮点数的编码方法，和二进制的编码方法不太一样，浮点数的编码方法，我在浮点数编码方法最后一个例子有详细说明。 其中值得一提的是，取最低有效字节的方法：1234x &amp; 0xFF //取出x的最低有效字节y &amp; ~0xFF //取出y的最低有效字节((x &amp; 0xff) | (y &amp; ~0xff)) //能够实现x的最低有效字节和//y除了最低有效字节外的其他字节合并 12345678910111213#include &lt;stdio.h&gt;//注意：不要打0x作为输入int main()&#123; int x,y; int res; printf(\"Please int x(H) and y(H): \"); scanf(\"%x%x\",&amp;x,&amp;y); res = ((x &amp; 0x000000ff) | (y &amp; 0xffffff00)); printf(\"The result is %.8x(H)\\n\",res);&#125; 类似的方法，常常用于处理某一个字节替换问题： 结论见图： 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;unsigned replace_byte(unsigned x, unsigned char b, int i)&#123; return (x &amp; ~(0xff&lt;&lt;(i&lt;&lt;3))) | (b&lt;&lt;(i&lt;&lt;3));&#125;int main()&#123; printf(\"0x%x\\n\",replace_byte(0x12345678,0xab,2)); printf(\"0x%x\\n\",replace_byte(0x12345678,0xab,0));&#125;` 位级整数编码原则算术右移和逻辑右移的关系算术右移和逻辑右移是不一样的算术右移需要考虑符号位，右移一位，若符号位为1，在左边补1逻辑右移，补0就可以 这里以-1为例，-1算术右移一位，所产生的二进制码代表的数值不变；而逻辑右移则会使最高位为0，变成（1&lt;&lt;63）-1，最大值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int judge_if_all_1(int x)&#123; return !(~x);&#125;int judge_if_all_0(int x)&#123; return !x;&#125;int judge_low_is_0(int x)&#123; //最低有效字节：x &amp; 0xff return !(x &amp; 0xff);&#125;int judge_low_is_1(int x)&#123; return (x &amp; 0xff);&#125;int judge_high_is_0(int x)&#123; //除最高字节以外的位数 //howmanybit=(sizeof(int)-1)&lt;&lt;3 // a&lt;&lt;3表示a*8，因为一位有8个比特 //右移howmanybit位 return !( (x&gt;&gt;((sizeof(x)-1)&lt;&lt;3)) );&#125;int main()&#123; int a; scanf(\"%x\",&amp;a); cout&lt;&lt;judge_low_is_0(a)&lt;&lt;endl; cout&lt;&lt;judge_low_is_1(a)&lt;&lt;endl; cout&lt;&lt;judge_high_is_0(a)&lt;&lt;endl; cout&lt;&lt;judge_if_all_0(a)&lt;&lt;endl; cout&lt;&lt;judge_if_all_1(a)&lt;&lt;endl;&#125; 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;//int_shifts_are_arithmetic()//对int类型数使用算术右移返回1，否则返回0；//显然，只需考虑负数即可（非负数算术右移与逻辑右移相同）。//显这里以-这里以-这里以-这里以-1为例，//-1算术右移一位，所产生的二进制码代表的数值不变；//-而逻辑右移则会使最高位为0，变成（1&lt;&lt;31）-1，最大值。int int_shifts_are_arithmetic()&#123; printf(\"%x %x\\n\", ((-1)&gt;&gt;1),-1); return ((-1)&gt;&gt;1)==-1;&#125;int main()&#123; cout&lt;&lt;int_shifts_are_arithmetic()&lt;&lt;endl; return 0;&#125; 算术右移有一个特点，移几位，补几个最高位举一个例子$[x_{w-1},x_{w-1}…x_{w-1},x_{w-2}…x_{k}]$ 算术右移和逻辑右移相互表示这里先提一点：算术右移和逻辑右移，其中涉及到有符号数和无符号数的相互转换，这个问题比较重要，公式如下： T2U_w(x)= \\begin{cases} x+2^w& \\text{x=0} \\end{cases}一个无符号数，转换成对应的有符号数，依据是：补码原则 U2T_w(x)= \\begin{cases} u& \\text{uTMaxw} \\end{cases}其中$TMax_w$表示符号类型如$int$最大的位数 基于以上公式，我们发现从$int$类型向$unsigned$类型转换的时候，只有x为负数，逻辑右移和算术右移才能够体现出区别，我们这里仅研究$x&lt;0$的情况 12sra()表示用逻辑右移完成算术右移srl()表示用算术右移完成逻辑右移 原理表示如下(仅仅研究$x&lt;0$情况)： 123456789101112131415int sra(int x,int k)&#123; //Perform shift logically int xsrl = (unsigned)x &gt;&gt; k; //转换成为无符号数 int w = (sizeof(int))&lt;&lt;3; returnx xsrl |= (-1 &lt;&lt; (w-k));&#125;unsigned srl(unsigned x, int k)&#123; //Perform shift arithmetically unsigned xsra = (int) x &gt;&gt; k; int w = (sizeof(int)) &lt;&lt; 3; return xsra &amp;= ~(-1 &lt;&lt; (w-k));&#125; 判断奇数位是否为11234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;iostream&gt;bool any_odd_one(unsigned x)&#123; //将所有的奇数位全部置为0，偶数位不变 //考虑&amp;...01010101 //&amp;0x55555555(32bits) //若奇数位有1，则提取奇数位，结果不为0 return 0!=(x&amp;0x55555555);&#125;int main()&#123; printf(\"%d\\n\",any_odd_one(0x5) ); printf(\"%d\\n\",any_odd_one(0x25) ); printf(\"%d\\n\",any_odd_one(0x7) ); return 0;&#125; 二分法位运算：有多少个位包含1注意：^异或运算，相当于无进位的加法，可以消除位中的1 有两种方法：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;//不用位运算的方法int even_ones_without_bit(unsigned x)&#123; int result = 0; for(int i=0;i&lt;(sizeof(int)&lt;&lt;3);i++) &#123; int y = x&gt;&gt;i; y=y&amp;1; if(y) result++; &#125; if(result%2) return 1; else return 0;&#125;int odd_ones(unsigned x)&#123; //用异或运算消除偶数 x ^= (x&gt;&gt;16); x ^= (x&gt;&gt;8); x ^= (x&gt;&gt;4); x ^= (x&gt;&gt;2); x ^= (x&gt;&gt;1); return (x&amp;1);&#125;int main()&#123; int x; scanf(\"%x\",&amp;x); int res=odd_ones(x); printf(\"%d\\n\",res);&#125; 二分法运算：只保留最高位的1 函数功能如下：10xFF00--&gt;0x8000 0x6600--&gt;0x4000 实现方法：123456789101112131415161718192021#include &lt;stdio.h&gt;int leftmost_one(unsigned x)&#123; x |= (x&gt;&gt;1); x |= (x&gt;&gt;2); x |= (x&gt;&gt;4); x |= (x&gt;&gt;8); x |= (x&gt;&gt;16); x &amp;= ~(x&gt;&gt;1); return x;&#125;int main()&#123; int x; scanf(\"%x\",&amp;x); int res=leftmost_one(x); printf(\"%x\\n\",res);&#125; 移位运算需要注意的可以知道：移位运算，移位的量，区间是$(0,w-1)$通过移位运算，使得在32位的机器上可以运行 这里说一下移位运算的溢出：注意第一位是符号位1234560000 -- 00001 -- 10010 -- 2...0111 -- 71000 -- -8 以32位机器举例，int的最大值位$2^{32-1}=2147483648$int型，若为正数，可以表示的最大的数为123450111 1111 1111 1111 1111 1111 1111 1111//最高位是符号位，为0,值为2147483647//加上1之后1000 0000 0000 0000 0000 0000 0000 0000//值为负数，-2147483648 判断一个机器是否为32位，只要用上述方法可以判断。具体实现如下： 12345678910111213#include &lt;stdio.h&gt;bool int_size_is_32()&#123; int set_msb = ~(1&lt;&lt;31); return (set_msb+1&lt;0);&#125;int main()&#123; bool res = int_size_is_32(); printf(\"%d\\n\",res);&#125; 位级运算完成置位lower_one_mask使用位级运算完成置位的过程，通常需要将二进制转换成如下形式：12345600000 111111//即前几个数都为0，后几个数都为1的形式//lower_one_mask函数的实现//0xFFFFFFFF&gt;&gt;(32-n)//00...011...1形式，最后就有n位为1 12345678910111213141516#include &lt;stdio.h&gt;int lower_one_mask(int n)&#123; unsigned mark = 0xffffffff; mark = mark &gt;&gt; (32-n); return mark;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); int res = lower_one_mask(n); printf(\"%x\",res);&#125; 旋转：rotate_left123//取最高m位和最低n位的方法：x&gt;&gt;(32-m)x&lt;&lt;(32-n) 123456789101112131415161718192021#include &lt;stdio.h&gt;unsigned rotate_left(unsigned x, int n)&#123; if(n==0) return x; else &#123; unsigned low = x&lt;&lt;n; unsigned high = x&gt;&gt;(32-n); return low | high; &#125;&#125;int main()&#123; int x,n; scanf(\"%x%d\",&amp;x,&amp;n); int res=rotate_left(x,n); printf(\"%x\\n\",res);&#125; 补码运算的原理1、补码中取反，反码的求法。 1234反码，以下讨论不包括符号位010110的反码111111-010110 = 101001这里不讨论符号位 2、补码原理： 假设计算机字长为n，源码、反码和补码的关系如下： 原码：123456[+1]_源 = 0000 0001[-1]_源 = 1000 0001其中第一位为符号位取值范围[1111 1111, 01111 1111]--&gt;[-127,127] 从公式上看，当$x&gt;0$时，很显然x的源码就是x自身$x&lt;0$时候，除去最高位外，剩下的位数的值等于$|x|=-x$，再加上最高位的1，即加上$2^{n-1}$，最后的值为$2^{n-1}-x$ 反码：123456正数反码不变负数反码，符号位不变，各位取反[+1]=[0000 0001]_源=[0000 0001]_反[-1]=[1000 0001]_源=[1111 1110]_反可以用[1000 0000]表示-128 负数的反码，除了符号位，各位取反，其实是12仅看数值位(n-1)11...1 - xxxxx 数值位取反即为$2^{(n-1)}-1-(-x)=2^{(n-1)}-1+x$解释：10xffffffff-(-x) 最高位，即符号位为$2^{n-1}$，数值位全部为1，表示为$2^{n-1}-1$数值位取反$2^{n-1}-1-(-x)$ 最后我们再加上符号位$2^{n-1}$所以答案为$2^{n-1}+(2^{n-1}-1+x)=2^n+x-1$ 补码：为什么是取反码加一？假设我们有正数 0000 0000 0000 1111，我们如何表示其相反数呢？一般我们的思路是，找一个数，跟它相加的结果等于0，但是我们发现，要找出一个与它相加后结果等于0的数还是要略加思考一下的（因为要计算进位），所以，为何不找出一个与它相加后结果是1111 1111 1111 1111的数，然后该数+1即是我们所要的答案啦。 A+(相加等于全部是11111的数)+1 = 0所以A的相反数等于：求出与A相加全部是11…1的数，然后加1于是就推出：补码等于反码+1 缩进后再暴露最高位的方法，来看看补码是否等于原来的数 123456789101112131415161718#include &lt;stdio.h&gt;//一个数能够用二进制补码表示//可以知道这个数为正数int fits_bits(int x, int n)&#123; //对最高位进行缩进表示 int bias = (sizeof(int) &lt;&lt; 3)-n; return ((x&lt;&lt;bias)&gt;&gt;bias)==x;&#125;int main()&#123; int x,n; scanf(\"%d%d\",&amp;x,&amp;n); int res = fits_bits(x,n); printf(\"%d\\n\",res);&#125; xbyte123456789101112131415161718192021222324#include &lt;stdio.h&gt;typedef unsigned packed_t;int xbyte(packed_t word, int bytenum)&#123; int move_to_high = (3-bytenum)&lt;&lt;3; //将要处理的字节移动到首字节 unsigned mask = (0xff) &lt;&lt; 24; //第一个字节设置掩码 int res = (word &lt;&lt; move_to_high) &amp; mask; res = res &gt;&gt; 24; return res;&#125;int main()&#123; int hex,n; scanf(\"%x%d\",&amp;hex,&amp;n); printf(\"%x\\n\",xbyte(hex,n)); return 0;&#125; 特别注意的地方：12345678if(maxbytes-sizeof(val)&gt;=0)&#123; //&#125;条件是恒正的，因为结果是无符号数，无符号数大于0是肯定的正确写法：if(maxbytes&gt;=sizeof(val)) 位运算实现饱和加法饱和加法，在正溢出的时候，返回$TMax$。 先来看正常情况下的加法123两个正数加法溢出011...1 + 1 = 100...0最后sum的符号位被置为1 所以最后的$TMax$会是一个绝对值比较大的负数 这里我们要返回$TMax$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int saturating_add(int x, int y)&#123; int mask = INT_MIN; //INT_MIN所有位均为1，构成了掩码 int sum = x+y; int w = sizeof(int)&lt;&lt;3; //负溢出的时候，获取最小值 //负溢出的情况，原来x,y的第一位为1 //即有(x &amp; mask) (y &amp; mask) //注意&amp;&amp;运算，() &amp;&amp; ()， //注意&amp;&amp;运算，连接两个非0数， //结果也只为0或者1 //(x &amp; mask) &amp;&amp; (y &amp; mask) &amp;&amp; !(sum &amp; mask) //在负溢出的时候为1，1&lt;&lt;(w-1)&gt;&gt;(w-1) //会把所有的位置为1，因为有符号数要补上符号位 //最后 &amp; INT_MIN，保证INT_MIN正确输出 int tmin = ( ((x&amp;mask) &amp;&amp; (y&amp;mask) &amp;&amp; !(sum&amp;mask)) &lt;&lt;(w-1)&gt;&gt;(w-1) ) &amp; INT_MIN; //这一步，关键是如果前半部分的值为1，说明溢出，溢出返回的是INT_MIN //不用if语句，我们要得到INT_MIN，需要INT_MIN &amp; 11...1 //前半部分的值为1，要让所有的位值都是1，需要&lt;&lt;(w-1)&gt;&gt;(w-1) //算术右移，前面是带上符号位的 int tmax = ( ((~x&amp;mask) &amp;&amp; (~y&amp;mask) &amp;&amp; (sum&amp;mask)) &lt;&lt;(w-1)&gt;&gt;(w-1) ) &amp; INT_MAX; return (sum&amp; ~(!(tmin | tmax))) | tmin | tmax; //这里重点说明一下没有溢出的情况： //[tmin,tmax) 其中tmin=11...1 tmax=011...1 //tmin|tmax = 11...1，这样的目的是把符号位的1也参与进运算中 //--&gt; !(tmin | tmax)=00...0 --&gt; ~(!(tmin|tmax))=11...1 //sum &amp; res = sum，符号位也原封不动地包含下来&#125;void show_saturating_add(int x,int y)&#123; printf(\"satuarating_add(0x%08x,0x%08x)=0x%08x--&gt;%d\\n\",x,y,saturating_add(x,y),saturating_add(x,y)); printf(\"%d+%d=%d\\n\",x,y,x+y); printf(\"\\n\");&#125;int main()&#123; int x,y; scanf(\"%x%x\",&amp;x,&amp;y); show_saturating_add(x,y);&#125; 同样，怎么判断减法是否溢出呢？减法的溢出会导致一个非常大的正数，用这样的思路来分析。1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;//判断x-y溢出，返回1int tsub_ok(int x,int y)&#123; return ( (y&gt;0 &amp;&amp; x-y&gt;x) || (y&lt;0 &amp;&amp; x-y&lt;x) );&#125;void show_tsub_ovf(int x, int y)&#123; printf(\"%d-%d=%d %s\\n\",x,y,x-y,tsub_ok(x,y)?\"overflow\":\"not_overflow\");&#125;int main()&#123; int x,y; scanf(\"%x%x\",&amp;x,&amp;y); show_tsub_ovf(x,y);&#125; 理解定点数的乘法对于位模式$x$，我们计算$B2U_w(x)-B2T_w(x)=x_{w-1}(2^{w-1}-(-2^{w-1}))=x_{w-1}2^w$$B2U_w(T2B_w(x))=T2U_w(x)=x+x_{w-1}2^w$$x’=x+x_{w-1}2^w$$y’=y+y_{w-1}2^w$$(x’\\times y’)mod 2^w =$$[(x+x_{w-1}2^w)\\times (y+y_{w-1}2^w)]mod 2^w=[x \\times y+(x_{w-1}y+y_{w-1}x)2^w+x_{w-1}y_{w-1}2^{2w}]mod 2^{w}$$=(x \\times y)mod2^w$ 重点看一下定点数乘法的运算过程 原码乘法原码乘法的原理可以用下图表示： 原码乘法的计算过程，如上面的公式表示的那样，$w$位的两个数相乘，最后得到的数是$2w$位。所以用“部分积寄存器”来表示积的高位，用“乘数寄存器”来表示低位。其中，乘数的位为0或者1，0表示不加任何数，1表示加上被乘数。乘数的位值，仅仅是一个标志，表示是否加上被乘数。被乘数保持不变。 具体的实现方法如下： 值得注意的是，原码乘法执行的是逻辑右移 补码乘法补码乘法有两种：第一是校正法，注意在末尾加上$[-x]_{complement}$ 第二种方法是booth方法，booth方法，最后一步不移位，那怎么判断乘积是否结束了呢？看看在乘数寄存器中，新更新的位数，是不是恰好为$w$位？ 位运算与定点数乘法从上面的分析可以看出，定点数乘法，$w$位的两个数相乘，我们可以得到$2w$位。如果$x$和$y$都是无符号数，并且运行在数据类型是unsigned的$w$位机器上。乘积的低$w$位能够用表达式$x\\times y$计算。我们需要一个具有下列原型的函数：12unsigned unsigned_high_prod(unsigned x,unsigned y);//计算无符号变量x*y的高w位 12int signed_high_prod(int x,int y)//计算x和y采用补码形式的情况下，x*y的高w位 针对上面的公式，我们不妨把计算结果用$2w$来表示$[(x+x_{w-1}2^w)\\times (y+y_{w-1}2^w)]mod 2^w=[x \\times y+(x_{w-1}y+y_{w-1}x)2^w+x_{w-1}y_{w-1}2^{2w}]mod 2^{w}$ 将计算结果对$2^w$取余，比如64位的量，可以对$2^64$取mod，最后的结果是有64位：位分别为0,1,2…63 我们要获得高$32$位，可以1234unsigned unsigned_high_prod(unsigned x, unsigned y) &#123; int sig_x = x &gt;&gt; 31; int sig_y = y &gt;&gt; 31; int signed_prod = signed_high_prod(x, y); 上述运算实现了：$[x \\times y+(x_{w-1}y+y_{w-1}x)2^w]mod 2^{w}$ 我们将上述值同时移位$w$，就可以实现$[(x \\times y) (&gt;&gt;w)+(x_{w-1}y+y_{w-1}x)]$ 其中$x_{w-1}$就是$x$的符号位12int sig_x = x &gt;&gt; 31//获取x_(w-1)的值 其中$x\\times y$表示int类型的值，是有符号数。 实现如下： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;inttypes.h&gt;int signed_high_prod(int x,int y)&#123; int64_t mul = (int64_t) x*y; return mul &gt;&gt; 32;&#125;unsigned unsigned_high_prod(unsigned x,unsigned y)&#123; int sig_x = x &gt;&gt; 31; int sig_y = y &gt;&gt; 31; int signed_prod = signed_high_prod(x,y); return signed_prod + sig_x * y + sig_y * x;&#125;unsigned compared_high_prod(unsigned x,unsigned y)&#123; uint64_t mul = (uint64_t) x*y; return mul &gt;&gt; 32;&#125;int main()&#123; unsigned x = 0x12345678; unsigned y = 0xffffffff; int test = unsigned_high_prod(x,y); int compared = compared_high_prod(x,y); printf(\"Test: %8x\\n\",test); printf(\"compared: %8x\\n\",compared);&#125; 本章中的其他一些问题(库函数)calloc.c1void* calloc(size_t nmemb, size_t size); 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;void* my_calloc(size_t nmemb,size_t size)&#123; if(nmemb==0 || size==0) return NULL; size_t buf_size = nmemb * size; if(nmemb == buf_size/size) &#123; void* ptr = malloc(buf_size); memset(ptr,0,buf_size); return ptr; &#125; return NULL;&#125;int main()&#123; void* p; p = my_calloc(0x1234,1); //一共有0x1234个元素，每个元素1字节 bool flag = (p!=NULL); if(flag) printf(\"Case 1 :Not Null \\n\"); else printf(\"Case 1 :Null\\n\"); free(p); p = my_calloc(SIZE_MAX,2); flag = (p==NULL); if(flag) printf(\"Case 2 :NULL\\n\"); else printf(\"Case 2 :Not Null\\n\");&#125; 使用移位运算完成倍乘123456//注意乘数为负数的时候怎么表示？int A(int x)&#123; return x - (x &lt;&lt; 3); //表示-7x&#125; 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;iostream&gt;using namespace std;int A(int x)&#123; return x + (x &lt;&lt; 4);&#125;int B(int x)&#123; return x - (x &lt;&lt; 3);&#125;int C(int x)&#123; return (x &lt;&lt; 6) - (x &lt;&lt; 2);&#125;int D(int x)&#123; return (x &lt;&lt; 4) - (x &lt;&lt; 7);&#125;int main()&#123; int x = 0x1; printf(\"Case A: %d\\n\",A(x)); printf(\"Case B: %d\\n\",B(x)); printf(\"Case C: %d\\n\",C(x)); printf(\"Case D: %d\\n\",D(x));&#125; 移位运算与舍入问题仅有乘法或除法 移位运算的舍入问题，遵循以下不等式：$[x]+[x+\\frac{1}{n}]+[x+\\frac{2}{n}]+\\cdots+[x+\\frac{n-1}{n}]=[nx]$ 观察上图：从上表中可以看到，当右移8位的时候，得到-49，这与向零舍入的结果-48并不吻合。右移总是向下舍入，而对于向零舍入的负数来说是向上舍入，因此为了保证结果吻合，需要进行一个偏置。 bias偏移规律如下： 123if(A&lt;0) A+=(1&lt;&lt;k)-1;A&gt;&gt;n; 实现方法：123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;limits.h&gt;int divide_power2(int x, int k)&#123; int is_neg = x &amp; INT_MIN; if(is_neg) x += (1&lt;&lt;k)-1; return x&gt;&gt;k;&#125;int mul3div4(int x)&#123; int mul3 = x+(x&lt;&lt;1); return divide_power2(mul3,2);&#125;int main()&#123; int x; scanf(\"%x\",&amp;x); printf(\"%8x\\n\",divide_power2(x,2)); printf(\"%8x\\n\",x/4); int y; scanf(\"%x\",&amp;y); printf(\"mul3div4: %x\\n\",mul3div4(y)); printf(\"check: %x\\n\",3*y/4); return 0;&#125; 乘除法相结合可以发现我们需要：1、最后$k$位置为0，得到$low$。2、将前面$w-k$位置为0，得到$high$ 12345678//例如：x*(6/8),8=2^3int low = x &amp; 0x7;//仅仅保留最后3位，用掩码(111 &amp; x)int high = x &amp; ~0x7//掩码获得x的高位，将低3位置为0//low high分别计算 具体实现：1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;limits.h&gt;int threefourths(int x)&#123; int is_neg = x &amp; INT_MIN; int low = x &amp; 0x3; int high = x &amp; ~0x3; int highd4 = high &gt;&gt; 2; int highd4m3 = highd4 + (highd4 &lt;&lt; 1); int lowm3 = low + (low &lt;&lt; 1); int bias = (1&lt;&lt;2) - 1; if(is_neg) lowm3 += bias; int lowm3d4 = lowm3 &gt;&gt; 2; return lowm3d4 + highd4m3;&#125;int main()&#123; int x; scanf(\"%d\",&amp;x); printf(\"Test: %d\\n\",threefourths(x)); printf(\"Real: %d\\n\",x*3/4);&#125; 位模式的表示方式$1^{w-k}0^k$$0^{w-k-j}1^k0^j$ 这两种都可以用移位来表示 其中$0^{w-k-j}1^k0^j$可以分成三步走：第一步：获取$1^{w-k}0^k$，通过右移实现第二步：获取$0^{w-k}1^k$，通过取反实现第三部：再右移$j$位 实现方法：123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;iostream&gt;int A(int k)&#123; return -1 &lt;&lt; k; //表示-1重复k次&#125;int B(int k,int j)&#123; return (~A(k)) &lt;&lt; j;&#125;int main()&#123; int x; scanf(\"%d\",&amp;x); printf(\"%8x\\n\",A(x)); printf(\"0xFFFFFF00\\n\"); printf(\"%8x\\n\",B(16,8)); printf(\"0x00FFFF00\\n\");&#125; 移位运算时候常见的错误12345int x = random();int y = random();unsigned ux = (unsigned) x;unsigned uy = (unsigned) y; 补码的非位级表示：对于任意数值1-x == ~x+1 从数学上解释这一点： -^{t}_{w}x= \\begin{cases} TMin_{w}& \\text{x=TMinw}\\\\ -x& \\text{x>TMinw} \\end{cases}$2^w-x=-x$$-x$表示$x$的相反数 $2^w-x-1=-x-1$$2^w-1-x$表示全1的位减去$x$，得到~x 1-x=~x+1 成立 12345(x&lt;y) == (-x&gt;-y)//wrong! x=INT_MIN//此时-x = ~x + 1//~x=011...1//~x+1 = 100...0 仍然为INT_MIN 1((x+y)&lt;&lt;4)+y-x == 17*y+15*x 123~x+~y+1=(~x+1)+(~y+1)-1=-x+-y-1=-(x+y)-1 123(ux-uy)==-(unsigned)(y-x)--&gt; -(ux-uy)==(unsigned)(y-x)--&gt; (uy-ux)==(unsigned)(y-x) 显然成立 1234(x&gt;&gt;2)&lt;&lt;2--&gt; x&amp; ~(0x3)--&gt; x + -num(00/01/10/11)--&gt; (x&gt;&gt;2)&lt;&lt;2 &lt;= x 特殊的二进制无穷串一些数字的二进制表示是$0.yyy\\cdots$，其中$y$是一个$k$位的序列。 1234n = 0.yyy...n&lt;&lt;k = y.yyy...=Y+n--&gt; n&lt;&lt;k-n=Y--&gt; n = Y/(2^k-1) 1234567应用：a) 101 Y=5 k=3 n=5/7b) 0110 Y=6 k=4 n=6/15=2/5c) 010011 Y=19 k=6 n=19/63 用unsigned测试float型数据的大小1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;unsigned f2u(float x)&#123; return *(unsigned*) &amp;x;&#125;int float_le(float x,float y)&#123; unsigned ux = f2u(x); unsigned uy = f2u(y); unsigned sx = ux &gt;&gt; 31; unsigned sy = uy &gt;&gt; 31; return sx==sy ? (sx==0 ? ux&lt;=uy : ux&gt;=uy) : sx&gt;sy;&#125;int main()&#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); int flag = float_le(x,y); printf(\"%d\\n\",flag);&#125; 浮点数概论 为什么要引入$bias$？因为就小数部分而言，比如$0.1010$，计算机是按照二进制编码来计算$1010=10$，无法表示$2^{-k}$，所以我们引入$bias$来表示。因为没有负值的符号位啊！$e_{k-1}e_{k-2}\\cdots e_{0}$，要表示$(-1)00\\cdots 0$，只要$0-2^{k-1}$，表示把符号位置为$-1$。可是为什么bias取$2^{k-1}-1$而不是$2^{k-1}$直观上可以这么理解，$00\\cdots 0$表示0，而$11\\cdots 1 \\ 00\\cdots0$表示无穷大。所以要除掉那个无穷大的，即为$2^{k-1}-1$ 几个问题：1、32位ieee 754的阶码偏移量为何用127?而不是128为了让表示的范围能够对称起来。 当阶码E为全0且尾数M也为全0时，表示的真值x为零，结合符号位S为0或1，有正零和负零之分。当阶码E为全1且尾数M为全0时，表示的真值x为无穷大，结合符号位S为0或1，也有+∞和-∞之分。这样在32位浮点数表示中，要除去E，用全0和全1(255)表示零和无穷大的特殊情况，指数的偏移值不选128(10000000)，而是127(01111111)。对于规格化浮点数，阶码E范围是1~254。 非规格化数$E=1-bias$规格化数$E=e-bias$，其中$e=e_{k-1}e_{k-2}\\cdots e_{0}$ 对于规格化的值当$exp$的位模式既不全为0，也不全为1，$E=e-bias$$e=e_{k-1}e_{k-2}\\cdots e_{0}$$bias=2^{k-1}-1$很显然$e_{min}=1$，则$E_{min}=1-2^{k-1}+1=2-2^{k-1}\\geq 2-1=1$同理$e_{max}=2^k-2$，(扣除全部为1的值),$E_{max}=2^k-2-2^{k-1}+1=2^{k-1}-1$ $127=2^{8-1}-1$，此时$k=8$想一想，如果我们让偏移值为128，而不是127，会是什么样？$E_{min}=1-2^7=-127$，所表示的值为$2^{-127}=5.877471754111438\\times 10^{-39}$$E_{max}=2^7-2=126$，所表示的值$2^126=8\\times 10^{37.9297}$不对称。 而相反，我们让偏移值为127，可以得到取值范围为：$E_{min}=1-2^{7}+1=-126$，$2^{-126}=1.1754943508222875\\times 10^{-38}$$E_{max}=2^7-1=127$，$2^{127}=1.7 \\times 10^{38.23080944932561}$ 很显然，偏移值为127的时候上下对称。 非规格化数的平滑处理为什么要将$E$定义为$1-bias$,这样的方法归功于平滑性的设计。你肯定想问，1是哪里来的？ 浮点数编码表示方法注意《深入理解计算机系统》这本书中，尾数的表示方法，和现行的中文教材不太一样。在《深入理解计算机系统》这本书中提到：尾数的范围是$[1,2-\\epsilon)$而在我们现行的教材上，尾数的范围是$[0,1-\\epsilon)$ 浮点数编码能够表示的范围 注意在尾数部分，小数点是跟在数符后面的。 浮点数的规格化浮点数的规格化表示，要求小数点后的第一位必须是$1$(基数$r=2$)，其他情况如果$r=4$，则小数点后最高2位不全为0。 举例1 特别注意，在这个例子中，阶码是正数，它的补码保持不变，尾数的补码要取反加一 在《深入理解计算机系统》这本书中，规定尾数M是二进制小数，它的范围是$[1,2-\\epsilon)$如果按照这样的规定：$7.0=111.0$$111.0=1.11\\times 2^{10}$，特别说明这里$2^{10}$表示小数点往右移动2位，$10$是二进制数。可以知道阶码用2位来表示，$E=2$，$M=1.11$，$f=0.11$，$e=bias+E$ 举例2与Intel兼容的处理器采用“扩展精度”浮点形式。这种格式具有80位字长，1个符号位，k=15个阶码位，1个单独的整数位和n=63个小数位。注意，阶码位15个，其中一个位用来保存阶符。所以如果阶码部分全部为1，其阶码值为$bias=2^{14}-1$最小的正非规格化数$1,11\\cdots 1(14) \\; 00\\cdots 0(62)1$，括号表示位值重复了多少次。相对应的十进制值为$2^{-bias}\\times 2 \\times 2^{-63}=2^{1-bias-63}$特别注意，非规格化数的偏置值为$1-bias$而不是$-bias$，多乘了一个2，为什么？这个是为了表示非规格化值平滑转换到规格化值。 最小的正规格化数$1,11\\cdots 1(14) \\; 100\\cdots 0(62)=2^{-bias}\\times 2^{-1}=2^{-(bias+1)}$ 最大的规格化数$0,11\\cdots 1(14) \\; 11\\cdots 1(63)=2^{bias}\\times (1-2^{-63})$ 举例3在2008版的IEEE浮点数标准中，为了表示数$\\frac{7}{8}$，很显然$s=0$，表示正数，$7=111.0$，$\\frac{7}{8}$表示小数点左移3位。$\\frac{7}{8}=\\frac{7}{4} \\times 2^{-1}$，其中$V=(-1)^{s}\\times M \\times 2^{E}$，对比一下可以推出$M=\\frac{7}{4}$，$E=-1$$bias=2^{4}-1=15$，$e=E+bias=-1+15=14$，14用二进制表示为$01110$，这是阶码字段。尾数字段计算如下：$1.11 \\times 2^{E}$，其中1.11扩充成10位。$1100000000$表示尾数字段。$01110 \\ combined \\ with \\ 1100000000=hex(3b00)$ 由此我们可以填表：情况1：机器0$bias=2^{4}-1=15$-0，表示机器0，机器0的$M$值为0，由于规格化表示隐含小数点后的第一位是1，所以$e=XXX.100\\cdots 0$，即$e=1$，$E=e-bias=1-15=-14$$V=-0 \\ D=-0.0$$hex(0b10000 \\ 0000000000)=0x8000$ 情况2：最小的大于2的值$(-1)^{s} \\times M \\times 2^{E}$，要使得最小，很显然$E=1$，并且使得$s=0$并且$M$最小。$e=E+bias=1+15=16$，所以阶码部分可以表示成$10000$，再来看$M$，$M$要尽可能小，怎么样才能让$M$尽可能小，$M$为正数。$M=0000000001$，这样该值的二进制表示为$100000000000001$，十六进制为$0x4001$注意到由于是规格化表示，这个数的尾数数值部分应该是$1.000000001$，如果看成是小数点移动，则$10000000001=2^{10}+1=1025$，可以看作小数点向左移动10位，所以$1.000000001=1025/2^{10}=1025/1024$，所对应的$V=\\frac{1025}{1024} \\times 2^{E}=\\frac{1025}{512}=2.001953125$ 情况3:512$512.0=2^{9} \\times 1$，$1=2^{0}$，可以看作不移动小数点。$M=1.0000000000$，这里只研究小数部分，所以为$.0000000000$$M=1 \\; E=9 \\quad e=E+bias=9+15=24=0b11000$组合起来$11000 \\; 0000000000=0x6000$ 最大的非规格化数此时$M$不包括开头的1，最大的值对应的尾数部分是$0.0111111111=001111111111 \\times 2^{-10}=\\frac{1023}{1024}$再看阶码部分，非规格化数的阶码恒为$E=1-bias=1-15=-14$，综合看来，$\\frac{1023}{1024} \\times 2^{-14}=\\frac{1023}{2^{24}}$上述结果为$6.097555160522461e-05$十六进制的值为$00000001111111111=0x3ff$ 负无穷负无穷就是阶码值全部为1，尾数字段全部为0$1111110000000000=0xfc00$ 十六进制为3bb0的数$3bb0=011101110110000$，可以去除阶码部分的5位数$01110=14 \\quad e=14 \\quad E=e-bias=14-15=-1$再看$M=1110110000=$，其实，实际上表示的数为$1.111011$，规格化数中这里的1省略，$.111011=\\frac{111011}{2^{6}}=59/64$综上$\\frac{59}{64} \\times 2^{E}=\\frac{59}{128}$ 举例4对于第一行的例子：$\\frac{9}{16}$要凑成一个大于1的数$\\frac{9}{16}=\\frac{9}{8} \\times \\frac{1}{2}=(1+\\frac{1}{8}) \\times 2^{-1}=(1+\\frac{2}{16}) \\times 2^{-1}$$E=-1 \\quad e=E+bias=-1+7=6$可以写成是：$f \\quad 0010 \\quad \\quad e \\quad 0110$$1 \\ 0110 \\ 0010$ 对于1阶码为$10110$，$e=22 \\quad E=e-bias=22-15=7 \\quad f=\\frac{0b101}{2^{3}}=\\frac{1+4}{8}=\\frac{5}{8}$$M=1+\\frac{5}{8}=\\frac{13}{8} \\quad V=(-1)^{s} \\times M \\times 2^{E}=13 \\times 2^{4}$ 先确定下在格式B中的$frac=1010$，$f=\\frac{0b1010}{2^{4}}=\\frac{5}{8} \\quad M=\\frac{13}{8}$$V=(-1)^{s} \\times \\frac{13}{8} times 2^{E} \\quad E-3=4 \\quad e=7+bias=14$$14=0b1110$$0 \\ 1110 \\ 1010$ 对于2$e=00111=7 \\quad E-7-bias=7-15=-8$$f=\\frac{0b110}{8}=\\frac{6}{8} \\quad M=1+f=\\frac{7}{4}$$V=(-1)^{s} \\times 2^{E} \\times M=- \\frac{7}{2^{10}}$ 在格式B下：$frac=1100$$f=\\frac{0b1100}{16}=\\frac{12}{16}=\\frac{3}{4} \\quad M=1+f=\\frac{7}{4}$$M \\times 2^{E}=\\frac{7}{2^{10}} \\quad E=-8 \\quad e=E+bias=-8+7=-1$推出在格式B下为非规格化数由此$e=0b0000 \\quad E=1-bias=1-7=-6 \\quad 2^{-6} \\times M = 7 \\times 2^{-10}$$f=M=7 \\times \\frac{1}{2^{4}}$$frac=f \\times 16 = 7 = 0b0111$$1 \\ 0000 \\ 01111$ 对于3$e=0b00000 \\quad E=1-bias=1-15=-14$$f=M=\\frac{0b101}{8}=\\frac{1+4}{8}=\\frac{5}{8} \\quad V=\\frac{5}{8} \\times 2^{-14}=\\frac{5}{2^{17}}$ 对于非规格化数$e=0b0000 \\quad E=1-bias=1-7=-6$$M \\times 2^{E}=\\frac{5}{2^{17}} \\quad M=f=5 \\times 2^{-11}$$frac=f \\times 2^4=\\frac{5}{2^{7}}$，舍入到1，结果为$0 \\ 0000 \\ 0001$ $e=0b0000 \\quad E=1-bias=1-7=-6$$f=M=\\frac{1}{16}$$V=M \\times 2^{-6}=\\frac{1}{2^{10}}$ 对于4$e=0b11011=27 \\quad E=e-bias=27-15=12$$f=\\frac{0b000}{2^3}=0 \\quad M=1$$V=-M \\times 2^{12}=-2^{12}$ $frac=0b0000$肯定是不行的，会出现溢出，仅靠e的部分无法表示$2^{12}$阶码位最大为$4$位，能够取得的最大值为$0b1111$，$e=15 \\quad E=e-bias=15-7=8$但注意到在IEEE标准中，$1111 \\ 0000$表示$\\infty$，所以我们让$e=14$$e=14 \\quad e=0b1110 \\quad E=e-bias=14-7=7$$V=-2^{12}=-2^{5} \\times 2^{7}$$-2^{5}$舍入到$-31$，所以$V=-31 \\times 2^{7}$ $0000$要向上舍入，而原来的A&lt;0，所以取绝对值减一，舍入到$0000-1=1111$$frac=1111 \\quad f=\\frac{1111}{16}=\\frac{15}{16} \\quad M=1+f=\\frac{31}{16}$$V=(-1)^{s} \\times \\frac{31}{16} \\times 2^{E}$$\\frac{31}{16} \\times 2^{E}=31 \\times 2^{7}$$e \\leq 14$，所以$e \\leq 1110 \\quad E \\leq (e-bias=7)$$\\frac{31}{16}$舍入到$31$$E=7 \\quad e=1110$$e=1110 \\quad frac=1111$$1 \\ 1110 \\ 1111 \\quad V=- \\frac{31}{16} \\times 2^{7}=-31 \\times 2^{3}$ 对于5$frac=0b100 \\quad f=\\frac{0b100}{8}=\\frac{4}{8}=\\frac{1}{2} \\quad M=\\frac{3}{2}$$e=0b11000=24 \\quad E=e-bias=24-15=9$$V=(-1)^{s} \\times 2^{E} \\times M=3 \\times 2^{8}$ 对于B，$frac=0b1000=8$$f=\\frac{8}{16}=\\frac{1}{2} \\quad M=1+f=\\frac{3}{2}$$V=3 \\times 2^{8}$$3 \\times 2^{8}=\\frac{3}{2} \\times 2^{E} \\quad 2^{8}=2^{E-1} \\quad E=9$$e=9+7=16$，很显然溢出了。向正无穷舍入$\\frac{3}{2}$舍入到$\\frac{6}{2}$，即有$3 \\times 2^{8}=\\frac{3}{2} \\times 2^{E}$$E=8 \\quad e=8+7=15 \\quad e=0b1111$$e=0b1111$，很显然结果为$\\infty$$0 \\ 1111 \\ 0000 \\quad V=\\infty$ 举例5float类型的值使用32位的IEEE格式，double类型的值使用64位IEEE格式。随机数转换成为double类型的值，来测试精度的转换。 这里值得注意的是，浮点运算一般是不能结合的。主要是因为舍入的问题，容易出错。1234567890.2+0.3=0.5-&gt;11+0.5=1.5-&gt;20.3+0.5=0.8-&gt;10.2+1=1.2-&gt;1(0.2+0.3)+0.5=1+0.5-&gt;20.2+(0.3+0.5)=0.2+1-&gt;1二者并不相等 在本机上，运行相关代码得到的结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;limits.h&gt;#include &lt;assert.h&gt;#include &lt;ctime&gt;using namespace std;/*int create_random()&#123; srand((unsigned)time(NULL)); return rand();&#125;*/int A(int x,double dx)&#123; return (float) x == (float) dx;&#125;int B(int x,int y,double dx,double dy)&#123; return (dx-dy) == (double) (x-y);&#125;int C(double dx,double dy,double dz)&#123; return (dx+dy)+dz == dx+(dy+dz);&#125;int D(double dx,double dy,double dz)&#123; return (dx*dy)*dz == dx*(dy*dz);&#125;int E(double dx,double dz)&#123; return dx/dx == dz/dz;&#125;int main()&#123; srand( (unsigned)time(NULL) ); int x = rand(); int y = rand(); int z = rand(); printf(\"x: %d\\n\",x); printf(\"y: %d\\n\",y); printf(\"z: %d\\n\",z); double dx = (double) x; double dy = (double) y; double dz = (double) z; printf(\"check:\\n\"); cout&lt;&lt;\"A: \"&lt;&lt;A(x,dx)&lt;&lt;endl; cout&lt;&lt;\"Another A: \"&lt;&lt;A(0x20001,(double)0x20001)&lt;&lt;endl; cout&lt;&lt;\"B: \"&lt;&lt;B(0,INT_MIN,(double)0,(double)INT_MIN)&lt;&lt;endl; dx = (double)0x2001; dy = (double)INT_MIN; dz = (double)100; cout&lt;&lt;\"C: \"&lt;&lt;C(dx,dy,dz)&lt;&lt;endl; cout&lt;&lt;\"rand c:\"&lt;&lt;endl; dx = (double)rand(); dy = (double)rand(); dz = (double)rand(); cout&lt;&lt;C(dx,dy,dz)&lt;&lt;endl; dx = (double)rand(); dy = (double)0xFFFFFFFF; dz = (double)INT_MIN; cout&lt;&lt;\"D: \"&lt;&lt;D(dx,dy,dz)&lt;&lt;endl; dx = (double)rand(); cout&lt;&lt;\"E: \"&lt;&lt;E(dx,(double)0)&lt;&lt;endl;&#125; 从以上代码可以看出：减法行为，在12x=0;y=INT_MIN; 会出现溢出错误。 除法行为，在除数为0的时候会发生错误。 举例6编写一个C函数来计算$2^{x}$的浮点表示。完成这个任务最好的方法是直接创建结果的IEEE单精度表示。当$x$太小时，你的程序会返回$0.0$，当x太大时，它会返回$+ \\infty$。填写代码的空白部分，计算正确结果。假设函数$u2f$返回的浮点值与它的无符号参数有相同的位表示。 浮点值和无符号参数的位表示相同1234567float u2f(unsigned x)&#123; return *(float*) &amp;x; // &amp;x是变量x的地址 // (float*) &amp;x 获取float型指针 // *(float*) &amp;x 对指针解引用，得到float型的值&#125; $2^{x}$的浮点表示，最终结果是IEEE的单精度表示，如下图所示： 先确定偏置量，$bias$等于$exp$中的位数。1234567bias=1&lt;&lt;(8-1)-1=pow(2,7)-1=127//DenormalizedE=1-bias=2-pow(2,7)//NormalizedE=e-bias=e-pow(2,7) 1234float fpwr2(int x)&#123; // x仅仅表示指数，只需要观察指数部分&#125; 浮点表示：$(-1)^{s} \\times frac \\times 2^{E}$ 1、x小于最小的非规格化数此时$E=1-bias=2-pow(2,7)$，而frac部分有23位，全部清0，相当于$2^E&gt;&gt;23$，右移23位可以让$frac$部分清0，这样得到的数比最小的非规格化数还小$2^{E}&gt;&gt;23$，此时满足的条件是：$x&lt;2-pow(2,7)-23$ 2、x小于最小的规格化数，此时$2^x$表示非规格化数此时$e=1$，$bias=pow(2,7)-1$，$E=e-bias=2-pow(2,7)$$x&lt;2-pow(2,7)$，此时仅有frac部分。 很显然，此时$E=0$，$2^{E}=1$，所以$2^{x}=frac$$frac=2^{x}=2^{b}$，$b$此时的值是$x$相对于最小基准$2-pow(2,7)-23$，即只取超出$2-pow(2,7)-23$的部分。1frac=1&lt;&lt;(unsigned)(x-(2-pow(2,7)-23)) 3、x小于最大的规格化数，此时$2^x$表示规格化数最大的规格化数，此时指数$E=bias=pow(2,7)-1$，注意到此时E可以取到$pow(2,7)-1$ 此时取$frac=0$$2^{x}=2^{E}$，$x=E=exp-bias$，可以得到$exp=x+bias=x+pow(2,7)-1$ 4、剩余情况，取无穷$exp=0xFF$$frac=0$ 实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;float u2f(unsigned x)//这里涉及到无符号数转换成浮点数//使用引用&#123; return *(float*) &amp;x; // &amp;x是变量x的地址 // (float*) &amp;x 获取float型指针 // *(float*) &amp;x 对指针解引用，得到float型的值&#125;float fpwr2(int x)&#123; unsigned expr,frac; unsigned u; if(x &lt; 2-pow(2,7)-23) &#123; expr = 0; frac = 0; &#125; else if(x &lt; 2-pow(2,7)) &#123; expr = 0; frac = 1 &lt;&lt; (unsigned)(x - (2-pow(2,7)-23) ); &#125; else if(x &lt; pow(2,7)-1+1) &#123; expr = x + pow(2,7) - 1; frac = 0; &#125; else &#123; expr = 0xFF; frac = 0; &#125; u = expr &lt;&lt; 23 | frac; return u2f(u);&#125;int main()&#123; cout&lt;&lt;\"calculate: \"&lt;&lt;powf(2,0)&lt;&lt;\" test: \"&lt;&lt;fpwr2(0)&lt;&lt;endl; cout&lt;&lt;\"calculate: \"&lt;&lt;powf(2,100)&lt;&lt;\" test: \"&lt;&lt;fpwr2(100)&lt;&lt;endl; cout&lt;&lt;\"calculate: \"&lt;&lt;powf(2,-100)&lt;&lt;\" test: \"&lt;&lt;fpwr2(-100)&lt;&lt;endl; cout&lt;&lt;\"calculate: \"&lt;&lt;powf(2,10000)&lt;&lt;\" test: \"&lt;&lt;fpwr2(10000)&lt;&lt;endl; cout&lt;&lt;\"calculate: \"&lt;&lt;powf(2,-10000)&lt;&lt;\" test: \"&lt;&lt;fpwr2(-10000)&lt;&lt;endl; return 0;&#125; 举例7$\\pi$的单精度浮点值的十六进制表示为$0x40490FDB$注意，给的数为单精度浮点型的小数，frac部分有23位，exp部分有8位。1、二进制小数表示的二进制小数的小数部分为：$100 \\ 1001 \\ 0000 \\ 1111 \\ 1101 \\ 1011$二进制小数的阶码部分为：$1000 \\ 0000$$bias=2^{8-1}-1=127$$E=exp-bias=128-127=1$由于二进制的阶码部分不为0，所以二进制小数是规格化数，二进制小数可以如下表示：$1.100 \\ 1001 \\ 0000 \\ 1111 \\ 1101 \\ 1011$二进制小数可以表示成：$1.100 1001 0000 1111 1101 1011 \\times 2^{1}=11.0010010000111111011011$ 2、$\\frac{22}{7}$的二进制小数表示是什么$\\frac{22}{7}=3+\\frac{1}{7}$$3=0b11$$\\frac{1}{7}$的二进制小数表示是：$\\frac{Y}{2^{k}-1}$，可以知道$Y=1 \\ k=3$，$y$是一个3位的序列。可以看作$1&gt;&gt;3=\\frac{1}{2^{3}-1}=0.001$综上$\\frac{22}{7}$的二进制表示是：$0b11.001001001(001)$ 3、这两个$\\pi$的近似值从小数点后第九位开始不同 位级浮点编码规则对于参数$f$，如果$f$是非规格化的，该函数返回$\\pm0$12345678910111213141516171819float_bits float_denorm_zero(float_bits f)&#123; unsigned sign = f &gt;&gt; 31; //相当于把小数点放置在第31位后面，这样就得到符号位 unsigned exp = f &gt;&gt; 23 &amp; 0xFF; //相当于把小数点放置在exp位置之后，这样就得到了阶码部分 //取出相应的值，只要&amp;ff就可以 unsigned frac = f &amp; 0x7FFFFF; //只取小数位，共23位 if(exp == 0) &#123; frac = 0; &#125; return (sign &lt;&lt; 31) | (exp &lt;&lt; 23) | frac; //这里移动小数点，相当于右移小数点&#125; 例1对于浮点数$f$，计算$-f$，如果$f=\\infty$，函数返回$f$1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include \"float_negate.h\"#include &lt;math.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt;#include &lt;cstring&gt;#include &lt;limits.h&gt;#include &lt;climits&gt;using namespace std;float_bits float_negate(float_bits f)&#123; unsigned sign = f &gt;&gt; 31; cout &lt;&lt; sign &lt;&lt; endl; unsigned exp = f &gt;&gt; 23 &amp; 0xFF; cout &lt;&lt; exp &lt;&lt; endl; unsigned frac = f &amp; 0x7FFFFF; cout &lt;&lt; frac &lt;&lt; endl; if(exp == 0xFF &amp;&amp; frac != 0) //NAN return f; return (~sign &lt;&lt; 31) | (exp &lt;&lt; 23) | (frac);&#125;int main()&#123; unsigned testV; cin &gt;&gt; testV; unsigned res = float_negate(testV); cout &lt;&lt; \"test value is \" &lt;&lt; *(float*) (&amp;res) &lt;&lt; endl; cout &lt;&lt; \"The real value is \" &lt;&lt; -(*(float*)(&amp;testV)) &lt;&lt; endl; &#125; 实现结果： 例2遵循位级浮点编码规则，实现具有如下原型的函数：1float_bits float_absval(float_bits f); 实现方法如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;limits.h&gt;#include &lt;math.h&gt;using namespace std;/* * float-absval.h */typedef unsigned float_bits;float_bits float_absval(float_bits f);float_bits float_absval(float_bits f)&#123; unsigned sign = f &gt;&gt; 31; unsigned exp = f &gt;&gt; 23 &amp; 0xFF; unsigned frac = f &amp; 0x7FFFFF; int is_NAN = (exp == 0xFF) &amp;&amp; (frac != 0); if(is_NAN) return f; return 0 &lt;&lt; 31 | exp &lt;&lt; 23 | frac;&#125;float u2f(unsigned u)&#123; return *(float*) &amp;u;&#125;unsigned f2u(float u)&#123; return *(unsigned*) &amp;u;&#125; int main()&#123; unsigned testV; float f_test; cin &gt;&gt; testV &gt;&gt; f_test; float testF = u2f(testV); unsigned u_test = f2u(f_test); if(isnan(testF)) &#123; cout &lt;&lt; \"test \" &lt;&lt; testF; cout &lt;&lt; \"real \" &lt;&lt; testV; &#125; else &#123; cout &lt;&lt; \"test1= \" &lt;&lt; u2f(float_absval(testV)) &lt;&lt; endl; cout &lt;&lt; \"real1= \" &lt;&lt; fabs(testF) &lt;&lt; endl; cout &lt;&lt; \"test2= \" &lt;&lt; u2f(float_absval(u_test)) &lt;&lt; endl; cout &lt;&lt; \"real2= \" &lt;&lt; fabs(f_test) &lt;&lt; endl; &#125;&#125; 结果： 例3实现能够计算$2.0 \\times f$的函数。 实现函数如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;limits.h&gt;using namespace std;typedef unsigned float_bits;float_bits float_half(float_bits f);/* 本例中要求舍入到偶数 0b00 --&gt; 0b00 + addition(0) = 0b00 0b01 --&gt; 0b00 + addition(0) = 0b00 0b10 --&gt; 0b01 + addition(0) = 0b01 0b11 --&gt; /2=1.5=2 --&gt; 0b01 + addition(1) = 0b10 only 0b11 --&gt; addition = 1 if &amp;0b11 == 0b11 addition = 1 else addition = 0 addition = (frac &amp; 0x3) == 0x3*/float_bits float_half(float_bits f)&#123; unsigned sign = f &gt;&gt; 31; unsigned exp = f &gt;&gt; 23 &amp; 0xFF; unsigned frac = f &amp; 0x7FFFFF; unsigned remain = f &amp; 0x7FFFFFFF; int is_NAN_or_infinity = (exp == 0xFF); if(is_NAN_or_infinity)&#123; return f; &#125; int addition = (frac &amp; 0x3) == 0x3; if(exp == 0) &#123; //Denormalized frac &gt;&gt;= 1; frac += addition; &#125; else if(exp == 1) &#123; //Normalized to Denormalized remain &gt;&gt;= 1; remain += addition; exp = (remain &gt;&gt; 23) &amp; 0xFF; frac = remain &amp; 0x7FFFFF; &#125; else &#123; //include factor 2 exp -= 1; &#125; return sign &lt;&lt; 31 | exp &lt;&lt; 23 | frac;&#125;float u2f(unsigned u)&#123; return *(float*) &amp;u;&#125;unsigned f2u(float u)&#123; return *(unsigned*) &amp;u;&#125;int main()&#123; float f_test; cout &lt;&lt; \"input float : \"; cin &gt;&gt; f_test; unsigned u_test = f2u(f_test); float real = f_test / 2; cout &lt;&lt; \"real: \" &lt;&lt; real &lt;&lt; endl; cout &lt;&lt; \"test: \" &lt;&lt; u2f(float_half(u_test)) &lt;&lt; endl;&#125; 结果： 例4对于浮点数f，这个函数计算(int)f，如果f是NaN，你的函数应该向0舍入。如果f不能用整数表示，例如，超出表示范围，或者它是一个NaN，那么函数应该返回0x800000000 我们这里仅仅考虑正数的情况：有如下几种： 第一种：1230 00000000 00000000000000000000000 ===&gt;0 01111111 00000000000000000000000 值所能表示的范围是：$1.0 \\times 2^{0}$，此时$2^{E}=2^0$，对应的指数的值为$E=exp-bias=0$，可以求出$exp=7$ 取值范围为：$0 \\leq f \\leq 1$，值舍入到0 第二种：1230 01111111 00000000000000000000000 ===&gt;0 (01111111+31) 00000000000000000000000 此时，我们得到的上界为$NaN$，浮点数可以表示32为整数，其中最高位为符号位，能够表示的最大的值为$2^{31}-1$，所以最大的$int$用浮点数表示就是：0 (01111111+31) 00000000000000000000000 第三种：12340 (01111111+31) 00000000000000000000000 ===&gt;infinityreturn 0x80000000 值得注意的是，把浮点数转换成整形，必须1frac | 0x80000000 来获取整数部分，如何最后我们如何舍去小数部分？采用移位的方式：$\\pm \\ 1.frac \\times 2^{exp-bias}$，用移位的方式去掉frac部分，如下图： 最后我们得到$M \\times 2^{E}$，相当于我们在$M$的基础上，执行M&lt;&lt;E运算。 如果$E&gt;23$，则执行$ M \\times 2^E $，相当于小数点右移23位，除去小数点，然后再整体执行左移(E-23)位，即M&lt;&lt;(E-23) 如果$E&lt;23$，则执行$M \\times 2^{E}$之后还会有小数点，小数点并不能完全消除掉。我们要人为地把小数点后的数全部抛弃，此时小数点的位置在距离末尾(23-E)处，此时M&gt;&gt;(23-E)，即可舍去小数点后的部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* * float-f2i.h */#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;limits.h&gt;using namespace std;typedef unsigned float_bits;int float_f2i(float_bits f);int float_f2i(float_bits f)&#123; unsigned sign = f &gt;&gt; 31; unsigned exp = f &gt;&gt; 23 &amp; 0xFF; unsigned frac = f &amp; 0x7FFFFF; unsigned bias = 0x7F; /* consider positive numbers 0 00000000 00000000000000000000000 ===&gt; 0 01111111 00000000000000000000000 1.0*(2^0),now E=exp-bias=0,means exp=7 exp=1111111 now 0&lt;=f&lt;=1 we get integer 0 0 01111111 00000000000000000000000 now E=exp-bias=0 2^E=1 ===&gt; NaN的取值为多少？我们注意到浮点数可以表示32位整数，最高位是符号位 所以能表示的最大的值是2^&#123;31&#125;-1 上面这个数用浮点数表示是： 0 (01111111+31) 00000000000000000000 */ unsigned M; unsigned E; int val; if(exp &gt;=0 &amp;&amp; exp &lt; 0 + bias) &#123; val = 0; &#125; else if(exp &gt;= 31 + bias) &#123; //overflow val = 0x80000000; &#125; else &#123; E = exp - bias; M = frac | 0x800000; if(E &gt; 23) val = M &lt;&lt; (E - 23); else val = M &gt;&gt; (23 - E); &#125; return sign ? -val : val;&#125;int u2i(unsigned u)&#123; return *(int*) &amp;u;&#125;unsigned i2u(int u)&#123; return *(unsigned*) &amp;u;&#125;unsigned f2u(float u)&#123; return *(unsigned*) &amp;u;&#125;int main()&#123; float f_test; cout &lt;&lt; \"input float : \"; cin &gt;&gt; f_test; unsigned u_test = f2u(f_test); int real = (int)f_test; //注意，float转换为int，要舍入，直接(int) float_v //而不是*(int*) float_v cout &lt;&lt; \"real : \" &lt;&lt; real &lt;&lt; endl; cout &lt;&lt; \"test : \" &lt;&lt; float_f2i(u_test) &lt;&lt; endl;&#125; 注意，float转换为int，要舍入，直接(int) float_v而不是(int) float_v 例5给出一个函数计算(float) i的位级表示。浮点数向偶数舍入的问题有效数字超出规定数位，例如，多余数字是1001，超出了规定最低位的一半，(规定最低位的一半为：1000)，故最低位进1.如果多余数字是0111，它小于最低位的一半，则舍掉多余数字（截断尾数）即可如果对于数字是1000，正好是最低位一半的特殊情况，例如：0 1000，最低位为0，舍掉多余位，1 1000，最低位为1，则舍掉多余位后加1，使得最低位为0(偶数)。 举例，要求保留小数点后3位。 对于1.0011001，舍入处理后为1.010（去掉多余的4位，加0.001）对于1.0010111，舍入处理后为1.001（去掉多余的4位）对于1.0011000，舍入处理后为1.010（去掉多余的4位，加0.001，使得最低位为0） 对于1.1001001，舍入处理后为1.101（去掉多余的4位，加0.001）对于1.1000111，舍入处理后为1.100（去掉多余的4位）对于1.1001000，舍入处理后为1.100（去掉多余的4位，不加，因为最低位已经为0） 对于1.01011，舍入处理后为1.011（去掉多余的2位，加0.001）对于1.01001，舍入处理后为1.010（去掉多余的2位）对于1.01010，舍入处理后为1.010（去掉多余的2位，不加） 对于1.01111，舍入处理后为1.100（去掉多余的2位，加0.001）对于1.01101，舍入处理后为1.011（去掉多余的2位）对于1.01110，舍入处理后为1.100（去掉多余的2位，加0.001） 在整数向浮点数转换的过程中，很重要的一点是，浮点数写成$2^{E}$，一定是规格化数，所以$exp$不为0。因为$exp$等于0的情况我们单独考虑。 整数转换成浮点数，需要以下几个函数：$bit-length()$判断int型有几位，是否超过了最大的32位frac的位数可能会超过23位，这个时候我们要把特定的舍入位数，比如低xx位取出来，完成这个取出任务所需要的函数是$bits-mask()$，给位数盖一个面罩，然后取出值得注意的是，由于int转换成float，必定为规格化数，所以最后的fbits=bits-1，float型的frac部分要减去最开始的1 比较难以理解的是$i=0xffffffff$的情况，此时整数转换成浮点数，是一个$-2^{E}$，注意此时frac为0，因为整数并不包含小数点后的部分，frac部分为1.0000…，是一个绝对值非常非常大的负数，指数expe要尽可能大，如果把指数看成是小数点移位的话，指数最大可以取多少呢？可以移动多少位呢？最多为31位。expe=bias+31 我们让expe=bias+fbits，这样可以看成是小数点在最左边，然后往右移动fbits位。唯一要考虑的就是23位够不够放int型的整数？int型的整数，罩上mask，获取val值，来进行移位操作val=i &amp; bits_mask(fbits) 如果值为负数，记得取反加1 思路1、首先考虑符号位，然后讲i取绝对值，当成一个正数转化即可。然后判断i是2的几次幂，可以通过类似于二分法的方式判断。即右移16位判断是否不为0，如果不为0则exp+16，然后判断右移16位后剩余的位数有几位，否则右移8位判断依次类推。2、因为是正数，小数点左边存在一个隐式的1，所以num=( ~ (1&lt;&lt; exp ) ) &amp; num ;把最高的1去掉，然后把剩余的数放进frac中，同时要考虑向偶数取整的问题。3、如果num不足23位，直接移动相应位数，放入frac中，否则截掉多余的位数，如果最后一位并且舍去一段中的最高也为1或者舍去的东西超过0.5那么就给frac+1，判断一下frac时候有溢出，溢出的话给exp+1，然后取剩余的23位的值即可。最后就是给exp加上bias偏置值，前提是如果num不为0。 重要思路：12345678910111213141516171819202122232425262728293031323334353637383940414243unsigned val = i;unsigned sign = i &lt; 0 ? 1 : 0;if(sign) val = ~val + 1;unsigned exp = 0;unsigned frac = 0;unsigned temp = val;if(val &gt;&gt; 16)&#123; exp += 0x10; //除以16，再加回来 val = val &gt;&gt; 0x10;&#125;if(val &gt;&gt; 8)&#123; exp += 0x8; val = val &gt;&gt; 0x8;&#125;if(val &gt;&gt; 4)&#123; exp += 0x4; val = val &gt;&gt; 0x4;&#125;if(val &gt;&gt; 2)&#123; exp += 0x2; val = val &gt;&gt; 0x2;&#125;if(val &gt;&gt; 1)&#123; exp += 0x1; val = val &gt;&gt; 0x1;&#125;//此时exp表示小数点从右边开始，往左多少位//去掉小数点最高位1val = temp;val = (~(1 &lt;&lt; exp)) &amp; val;//此时val为小数点后面的部分// (temp &gt;&gt; 23)判断temp大于23位 最终$\\times 2^{expe}$小数点在最右边，所以expe实际上表示小数点的实际位置：即从最右边开始，向左移动expe位就是小数点实际位置 舍入原则上面说明了，值得注意的是，向偶数舍入，frac+=1，可能会造成frac溢出例如： frac=111 1111 1111 1111 1111 1111frac+1=1000 0000 0000 0000 0000 0000相当于小数点从右边开始移动到实际位置要多移动1位，所以是expe+=1frac=frac &amp; 0x7fffff取最后23位 可能遇到的情况描述如下图： 实现方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;math.h&gt;using namespace std;typedef unsigned float_bits;float_bits float_i2f(int i);unsigned mask(unsigned bits)&#123; return (1 &lt;&lt; bits) - 1;&#125;unsigned leftmost(unsigned bits)&#123; return 1 &lt;&lt; bits;&#125;float_bits float_i2f(int i)&#123; unsigned val = i; unsigned sign = i &lt; 0 ? 1 : 0; if(sign) val = ~val + 1; unsigned expe = 0; unsigned frac = 0; unsigned temp = val; if(val &gt;&gt; 16) &#123; expe += 0x10; //除以16，再加回来 val = val &gt;&gt; 0x10; &#125; if(val &gt;&gt; 8) &#123; expe += 0x8; val = val &gt;&gt; 0x8; &#125; if(val &gt;&gt; 4) &#123; expe += 0x4; val = val &gt;&gt; 0x4; &#125; if(val &gt;&gt; 2) &#123; expe += 0x2; val = val &gt;&gt; 0x2; &#125; if(val &gt;&gt; 1) &#123; expe += 0x1; val = val &gt;&gt; 0x1; &#125; //此时expe表示小数点从右边开始，往左多少位 //去掉小数点最高位1 val = temp; val = (~(1 &lt;&lt; expe)) &amp; val; //此时val为小数点后面的部分 if(temp &gt;&gt; 23) &#123; unsigned offset = expe - 23; //溢出部分 frac = val &gt;&gt; offset; unsigned roundv = 0; unsigned round_bits = val &amp; mask(offset); int cond1 = ( (val &amp; mask(offset)) &gt; leftmost(offset-1)); int cond2 = ( (frac &amp; 0x1) &amp;&amp; (round_bits == leftmost(offset-1)) ); if( (expe != 23) &amp;&amp; (cond1 || cond2) ) &#123; frac += 1; &#125; //向偶数舍入溢出了怎么办？ //小数点从右边开始，往左边多移动1位 if(frac &gt;&gt; 23) &#123; expe += 1; frac = frac &amp; 0x7fffff; &#125; &#125; else frac = val &lt;&lt; (23 - expe); if(temp) expe += 127; return sign &lt;&lt; 31 | expe &lt;&lt; 23 | frac;&#125;float u2f(unsigned u)&#123; return *(float*)&amp;u;&#125;int main()&#123; int i_test; cout &lt;&lt; \"input int: \"; scanf(\"%d\",&amp;i_test); float real = (float) i_test; printf(\"real: %f\\n\",real); printf(\"test: %f\\n\",u2f(float_i2f(i_test)));&#125;","categories":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://www.fogsail.net/categories/计算机系统结构/"}],"tags":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://www.fogsail.net/tags/计算机系统结构/"}]},{"title":"儿时游戏：数组和字符串模拟","slug":"20180204","date":"2018-02-04T09:37:00.000Z","updated":"2018-03-02T21:15:44.000Z","comments":true,"path":"2018/02/04/20180204/","link":"","permalink":"https://www.fogsail.net/2018/02/04/20180204/","excerpt":"对于90后一代，小学时候我们没有微信，没有王者荣耀，也没有大吉大利，今晚吃鸡的喜悦。小时候我们玩的很多游戏，都是一些拼图，连接线段等等。这些问题，我们可以尝试用数组和字符串模拟。","text":"对于90后一代，小学时候我们没有微信，没有王者荣耀，也没有大吉大利，今晚吃鸡的喜悦。小时候我们玩的很多游戏，都是一些拼图，连接线段等等。这些问题，我们可以尝试用数组和字符串模拟。 我们以刘汝佳的《算法竞赛》来探讨一些这样的问题 Puzzle (Uva227)问题描述如下图： c++ STL vector 字母矩阵常用的方法字母矩阵常常用string来表示主要是要实现字母坐标值，和具体字母的分离。$grid[i][j]$表示字母具体值$i=node[k].x\\quad j=node[k].y$ 下面介绍两种常用的数据结构$string\\quad map$的使用 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;cctype&gt;using namespace std;const int size = 5;typedef struct point&#123; int x; int y; point(int x=0,int y=0):x(x),y(y) &#123;&#125;&#125;pos;pos empty;vector&lt;string&gt; puzzle;map&lt;char,pos&gt; dir;//重载运算符pos operator+ (const pos&amp; A,const pos&amp; B) &#123;return pos(A.x+B.x,A.y+B.y);&#125;pos operator- (const pos&amp; A,const pos&amp; B) &#123;return pos(A.x-B.x,A.y-B.y);&#125;pos operator* (const pos&amp; A,int m) &#123;return pos(A.x*m,A.y*m);&#125;pos operator/ (const pos&amp; A,int m) &#123;return pos(A.x/m,A.y/m);&#125;bool operator== (const pos&amp; A,const pos&amp; B) &#123;return A.x==B.x &amp;&amp; A.y==B.y;&#125;bool operator&lt; (const pos&amp; A,const pos&amp; B) &#123;return A.x&lt;B.x || (A.x==B.x &amp;&amp; A.y&lt;B.y);&#125;void printpuzzle()&#123; for(int i=0;i&lt;size;i++) &#123; for(int j=0;j&lt;size;j++) &#123; if(j) cout&lt;&lt;' '; cout&lt;&lt;puzzle[i][j]; &#125; cout&lt;&lt;endl; &#125;&#125;void getdir()&#123; dir['A']=pos(-1,0); dir['B']=pos(1,0); dir['L']=pos(0,-1); dir['R']=pos(0,1);&#125;bool GetPuzzle()&#123; puzzle.clear(); string line; bool flag=true; for(int i=0;i&lt;size;i++) &#123; getline(cin,line); if(line==\"Z\") &#123; flag=false; break; &#125; for(int j=0;j&lt;size;j++) &#123; if(line[j]==' ') &#123; empty.x=i; empty.y=j; &#125; &#125; puzzle.push_back(line); //puzzle为输入的值 &#125; if(flag) return true; else return false;&#125;bool valid(const pos&amp; p)&#123; return p.x&gt;=0 &amp;&amp; p.x&lt;size &amp;&amp; p.y&gt;=0 &amp;&amp; p.y&lt;size;&#125;bool move(char op)&#123; if(!dir.count(op)) return false; pos next = empty+dir[op]; if(!valid(next)) return false; swap(puzzle[empty.x][empty.y],puzzle[next.x][next.y]); empty=next; //结构体可以直接赋值 return true;&#125;bool getmoves()&#123; string moves; string line; while(true) &#123; getline(cin,line); bool end= *(line.rbegin())=='0'; if(!end) moves.append(line); else moves.append(line,0,line.size()-1); if(end) break; &#125; bool legal = true; for(int i=0;i&lt;moves.size();i++) &#123; if(move(moves[i])==false) &#123; legal=false; break; &#125; &#125; if(legal) return true; else return false;&#125;int main()&#123; int flag=1; getdir(); while(GetPuzzle()) &#123; bool ok = getmoves(); if(flag&gt;1) cout&lt;&lt;endl; cout&lt;&lt;\"Puzzle #\"&lt;&lt;flag++&lt;&lt;\":\"&lt;&lt;endl; if(ok) printpuzzle(); else cout&lt;&lt;\"This puzzle has no final configuration.\"&lt;&lt;endl; &#125;&#125; Digit counting uva1225题目描述： 本题陈锋的答案写的过于繁琐，这里给出一种一维数组的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;//#define maxn 10005#define data 15void calculate()&#123; //int cnt[maxn][data]; int cnt[data]=&#123;0&#125;; int maxn; scanf(\"%d\",&amp;maxn); for(int i=1;i&lt;=maxn;i++) &#123; //id=i int cur = i; //int id = i; //第id个数 while(cur&gt;0) &#123; int val = cur%10; cnt[val]++; cur/=10; &#125; &#125; for(int i=0;i&lt;9;i++) printf(\"%d \",cnt[i]); printf(\"%d\\n\",cnt[9]);&#125;int main()&#123; int kase; scanf(\"%d\",&amp;kase); while(kase--) &#123; calculate(); &#125; return 0;&#125; crossword answers uva232题目如下： 这里我谈一谈我编程的心得体会吧：分享一些编程的技巧，就是main函数不宜写的很长，比如上面你要去模拟那个矩阵，怎么移动的，你不宜把main函数写太长，你要想：如果是你来移动这个矩阵，你会怎么做？第一步，当然是获取数据，所以你要写一个获取数据的函数getpuzzle()第二部是移动操作，往左？往右？于是你需要一个移动函数getmoves()如果更细致一点？越界？不越界？这更细一点的在getmoves()里面再写一个move()来判断每一步怎么走？下一步可能出现的情况？层层递进～这是编程最难的一点，就是把一个很复杂的问题，分解，在分解，然后，看到不同子问题之间的逻辑性，抽离出来。不同的抽离方法，会导致编程的难易程度不一样。如果你先入为主地想，怎么移动？万一越界了怎么办？万一不合法的移动怎么办？问题会变得很复杂，当然很难编程。如果你先入为主，首先不要考虑太多细节。然后，逐渐加入某些细节，再写代码。至于每一步，每一层，要加入哪些细节，可以减少编程难度呢？这就是编程艺术性所在的地方，跟画画一样。首先你要描绘一个轮廓，然后，近景？远景的布局是怎么样的，画出来有什么样的效果？这就是编程艺术所在的地方。 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef struct point&#123; int r; int c; point(int r=0,int c=0):r(r),c(c) &#123;&#125;&#125;pos;pos operator+ (const pos&amp; A,const pos&amp; B) &#123;return pos(A.r+B.r,A.c+B.c);&#125;const pos dLeft(0,-1),dUp(-1,0),dRight(0,1),dDown(1,0);int row,col;const int maxn = 16;char grid[maxn][maxn];char buf[maxn];queue&lt;pos&gt; Crossletter;queue&lt;pos&gt; Downletter;map&lt;int,int&gt; Crossid;map&lt;int,int&gt; Downid;bool valid(const pos&amp; p)&#123; return p.r&gt;=0 &amp;&amp; p.r&lt;row &amp;&amp; p.c&gt;=0 &amp;&amp; p.c&lt;col;&#125;bool getgrid()&#123; memset(grid,'0',sizeof(grid)); if(scanf(\"%d%d\",&amp;row,&amp;col)==2 &amp;&amp; row) &#123; for(int i=0;i&lt;row;i++) scanf(\"%s\",grid[i]); return true; &#125; else return false;&#125;/*void printgrid()&#123; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) cout&lt;&lt;grid[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125;&#125;*/void CheckQueueEmpty(queue&lt;pos&gt; letter)&#123; while(!letter.empty()) &#123; letter.pop(); &#125;&#125;void GetWordBegin()&#123; CheckQueueEmpty(Crossletter); CheckQueueEmpty(Downletter); int crosscnt=0,downcnt=0; Crossid.clear(); Downid.clear(); int k = 1; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) &#123; if(grid[i][j]=='*') continue; pos cur(i,j); pos left = cur+dLeft; pos up = cur+dUp; bool IsCrossBeg = !valid(left) || grid[left.r][left.c]=='*'; bool IsDownBeg = !valid(up) || grid[up.r][up.c]=='*'; if(IsCrossBeg) &#123; Crossletter.push(cur); Crossid[++crosscnt]=k; &#125; if(IsDownBeg) &#123; Downletter.push(cur); Downid[++downcnt]=k; &#125; if(IsCrossBeg || IsDownBeg) k++; &#125; &#125;&#125;void GetCrossWord()&#123; int i=0; while(!Crossletter.empty()) &#123; int buflen=0; memset(buf,0,sizeof(buf)); pos p = Crossletter.front(); //id = PosCross[p]; while(grid[p.r][p.c]!='*' &amp;&amp; valid(p)) &#123; buf[buflen++]=grid[p.r][p.c]; p=p+dRight; &#125; printf(\"%3d.%s\\n\",Crossid[++i],buf); Crossletter.pop(); &#125;&#125;void GetDownWord()&#123; int i=0; while(!Downletter.empty()) &#123; int buflen=0; memset(buf,0,sizeof(buf)); pos p = Downletter.front(); while(grid[p.r][p.c]!='*' &amp;&amp; valid(p)) &#123; buf[buflen++]=grid[p.r][p.c]; p=p+dDown; &#125; printf(\"%3d.%s\\n\",Downid[++i],buf); Downletter.pop(); &#125;&#125;int main()&#123; for(int kase=1;getgrid();kase++) &#123; if(kase&gt;1) cout&lt;&lt;endl; printf(\"puzzle #%d:\\n\",kase); GetWordBegin(); cout&lt;&lt;\"Across\"&lt;&lt;endl; GetCrossWord(); cout&lt;&lt;\"Down\"&lt;&lt;endl; GetDownWord(); &#125; return 0;&#125; Repeating Decimals uva202 这里我给出一种重要的数据处理技巧：1char example[maxn] 输入的时候1scanf(\"%s\",example) 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 30000;int pos[maxn];//int len;//string ans;char shang[maxn];int solve(int a,int b)&#123; int len; int Integer = a/b; int r = a%b; memset(pos,0,sizeof(pos)); memset(shang,0,sizeof(shang)); //int pos[maxn]; //char shang[maxn]; printf(\"%d/%d = %d\",a,b,Integer); shang[0]='.'; if(r==0) &#123; //ans+=\"(0)\"; printf(\".(0)\"); len=1; &#125; else &#123; //小数部分 int d = r*10; int cnt = 0; while(d &amp;&amp; pos[d]==0) &#123; pos[d]=++cnt; int cur_r = d%b; //ans+=(char) (d/b+'0'); shang[cnt]=(char)(d/b+'0'); d = cur_r*10; &#125; if(d==0) &#123; //ans+=\"(0)\"; //shang[cnt]='('; //flag! if(shang[i]==-1) printf(\"(0)\"); for(int i=0;i&lt;=cnt;i++) //cout&lt;&lt;shang[i]; printf(\"%c\",shang[i]); //cout&lt;&lt;\"(0)\"; printf(\"(0)\"); len=1; &#125; if(pos[d]) &#123; int p = pos[d]; len = cnt-p+1; /*if(len&gt;50) &#123; ans.erase(p+50,cnt-1); ans+=\"...\"; &#125; ans.insert(p,\"(\"); ans+=\")\";*/ if(len&gt;50) &#123; for(int i=0;i&lt;p;i++) //cout&lt;&lt;shang[i]; printf(\"%c\",shang[i]); //cout&lt;&lt;\"(\"; printf(\"(\"); int k=0; for(int i=p;i&lt;=cnt &amp;&amp; k&lt;50;i++) &#123; //cout&lt;&lt;shang[i]; printf(\"%c\",shang[i]); k++; &#125; //cout&lt;&lt;\"...)\"; printf(\"...)\"); &#125; else &#123; for(int i=0;i&lt;p;i++) //cout&lt;&lt;shang[i]; printf(\"%c\",shang[i]); //cout&lt;&lt;\"(\"; printf(\"(\"); //int k=0; for(int i=p;i&lt;=cnt;i++) //cout&lt;&lt;shang[i]; printf(\"%c\",shang[i]); //cout&lt;&lt;\")\"; printf(\")\"); &#125; &#125; //printf(\"%d/%d = %d%s\\n\",a,b,Integer,ans.c_str()); //printf(\" %d = number of digits in repeating cycle\\n\\n\",len); //cout&lt;&lt;endl; &#125; printf(\"\\n\"); return len;&#125;int main()&#123; int a,b; while(scanf(\"%d%d\",&amp;a,&amp;b)==2 &amp;&amp; b) &#123; int reslen=solve(a,b); printf(\" %d = number of digits in repeating cycle\\n\\n\",reslen); &#125; return 0;&#125; box uva1587这个例子我想分享一下简洁的代码怎样写。 题目如下： 12bool operator&lt; (const point&amp; p1, const point&amp; p2) &#123; return p1.x &lt; p2.x || (p1.x == p2.x &amp;&amp; p1.y &lt; p2.y); &#125; 这里是特别说明的一点：因为排序的时候，默认先比较x成员的大小，再比较y成员的大小，所以默认x成员小于y成员另外涉及排序的时候，我们需要直接输入结构体变量的值，涉及重载运算符用以下方法输入会导致wrong answer 12345678for(int i=0;i&lt;6;i++)&#123; if(scanf(\"%d%d\",&amp;a,&amp;b)==EOF) flag=0; if(a&gt;b) swap(a,b); r.push_back(point(a,b));&#125; 我们在处理结构体数组的时候，最好是直接对结构体数组的元素执行输入操作，重载&gt;&gt;运算符example 123456789typedef struct&#123; //&#125;node;istream&amp; operator&gt;&gt; (istream&amp; is,point&amp; p)&#123; return is&gt;&gt;p.x&gt;&gt;p.y; &#125;node n;cin&gt;&gt;n.x&gt;&gt;n.y 技巧：在处理EOF为终止的输入的时候，用如下方法，很好用 123456789while(true)&#123; r.clear(); for(int i=0;i&lt;6;i++) &#123; if(!(cin&gt;&gt;cur)) return 0; &#125;&#125; 算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct point&#123; int x; int y; point(int x=0,int y=0):x(x),y(y) &#123;&#125;&#125;;bool operator&lt; (const point&amp; p1, const point&amp; p2) &#123; return p1.x &lt; p2.x || (p1.x == p2.x &amp;&amp; p1.y &lt; p2.y); &#125;istream&amp; operator&gt;&gt; (istream&amp; is,point&amp; p)&#123; return is&gt;&gt;p.x&gt;&gt;p.y; &#125;//typedef point rect;vector&lt;point&gt; r;bool judge()&#123; if(r[0].x!=r[1].x || r[0].y!=r[1].y) return false; if(r[2].x!=r[3].x || r[2].y!=r[3].y) return false; if(r[4].x!=r[5].x || r[4].y!=r[5].y) return false; const point &amp;r1 = r[1], &amp;r2 = r[3], &amp;r3 = r[5]; return r1.x == r2.x &amp;&amp; r1.y == r3.x &amp;&amp; r2.y == r3.y;&#125;int main()&#123; point cur; while(true) &#123; r.clear(); for(int i=0;i&lt;6;i++) &#123; if(!(cin&gt;&gt;cur)) return 0; if(cur.x&gt;cur.y) swap(cur.x,cur.y); r.push_back(cur); &#125; sort(r.begin(),r.end()); bool ok = judge(); if(ok) printf(\"POSSIBLE\\n\"); else printf(\"IMPOSSIBLE\\n\"); &#125; return 0;&#125; 字符串匹配：模板链方法 uva1588这里以uva1588为例子，简单讲讲字符串匹配中的模板链方法。 题目描述如下： 模板链方法描述 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;string s1,s2;bool getstring()&#123; if(cin&gt;&gt;s1&gt;&gt;s2) &#123; if(s2.length()&gt;s1.length()) &#123; swap(s1,s2); &#125; return true; &#125; else return false;&#125;int maxv(int a,int b)&#123; return a&gt;b?a:b;&#125;int minv(int a,int b)&#123; return a&lt;b?a:b;&#125;void calculate()&#123; int len1 = s1.length(); int len2 = s2.length(); int inside = 0; int minres = 0x3f3f3f3f; for(int i=-len2;i&lt;=len1+len2-1;i++) &#123; int flag = 1; for(int bias=0;bias&lt;len2;bias++) &#123; if(i+bias&gt;=0 &amp;&amp; i+bias&lt;=len1-1) &#123; if(s1[i+bias]-'0'+s2[bias]-'0'&gt;3) flag=0; &#125; &#125; //bias遍历完成，意味着标签贴完毕了 if(flag &amp;&amp; i&lt;0) minres=min(minres,(-i)+len1); if(flag &amp;&amp; i+len2&gt;=len1) minres=min(minres,i+len2); if(flag &amp;&amp; i&gt;=0 &amp;&amp; i&lt;len1-len2) inside=1; &#125; if(inside==1) cout&lt;&lt;len1&lt;&lt;endl; else cout&lt;&lt;minres&lt;&lt;endl;&#125;int main()&#123; while(getstring()) &#123; calculate(); &#125; return 0;&#125; c++11中涉及精度的问题涉及精度的问题并不难，关键是c++提供了一些非常重要的思路：问题描述： 一些重要的思路c++11中，中提供了一个round()函数，用来做四舍五入操作 strchr是计算机的一个函数，原型为char strchr(const char s,char c)，可以查找字符串s中首次出现字符c的位置strcmp() C/C++函数，比较两个字符串,设这两个字符串为str1，str2，若str1==str2，则返回零；若str1str2，则返回正数。 原型：1*strchr(const char *s,char c) 1234567891011char line[maxn];double A;int B;while(scanf(\"%s\",line)==1 &amp;&amp; strcmp(line,\"0e0\")!=0)&#123; *strchr(line,'e') = ' '; //将line中首次出现‘e’的地方，用‘ ’来代替 sscanf(line,\"%lf%d\",&amp;A,&amp;B); //sscanf()是很重要的输入方法，将line中 //符合%lf %d格式的 //分别输入到A,B中， //其中，%lf--&gt;A %d--&gt;B，A和B用空格分开，表示输入两个变量&#125; 上面注释部分，表示一种非常重要的编程技巧。 算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 256;const double eps = 1e-6;int main()&#123; /*char A[256]; scanf(\"%s\",A); char *ptr = strchr(A,'e'); cout&lt;&lt;ptr&lt;&lt;\" \"&lt;&lt;*ptr&lt;&lt;endl; *strchr(A,'e')='f'; printf(\"%s\\n\",A);*/ char line[maxn]; double lg2 = log10(2); double A,lgV; int B; while(scanf(\"%s\",line)==1 &amp;&amp; strcmp(line,\"0e0\")!=0) //这种输入方式要记住 &#123; *strchr(line,'e')=' '; sscanf(line,\"%lf%d\",&amp;A,&amp;B); //cout&lt;&lt;A&lt;&lt;\" \"&lt;&lt;B&lt;&lt;endl; lgV = log10(A)+B; for(int M=1;M&lt;=10;M++) &#123; int E = round( log10( (lgV+M*lg2-log10(pow(2,M)-1))/lg2+1 )/lg2 ); if( fabs( ((1&lt;&lt;E)-1)*lg2 + log10(pow(2,M)-1) - M*lg2 - lgV ) &lt;= eps ) &#123; printf(\"%d %d\\n\",M-1,E); break; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"data_structure","slug":"data-structure","permalink":"https://www.fogsail.net/categories/data-structure/"}],"tags":[{"name":"data_structure","slug":"data-structure","permalink":"https://www.fogsail.net/tags/data-structure/"}]},{"title":"linux脚本编程：系统软件的安装","slug":"20170630","date":"2017-06-29T19:12:00.000Z","updated":"2018-03-02T21:08:40.000Z","comments":true,"path":"2017/06/30/20170630/","link":"","permalink":"https://www.fogsail.net/2017/06/30/20170630/","excerpt":"Linux的核心是shell，这里先简单阐述一下基本的shell编程的概念。","text":"Linux的核心是shell，这里先简单阐述一下基本的shell编程的概念。 Linux系统中安装java安装python依赖包12sudo apt-get install python-softwaresudo apt-get install software-properties-common 添加ppa源12345sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-j +按两次TABsudo apt-get install oracle-java9-installersudo apt-get install oracle-java9-set-default 查看java安装位置1234567891011apt-cache search openjdk #查看jdk的安装位置apt-file list java #查看包含java的文件，太多了，不建议使用这个命令whereis java#定位可执行文件、源代码文件、帮助文件在文件系统中的位置。which java#java的执行路径ll /usr/bin/java #查看命令链接位置ll /etc/alternatives/java #查看命令可执行文件的实际位置 如图所示： 获取java命令路径 1/usr/lib/jvm/java-9-oracle/bin/java 查看java其他版本123456sudo update-alternatives --install link(java_01版本的绝对路径) name(新命令名字) path(新命令java_02的路径) prioritysudo update-alternatives --install /usr/bin/java java XXX/XXX 300#priority为优先级，系统默认启动priority高的链接#与之对应的删除命令sudo update-alternatives --remove java XXX/XXX(即为上一步中的name path) 12sudo update-alternatives --config javasudo update-alternatives --config javac 环境变量的配置1234567891011#一般我们用~/.bashrc来设置当前用户的环境变量#/etc/profile一般我们不去改变，系统的环境变量不要随便更改sudo gedit ~/.bashrc#在末尾添加export JAVA_HOME=/usr/lib/jvm/java-9-oracleexport JRE_HOME=$&#123;JAVA_HOME&#125;/jre1.8.0_131export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$PATH:$&#123;JAVA_HOME&#125;/bin:$&#123;JRE_HOME&#125;/binsources ~/.bashrc","categories":[{"name":"linux","slug":"linux","permalink":"https://www.fogsail.net/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.fogsail.net/tags/linux/"}]},{"title":"深度学习基础：Linux系统配置","slug":"20170626","date":"2017-06-25T19:12:00.000Z","updated":"2018-05-02T09:24:22.000Z","comments":true,"path":"2017/06/26/20170626/","link":"","permalink":"https://www.fogsail.net/2017/06/26/20170626/","excerpt":"深度学习无疑是2016年下半年到2017年最火的研究方向了。深度学习一般都采用Linux系统作为配置。与Caffe、Theano、Torch、MXNet等框架相比，TensorFlow在Github上Fork数和Star数都是最多的，而且在图形分类、音频处理、推荐系统和自然语言处理等场景下都有丰富的应用。最近流行的Keras框架底层默认使用TensorFlow，著名的斯坦福CS231n课程使用TensorFlow作为授课和作业的编程语言，国内外多本TensorFlow书籍已经在筹备或者发售中，AlphaGo开发团队Deepmind也计划将神经网络应用迁移到TensorFlow中，这无不印证了TensorFlow在业界的流行程度。 首先我先说一下我用的主机配置：","text":"深度学习无疑是2016年下半年到2017年最火的研究方向了。深度学习一般都采用Linux系统作为配置。与Caffe、Theano、Torch、MXNet等框架相比，TensorFlow在Github上Fork数和Star数都是最多的，而且在图形分类、音频处理、推荐系统和自然语言处理等场景下都有丰富的应用。最近流行的Keras框架底层默认使用TensorFlow，著名的斯坦福CS231n课程使用TensorFlow作为授课和作业的编程语言，国内外多本TensorFlow书籍已经在筹备或者发售中，AlphaGo开发团队Deepmind也计划将神经网络应用迁移到TensorFlow中，这无不印证了TensorFlow在业界的流行程度。 首先我先说一下我用的主机配置： CPU参数CPU主频: 3.0GHz及以上CPU型号: Intel I7 6800KCPU核心数: 六核心 显卡参数NVIDIA GTX 1080 Ti 内存类型DDR4 容量8GB*2根 硬盘类型samsung 256GB M.2接口固态硬盘 主板华硕 ATX主板芯片组类型:Intel X99 操作系统Ubuntu 16.04（LTS） Linux下显卡驱动的安装从官方网站上下载GTX 1080 Ti驱动程序一般放置在以下目录中： 1/home/fogsail 打开终端，输入：1fogsail@fogsailPC:~$ pwd 查看当前终端所在的文件目录，看一看是不是/home/fogsail 如下图所示： 接下来，为下载的驱动程序添加可执行权限：1sudo chmod 755 NVIDIA-Linux-x86_64-381.22.run 然后将图形界面切换到命令行界面： 1234Ctrl+Alt+F2login:fogsail(your name)password: your computer password 这样就成功切换到命令行状态下了，如果想从命令行状态切换回图形界面 1Ctrl+Alt+F7 由于这里要装显卡，所以必须把图形界面关掉，在纯字符的页面下输入： 12345678910Ctrl+Alt+F2login:fogsail(your name)password: your computer passwordsudo service lightdm stop##重新换回图形界面命令如下：sudo service lightdm start#如果是Linuxmint系统，则用mdm代替lightdm 这样就切换到纯命令行了 在纯命令行的状态下1sudo ./NVIDIA-Linux-x86_64-381.22.run 然后就是安装过程，特别注意，在安装的时候有几个选项：前几个选项是接受协议什么的分别选accept、continue installation即可 注意最后一个选项，是要不要将NVIDIA GTX1080 Ti的驱动覆盖原来的默认驱动，并且对原驱动进行更新，这里一定要选择yes 安装完成之后，开启图形界面即可。 这样安装就大功告成了。 当然，在ubuntu 16.04下面安装不用这么麻烦，直接有包如图所示： Linux下一些驱动的卸载下载软件包装的驱动如本例所示，用.run赋予可执行权限安装的驱动，卸载的时候，也需要用到原文件 1sudo ./NVIDIA-Linux-x86_64-381.22.run -uninstall 一般来说，使用软件包安装的驱动，卸载的时候都要用到软件包 使用apt包安装的驱动一般来说，先看一下有哪些和驱动相关的软件包，如下命令： 1apt-cache search nvidia ##搜索带nvidia字样的软件包 还有一个常用的命令是 1apt-cache depends nvidia ##查询nvidia的依赖关系 如果需要删除所有和nvidia相关的组件： 1sudo apt-get remove nvidia-* Linux下.deb软件包的安装：网易云音乐第一步，安装包放到/opt从网易云音乐官方网站上下载ubuntu 16.04软件包.deb .deb软件包，可以考虑下载完，把.deb的安装文件，放置在：12/opt ##/opt中一般都放置完整的软件包，没有其他依赖关系 ##一般是额外自己安装的其他应用软件 这里说明一下： /usr: 系统级的目录，可以理解为C:/Windows，/usr/lib理解为C:/Windows/System32 /usr/local: 用户级的程序目录，这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面，我想这应该是个不错的主意。可以理解为C:/Progrem Files/。用户自己编译的软件默认会安装到这个目录下。 /opt:用户级的程序目录，可以理解为D:/Software，opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf即可。在硬盘容量不够时，也可将/opt单独挂载到其他磁盘上使用。举个例子：你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可 以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。 源码放在哪里？/usr/src: 系统级的源码目录/usr/local/src: 用户级的源码目录 第二步：dpkg安装软件包123sudo dpkg -i netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb##--install or -i选项会在安装软件包之前把系统中原有的旧版本删除 所有的软件包在安装之前都必须保证所依赖的库和支持构造已经安装在系统中。不过可以使用—force来强制安装软件包，这个时候系统将忽略一切兼容问题直到软件包安装完毕。大部分情况下不建议这么使用，—force会让问题变得更糟糕。 但是在这里，可以重新配置一下依赖： 12sudo apt-get install -fsudo dpkg -i netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb 第三步：执行检查查看版本信息1dpkg -l | grep netease-cloud-music 运行的结果： 查看软件相关的文件我们有的时候还需要找到软件在安装的时候，向系统复制了哪些文件？这个时候需要—search选项 1dpkg -S netease-cloud-music 运行结果： 卸载软件1dpkg --remove netease-cloud-music 这里注意，—remove后面跟的软件名称和netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb这个deb包版本号之前的名称是一致的。 Linux下使用高级软件包工具APT以安装vlc为例： 安装完成之后，要查看安装的情况，到底装到什么位置了？这里我们使用123sudo apt-get install apt-file ##第一次需要安装apt-fileapt-file updateapt-file list vlc 最后的结果如下： 如果我们要删除，则执行：123sudo apt-get remove vlc browser-plugin-vlc##注意跟intall要对上去啊～就是把install换成remove 卸载命令，就是把sudo apt-get install换成remove 查询软件包信息（不是安装位置）:1apt-cache search vlc ##搜索带\"vlc\"字样的软件包 1apt-cache depends vlc ##查询vlc的依赖关系，查看vlc执行过程中需要依赖什么文件 特别说明：APT-get的配置apt-get的安装源，放在1/etc/apt/sources.list 1gedit /etc/apt/sources.list 打开如下： 一些重要字段的含义： deb和deb-src：表示软件包的类型。Debian类型的软件包使用deb或deb-src。如果是RPM类型的软件包，则应该使用rpm和rpm-src。 特别注意：12deb http://security.ubuntu.com/ubuntu xenial-security universedeb http://security.ubuntu.com/ubuntu xenial-security multiverse 应该作为一个单独的源来列出，以便能够访问到最新的安全补丁。 解压缩安装软件—sublimetext安装方法第一步，从网站上下载得到，并且移动到/opt目录下12345.tar.gz##解压格式tar -jxvf xx.tar.bz2 第二步，自定义图标链接 12cd /opt/sublime_text_3sudo gedit sublime_text.desktop 更改以下内容： 1234Exec=/opt/sublime_text_3/sublime_text %FTerminal=falseStartupNotify=trueIcon=/opt/sublime_text_3/Icon/48*48/sublime-text.png 然后执行 1sudo cp /opt/sublime_text_3/sublime_text.desktop /usr/share/applications 创建快捷方式补充：创建应用程序图标的快捷方法：1234sudo apt-get install gnome-panel#使用gnome-panel gnome-desktop-item-edit [选线][路径] [指令]gnome-desktop-item-edit /usr/share/applications/ --create-new 会弹出对话框，填写name, excu, comment 等信息创建成功了，可以在该目录下看到，而且点击的时候就能打开软件， 其他操作 ln -s 用于建立符号连接（又称软连接）这个可以用一个sublime命令代替sublime_text程序 1sudo ln -s /opt/sublime_text_3/sublime_text /usr/bin/sublime 但是一般不建议这样使用，因为这样在/usr/bin中多出来的命令，不好删除怎么删除/usr/bin中多出来的命令？ 1sudo rm -rf /usr/bin/sublime 但是！！千万小心，会造成错误删除的严重后果 创建软链接：12ln -s /home/zhenwx/htccode-v1/ /home/zhenwx/htccode ##建立/home/zhenwx/htccode-v1 的软连接 删除软链接：12rm -rf /home/zhenwx/htccode ##注意不是rm -rf /home/zhenwx/htccode/ 卸载方法一般来说，如果1tar -zxvf XXXX.tar.gz 解压缩之后，会得到一个文件夹。删除的时候，只要把/opt下面对应的文件夹删除即可。 注意的是，配置的相关信息，在ubuntu中，存储在 1/home/fogsail/.config 中，打开如下： 删除的时候要把对应的./config相关的文件夹也要删除。 如果tar -zxvf之后，是执行./configure和make and make install安装卸载方式在后面。 gtk的安装，实现sublime中文输入窗口gtk的安装方法如下12345678910pkg-config --list-all grep gtk ##查看是否安装了gtksudo apt-get updatesudo apt-get automovesudo apt-get build-essentialsudo apt-get install gnome-devel gnome-devel-doc#装好之后查看gtk库版本：pkg-config --modversion gtk+-2.0pkg-config --modversion gtk+-3.0 使用gtk安装sublime中文输入将下面的代码保存到文件sublime_imfix.c目录12345678910111213141516#include &lt;gtk/gtkimcontext.h&gt;void gtk_im_context_set_client_window(GtkIMContext *context,GdkWindow *window)&#123; GtkIMContextClass *klass; g_return_if_fail(GTK_IS_IM_CONTEXT(context)); klass=GTK_IM_CONTEXT_GET_CLASS(context); if(klass-&gt;set_client_window) klass-&gt;set_client_window(context,window); g_object_set_data(G_OBJECT(context),\"window\",window); if(!GDK_IS_WINDOW(window)) return; int width=gdk_window_get_width(window); int height=gdk_window_get_height(window); if(width!=0 &amp;&amp; height!=0) gtk_im_context_focus_in(context);&#125; 将上面的代码编译成共享库： 123gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPICsudo mv libsublime-imfix.so /opt/sublime_text_3/ 最后在sublime-text.desktop文件中做一些修改： 1234567891011sudo gedit ~/.sublime_text.desktop[Desktop Entry]Exec=bash -c \"LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text %F\"[Desktop Action Window]Exec=bash -c \"LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text -n\"[Desktop Action Document]Exec=bash -c \"LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text --command new_file\" 编译运行： 编译：1gcc -o Hello Hello.c `pkg-config --cflags --libs gtk+-2.0` 运行：1./helloworld 进阶：从源代码编译软件—MPlayer将下载的tar.gz放入/opt下一般地说，通常情况下我们把第三方软件放在/opt中，如果是系统依赖的软件，如非必要，也尽量地安装在/usr/local目录下，这是一个好习惯，可以同安装在/usr目录下的系统工具有效地区分开来。 12tar zxvf MPlayerr-1.1.tar.gzls -F 正确配置软件Linux上面所有的软件都使用configure这个脚本来配置以源代码形式发布的软件。 12./configure --prefix=/usr/local/Games/MPlayer##指定将软件安装在/usr/local/Games/MPlayer的目录下 —prefix指定软件的安装位置。至于configure的其他选项就不好说了，必须阅读README文档，举例如下： 123456789101112cd MPlayer-1.1/ ##进入MPlayer的源代码目录cat READMEstep2: Configuring MPlayerMPlayer can be adapted to all kinds of needs and hardware environments.run./configureto configure MPlayer with the default options. GUI support has to be enabled seperately,run./configure --enable-gui 按提示执行1234./configure --enable-gui...'make' will now compile MPlayer and 'make install' will install it 编译源代码： 1make 1sudo make install 看看有没有出错接下来就是一些细节的处理了。 12345Unpack the archive and put the contents in /usr/local/share/mplayer/skins/ or ~/.mplayer/skins/.mplayer will use the skin in the subdirectory named default of /usr/local/share/mplayer/skins/ or ~/.mplayer/skins/ unless told otherwise via the '-skin' switch.you should rename your skin subdirectory or make a suitable symbolic link..... 把皮肤文件复制到/usr/local/share/mplayer/skins/下面，并且命名为default. 12345cd .. ##返回上一级目录sudo cp -r Blue/ /usr/local/share/mplayer/skins/default##复制皮肤文件##不加-r或者－R的时候，只拷贝文件，不拷贝文件夹；##加上后则会拷贝文件夹——包括下一级的子文件夹，以及子文件夹中的子文件夹。 其他错误：123STEP4: Choose an onscreen display fontJust pass '-font/path/to/font.ttf' on the command line or add 'font=/path/to/font.tff' to your configuration file. The manual page has more details. Alternatively you can create a symbolic link from either ~/.mplayer/subfont.ttf or /usr/local/share/mplayer/subfont.ttf to your TrueType font. 执行： 1cp /usr/share/fonts/truetype/FZSongTi.ttf ~/.mplayer/subfont.ttf 从源代码安装node.js修改目录权限 1sudo chmod -R 755 node 1234cd nodesudo ./configure --prefix=usr/local/binsudo makesudo make install 必要的时候，还需设置环境变量 一般情况下：1234npm --versionnode --version#检查有没有信息？如果没有，则设置环境变量 1234567vim /etc/profile#export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL##上面添加：export NODE_HOME=/usr/local/node/0.10.24export PATH=$NODE_HOME/bin:$PATH 在安装的最后，需要把node安装到系统命令123sudo ln -s /usr/local/node/bin/node /usr/bin/nodesudo ln -s /usr/local/node/lib/node_modules /usr/lib/nodesudo ln -s /usr/local/node/bin/npm /usr/bin/npm 从源代码卸载node.js同样我们需要原来的包含./configure文件的解压包node 1sudo make uninstall 环境变量的配置(源码编译安装这步不必要)这里以安装nodejs为例，来说说配置环境变量的方法。 1、在nodejs官网上下载nodejs源码node-v5.1.0-linux-x64.tar.gz，到/opt目录下；进入/opt目录，输入命令：tar -zxf node-v5.1.0-linux-x64.tar.gz，将文件解压到当前目录 2、输入命令：vim /etc/profile添加以下三行：export NODE_HOME=/opt/nodeexport PATH=$PATH:$NODE_HOME/binexport NODE_PATH=$NODE_HOME/lib/node_modules之后按Esc键，并输入“：wq!”命令保存配置并推出 3、在命令行输入：source /etc/profile，然后在命令行输入：node -v，返回版本信息v5.1.0，说明环境变量配置就生效了；但，你会发现进入root账户，改配置并没有生效 4、在命令行输入：vim /root/.bashrc,并在文件末尾加入一行source etc/profile命令，保存。这样就大功告成了。 /etc/profile等环境变量/etc/profile该文件登录操作系统时，为每个用户设置环境信息，当用户第一次登录时,该文件被执行。也就是说这个文件对每个shell都有效，用于获取系统的环境信息。 /etc/bashrc为每一个运行bash shell的用户执行此文件，当bash shell被打开时,该文件被读取。也就是说，当用户shell执行了bash时，运行这个文件。 ~/.bashrc该文件存储的是专属于个人bash shell的信息，当登录时以及每次打开一个新的shell时,执行这个文件。在这个文件里可以自定义用户专属的个人信息。 那么在用户登录系统时候，相关的文件执行顺序是什么呢。在刚登录linux时，首先启动 /etc/profile 文件，然后再启动用户目录下的 ~/.bash_profile、 ~/.bash_login或 ~/.profile文件中的其中一个，执行的顺序为：~/.bash_profile、 ~/.bash_login、 ~/.profile。如果 ~/.bash_profile文件存在的话，一般还会执行 ~/.bashrc文件。 添加配置项的方法12345678910111213141516171819202122232425添加配置项，共有三种方式方式一：修改/etc/bash.bashrc文件 gedit /etc/bash.bashrc 在最后加上： export PATH＝/usr/local/arm/4.4.3/bin:$PATH方式二：修改/etc/profile文件： gedit /etc/profile 增加路径设置，在末尾添加如下,保存/etc/profile文件： export PATH＝/usr/local/arm/4.4.3/bin:$PATH 注意设置变量后，重新开机才能看见shell运行方式三：修改～/.bashrc gedit ~/.bashrc 增加路径设置，在末尾添加如下,保存~/.bashrc文件： export PATH＝/usr/local/arm/4.4.3/bin:$PATH 运行 source ~/.bashrc 生效 #export PATH＝/usr/local/arm/4.4.3/bin:$PATH 注：(这只能在当前的终端下才是有效的！) node和npm的安装解压安装文件到/opt 安装npm和node命令到系统命令 sudo ln -s /opt/XXXXXX /usr/local/bin/nodesudo ln -s /opt/XXXXXX /usr/local/bin/npm 安装过程中bash的设置 1gedit ~/.bashrc 如图所示： 设置npm为淘宝源 方法一：1npm install cnpm --registry=https://registry.npm.taobao.org 先备份请先备份 cp ~/.bashrc ~/.bashrc.bak在~/.bashrc中添加 1234alias cnpm=\"npm --registry=https://registry.npm.taobao.org \\--cache=$HOME/.npm/.cache/cnpm \\--disturl=https://npm.taobao.org/dist \\--userconfig=$HOME/.cnpmrc\" 输入1source ~/.bashrc ubuntu安装hexo在hexo deploy的时候，可能会遇到权限不够的问题。在安装hexo-deployer-git的时候，一定要cd到你的博客目录下 123cd ~/blognpm install hexo-deployer-git --save 在执行的时候，配置_config.yml如下：12345deploy: type: git repo: https://git.coding.net/fogsail/fogsail.git # 注意，这里要用https，要不然会出现权限不够的问题 branch: master 特别注意，对于ubuntu 16.04系统，repo使用https，这样要求输入用户名和密码，而不是使用git@github.com，如果使用git@github.com，则会造成权限不足的情况","categories":[{"name":"linux","slug":"linux","permalink":"https://www.fogsail.net/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.fogsail.net/tags/linux/"}]},{"title":"数论算法：基础数论概念","slug":"20170529","date":"2017-05-28T22:50:00.000Z","updated":"2018-03-02T20:56:56.000Z","comments":true,"path":"2017/05/29/20170529/","link":"","permalink":"https://www.fogsail.net/2017/05/29/20170529/","excerpt":"数论算法中有几个重要的定理，这里先对这部分定理进行证明。","text":"数论算法中有几个重要的定理，这里先对这部分定理进行证明。 数论基本定理 1）若$a&gt;b&gt;0$，且$c=a+b$，则 $c \\ mod \\ a=b$ 证明：$c \\ mod \\ a \\ =(a+b) \\ mod \\ a = 0+(b \\ mod \\ a) $因为$a&gt;b&gt;0$，所以$b \\ mod \\ a = b$ 2）证明有无穷多个素数 证明： 假设$2,3,4,5, \\cdots ,p$是无穷多个素数组成的集合，并且令$q=2 \\times 3 \\times 5 \\times \\cdots \\times p+1$，则可以发现$q$不能够被$2,3,5 \\cdots , p$中的任何一个整除。 $q$要么是一个素数，要么能够被$p \\cdots q$中的任何一个素数整除。无论哪种情形，肯定有大于$q$的素数存在。 3) 证明：如果$a|b$且$b|c$，则$a|c$ 证明： 可知$b=k_1a$，$c=k_2b$，则$c=k_1k_2a$，原式成立。 4）证明：如果$p$是素数并且$0&lt;k&lt;p$，则$gcd(k,p)=1$ 证明： 这是显然成立的，依据素数的定义 5) 证明: 对任意的正整数$n,a,b$，如果$n|ab$且$gcd(a,n)=1$，则$n|b$ 证明： 由题中条件可以知道：$ab=kn$，存在$x,y$， 使得$ax+ny=1$因为$gcd(a,n)=1$，$k/a$是一个整数。所以$b=n(k/a)=k_1n$，其中$k_1=k/a$所以很显然$n|b$ 6) 证明：如果$p$是素数，且$0&lt;k&lt;p$，则$p|{p \\choose k}$，证明若对所有的整数$a,b$和素数$p$，有$(a+b)^p \\equiv a^p+b^p (mod \\ p)$ 证明：这个结论可以由$(a+b)^p$的二项展开式显然得出 7) 证明：如果$a$和$b$是任意正整数，且满足$a|b$，则对任意$x$$(x \\ mod \\ b) \\ mod \\ a = x \\ mod \\ a$在相同的假设下，证明对任意整数$x,y$，如果$x \\equiv y (mod \\ b)$，则 $x \\equiv y(mod \\ a)$ 证明：从完全剩余系的观点来理解。$x \\ mod \\ a$可以写出$x \\in [\\cdots,l-a,l,l+a,\\cdots]$$(x \\ mod \\ b) = (x \\ mod \\ ka) =l$$(x \\ mod \\ b) \\ mod \\ a = l \\ mod \\ a = l$ $此时x \\equiv y \\equiv l(mod \\ b)$而很显然$x \\in [\\cdots,l-a,l,l+a,\\cdots]$可以得出$x \\equiv l \\ (mod \\ a)$ 8) 证明一系列等式 利用一部分结论：$a= \\prod_p p^{\\alpha} \\quad (\\alpha \\geq 0)$$b= \\prod_p p^{\\beta} \\quad (\\beta \\geq 0)$$gcd(a,b)= \\prod_p p^{min(\\alpha, \\beta)}$ 上述结论的证明，可以利用素数的唯一分解定理。由此可以知道，1)$gcd(a,b)=gcd(b,a)$ 2)$-a=- \\prod_p p^{\\alpha} \\quad (\\alpha \\geq 0)$$b= \\prod_p p^{\\beta} \\quad (\\beta \\geq 0)$$gcd(-a,b)= \\prod_p p^{min(\\alpha, \\beta)}=gcd(a,b)$ 3)$|a|=\\pm \\prod_p p^{\\alpha} \\quad (\\alpha \\geq 0)$$|b|=\\pm \\prod_p p^{\\beta} \\quad (\\beta \\geq 0)$$gcd(a,b)= \\prod_p p^{min(\\alpha, \\beta)}=gcd(|a|,|b|)$ 4)$gcd(a,ka)$可知，$a=\\prod_p p^{\\alpha} \\quad (\\alpha \\geq 0)$$ka=\\prod_p p^{\\alpha+\\alpha_{0}}$$min(\\alpha, \\alpha+\\alpha_{0})=\\alpha$$gcd(a,ka)=|a|$ 9) 证明：最大公约数满足结合律，对所有的整数$a,b,c$有：$gcd(a,gcd(b,c))=gcd(gcd(a,b),c)$ 由以上分析可知：$a=\\prod_p p^{\\alpha} \\quad b=\\prod_p p^{\\beta1} \\quad c=\\prod_p p^{\\beta2}$$gcd(a,gcd(b,c))=gcd(gcd(a,b),c)=\\prod_p p^{min(\\alpha,\\beta1,\\beta2)}$ 10）素数唯一分解定理 证明：如果$p$是素数，并且$p|ab$，那么$p|a$或者$p|b$假设某个数可以被分解成$ab$，那么由于$p|a$，则$a$可以继续往下分解。 更严格的证明表述如下：$n=p_1p_2p_3 \\cdots = q_1q_2 \\cdots \\quad (p_i \\neq q_j)$$p_1$最小，则$p_1^2 \\leq n$$q_1$最小，则$q_1^2 \\leq n$因为$p_1q_1&lt;n$，则$N=n-p_1q_1=p_1q_1(m-1)$可见$N$只有一种分解$p_1,q_1,m-1$ $p_1|n$，则$p_1|N$$q_1|n$，则$q_1|N$$(p_1q_1)|N \\quad (p_1q_1)|n$$q_1|(n/p_1)$则$q_1|(p_2p_3\\cdots)$，但q与p各不相同，矛盾","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"}]},{"title":"签约棒球运动员","slug":"20170523","date":"2017-05-22T16:50:00.000Z","updated":"2019-03-06T09:44:22.942Z","comments":true,"path":"2017/05/23/20170523/","link":"","permalink":"https://www.fogsail.net/2017/05/23/20170523/","excerpt":"假设你是一支棒球大联盟球队的总经理。在赛季休季期间，你需要签入一些自由球员。球队老板给你的预算为X美元，你可以使用少于X美元来签入球员，但如果超支，球队老板就会解雇你。 你正在考虑在N个不同位置签入球员，在每个位置上，有P个该位置的自由球员供你选择。由于你不希望任何位置过于臃肿，因此每个位置最多签入一名球员(如果在某个特定位置上你没有签入任何球员，则意味着计划继续使用现有球员)。","text":"假设你是一支棒球大联盟球队的总经理。在赛季休季期间，你需要签入一些自由球员。球队老板给你的预算为X美元，你可以使用少于X美元来签入球员，但如果超支，球队老板就会解雇你。 你正在考虑在N个不同位置签入球员，在每个位置上，有P个该位置的自由球员供你选择。由于你不希望任何位置过于臃肿，因此每个位置最多签入一名球员(如果在某个特定位置上你没有签入任何球员，则意味着计划继续使用现有球员)。 为了确定一名球员的价值，你决定使用一种称为“VORP”，或“球员替换价值”的统计评价指标。球员的VORP值越高，其价值越高。但VORP值高的球员签约费用并不一定比VORP值低的球员高，因为还有球员价值之外的因素影响签约费用。 对于每个可选择的自由球员，你知道他的三方面信息： 1.他打哪个位置。2.他的签约费用。3.他的VORP。 设计一个球员选择算法，是的总签约费用不超过X美元，而球员的总VORP最大。你可以假定每位球员的签约费用是10万美元的整数倍。算法应输出签约球员的总VORP值，总签约费用，以及球员名单。分析算法的时间和空间复杂度。 算法设计与分析 状态转移函数如下： value[i,x]= \\begin{cases} \\max \\limits_{p \\in S(N,x)} (candidate.vorp) & \\text{i==N}\\\\ \\max {(value[i+1,x],\\max \\limits_{p \\in S(N,x)} (candidate.vorp+value[i+1,x-candidate.cost]))} & \\text{i","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"库存规划","slug":"20170513","date":"2017-05-13T06:07:00.000Z","updated":"2018-03-02T20:45:10.000Z","comments":true,"path":"2017/05/13/20170513/","link":"","permalink":"https://www.fogsail.net/2017/05/13/20170513/","excerpt":"Rinky Dink公司是一家制造溜冰场冰面修整设备的公司。这种设备每个月的需求量都在变化，因此公司希望设计一种策略来规划生产，需求是给定的，即它虽然是波动的，但是是可预测的。公司希望设计接下来的$n$个月的生产计划。 对第$i$个月，公司知道需求$d_i$，即该月能够销售出去的设备的总量。令$D=\\sum_{i=1}^{n}d_i$为后$n$个月的总需求。公司雇佣的全职员工，可以提供一个月制造$m$台设备的劳动力。如果公司希望一个月内制造多于$m$台的设备，可以雇佣额外的兼职劳动力，雇佣的成本为每制造一台机器付出$c$美元。而且，如果在月末还有设备未售出，公司将付出库存成本。","text":"Rinky Dink公司是一家制造溜冰场冰面修整设备的公司。这种设备每个月的需求量都在变化，因此公司希望设计一种策略来规划生产，需求是给定的，即它虽然是波动的，但是是可预测的。公司希望设计接下来的$n$个月的生产计划。 对第$i$个月，公司知道需求$d_i$，即该月能够销售出去的设备的总量。令$D=\\sum_{i=1}^{n}d_i$为后$n$个月的总需求。公司雇佣的全职员工，可以提供一个月制造$m$台设备的劳动力。如果公司希望一个月内制造多于$m$台的设备，可以雇佣额外的兼职劳动力，雇佣的成本为每制造一台机器付出$c$美元。而且，如果在月末还有设备未售出，公司将付出库存成本。 保存$j$台设备的成本可以描述为一个函数$h(j)$，$j=1,2,\\cdots,D$，其中对所有的$1 \\leq j \\leq D$，$h(j) \\geq 0$，对$1 \\leq j \\leq D-1$，$h(j) \\leq h(j+1)$。 设计库存规划算法。 能量守恒的观点分析库存规划的问题，可以用物理学中的能量守恒的观点进行分析 $store \\ cost+HR \\ cost=total \\ value$其中，$total \\ value$表示总能量，总能量在$store \\ cost$和$HR \\ cost$中能够相互转换。 算法分析： inventory_dynamic.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#define m 15#define n 10#define c 3void find_create(int *extra_create,int *create_result,int *d)&#123; for(int i=0;i&lt;=n;i++) create_result[i]=extra_create[i]+d[i];&#125;int min_val(int a ,int b)&#123; return a&lt;b?a:b;&#125;int man_cost(int man_num)&#123; if(man_num&lt;=m) return 0; else return c*(man_num-m);&#125;int store_cost(int store_num)&#123; if(store_num&gt;0) return (int)log((double)store_num); else return 0;&#125;int create_material(int d[],int create[][n+1],int start,int end)//start从0开始&#123; if(start==end) &#123; create[start][end]=0; &#125; if(end==start+1) &#123; create[start][end]=d[end]; &#125; if(end&gt;start) &#123; create[start][end]=create_material(d,create,start,end-1)+d[end]; //实现结果 d[start+1]+d[start+2]+.....+d[end] &#125; else &#123; return 0; &#125; return create[start][end];&#125;void init_create(int create[][n+1],int d[])&#123; for(int i=0;i&lt;n;i++) create_material(d,create,i,n);&#125;int min_cost(int d[],int HR_extra[],int start,int end)&#123; if(start&gt;=end) return 0; int cost=0; //最初cost[]值为0，一开始每一个位置所保存的create[]就是当前需求值 for(int i=start;i&lt;=end;i++) &#123; if(d[i]&lt;=m) &#123; //此时不需要花费额外的人力成本，所有的create[i]==d[i]均会销售出去 cost+=0; //不需要花费任何代价，月末就可以出售完毕，没有库存 HR_extra[i]=m-d[i]; &#125; else &#123; HR_extra[i]=m-d[i]; int HR_cost=d[i]; //人力资源成本超出预算，这部分预算可以考虑转换成库存成本 int HR_cost_copy=d[i]; //副本，用来输出 int cost_original=man_cost(HR_cost); int extra_store=0; //额外付出的库存代价 //注意判断cost_original和cost_adjust哪个大？哪个小？ for(int l=start;l&lt;i;l++) //(l,i) &#123; int cur_extra=HR_extra[l]; if(cur_extra&gt;0 &amp;&amp; HR_cost!=0) //这部分人力资源成本可以用来存放库存，转换成库存成本 &#123; int temp_excess=min_val(cur_extra,HR_cost); //势能守恒来求解 HR_cost-=temp_excess; extra_store+=temp_excess; &#125; &#125; int cost_adjust=man_cost(HR_cost)+store_cost(extra_store); if(cost_adjust&lt;cost_original) &#123; cost+=cost_adjust; //HR_extra也要调整 for(int l=start;l&lt;i;l++) &#123; if(HR_extra[l]&gt;0 &amp;&amp; HR_cost_copy!=0) &#123; int temp_excess_copy=min_val(HR_extra[l],HR_cost_copy); HR_cost_copy-=temp_excess_copy; //保持势能守恒 HR_extra[l]-=temp_excess_copy; HR_extra[i]+=temp_excess_copy; &#125; &#125; &#125; else &#123; cost+=cost_original; &#125; &#125; &#125; return cost;&#125; inventory_dynamic.cpp1234567891011121314151617181920212223242526272829#include \"inventory_dynamic.h\"int main()&#123; int result_cost,original_create; int d[n+1]=&#123;0,10,11,13,14,20,25,29,9,8,7&#125;; //146 int HR_extra[n+1]=&#123;0&#125;; int result[n+1]=&#123;0&#125;; int create[n+1][n+1]=&#123;0&#125;; //int cost[n+1][n+1]=&#123;0&#125;; original_create=create_material(d,create,0,n); init_create(create,d); result_cost=min_cost(d,HR_extra,1,n); cout&lt;&lt;\"The result is :\"&lt;&lt;endl; cout&lt;&lt;result_cost&lt;&lt;endl; cout&lt;&lt;\"The create result is :\"&lt;&lt;endl; for(int i=1;i&lt;=n;i++) &#123; cout&lt;&lt;m-HR_extra[i]&lt;&lt;\" \"; &#125;&#125; 算法运行结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"基于接缝裁剪的图像压缩","slug":"20170512","date":"2017-05-12T01:54:00.000Z","updated":"2018-03-02T20:38:42.000Z","comments":true,"path":"2017/05/12/20170512/","link":"","permalink":"https://www.fogsail.net/2017/05/12/20170512/","excerpt":"给定一幅彩色图像，它由$m\\times n$的像素$A[1\\cdots m,1\\cdots n]$构成，每个像素是一个红绿蓝$(RGB)$亮度的三元组。假定我们希望轻度压缩这幅图像。具体地，我们希望从每一行中删除一个像素，使得图像变窄一个像素。 为了避免影响视觉效果，我们要求删除的像素必须位于同一列或者是相邻列，也就是说，删除的像素构成从底端到顶端的一条“接缝”(seam)，相邻像素均在垂直或对角线方向上相邻。","text":"给定一幅彩色图像，它由$m\\times n$的像素$A[1\\cdots m,1\\cdots n]$构成，每个像素是一个红绿蓝$(RGB)$亮度的三元组。假定我们希望轻度压缩这幅图像。具体地，我们希望从每一行中删除一个像素，使得图像变窄一个像素。 为了避免影响视觉效果，我们要求删除的像素必须位于同一列或者是相邻列，也就是说，删除的像素构成从底端到顶端的一条“接缝”(seam)，相邻像素均在垂直或对角线方向上相邻。 a.证明：可能的接缝数量是$m$的指数函数，假定$n&gt;1$ 证明：第一行有n中可能的取像素的方式，第二行到第m行，每一行有3种可能：$A[i][j-1],A[i][j],A[i][j+1]$。（当j==1或者j==0时，是两种可能)所以至少有$n\\times 2^{(m-1)}$ b.假定现在对每个像素$A[i,j]$我们都已经计算出一个破坏度$d[i,j]$，表示删除像素$A[i,j]$对图像可视化效果的破坏程度。 直观地，一个像素的破坏度越低，它与像素的相似度越高。再假定一条接缝的破坏度定义为包含的响度的破坏度之和。设计算法，寻求破坏度最低的接缝。 seam_carving.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;using namespace std;#define n 6 //数组行#define m 5 //数组列#define INFINITY 0x7fffffff//总共n行 m列void print_seam(int **A,int i,int j); //第i行 第j列int Additional_Min(int **A,int i,int j) //第i行 第j列&#123; int temp=0; if(j==1) &#123; temp=A[i-1][j]&gt;A[i-1][j+1]?A[i-1][j+1]:A[i-1][j]; &#125; else if(j==m) &#123; temp=A[i-1][j]&gt;A[i-1][j-1]?A[i-1][j-1]:A[i-1][j]; &#125; else &#123; if(A[i-1][j]&gt;A[i-1][j-1]) &#123; temp=A[i-1][j-1]; if(A[i-1][j-1]&gt;A[i-1][j+1]) temp=A[i-1][j+1]; &#125; else &#123; temp=A[i-1][j]; if(A[i-1][j]&gt;A[i-1][j+1]) temp=A[i-1][j+1]; &#125; &#125; return temp;&#125;void seam_carving(int **d)&#123; int **A,i; //二维数组表示破坏度之和 A=new int *[n+1]; for(i=0;i&lt;=n;i++) A[i]=new int[m+1]; for(int j=1;j&lt;=m;j++) A[1][j]=d[1][j]; for(i=2;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) A[i][j]=d[i][j]+Additional_Min(A,i,j); &#125; //输出最后接缝的位置 int min_seam=INFINITY; int seam_plot=0; for(int j=1;j&lt;=m;j++) &#123; if(A[n][j]&lt;min_seam) &#123; min_seam=A[n][j]; seam_plot=j; &#125; &#125; cout&lt;&lt;\"MIN break point is \"&lt;&lt;min_seam&lt;&lt;endl; print_seam(A,n,seam_plot); for(int i=0;i&lt;=m;i++) delete [] A[i]; delete[] A;&#125;void print_seam(int **A,int i,int j) //i行 j列，总共n行 m列&#123; int seam_next; if(i==0) return; else &#123; if(j==m) seam_next=A[i][j]&gt;A[i][j-1]?j-1:j; else if(j==1) seam_next=A[i][j]&gt;A[i][j+1]?j+1:j; else &#123; if(A[i][j]&gt;A[i][j-1]) &#123; seam_next=j-1; if(A[i][j-1]&gt;A[i][j+1]) seam_next=j+1; &#125; else &#123; seam_next=j; if(A[i][j]&gt;A[i][j+1]) seam_next=j+1; &#125; &#125; &#125; print_seam(A,i-1,seam_next); cout&lt;&lt;\"ROW: \"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;\"COLUMN: \"&lt;&lt;seam_next&lt;&lt;\"-&gt;\"; //输出方式，注意把这一句放在递归下面，从i=1---&gt;i=n从上往下执行输出 //如果放在递归前面就是从下往上输出&#125; seam_carving.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;using namespace std;#define n 6 //数组行#define m 5 //数组列#define INFINITY 0x7fffffff//总共n行 m列void print_seam(int **A,int i,int j); //第i行 第j列int Additional_Min(int **A,int i,int j) //第i行 第j列&#123; int temp=0; if(j==1) &#123; temp=A[i-1][j]&gt;A[i-1][j+1]?A[i-1][j+1]:A[i-1][j]; &#125; else if(j==m) &#123; temp=A[i-1][j]&gt;A[i-1][j-1]?A[i-1][j-1]:A[i-1][j]; &#125; else &#123; if(A[i-1][j]&gt;A[i-1][j-1]) &#123; temp=A[i-1][j-1]; if(A[i-1][j-1]&gt;A[i-1][j+1]) temp=A[i-1][j+1]; &#125; else &#123; temp=A[i-1][j]; if(A[i-1][j]&gt;A[i-1][j+1]) temp=A[i-1][j+1]; &#125; &#125; return temp;&#125;void seam_carving(int **d)&#123; int **A,i; //二维数组表示破坏度之和 A=new int *[n+1]; for(i=0;i&lt;=n;i++) A[i]=new int[m+1]; for(int j=1;j&lt;=m;j++) A[1][j]=d[1][j]; for(i=2;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) A[i][j]=d[i][j]+Additional_Min(A,i,j); &#125; //输出最后接缝的位置 int min_seam=INFINITY; int seam_plot=0; for(int j=1;j&lt;=m;j++) &#123; if(A[n][j]&lt;min_seam) &#123; min_seam=A[n][j]; seam_plot=j; &#125; &#125; cout&lt;&lt;\"MIN break point is \"&lt;&lt;min_seam&lt;&lt;endl; print_seam(A,n,seam_plot); for(int i=0;i&lt;=m;i++) delete [] A[i]; delete[] A;&#125;void print_seam(int **A,int i,int j) //i行 j列，总共n行 m列&#123; int seam_next; if(i==0) return; else &#123; if(j==m) seam_next=A[i][j]&gt;A[i][j-1]?j-1:j; else if(j==1) seam_next=A[i][j]&gt;A[i][j+1]?j+1:j; else &#123; if(A[i][j]&gt;A[i][j-1]) &#123; seam_next=j-1; if(A[i][j-1]&gt;A[i][j+1]) seam_next=j+1; &#125; else &#123; seam_next=j; if(A[i][j]&gt;A[i][j+1]) seam_next=j+1; &#125; &#125; &#125; print_seam(A,i-1,seam_next); cout&lt;&lt;\"ROW: \"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;\"COLUMN: \"&lt;&lt;seam_next&lt;&lt;\"-&gt;\"; //输出方式，注意把这一句放在递归下面，从i=1---&gt;i=n从上往下执行输出 //如果放在递归前面就是从下往上输出&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"投资策略规划","slug":"20170508","date":"2017-05-07T21:03:00.000Z","updated":"2018-03-02T18:23:26.000Z","comments":true,"path":"2017/05/08/20170508/","link":"","permalink":"https://www.fogsail.net/2017/05/08/20170508/","excerpt":"你所掌握的算法知识帮助你从Acme计算机公司获得了一份令人兴奋的工作，签约奖金为1万美元。你决定利用这笔钱进行投资，目标是10年后获取最大回报。你决定请Amalgamated投资公司管理你的投资，该公司投资回报规则如下：","text":"你所掌握的算法知识帮助你从Acme计算机公司获得了一份令人兴奋的工作，签约奖金为1万美元。你决定利用这笔钱进行投资，目标是10年后获取最大回报。你决定请Amalgamated投资公司管理你的投资，该公司投资回报规则如下： 该公司提供$n$种不同的投资，从1～n编号。在第$j$年，第$i$种投资的回报率为$r_{ij}$。换句话说，如果你在第$j$年在第$i$种投资中投入$d$美元，那么你在第j年年底，你会得到$dr_{ij}$美元。回报率是有保证的，即未来10年每种投资的回报率均为已知。 你每年只能做出一次的投资决定。在每年的年底，你既可以将钱投入到上一年的投资种类中，也可以转移到其他的投资中。如果跨年时候你不做投资转移，需要支付$f_1$的费用，否则，需要支付$f_2$的投资费用。 $f_2&gt;f_1$ 算法设计与分析 可以看出，投资策略规划问题具有最优子结构。如图所示，红色部分的$V[j][k]$是从$V[j][k1] \\ V[j][k2] \\ V[j][k3] \\ V[j][k4] \\ V[j][k5]$中选择出最大的值。 能量守恒观点分析$V[j-1][check]$具有的总能量为total total经过$f1 \\ f2 \\ f3 \\ f4 \\ f5$不同的路径的流动，最后流动到$V[j][k]$，必然存在一条流量最大的路径。 这可以用反证法，假设$f_i$不是流量最大的那个，那必然可以用$f_j$这条流量更大的路径来代替它。 如果Amalgamated公司在上述规则上又加入了新的限制条款，在任何时候单一的投资种类不得超过15000元，那么该问题就失去了最优子结构性质。 举个例子： 假设最优子结构是通过$f3$这个流量来获取的。但是对$f3$执行限流，有约束条件，则这条$f3$路径就“走不通”了，自然取不到最优解。 investment_program.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;ctime&gt;using namespace std;#define n 10#define m 8void best_investment(double **r)&#123; double increase[n+1][m+1]; //二维数组increase[i][j]表示第i年购买第j种投资 double f1=0.01,f2=0.04; double addition; for(int i=1;i&lt;=m;i++) &#123; increase[1][i]=r[i][1]+1.0; //第一年为初始状态，最大值就是本年每一种投资的值 &#125; for(int j=2;j&lt;=n;j++) //表示第j年 &#123; for(int k=1;k&lt;=m;k++) //表示第k种投资 &#123; increase[j][k]=-0x7fffffff; //从第一种投资开始检查，看看是否有和k相等类型的投资？ //类似的问题可以这样解决：两个for循环，然后从第一种投资一次开始检查 //第二种投资类型，只有几种状态：A B C等等。依次检查，看看addition值属于哪种类型 for(int check=1;check&lt;=m;check++) &#123; if(check==k) addition=f1; else addition=f2; if((increase[j-1][check]-addition)*(1.0+r[k][j])&gt;increase[j][k]) &#123; //r[k][j]第j年第k种投资 increase[j][k]=(increase[j-1][check]-addition)*(1.0+r[k][j]); &#125; &#125; &#125; &#125; cout&lt;&lt;\"year i, investment j, total: \"&lt;&lt;endl; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; cout&lt;&lt;setprecision(5)&lt;&lt;showpoint&lt;&lt;increase[i][j]&lt;&lt;\"\\t\"; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;\"after 10 years, the investment is :\"&lt;&lt;endl; double total_10=-0x7fffffff; for(int k=1;k&lt;=m;k++) //表示第k种投资 &#123; if(increase[n][k]&gt;total_10) total_10=increase[n][k]; &#125; cout&lt;&lt;total_10&lt;&lt;endl;&#125; investment_program.cpp12345678910111213141516171819202122232425262728293031323334#include \"investment_program.h\"int main()&#123; srand( (unsigned)time(NULL)); double **r; r=new double*[m+1]; for(int i=0;i&lt;=m;i++) &#123; r[i]=new double[n+1]; &#125; cout&lt;&lt;\"year j, investment i, return: \"&lt;&lt;endl; for(int i=1;i&lt;=m;i++) //共有i种投资类型 &#123; for(int j=1;j&lt;=n;j++) //年份从j=1到n，共n年 &#123; r[i][j]=(((rand()%1000+1)/1000.0+1)-1)/10.0; cout&lt;&lt;setprecision(3)&lt;&lt;showpoint&lt;&lt;r[i][j]&lt;&lt;\"\\t\"; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; best_investment(r); for(int i=0;i&lt;=m;i++) &#123; delete[] r[i]; &#125; delete[] r; return 0;&#125; 算法实现结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"字符串拆分","slug":"20170419","date":"2017-04-19T14:20:00.000Z","updated":"2018-03-02T17:51:06.000Z","comments":true,"path":"2017/04/19/20170419/","link":"","permalink":"https://www.fogsail.net/2017/04/19/20170419/","excerpt":"字符串拆分概论某种字符串处理语言能够允许程序员将一个字符串拆分成为两段。由于此操作需要复制字符串，因此需要$n$个时间单位来将一个$n$个字符串拆分为两段。假定一个程序员希望将一个20个字符的字符串在第2个，第8个，以及第10个字符串进行从左到右拆分。","text":"字符串拆分概论某种字符串处理语言能够允许程序员将一个字符串拆分成为两段。由于此操作需要复制字符串，因此需要$n$个时间单位来将一个$n$个字符串拆分为两段。假定一个程序员希望将一个20个字符的字符串在第2个，第8个，以及第10个字符串进行从左到右拆分。 主要的拆分方式如下； 自底向上非递归求解算法分析： break_string2.h1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;#define n 7 //为L[]的数组元素的个数int break_string_array(int L[],int cut[][n+1])&#123; int cost[n+1][n+1]=&#123;0&#125;; for(int len=2;len&lt;=n;len++) &#123; for(int i=1;i&lt;=n-len+1;i++) &#123; int j=i+len-1; if(j-i&gt;1) cost[i][j]=0x7fffffff; for(int part=i+1;part&lt;j;part++) &#123; int value=cost[i][part]+cost[part][j]+(L[j-1]-L[i-1]); //注意，这里cost[start][part]+cost[part+1][end]会发生错误 if(value&lt;cost[i][j]) &#123; cost[i][j]=value; cut[i][j]=part; &#125; &#125; &#125; &#125; return cost[1][n];&#125;void print_breaks(int L[],int cut[][n+1],int i,int j)&#123; if(j-i&gt;=2) &#123; int k=cut[i][j]; cout&lt;&lt;L[k-1]&lt;&lt;\" \"; print_breaks(L,cut,i,k); print_breaks(L,cut,k,j); &#125;&#125; break_string2.cpp1234567891011121314#include \"break_string2.h\"int main()&#123; //int L[n]=&#123;0,2,8,10,20&#125;; int L[n]=&#123;0,11,14,17,20,25,30&#125;; int cut[n+1][n+1]=&#123;0&#125;; int result=break_string_array(L,cut); cout&lt;&lt;\"result is : \"&lt;&lt;endl; cout&lt;&lt;result&lt;&lt;endl; print_breaks(L,cut,1,n);&#125; 算法实现结果 自顶向下递归算法记得带备忘机制 break_string.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//L[]表示拆分点数组//cost[][]表示花费#include &lt;iostream&gt;#define INFINITY 0x7fffffffusing namespace std;#define m 5#define n 30using namespace std;//int position[n+1][n+1]=&#123;0&#125;;int cost[n+1][n+1]=&#123;0&#125;;int exist[n+1][n+1]=&#123;0&#125;;int total_cost=INFINITY;int part=0;int cut_point=0;void INITIATE(int cost[][n+1])&#123; for(int i=0;i&lt;=n-1;i++) &#123; for(int j=i+1;j&lt;=n;j++) cost[i][j]=INFINITY; &#125;&#125;//break_point中，start,end分别表示下标起始坐标，尾坐标int break_point(int L[],int cost[][n+1],int start,int end,int cut[][n+1]) //start end表示第几个数，而不是数组下标&#123; //使用递归判断的时候要先看看在start和end之间是否存在这样的值 if(end-start&lt;2) &#123; cost[start][end]=0; return cost[start][end]; &#125; if(cost[start][end]!=INFINITY) return cost[start][end]; for(int i=0;i&lt;m;i++) &#123; if(L[i]&gt;start &amp;&amp; L[i]&lt;end) &#123; exist[start][end]=1; break; &#125; &#125; if(exist[start][end]==0) &#123; cost[start][end]=0; return cost[start][end]; &#125; else &#123; int total_cost=INFINITY; for(int i=0;i&lt;m;i++) &#123; if(L[i]&gt;start &amp;&amp; L[i]&lt;end) &#123; part=L[i]; if(break_point(L,cost,start,part,cut)+break_point(L,cost,part+1,end,cut)+(end-start+1)&lt;=total_cost) &#123; total_cost=break_point(L,cost,start,part,cut)+break_point(L,cost,part+1,end,cut)+(end-start+1); cut_point=i; &#125; &#125; &#125; if(total_cost&lt;=cost[start][end]) &#123; cost[start][end]=total_cost; cut[start][end]=cut_point; &#125; &#125; return cost[start][end];&#125;void print_breaks(int L[],int cut[][n+1],int start,int end)&#123; if(exist[start][end]==1) &#123; cout&lt;&lt;L[cut[start][end]]&lt;&lt;\" \"; print_breaks(L,cut,start,L[cut[start][end]]); print_breaks(L,cut,L[cut[start][end]]+1,end); &#125;&#125; break_string.cpp12345678910111213141516171819202122#include \"break_string.h\"int main()&#123; //int L[m]=&#123;2,8,10&#125;; int L[m]=&#123;11,14,17,20,25&#125;; int cost[n+1][n+1]; int cut[n+1][n+1]=&#123;0&#125;; INITIATE(cost); //初始化完毕 int result=break_point(L,cost,1,n,cut); print_breaks(L,cut,1,n); cout&lt;&lt;endl; cout&lt;&lt;\"The result is :\"; cout&lt;&lt;result&lt;&lt;endl; return 0;&#125; 这里注意的是递归式和自底向上方法不一样 $ if(breakpoint(L,cost,start,part,cut)+breakpoint(L,cost,part+1,end,cut)+(end-start+1)&lt;=totalcost)$ 算法实现结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"译码算法","slug":"20170416","date":"2017-04-16T07:20:00.000Z","updated":"2018-03-02T18:15:54.000Z","comments":true,"path":"2017/04/16/20170416/","link":"","permalink":"https://www.fogsail.net/2017/04/16/20170416/","excerpt":"我们可以通过在有向图$G=(V,E)$中使用动态规划的算法来实现语音识别功能。对每条边$(u,v) \\in E$打上一个声音标签$\\sigma (u,v)$，该声音来自于有限声音集$\\sum$ 。图中从特定的顶点$v_0 \\in V$开始的每条路径都对应模型产生一个可能的声音序列。对于一条有向路径，我们定义标签为路径中边的标签的简单连结。","text":"我们可以通过在有向图$G=(V,E)$中使用动态规划的算法来实现语音识别功能。对每条边$(u,v) \\in E$打上一个声音标签$\\sigma (u,v)$，该声音来自于有限声音集$\\sum$ 。图中从特定的顶点$v_0 \\in V$开始的每条路径都对应模型产生一个可能的声音序列。对于一条有向路径，我们定义标签为路径中边的标签的简单连结。 寻找特定的声音序列对给定的带标签的图$G$，特定顶点$v_0$以及$\\sum$上的声音序列$\\sigma=&lt;\\sigma _1,\\sigma _2,\\sigma_3, \\cdots, \\sigma_k&gt;$返回从$G$中从$V_0$开始的一条路径，$s$为该路径的标签（如果存在这样的路径）。否则，返回NO-SUCH-PATH viterbi_graph.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include \"stdlib.h\"#include &lt;string.h&gt;using namespace std;#define MAXVEX 100enum color&#123;WHITE,GRAY,BLACK&#125;;enum which_edge&#123;NONE,TREE,BACK,FORWARD,CROSS&#125;;typedef int status;typedef string VertexType;typedef int EdgeType;typedef struct EdgeNode&#123; int Edgestart; int Edgeend; //邻接点域，储存该顶点对应的下标 EdgeType weight; //用于存储权值 int type; struct EdgeNode *next; //下一个邻接点&#125;EdgeNode;typedef struct VertexNode //顶点表结点&#123; VertexType data; //顶点域，存储顶点信息 int color; int touch,finish; //访问开始时间和结束时间 EdgeNode* FirstEdge; //边表头指针 int parent; //指向遍历的父结点&#125;VertexNode,AdjList[MAXVEX];typedef struct&#123; AdjList adjList; //图的顶点表 int numNodes,numEdges;&#125;GraphAdjList;void CreateALGraph(GraphAdjList *G)&#123; EdgeNode *e; cout&lt;&lt;\"Input the number of vertexes and edges: \"&lt;&lt;endl; cin&gt;&gt;G-&gt;numNodes&gt;&gt;G-&gt;numEdges; //输入顶点表的信息 for(int i=0;i&lt;G-&gt;numNodes;i++) &#123; cout&lt;&lt;\"Input the data (information) of vertexes \"&lt;&lt;i+1&lt;&lt;endl; cin&gt;&gt;G-&gt;adjList[i].data; G-&gt;adjList[i].FirstEdge=NULL; G-&gt;adjList[i].parent=-1; G-&gt;adjList[i].color=WHITE; G-&gt;adjList[i].touch=G-&gt;adjList[i].finish=-1; &#125; int beg,end; for(int k=0;k&lt;G-&gt;numEdges;k++) &#123; cout&lt;&lt;\"Input the serial number of edges (Vi,Vj) \"&lt;&lt;endl; cout&lt;&lt;\"Input the vertex of beginning: \"; cin&gt;&gt;beg; cout&lt;&lt;\"Input the vertex of endding: \"; cin&gt;&gt;end; e=(EdgeNode *)malloc(sizeof(EdgeNode)); e-&gt;Edgeend=end; e-&gt;Edgestart=beg; e-&gt;weight=0; e-&gt;type=NONE; e-&gt;next=G-&gt;adjList[beg].FirstEdge; G-&gt;adjList[beg].FirstEdge=e; &#125;&#125; graph_algorithm.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include \"viterbi_graph.h\"int path_time=0;int path_exist=0;int path_print_signal=0;void print_graph(GraphAdjList *G)&#123; EdgeNode *cur_edge; for(int i=0;i&lt;G-&gt;numNodes;i++) &#123; cout&lt;&lt;\"The start is \"&lt;&lt;G-&gt;adjList[i].data&lt;&lt;endl; cout&lt;&lt;G-&gt;adjList[i].data; if(G-&gt;adjList[i].FirstEdge) cout&lt;&lt;\" adjust end is: \"; for(cur_edge=G-&gt;adjList[i].FirstEdge;cur_edge;cur_edge=cur_edge-&gt;next) &#123; cout&lt;&lt;cur_edge-&gt;Edgeend&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125;&#125;void DFS_visit(GraphAdjList *G,int start,int end)&#123; G-&gt;adjList[start].color=GRAY; path_time++; G-&gt;adjList[start].touch=path_time; for(EdgeNode *cur_e=G-&gt;adjList[start].FirstEdge;cur_e;cur_e=cur_e-&gt;next) &#123; if(cur_e-&gt;Edgeend==end) &#123; path_exist=1; &#125; if(path_exist==1) return; int cur_end=cur_e-&gt;Edgeend; if(G-&gt;adjList[cur_end].color==WHITE) &#123; G-&gt;adjList-&gt;parent=start; DFS_visit(G,cur_end,end); cur_e-&gt;type=TREE; &#125; else if(G-&gt;adjList[cur_end].color==GRAY) &#123; cur_e-&gt;type=BACK; &#125; else if(G-&gt;adjList[cur_end].color==BLACK) &#123; if(G-&gt;adjList[start].touch&lt;G-&gt;adjList[end].touch) cur_e-&gt;type=FORWARD; else cur_e-&gt;type=CROSS; &#125; &#125; //G-&gt;adjList[start] has finished G-&gt;adjList[start].color=BLACK; path_time++; G-&gt;adjList[start].finish=path_time;&#125;void DFS(GraphAdjList *G,int start,int end)&#123; for(int u=0;u&lt;G-&gt;numNodes;u++) &#123; G-&gt;adjList[u].color=WHITE; G-&gt;adjList[u].parent=-1; &#125; path_time=0; if(G-&gt;adjList[start].color==WHITE) DFS_visit(G,start,end);&#125;void path_print(GraphAdjList *G,int start,int end)&#123; if(path_exist==1) &#123; cout&lt;&lt;\" \"&lt;&lt;start; for(EdgeNode *e_ptr=G-&gt;adjList[start].FirstEdge;e_ptr;e_ptr=e_ptr-&gt;next) &#123; if(e_ptr-&gt;Edgeend==end) &#123; cout&lt;&lt;\" \"&lt;&lt;end; path_print_signal=1; return; &#125; &#125; if(path_print_signal==0) &#123; for(EdgeNode *e_ptr=G-&gt;adjList[start].FirstEdge;e_ptr;e_ptr=e_ptr-&gt;next) &#123; if(e_ptr-&gt;type==TREE) path_print(G,e_ptr-&gt;Edgeend,end); &#125; &#125; &#125; else &#123; cout&lt;&lt;\"The path is not exist\"&lt;&lt;endl; &#125;&#125; viterbi_algorithm.cpp1234567891011121314151617181920212223242526#include \"graph_algorithm.h\"int main()&#123; GraphAdjList G; CreateALGraph(&amp;G); print_graph(&amp;G); int start,end; cout&lt;&lt;\"Input the start of the edge : \"&lt;&lt;endl; cin&gt;&gt;start; cout&lt;&lt;\"Input the end of the edge : \"&lt;&lt;endl; cin&gt;&gt;end; DFS(&amp;G,start,end); cout&lt;&lt;endl; cout&lt;&lt;path_exist&lt;&lt;endl; cout&lt;&lt;G.adjList[start].color&lt;&lt;\" \"&lt;&lt;G.adjList[start].touch&lt;&lt;\" \"&lt;&lt;G.adjList[start].finish&lt;&lt;\" \"&lt;&lt;endl; cout&lt;&lt;G.adjList[end].color&lt;&lt;\" \"&lt;&lt;G.adjList[end].touch&lt;&lt;\" \"&lt;&lt;G.adjList[end].finish&lt;&lt;\" \"&lt;&lt;endl; cout&lt;&lt;\"The path is :\"&lt;&lt;endl; path_print(&amp;G,start,end); return 0;&#125; 算法运行结果 随机游动假定每条边$(u,v) /in E$都关联一个非负概率$p(u,v)$，它表示从顶点$u$开始，经过边$(u,v)$，产生对应的声音的概率。任何一个顶点射出的概率之和均为1。 一条路径上的概率定义为路径上所有边的概率之积。 状态转移函数 可以看出：从$v_1$到$v_4$，最大的概率值为$0.8 \\times 1=0.8$ 动态规划能够实现的状态转移函数如下： 1234567answer=e-&gt;probability*DFS_compute(G,e-&gt;e_end,end);//计算从G-&gt;adjlist[beg]出发的每一条边，找出最大值if(answer&gt;G-&gt;adjlist[beg].res)&#123; G-&gt;adjlist[beg].res=answer; G-&gt;adjlist[beg].direction=e-&gt;e_end;&#125; probability_graph.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;string.h&gt;#include \"stdlib.h\"using namespace std;#define MAXVEX 100typedef int status;typedef string VertexType;typedef double EdgeType;typedef struct Edge&#123; int e_start; int e_end; //邻接点域 EdgeType probability; //用于存储权值，即边的概率 struct Edge *next;&#125;Edge;typedef struct Vertex&#123; VertexType data; Edge* head; //边表头指针 int direction; //用于指明节点下一步该往哪里走 double res; //用于储存最后的结果，初始化为-1 //direction和res要联动&#125;Vertex,adjvertex[MAXVEX];typedef struct&#123; adjvertex adjlist; //图的顶点表 int numNodes,numEdges;&#125;GraphAdj;void CreateGraph(GraphAdj *G)&#123; Edge *e; cout&lt;&lt;\"Input the number of vertexes and edges: \"&lt;&lt;endl; cin&gt;&gt;G-&gt;numNodes&gt;&gt;G-&gt;numEdges; //输入顶点表信息 for(int i=0;i&lt;G-&gt;numNodes;i++) &#123; cout&lt;&lt;\"Input the data (information) of vertexes \"&lt;&lt;i+1&lt;&lt;endl; cin&gt;&gt;G-&gt;adjlist[i].data; G-&gt;adjlist[i].head=NULL; G-&gt;adjlist[i].direction=-1; G-&gt;adjlist[i].res=-1; &#125; int beg,end; double prob; for(int k=0;k&lt;G-&gt;numEdges;k++) &#123; cout&lt;&lt;\"Input the serial number of Edges (Vi,Vj) \"&lt;&lt;endl; cout&lt;&lt;\"Input the vertex of beginning: \"; cin&gt;&gt;beg; cout&lt;&lt;\"Input the vertex of endding: \"; cin&gt;&gt;end; cout&lt;&lt;\"Input the probability of edge: \"; cin&gt;&gt;prob; e=(Edge *)malloc(sizeof(Edge)); e-&gt;e_start=beg; e-&gt;e_end=end; e-&gt;probability=prob; e-&gt;next=G-&gt;adjlist[beg].head; G-&gt;adjlist[beg].head=e; &#125;&#125; viterbi_probability.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include \"probability_graph.h\"double answer=1;double maxpath=0;int path_exist=0;int path_print_signal=0;int has_founded[MAXVEX];double DFS_compute(GraphAdj *G,int beg,int end);double max(double a,double b)&#123; return a&gt;b?a:b;&#125;double DFSTraverse(GraphAdj *G,int beg,int end)&#123; for(int i=0;i&lt;G-&gt;numNodes;i++) has_founded[i]=0; maxpath=DFS_compute(G,beg,end); return maxpath;&#125;double DFS_compute(GraphAdj *G,int beg,int end)&#123; if(beg==end) &#123; answer=1; return 1; &#125; for(Edge *e=G-&gt;adjlist[beg].head;e;e=e-&gt;next) &#123; if(has_founded[beg]==1) &#123; answer=G-&gt;adjlist[e-&gt;e_start].res; return G-&gt;adjlist[e-&gt;e_start].res; &#125; if(has_founded[beg]==0) &#123; if(e-&gt;e_end==end) &#123; path_exist=1; answer=e-&gt;probability; if(answer&gt;G-&gt;adjlist[e-&gt;e_start].res) &#123; G-&gt;adjlist[e-&gt;e_start].res=answer; G-&gt;adjlist[e-&gt;e_start].direction=e-&gt;e_end; &#125; return G-&gt;adjlist[e-&gt;e_start].res; &#125; answer=e-&gt;probability*DFS_compute(G,e-&gt;e_end,end); //计算从G-&gt;adjlist[beg]出发的每一条边，找出最大值 if(answer&gt;G-&gt;adjlist[beg].res) &#123; G-&gt;adjlist[beg].res=answer; G-&gt;adjlist[beg].direction=e-&gt;e_end; &#125; &#125; &#125; //beg开始的answer已经全部计算完了 has_founded[beg]=1; return G-&gt;adjlist[beg].res;&#125;void print_graph(GraphAdj *G)&#123; Edge *cur_edge; for(int i=0;i&lt;G-&gt;numNodes;i++) &#123; cout&lt;&lt;\"The start is \"&lt;&lt;G-&gt;adjlist[i].data&lt;&lt;endl; cout&lt;&lt;G-&gt;adjlist[i].data; if(G-&gt;adjlist[i].head) cout&lt;&lt;\" adjust end is: \"; for(cur_edge=G-&gt;adjlist[i].head;cur_edge;cur_edge=cur_edge-&gt;next) &#123; cout&lt;&lt;cur_edge-&gt;e_end&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125;&#125; viterbi_probability.cpp1234567891011121314151617181920212223242526272829303132333435#include \"viterbi_probability.h\"int main()&#123; GraphAdj G; CreateGraph(&amp;G); print_graph(&amp;G); int start,end; cout&lt;&lt;\"Input the start of the edge : \"&lt;&lt;endl; cin&gt;&gt;start; cout&lt;&lt;\"Input the end of the edge : \"&lt;&lt;endl; cin&gt;&gt;end; double result=DFSTraverse(&amp;G,start,end); cout&lt;&lt;endl; cout&lt;&lt;path_exist&lt;&lt;endl; cout&lt;&lt;result&lt;&lt;endl; cout&lt;&lt;\"The max path is : \"&lt;&lt;endl; cout&lt;&lt;start&lt;&lt;\" \"; if(path_exist==1) &#123; int pathID=G.adjlist[start].direction; while(pathID!=end) &#123; cout&lt;&lt;pathID&lt;&lt;\" \"; pathID=G.adjlist[pathID].direction; &#125; cout&lt;&lt;end; &#125; return 0;&#125; 算法运行结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"有向无环图的最长简单路径","slug":"20170405","date":"2017-04-05T05:05:00.000Z","updated":"2018-03-02T18:07:28.000Z","comments":true,"path":"2017/04/05/20170405/","link":"","permalink":"https://www.fogsail.net/2017/04/05/20170405/","excerpt":"给定一个有向无环图$G=(V,E)$，边权重为实数，给定图中的两个顶点$k,t$，设计动态规划算法，求从k到t的最长简单路径，子问题图是怎样的？算法的效率如何？","text":"给定一个有向无环图$G=(V,E)$，边权重为实数，给定图中的两个顶点$k,t$，设计动态规划算法，求从k到t的最长简单路径，子问题图是怎样的？算法的效率如何？ 算法分析：该问题不能够用贪心求解，假设从k出发，每一步取得weight最大的边，按这样的路径，并不能够保证能走到终点t。所以考虑动态规划算法。该问题满足动态规划算法的两个特征：一、最优子结构：从k出发到t的最优路径，一定是$max(best \\, path \\, A_1 \\, to \\,\\, t+weight[A_0][A_1])$，其中$A0—&gt;A1—&gt;\\cdots t$和$B0—&gt;B1—&gt;\\cdots t$等等的诸多方案中的最优方案，构成了最优解。符合“剪贴”性质。 二、重叠子结构 有上面的公式可知，子问题：$A0—&gt;A1—&gt;\\cdots t$会被反复求解。 状态转移函数： 1234567int q=weight[k][t];for(int i=k+1;i&lt;=t &amp;&amp; weight[k][i];i++)&#123; q=max(q,weight[k][i]+Find_longest_path(weight,numVertexes,i,t,r));&#125;r[k]=q;return q; 算法实现Graphic_longest_path.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;#define INITWEIGHT 0//用矩阵实现图class graph&#123; private: bool isWeighted; //是否带权？ bool isDirected; //是否有向？ int numV; //顶点数 int numE; //边数 int **matrix; //邻接矩阵 public: graph(int numV,bool isWeighted=false,bool isDirected=false); void createGraph(); ~graph(); int getVerNums() &#123; return numV; &#125; int getEdgeNums() &#123; return numE; &#125; int **getWeight() &#123; return matrix; &#125; void setEdgeWeight(int beg,int end,int weight); void printAdjacentMatrix(); //检查输入 bool check(int i,int j,int w=1);&#125;;//类的实现graph::graph(int numV,bool isWeighted,bool isDirected)&#123; while(numV&lt;=0) &#123; cout&lt;&lt;\"Vertex is wrong! Please enter again! \"&lt;&lt;endl; cin&gt;&gt;numV; &#125; this-&gt;numV=numV; this-&gt;isWeighted=isWeighted; this-&gt;isDirected=isDirected; //private之后的成员可以被类的成员函数访问，但是不能够被使用该类的代码访问 matrix=new int *[numV]; for(int i=0;i&lt;numV;i++) matrix[i]=new int [numV]; //对图进行初始化 if(!isWeighted) //无权图 &#123; //对所有的权值初始化为0 for(int i=0;i&lt;numV;i++) for(int j=0;j&lt;numV;j++) matrix[i][j]=0; &#125; else //有权图 &#123; for(int i=0;i&lt;numV;i++) for(int j=0;j&lt;numV;j++) matrix[i][j]=INITWEIGHT; &#125;&#125;//建图void graph::createGraph()&#123; cout&lt;&lt;\"input edges: \"&lt;&lt;endl; while(cin&gt;&gt;numE &amp;&amp; numE&lt;0) cout&lt;&lt;\"wrong input! \"&lt;&lt;endl; int i,j,w; if(!isWeighted) //无权图 &#123; if(!isDirected) //无向图 &#123; cout&lt;&lt;\"Input begin and end \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j; while(!check(i,j)) &#123; cout&lt;&lt;\"wrong edges, input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j; &#125; matrix[i][j]=matrix[j][i]=1; &#125; &#125; else &#123; cout&lt;&lt;\"enter begin and end \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j; while(!check(i,j)) &#123; cout&lt;&lt;\"wrong edges, input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j; &#125; matrix[i][j]=1; &#125; &#125; &#125; else //有权图 &#123; if(!isDirected) //无向图 &#123; cout&lt;&lt;\"enter begin, end, and weight: \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; while(!check(i,j,w)) &#123; cout&lt;&lt;\"wrong edges,input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; &#125; matrix[i][j]=matrix[j][i]=w; &#125; &#125; else &#123; cout&lt;&lt;\"begin, end, and weight: \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; while(!check(i,j,w)) &#123; cout&lt;&lt;\"wrong edges, input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; &#125; matrix[i][j]=w; &#125; &#125; &#125;&#125;graph::~graph() //析构函数&#123; for(int i=0;i&lt;numV;i++) delete[] matrix[i]; delete[] matrix;&#125;//设置指定边权值：void graph::setEdgeWeight(int beg,int end,int weight)&#123; if(isWeighted) &#123; while(!check(beg,end,weight)) &#123; cout&lt;&lt;\"wrong input, input again:\"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end&gt;&gt;weight; &#125; if(isDirected) matrix[beg][end]=weight; else matrix[beg][end]=matrix[end][beg]=weight; &#125; else &#123; while(!check(beg,end,1)) &#123; cout&lt;&lt;\"wrong input, input again: \"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end; &#125; if(isDirected) //对邻接矩阵的值进行反转，重置，1变成0，0变成1 matrix[beg][end]=1-matrix[beg][end]; else matrix[beg][end]=matrix[end][beg]=1-matrix[beg][end]; &#125;&#125;//输入检查bool graph::check(int i,int j,int w)&#123; if(i&gt;=0 &amp;&amp; i&lt;numV &amp;&amp; j&gt;=0 &amp;&amp; j&lt;numV &amp;&amp; w&gt;0) return true; else return false;&#125;void graph::printAdjacentMatrix()&#123; cout.setf(ios::left); cout&lt;&lt;setw(4)&lt;&lt;\" \"; for(int i=0;i&lt;numV;i++) cout&lt;&lt;setw(4)&lt;&lt;i; cout&lt;&lt;endl; for(int i=0;i&lt;numV;i++) &#123; cout&lt;&lt;setw(4)&lt;&lt;i; for(int j=0;j&lt;numV;j++) cout&lt;&lt;setw(4)&lt;&lt;matrix[i][j]; cout&lt;&lt;endl; &#125;&#125; dynamic_longest_path.h123456789101112131415161718192021222324252627282930313233343536373839404142434445#include \"Graphic_longest_path.h\"#include &lt;iostream&gt;#include &lt;vector&gt;#define INFINITY 0x7fffffffint max(int a,int b)&#123; return a&gt;b?a:b;&#125;int Find_longest_path(int **weight,int numVertexes,int k,int t,vector&lt;int&gt; &amp;r) //寻找k到t的最短路径&#123; if(r[k]&gt;=0) return r[k]; if(k==t) &#123; int q=0; r[k]=q; return q; &#125; else &#123; int q=weight[k][t]; for(int i=k+1;i&lt;=t &amp;&amp; weight[k][i];i++) &#123; q=max(q,weight[k][i]+Find_longest_path(weight,numVertexes,i,t,r)); &#125; r[k]=q; return q; &#125;&#125;int dynamic_longest_path(int **weight,int numVertexes,int k,int t)&#123; vector&lt;int&gt; r; r.resize(numVertexes); for(int i=0;i&lt;numVertexes;i++) r[i]=-INFINITY; return Find_longest_path(weight,numVertexes,k,t,r);&#125; Graphic_longest_path.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include \"dynamic_longest_path.h\"#include &lt;iostream&gt;int main()&#123; cout&lt;&lt;\"AdjacentMatrix Graphic: \"&lt;&lt;endl; bool isDirected, isWeighted; int numV; cout&lt;&lt;\"Create Graphics: \"&lt;&lt;endl; cout&lt;&lt;\"input Vertexes: \"; cin&gt;&gt;numV; cout&lt;&lt;\"Is weighted? 0(no), 1(yes) : \"; cin&gt;&gt;isWeighted; cout&lt;&lt;\"IS directed? 0(no), 1(yes) : \"; cin&gt;&gt;isDirected; graph graph(numV,isWeighted,isDirected); cout&lt;&lt;\"This is a \"; isDirected ? cout&lt;&lt;\"Directed \" : cout&lt;&lt;\"Undirected: \"; isWeighted ? cout&lt;&lt;\"Weighted \" &lt;&lt;endl : cout&lt;&lt;\"Unweighted \"&lt;&lt;endl; graph.createGraph(); cout&lt;&lt;\"print AdjacentMatrix: \"&lt;&lt;endl; graph.printAdjacentMatrix(); cout&lt;&lt;endl; int k,t; cout&lt;&lt;\"input k, t :\"&lt;&lt;endl; cin&gt;&gt;k&gt;&gt;t; int numVertex=graph.getVerNums(); int **weight_dynamic=graph.getWeight(); cout&lt;&lt;\"test: \"; cout&lt;&lt;weight_dynamic[k][t]&lt;&lt;endl; int result=dynamic_longest_path(weight_dynamic,numVertex,k,t); cout&lt;&lt;\"The result is :\"&lt;&lt;endl; cout&lt;&lt;result&lt;&lt;endl; int beg, end, weight; bool flag; cout&lt;&lt;\"Adjust the weight, no(0), yes(1): \"&lt;&lt;endl; cin&gt;&gt;flag; if(flag) &#123; if(isWeighted) &#123; cout&lt;&lt;\"Enter edges--begin, end, and weight: \"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end&gt;&gt;weight; graph.setEdgeWeight(beg,end,weight); &#125; else &#123; cout&lt;&lt;\"Enter edges--begin, end: \"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end; graph.setEdgeWeight(beg,end,1); &#125; cout&lt;&lt;\"Successed!\"&lt;&lt;endl; cout&lt;&lt;\"Print AdjacentMatrix: \"&lt;&lt;endl; graph.printAdjacentMatrix(); &#125; return 0;&#125; 重构解为了能够输出最短路径的方案，可以对解进行重构： Graphic_longest_path.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;#define INITWEIGHT 0//用矩阵实现图class graph&#123; private: bool isWeighted; //是否带权？ bool isDirected; //是否有向？ int numV; //顶点数 int numE; //边数 int **matrix; //邻接矩阵 public: graph(int numV,bool isWeighted=false,bool isDirected=false); void createGraph(); ~graph(); int getVerNums() &#123; return numV; &#125; int getEdgeNums() &#123; return numE; &#125; int **getWeight() &#123; return matrix; &#125; void setEdgeWeight(int beg,int end,int weight); void printAdjacentMatrix(); //检查输入 bool check(int i,int j,int w=1);&#125;;//类的实现graph::graph(int numV,bool isWeighted,bool isDirected)&#123; while(numV&lt;=0) &#123; cout&lt;&lt;\"Vertex is wrong! Please enter again! \"&lt;&lt;endl; cin&gt;&gt;numV; &#125; this-&gt;numV=numV; this-&gt;isWeighted=isWeighted; this-&gt;isDirected=isDirected; //private之后的成员可以被类的成员函数访问，但是不能够被使用该类的代码访问 matrix=new int *[numV]; for(int i=0;i&lt;numV;i++) matrix[i]=new int [numV]; //对图进行初始化 if(!isWeighted) //无权图 &#123; //对所有的权值初始化为0 for(int i=0;i&lt;numV;i++) for(int j=0;j&lt;numV;j++) matrix[i][j]=0; &#125; else //有权图 &#123; for(int i=0;i&lt;numV;i++) for(int j=0;j&lt;numV;j++) matrix[i][j]=INITWEIGHT; &#125;&#125;//建图void graph::createGraph()&#123; cout&lt;&lt;\"input edges: \"&lt;&lt;endl; while(cin&gt;&gt;numE &amp;&amp; numE&lt;0) cout&lt;&lt;\"wrong input! \"&lt;&lt;endl; int i,j,w; if(!isWeighted) //无权图 &#123; if(!isDirected) //无向图 &#123; cout&lt;&lt;\"Input begin and end \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j; while(!check(i,j)) &#123; cout&lt;&lt;\"wrong edges, input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j; &#125; matrix[i][j]=matrix[j][i]=1; &#125; &#125; else &#123; cout&lt;&lt;\"enter begin and end \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j; while(!check(i,j)) &#123; cout&lt;&lt;\"wrong edges, input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j; &#125; matrix[i][j]=1; &#125; &#125; &#125; else //有权图 &#123; if(!isDirected) //无向图 &#123; cout&lt;&lt;\"enter begin, end, and weight: \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; while(!check(i,j,w)) &#123; cout&lt;&lt;\"wrong edges,input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; &#125; matrix[i][j]=matrix[j][i]=w; &#125; &#125; else &#123; cout&lt;&lt;\"begin, end, and weight: \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; while(!check(i,j,w)) &#123; cout&lt;&lt;\"wrong edges, input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; &#125; matrix[i][j]=w; &#125; &#125; &#125;&#125;graph::~graph() //析构函数&#123; for(int i=0;i&lt;numV;i++) delete[] matrix[i]; delete[] matrix;&#125;//设置指定边权值：void graph::setEdgeWeight(int beg,int end,int weight)&#123; if(isWeighted) &#123; while(!check(beg,end,weight)) &#123; cout&lt;&lt;\"wrong input, input again:\"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end&gt;&gt;weight; &#125; if(isDirected) matrix[beg][end]=weight; else matrix[beg][end]=matrix[end][beg]=weight; &#125; else &#123; while(!check(beg,end,1)) &#123; cout&lt;&lt;\"wrong input, input again: \"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end; &#125; if(isDirected) //对邻接矩阵的值进行反转，重置，1变成0，0变成1 matrix[beg][end]=1-matrix[beg][end]; else matrix[beg][end]=matrix[end][beg]=1-matrix[beg][end]; &#125;&#125;//输入检查bool graph::check(int i,int j,int w)&#123; if(i&gt;=0 &amp;&amp; i&lt;numV &amp;&amp; j&gt;=0 &amp;&amp; j&lt;numV &amp;&amp; w&gt;0) return true; else return false;&#125;void graph::printAdjacentMatrix()&#123; cout.setf(ios::left); cout&lt;&lt;setw(4)&lt;&lt;\" \"; for(int i=0;i&lt;numV;i++) cout&lt;&lt;setw(4)&lt;&lt;i; cout&lt;&lt;endl; for(int i=0;i&lt;numV;i++) &#123; cout&lt;&lt;setw(4)&lt;&lt;i; for(int j=0;j&lt;numV;j++) cout&lt;&lt;setw(4)&lt;&lt;matrix[i][j]; cout&lt;&lt;endl; &#125;&#125; longest_path_constitute.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include \"Graphic_longest_path.h\"#include &lt;iostream&gt;#include &lt;vector&gt;#define INFINITY 0x7fffffffint max(int a,int b)&#123; return a&gt;b?a:b;&#125;int Find_longest_path(int **weight,int numVertexes,int k,int t,vector&lt;int&gt; &amp;r,int *solution) //寻找k到t的最短路径&#123; if(r[k]&gt;=0) return r[k]; if(k==t) &#123; int q=0; r[k]=q; solution[k]=t; return q; &#125; else &#123; int q=weight[k][t]; if(weight[k][t]) solution[k]=t; for(int i=k+1;i&lt;=t &amp;&amp; weight[k][i];i++) &#123; int tmp=max(q,weight[k][i]+Find_longest_path(weight,numVertexes,i,t,r,solution)); if(tmp&gt;q) &#123; q=tmp; solution[k]=i; &#125; &#125; r[k]=q; return q; &#125;&#125;int dynamic_longest_path(int **weight,int numVertexes,int k,int t,int *solution)&#123; vector&lt;int&gt; r; r.resize(numVertexes); for(int i=0;i&lt;numVertexes;i++) &#123; r[i]=-INFINITY; &#125; //完成初始化 return Find_longest_path(weight,numVertexes,k,t,r,solution);&#125;void print_solution(int *solution,int k,int t)&#123; if(solution[k]==-1) cout&lt;&lt;\"The path is not exist! \"&lt;&lt;endl; else &#123; cout&lt;&lt;\"The result is : \"&lt;&lt;endl; cout&lt;&lt;\" \"&lt;&lt;k&lt;&lt;\" --&gt; \"; while(k!=t) &#123; cout&lt;&lt;solution[k]; if(solution[k]!=t) &#123; cout&lt;&lt;\" --&gt; \"; &#125; k=solution[k]; &#125; cout&lt;&lt;endl; &#125;&#125; Graphic_longest_path.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include \"longest_path_constitute.h\"#include &lt;iostream&gt;int main()&#123; cout&lt;&lt;\"AdjacentMatrix Graphic: \"&lt;&lt;endl; bool isDirected, isWeighted; int numV; cout&lt;&lt;\"Create Graphics: \"&lt;&lt;endl; cout&lt;&lt;\"input Vertexes: \"; cin&gt;&gt;numV; cout&lt;&lt;\"Is weighted? 0(no), 1(yes) : \"; cin&gt;&gt;isWeighted; cout&lt;&lt;\"IS directed? 0(no), 1(yes) : \"; cin&gt;&gt;isDirected; graph graph(numV,isWeighted,isDirected); cout&lt;&lt;\"This is a \"; isDirected ? cout&lt;&lt;\"Directed \" : cout&lt;&lt;\"Undirected: \"; isWeighted ? cout&lt;&lt;\"Weighted \" &lt;&lt;endl : cout&lt;&lt;\"Unweighted \"&lt;&lt;endl; graph.createGraph(); cout&lt;&lt;\"print AdjacentMatrix: \"&lt;&lt;endl; graph.printAdjacentMatrix(); cout&lt;&lt;endl; int k,t; cout&lt;&lt;\"input k, t :\"&lt;&lt;endl; cin&gt;&gt;k&gt;&gt;t; int numVertex=graph.getVerNums(); int **weight_dynamic=graph.getWeight(); cout&lt;&lt;\"test: \"; cout&lt;&lt;weight_dynamic[k][t]&lt;&lt;endl; //初始化solution： int *solution=new int[numVertex+1]; for(int i=0;i&lt;numVertex;i++) solution[i]=-1; //返回最优解： int result=dynamic_longest_path(weight_dynamic,numVertex,k,t,solution); cout&lt;&lt;\"The result is :\"&lt;&lt;endl; cout&lt;&lt;result&lt;&lt;endl; //返回solution的解，注意delete[] cout&lt;&lt;\"The solution is \"&lt;&lt;endl; print_solution(solution,k,t); int beg, end, weight; bool flag; cout&lt;&lt;\"Adjust the weight, no(0), yes(1): \"&lt;&lt;endl; cin&gt;&gt;flag; if(flag) &#123; if(isWeighted) &#123; cout&lt;&lt;\"Enter edges--begin, end, and weight: \"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end&gt;&gt;weight; graph.setEdgeWeight(beg,end,weight); &#125; else &#123; cout&lt;&lt;\"Enter edges--begin, end: \"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end; graph.setEdgeWeight(beg,end,1); &#125; cout&lt;&lt;\"Successed!\"&lt;&lt;endl; cout&lt;&lt;\"Print AdjacentMatrix: \"&lt;&lt;endl; graph.printAdjacentMatrix(); &#125; return 0;&#125; 输出结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"公司聚会计划","slug":"20170312","date":"2017-03-12T10:00:00.000Z","updated":"2018-03-02T20:53:28.000Z","comments":true,"path":"2017/03/12/20170312/","link":"","permalink":"https://www.fogsail.net/2017/03/12/20170312/","excerpt":"公司内部结构关系是层次化的，即员工按主管—下属关系构成一棵树，根节点为公司主席。人事部按“宴会交际能力”给每个员工打分，分值为实数。Stewart教授是一家公司总裁的顾问，这家公司正在计划一个公司的聚会。这个公司有一个层次式的结构；也就是，管理关系形成一颗以总裁为根的树。人事部门按每个员工喜欢聚会的程度来排名，排名是一个实数。为了使每个参加聚会者都喜欢这个聚会，总裁不希望一个雇员和她的直接上司同时参加。 Stewart教授面对一颗描述公司结构的树，使用了左孩子右兄弟描述法。树中每个节点除了包含指针，还包含雇员的名字以及雇员喜欢聚会的排名。描述一个算法，它生成一张客人列表，使得客人喜欢聚会的程度的总和最大。分析你的算法的执行时间。 最大喜欢程度和？","text":"公司内部结构关系是层次化的，即员工按主管—下属关系构成一棵树，根节点为公司主席。人事部按“宴会交际能力”给每个员工打分，分值为实数。Stewart教授是一家公司总裁的顾问，这家公司正在计划一个公司的聚会。这个公司有一个层次式的结构；也就是，管理关系形成一颗以总裁为根的树。人事部门按每个员工喜欢聚会的程度来排名，排名是一个实数。为了使每个参加聚会者都喜欢这个聚会，总裁不希望一个雇员和她的直接上司同时参加。 Stewart教授面对一颗描述公司结构的树，使用了左孩子右兄弟描述法。树中每个节点除了包含指针，还包含雇员的名字以及雇员喜欢聚会的排名。描述一个算法，它生成一张客人列表，使得客人喜欢聚会的程度的总和最大。分析你的算法的执行时间。 最大喜欢程度和？ 动态规划原理：1、重叠子问题：该问题会对某个领导的下属反复求解。 2、最优子结构公司聚会有最佳方案，构成最优子结构 状态转移函数： $people(0)=\\sum max(confirm(i,0),confirm(i,1))$$people(1)=likevalue+\\sum confirm(i,0)$$result=max(confirm(root,0),confirm(root,1))$ 邻接矩阵求解company_party_array.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#define MAXNUM 20//使用有向图的邻接矩阵来表示bool party_graph[MAXNUM][MAXNUM];int solution[MAXNUM][2]; //用来存储解决方案，solution[i][0]表示不被选中 //solution[i][1]表示被选中int likevalue[MAXNUM]; //表示对party的热衷程度int how_many_member;int id;int how_many_branch,branch_id;int max(int a,int b)&#123; return a&gt;b?a:b;&#125;int confirm(int id,int status) //递归求解方案&#123; int result; if(solution[id][status]!=-1) return solution[id][status]; if(status==0) &#123; result=0; //表示这个id不参加聚会 for(int i=0;i&lt;how_many_member;i++) //遍历这个id的边，即邻接链表 &#123; if(party_graph[id][i]) result+=max(confirm(i,0),confirm(i,1)); &#125; solution[id][status]=result; return result; &#125; else &#123; result=likevalue[id]; for(int i=0;i&lt;how_many_member;i++) &#123; if(party_graph[id][i]) result+=confirm(i,0); &#125; solution[id][status]=result; return result; &#125;&#125; company_party_array.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344#include \"company_party_array.h\"#include &lt;string.h&gt;using namespace std;int main()&#123; //Initialize:对数组的值进行初始化 for(int i=0;i&lt;MAXNUM;i++) &#123; for(int j=0;j&lt;2;j++) solution[i][j]=-1; &#125; cout&lt;&lt;\"Input the number of members who join the party: \"&lt;&lt;endl; cin&gt;&gt;how_many_member; cout&lt;&lt;\"Input the like value of members: \"&lt;&lt;endl; for(int i=0;i&lt;how_many_member;i++) cin&gt;&gt;likevalue[i]; for(int i=0;i&lt;how_many_member;i++) &#123; cout&lt;&lt;\"Input member id and how many branch it has: \"&lt;&lt;endl; cin&gt;&gt;id&gt;&gt;how_many_branch; //输入每个人的编号和下属的个数 cout&lt;&lt;\"branch id: \"&lt;&lt;endl; for(int j=0;j&lt;how_many_branch;j++) &#123; cin&gt;&gt;branch_id; //输入下属员工的id party_graph[id][branch_id]=true; &#125; &#125; //初始化完成 int root=0; int result=confirm(root,0); memset(solution,-1,sizeof(solution)); //注意使用这种方法，对数组中的值进行赋值 result=max(result,confirm(root,1)); cout&lt;&lt;result&lt;&lt;endl; return 0;&#125; 左孩子右兄弟树求解用辅助队列完成特别说明：用辅助队列，使用标准库比较安全 1queue&lt;CSTree&gt; helpqueue; 用g++编译的时候，在最新的版本中，用malloc分配内存会出现错误 1CSTree child_node=temp-&gt;firstChild=new CSNode; 使用new来分配内存 CSTree.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#define Wrong 'W'using namespace std;typedef struct CSNode&#123; int data; int status; struct CSNode *firstChild; struct CSNode *nextsibling; struct CSNode *parent;&#125;CSNode,*CSTree;int InitTree(CSTree &amp;T)&#123; T=NULL; return true;&#125;int CreateTree(CSTree &amp;T)&#123; queue&lt;CSTree&gt; helpqueue; int buffchild[10]=&#123;0&#125;; int child_num; cout&lt;&lt;\"Input root of the tree: if empty, enter -1: \"&lt;&lt;endl; cin&gt;&gt;buffchild[0]; if(buffchild[0]!=-1) &#123; T=new CSNode; T-&gt;status=-1; T-&gt;data=buffchild[0]; T-&gt;nextsibling=NULL; helpqueue.push(T); //根结点入队，只存储根节点 while(!helpqueue.empty()) &#123; CSTree temp=helpqueue.front(); helpqueue.pop(); cout&lt;&lt;\"Input the child number of \"&lt;&lt;temp-&gt;data&lt;&lt;\" if child number is 0, please enter '0'\"&lt;&lt;endl; cin&gt;&gt;child_num; cout&lt;&lt;\"Input the child data of \"&lt;&lt;temp-&gt;data&lt;&lt;\" ,if it has no child , enter -1\"&lt;&lt;endl; for(int i=0;i&lt;child_num;i++) cin&gt;&gt;buffchild[i]; if(child_num!=0) &#123; CSTree child_node=temp-&gt;firstChild=new CSNode; child_node-&gt;status=-1; child_node-&gt;data=buffchild[0]; helpqueue.push(child_node); //第一个孩子入队列 for(int i=1;i&lt;child_num;i++) &#123; child_node-&gt;nextsibling=new CSNode; child_node-&gt;nextsibling-&gt;data=buffchild[i]; helpqueue.push(child_node-&gt;nextsibling); child_node=child_node-&gt;nextsibling; //指向刚刚入队的孩子 &#125; child_node-&gt;nextsibling=NULL; &#125; else temp-&gt;firstChild=NULL; &#125; &#125; else T=NULL; return true;&#125;void DestroyTree(CSTree &amp;T)&#123; if(T) &#123; if(T-&gt;firstChild) DestroyTree(T-&gt;firstChild); if(T-&gt;nextsibling) DestroyTree(T-&gt;nextsibling); free(T); T=NULL; &#125;&#125;void ClearTree(CSTree &amp;T)&#123; DestroyTree(T);&#125;bool TreeEmpty(CSTree &amp;T)&#123; if(T) return true; else return false;&#125;int TreeDepth(CSTree &amp;T)&#123; if(!T) return 0; if(!T-&gt;firstChild) return 1; CSTree child_ptr; int depth, max=0; for(child_ptr=T-&gt;firstChild;child_ptr;child_ptr=child_ptr-&gt;nextsibling) &#123; depth=TreeDepth(child_ptr); if(depth&gt;max) max=depth; &#125; return max+1;&#125;int Root(CSTree &amp;T,int cur_node)&#123; if(T) return T-&gt;data; return 0;&#125;CSNode *FindNode(CSTree &amp;T,int cur_node)&#123; queue&lt;CSTree&gt; Q; if(T) &#123; Q.push(T); while(!Q.empty()) &#123; CSTree tmp_node=Q.front(); Q.pop(); if(tmp_node-&gt;data==cur_node) return tmp_node; if(tmp_node-&gt;firstChild) Q.push(tmp_node-&gt;firstChild); if(tmp_node-&gt;nextsibling) Q.push(tmp_node-&gt;nextsibling); &#125; &#125; return NULL;&#125;bool Assign(CSTree &amp;T,int cur_node,int value) //进行赋值操作&#123; if(!T) return false; CSNode *find_cur_node=FindNode(T,cur_node); if(!find_cur_node) return false; find_cur_node-&gt;data=value; return true;&#125;CSNode *parent(CSTree &amp;T,int cur_value)&#123; queue&lt;CSTree&gt; Q; if(T) &#123; if(T-&gt;data==cur_value) return NULL; Q.push(T); while(!Q.empty()) &#123; CSTree cur_node=Q.front(); Q.pop(); CSTree parent_ptr=cur_node; if(cur_node-&gt;firstChild) &#123; if(cur_node-&gt;firstChild-&gt;data==cur_value) return parent_ptr; Q.push(cur_node-&gt;firstChild); CSTree brotherptr=cur_node-&gt;firstChild-&gt;nextsibling; while(brotherptr) &#123; if(brotherptr-&gt;data==cur_value) return parent_ptr; Q.push(brotherptr); brotherptr=brotherptr-&gt;nextsibling; &#125; &#125; &#125; &#125; return NULL;&#125;int leftchild(CSTree &amp;T,int cur_node)&#123; CSNode *node=FindNode(T,cur_node); if(node) &#123; if(node-&gt;firstChild) return node-&gt;firstChild-&gt;data; &#125; return Wrong;&#125;int rightsibling(CSTree &amp;T,int cur_node)&#123; CSNode *node=FindNode(T,cur_node); if(node) &#123; if(node-&gt;nextsibling) return node-&gt;nextsibling-&gt;data; &#125; return Wrong;&#125;bool LevelOrderTraverse(CSTree T)&#123; queue&lt;CSTree&gt; Q; if(T) &#123; cout&lt;&lt;T-&gt;data&lt;&lt;\" \"; Q.push(T); while(!Q.empty()) &#123; CSTree cur_node,child_node; cur_node=Q.front(); Q.pop(); child_node=cur_node-&gt;firstChild; while(child_node) &#123; cout&lt;&lt;child_node-&gt;data&lt;&lt;\" \"; Q.push(child_node); child_node=child_node-&gt;nextsibling; &#125; &#125; return true; &#125; return false;&#125;void recurse_Traverse(CSTree T)&#123; if(T) &#123; T-&gt;status=-1; cout&lt;&lt;T-&gt;data&lt;&lt;\" \"&lt;&lt;T-&gt;status&lt;&lt;\" \"; recurse_Traverse(T-&gt;firstChild); recurse_Traverse(T-&gt;nextsibling); &#125;&#125;void refresh_tree(CSTree &amp;T)&#123; if(T) &#123; T-&gt;status=-1; refresh_tree(T-&gt;firstChild); refresh_tree(T-&gt;nextsibling); &#125;&#125;void recurse_createtree(CSTree T)&#123; int child_number; cout&lt;&lt;\"Input the child number of \"&lt;&lt;T-&gt;data&lt;&lt;\" if it has no child, input 0 \"&lt;&lt;endl; cin&gt;&gt;child_number; if(child_number==0) &#123; T-&gt;firstChild=NULL; &#125; else &#123; CSTree child,ptr; int child_data; child=new CSNode; child-&gt;status=-1; cout&lt;&lt;\"Input the data of the child node : \"&lt;&lt;endl; cin&gt;&gt;child_data; child-&gt;data=child_data; T-&gt;firstChild=child; ptr=child; for(int i=1;i&lt;child_number;i++) &#123; CSTree brother=new CSNode; brother-&gt;status=-1; int brother_data; cout&lt;&lt;\"Input the data of the child node: \"&lt;&lt;endl; cin&gt;&gt;brother_data; brother-&gt;data=brother_data; ptr-&gt;nextsibling=brother; ptr=ptr-&gt;nextsibling; &#125; ptr-&gt;nextsibling=NULL; for(CSTree p=T-&gt;firstChild;p;p=p-&gt;nextsibling) recurse_createtree(p); &#125;&#125;void depth_traverse(CSTree &amp;T)&#123; if(T) &#123; T-&gt;status=-1; cout&lt;&lt;T-&gt;data&lt;&lt;\" \"&lt;&lt;T-&gt;status&lt;&lt;\" \"; for(CSTree p=T-&gt;firstChild;p;p=p-&gt;nextsibling) depth_traverse(p); &#125;&#125; company_party.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include \"CSTree.h\"int max(int a,int b)&#123; return a&gt;b?a:b;&#125;int confirm(CSTree &amp;T,int flag)&#123; int result; if(T-&gt;status!=-1) return T-&gt;status; if(flag==1) &#123; result=T-&gt;data; for(CSTree p=T-&gt;firstChild;p!=NULL;p=p-&gt;nextsibling) &#123; result+=confirm(p,0); &#125; T-&gt;status=result; return result; &#125; else &#123; result=0; int maxnum; for(CSTree p=T-&gt;firstChild;p;p=p-&gt;nextsibling) &#123; maxnum=confirm(p,0); refresh_tree(p); //注意在求max的时候，洗刷status的值 maxnum=max(maxnum,confirm(p,1)); result+=maxnum; &#125; T-&gt;status=result; return result; &#125;&#125;int main()&#123; CSTree T; CreateTree(T); cout&lt;&lt;\"Level order Traverse: \"&lt;&lt;endl; LevelOrderTraverse(T); cout&lt;&lt;endl; recurse_Traverse(T); cout&lt;&lt;endl; int result=confirm(T,1); cout&lt;&lt;result&lt;&lt;endl; refresh_tree(T); cout&lt;&lt;endl; result=max(result,confirm(T,0)); cout&lt;&lt;result; cout&lt;&lt;endl; cout&lt;&lt;\"recurse mathod:\"&lt;&lt;endl; CSTree Recur_T; int root_data; Recur_T=new CSNode; Recur_T-&gt;status=-1; cout&lt;&lt;\"Input the data of root : \"&lt;&lt;endl; cin&gt;&gt;root_data; Recur_T-&gt;data=root_data; recurse_createtree(Recur_T); cout&lt;&lt;\"Level order Traverse: \"&lt;&lt;endl; LevelOrderTraverse(Recur_T); cout&lt;&lt;endl; depth_traverse(Recur_T); cout&lt;&lt;endl;&#125; 递归建立左孩子右兄弟树的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546void recurse_createtree(CSTree T)&#123; int child_number; cout&lt;&lt;\"Input the child number of \"&lt;&lt;T-&gt;data&lt;&lt;\" if it has no child, input 0 \"&lt;&lt;endl; cin&gt;&gt;child_number; if(child_number==0) &#123; T-&gt;firstChild=NULL; &#125; else &#123; CSTree child,ptr; int child_data; child=new CSNode; child-&gt;status=-1; cout&lt;&lt;\"Input the data of the child node : \"&lt;&lt;endl; cin&gt;&gt;child_data; child-&gt;data=child_data; T-&gt;firstChild=child; ptr=child; for(int i=1;i&lt;child_number;i++) &#123; CSTree brother=new CSNode; brother-&gt;status=-1; int brother_data; cout&lt;&lt;\"Input the data of the child node: \"&lt;&lt;endl; cin&gt;&gt;brother_data; brother-&gt;data=brother_data; ptr-&gt;nextsibling=brother; ptr=ptr-&gt;nextsibling; &#125; ptr-&gt;nextsibling=NULL; for(CSTree p=T-&gt;firstChild;p;p=p-&gt;nextsibling) recurse_createtree(p); &#125;&#125; 实现结果非递归建树（使用辅助队列）： 递归建树的过程：仅用于测试： 特别注意：在用树实现递归的时候，算完一次confirm()之后，要使用refresh_tree把树刷新一遍，去掉第一次计算的痕迹","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"整齐打印与编辑距离问题","slug":"20170307","date":"2017-03-06T06:00:00.000Z","updated":"2018-03-02T17:45:52.000Z","comments":true,"path":"2017/03/06/20170307/","link":"","permalink":"https://www.fogsail.net/2017/03/06/20170307/","excerpt":"整齐打印使用等宽字符打印一段文本。输入文本为n个单词的序列，单词长度为$l_1,l_2, \\cdots l_n$个字符，将其打印在若干行上，每一行最多$Maxnum$个字符。如果某行包含第$i$到第$j(i \\leq j)$个单词，行尾额外空格符的数量是$M-j+i-\\sum_{k=i}^jl_k$，这个值必须是非负的。","text":"整齐打印使用等宽字符打印一段文本。输入文本为n个单词的序列，单词长度为$l_1,l_2, \\cdots l_n$个字符，将其打印在若干行上，每一行最多$Maxnum$个字符。如果某行包含第$i$到第$j(i \\leq j)$个单词，行尾额外空格符的数量是$M-j+i-\\sum_{k=i}^jl_k$，这个值必须是非负的。 算法分析： 实现过程： .h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;string.h&gt;#define infinity 0x7fffffffusing namespace std;int get_lines(int solution[],int j,string number[]);void (int length[],string number[],int n,int Maxnum)&#123; int i,j; //保存空格数 int **space; space=new int *[n+1]; for(int i=0;i&lt;=n;i++) &#123; space[i]=new int [n+1]; &#125; //保存立方值 int **cube; cube=new int *[n+1]; for(int i=0;i&lt;=n;i++) &#123; cube[i]=new int [n+1]; &#125; //用于保存解决方案 int *solution=new int [n+1]; //初始化获取space[][]的值 for(int i=1;i&lt;=n;i++) &#123; space[i][i]=Maxnum-length[i-1]; //这里space[i][]表示第几个数？length[i-1]对应的是下标 for(int j=i+1;j&lt;=n;j++) space[i][j]=space[i][j-1]-length[j-1]-1; &#125; //获取cube的值，整齐打印是依据cube的值来确定打印距离 for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=n;j++) &#123; if(space[i][j]&lt;0) cube[i][j]=infinity; else if(j==n &amp;&amp; space[i][j]&gt;=0) cube[i][j]=0; else cube[i][j]=space[i][j]*space[i][j]*space[i][j]; &#125; &#125; //动态规划过程，将结果存储在res数组中 int *res=new int [n+1]; res[0]=0; for(int j=1;j&lt;=n;j++) &#123; res[j]=infinity; for(int i=1;i&lt;=j;i++) &#123; if(res[i-1]!=infinity &amp;&amp; cube[i][j]!=infinity &amp;&amp; (res[i-1]+cube[i][j]&lt;res[j])) &#123; res[j]=res[i-1]+cube[i][j]; solution[j]=i; //i为当前行的第一个元素 &#125; &#125; &#125; get_lines(solution,n,number); //释放内存 delete[] res; delete[] solution; for(int i=0;i&lt;=n;i++) delete[] cube[i]; delete[] cube; for(int i=0;i&lt;=n;i++) delete[] space[i]; delete[] space;&#125;int get_lines(int solution[],int j,string number[]) //j为当前行的最后一个元素下标&#123; int k; int i=solution[j]; if(i==1) //表示第一个元素 k=1; else k=get_lines(solution,i-1,number)+1; //递归 cout&lt;&lt;\"current line number is : \"&lt;&lt;k&lt;&lt;\" \"; for(int l=i;l&lt;=j;l++) cout&lt;&lt;number[l-1]&lt;&lt;\" \"; //当前行的第l个元素，str下标为l-1 cout&lt;&lt;endl; return k;&#125; .cpp12345678910111213141516#include \".h\"int main()&#123; int n=10; //10个单词 int Maxnum=8; //一行可以容纳最多8个字符 string number[n]=&#123;\"abc\",\"def\",\"gh\",\"polq\",\"cs\",\"opaqe\",\"klfgh\",\"t\",\"asd\",\"th\"&#125;; int length[n]=&#123;0&#125;; for(int i=0;i&lt;n;i++) &#123; length[i]=number[i].size(); &#125; (length,number,n,Maxnum); return 0;&#125; 编辑距离算法分析 状态转移函数res[i,j]=min \\begin{cases} res[i-1,j-1]+copy& \\text{x[i]==y[j]}\\\\ res[i-1,j-1]+replace& \\text{x[i]!=y[j]}\\\\ res[i-2,j-2]+twiddle& \\text{i,j>=2 x[i]==y[j-1] && x[i-1]==y[j]}\\\\ res[i-1,j]+delete& \\text{other}\\\\ res[i,j-1]+insert& \\text{other}\\\\ \\mathop{\\min}_{0 \\leq i \\leq m} {res[i,n]}+kill& \\text{i==m && j==n} \\end{cases}分析方法与“最长公共子序列”问题分析的方法类似。 count_distance.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;using namespace std;#define infinity 0x7fffffffenum &#123;COPY,REPLACE,DELETE,INSERT,TWIDDLE,KILL,TYPE_NUM&#125;;struct TABLE&#123; int **cnt,**res; TABLE(int m,int n) //res[m][n] 分别表示图中x_max和y_max &#123; cnt=new int *[m+1]; for(int i=0;i&lt;=m;i++) cnt[i]=new int [n+1]; res=new int *[m+1]; for(int i=0;i&lt;=m;i++) res[i]=new int [n+1]; &#125;&#125;;void PRINT_SOLUTION(TABLE dis,int i,int j);TABLE count_distance(char x[],char y[],int m,int n)&#123; TABLE dis(m,n); int cost[TYPE_NUM]=&#123;-1,1,2,2,-2,1&#125;; //初始化 dis.cnt[0][0]=0; for(int i=0;i&lt;=m;i++) &#123; dis.cnt[i][0]=i*cost[DELETE]; //这里不操作y，等于把x中的元素全部删除 //删除的代价就是 第几个元素×cost dis.res[i][0]=DELETE; &#125; for(int j=0;j&lt;=n;j++) &#123; //这里相当于x中没有元素，y[]的值等于插入每一个新的元素 dis.cnt[0][j]=j*cost[INSERT]; dis.res[0][j]=INSERT; &#125; //计算最优代价 for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; dis.cnt[i][j]=0x7fffffff; if(x[i]==y[j] &amp;&amp; dis.cnt[i-1][j-1]+cost[COPY]&lt;dis.cnt[i][j]) &#123; dis.cnt[i][j]=dis.cnt[i-1][j-1]+cost[COPY]; dis.res[i][j]=COPY; &#125; if(x[i]!=y[j] &amp;&amp; dis.cnt[i-1][j-1]+cost[REPLACE]&lt;dis.cnt[i][j]) &#123; dis.cnt[i][j]=dis.cnt[i-1][j-1]+cost[REPLACE]; dis.res[i][j]=REPLACE; &#125; if(i&gt;=2&amp;&amp;j&gt;=2&amp;&amp; x[i]==y[j-1] &amp;&amp; x[i-1]==y[j] &amp;&amp; dis.cnt[i-2][j-2]+cost[TWIDDLE]&lt;dis.cnt[i][j]) &#123; dis.cnt[i][j]=dis.cnt[i-2][j-2]+cost[TWIDDLE]; dis.res[i][j]=TWIDDLE; &#125; if(dis.cnt[i-1][j]+cost[DELETE]&lt;dis.cnt[i][j]) &#123; dis.cnt[i][j]=dis.cnt[i-1][j]+cost[DELETE]; dis.res[i][j]=DELETE; &#125; if(dis.res[i][j-1]+cost[INSERT]&lt;dis.cnt[i][j]) &#123; dis.cnt[i][j]=dis.cnt[i][j-1]+cost[INSERT]; dis.res[i][j]=INSERT; &#125; &#125; &#125; //此时序列y[n]的值已经完成，这个时候截取从0&lt;=i&lt;=m-1中最小的kill值 //把m以后的值全部截取掉 for(int i=0;i&lt;=m-1;i++) &#123; if(dis.cnt[i][n]+cost[KILL]&lt;dis.cnt[m][n]) //相当于调整res[m][n]的值 //判断从哪里开始截断？ &#123; dis.cnt[m][n]=dis.cnt[i][n]+cost[KILL]; dis.res[m][n]=i; //从i开始截断，distance.solution[][]提供回溯的点，回溯到哪个点？ &#125; &#125; cout&lt;&lt;\"distance[m][n]=\"&lt;&lt;dis.cnt[m][n]&lt;&lt;\" \"&lt;&lt;endl; //输出： for(int i=0;i&lt;=m;i++) &#123; for(int j=0;j&lt;=n;j++) cout&lt;&lt;dis.cnt[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; for(int i=0;i&lt;=m;i++) &#123; for(int j=0;j&lt;=n;j++) PRINT_SOLUTION(dis,i,j); cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; return dis;&#125;void PRINT_sequence(TABLE dis,int i,int j)&#123; int I,J; if(i==0 &amp;&amp; j==0) return; if(dis.res[i][j]==COPY || dis.res[i][j]==REPLACE) &#123; I=i-1; J=j-1; &#125; else if(dis.res[i][j]==TWIDDLE) &#123; I=i-2; J=j-2; &#125; else if(dis.res[i][j]==DELETE) &#123; I=i-1; J=j; &#125; else if(dis.res[i][j]==INSERT) &#123; I=i; J=j-1; &#125; else &#123; I=dis.res[i][j]; J=j; dis.res[i][j]=KILL; &#125; PRINT_sequence(dis,I,J); PRINT_SOLUTION(dis,i,j);&#125;void PRINT_SOLUTION(TABLE dis,int i,int j)&#123; if(dis.res[i][j]==COPY) cout&lt;&lt;\"COPY\"&lt;&lt;\" \"; else if(dis.res[i][j]==REPLACE) cout&lt;&lt;\"REPLACE\"&lt;&lt;\" \"; else if(dis.res[i][j]==INSERT) cout&lt;&lt;\"INSERT\"&lt;&lt;\" \"; else if(dis.res[i][j]==TWIDDLE) cout&lt;&lt;\"TWIDDLE\"&lt;&lt;\" \"; else cout&lt;&lt;\"KILL\"&lt;&lt;\" \";&#125; count_distance.cpp1234567891011#include \"count_distance.h\"#include &lt;string.h&gt;using namespace std;int main()&#123; char x[]=\"algorithm\"; char y[]=\"altruistic\"; int x_len=strlen(x),y_len=strlen(y); TABLE distance=count_distance(x,y,x_len,y_len); PRINT_sequence(distance,x_len,y_len);&#125; 算法实现结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"回文子序列与欧几里德旅行商","slug":"20170305","date":"2017-03-04T23:27:00.000Z","updated":"2018-03-02T17:25:26.000Z","comments":true,"path":"2017/03/05/20170305/","link":"","permalink":"https://www.fogsail.net/2017/03/05/20170305/","excerpt":"回文子序列最长回文子序列是正序与逆序相同的非空字符串。例如，所有长度为1的字符串，civic，racecar，aibobphobia都是回文。设计算法，求给定输入字符串的最长回文子序列。例如，给定输入character，算法应该返回carac。算法的运行时间是怎么样的？","text":"回文子序列最长回文子序列是正序与逆序相同的非空字符串。例如，所有长度为1的字符串，civic，racecar，aibobphobia都是回文。设计算法，求给定输入字符串的最长回文子序列。例如，给定输入character，算法应该返回carac。算法的运行时间是怎么样的？ 算法设计与分析： 注意这里是回文子序列，而不是回文子串。求子串和子序列有一些不同，这里的方法用于求子序列。字串的意义是：aaabbb，需要连续的字符相同。 而子序列，是字母按照一定的排列顺序，保持回文的一致性就可以。 实现过程：将原字符串反转，然后用LCS_length(),Print_LCS()计算出最长公共子序列即可。 palidrome_longest.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;locale&gt;using namespace std;#define N 9 //输入您要判断的字符串的字符数wchar_t b[N+1][N+1]=&#123;'S'&#125;; //表示起点startint c[N+1][N+1]=&#123;0&#125;;wchar_t northwest=L'\\\\', up=L'|', leftway=L'-';void LCS_length(char *x,char *y)&#123; for(int i1=0;i1&lt;N;i1++) b[i1][0]='S'; for(int j1=0;j1&lt;N;j1++) b[0][j1]='S'; for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;N;j++) &#123; if(x[i]==y[j]) &#123; c[i+1][j+1]=c[i][j]+1; b[i+1][j+1]=northwest; //Northwest往左上 &#125; else &#123; if(c[i][j+1]&gt;=c[i+1][j]) //c[i-1][j-1] 过渡到 c[i][j]，需要将c[i-1][j]和c[i][j-1]比较大小 //取较大的那一个值 &#123; c[i+1][j+1]=c[i][j+1]; b[i+1][j+1]=up; //Up往上 &#125; else &#123; c[i+1][j+1]=c[i+1][j]; b[i+1][j+1]=leftway; //Left往左 &#125; &#125; &#125; &#125;&#125;void Print_lcs(char *x,int i,int j)&#123; if(i==0||j==0) return; if(b[i][j]==northwest) &#123; Print_lcs(x,i-1,j-1); cout&lt;&lt;x[i-1]&lt;&lt;\" \"; //当然，按y[j]输出也没有问题，因为是公共序列嘛！ &#125; //这里的下标是从i=0开始的，所以输出x[i-1] else &#123; if(b[i][j]==up) Print_lcs(x,i-1,j); else Print_lcs(x,i,j-1); &#125;&#125;char *strReverse(char *str)&#123; for(int i=0;i&lt;N/2;i++) &#123; swap(str[i],str[N-1-i]); &#125; return str;&#125; palidrome_longest.cpp1234567891011121314151617181920212223#include \"palidrome_longest.h\"int main()&#123; char x[N+1]=&#123;0&#125;; char y[N+1]=&#123;0&#125;; char c; cout&lt;&lt;\"get the string you need to judge: \"&lt;&lt;endl; int i; for(i=1;i&lt;=N;i++) //默认的字符串是从下标1开始的，这里我们可以让它从0开始 &#123; cin&gt;&gt;c; y[i]=x[i]=c; &#125; x[i]='\\0';y[i]='\\0'; cout&lt;&lt;y&lt;&lt;endl; cout&lt;&lt;\"x=\"&lt;&lt;y&lt;&lt;endl; strReverse(y); //反转字符串 cout&lt;&lt;\"y=\"&lt;&lt;y&lt;&lt;endl; LCS_length(x,y); Print_lcs(x,N,N); return 0;&#125; 实现结果 欧几里德旅行商问题算法分析图 Eucilid_travel.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#define N 7 //确定有几个点？struct travelnode&#123; double x; double y;&#125;T[N];//计算两个点之间的直线距离double distance(travelnode T[],int i,int j) //T[]的下标，第几个数？1,2....N&#123; return sqrt((T[i].x-T[j].x)*(T[i].x-T[j].x)+(T[i].y-T[j].y)*(T[i].y-T[j].y));&#125;double Bitonic_Eucilid(travelnode T[])&#123; double b[N+1][N+1]=&#123;0&#125;; //初始化b[1][2]，注意初始下标从1开始，1,2.....N b[1][2]=distance(T,1,2); for(int j=3;j&lt;=N;j++) &#123; for(int i=1;i&lt;j-1;i++) //注意1&lt;=i&lt;=j-2 &#123; b[i][j]=b[i][j-1]+distance(T,j-1,j); //巡路系统的初始化，递归求解 //length((start-&gt;j-1)+(start-&gt;i)+length(j-1,j)) //即b[i][j]=b[i][j-1]+distance(T,j-1,j) 这里distance(T,j-1,j)封闭了路径 &#125; //注意：这里递归求解所得到的路径，b[i][j]不一定就是最短的欧几里德旅行商 //必须用min()维护旅行商信息 //用min()维护每一条线段[j-1,j]，保证从length(start-&gt;j-1)+length(start-&gt;k)+length(k,j)均是最小的 //如图所示：对每一个线段[j-1,j]的两端进行维护，保证最短的Eucilid巡回，即维护b[j-1][j] //在维护的过程中b[j-1][j]=min(b[k][j-1]+distance(k,j))，封闭了[k,j]就获取了最佳路径 //因为j是在最远端，1&lt;=k&lt;=j-1&lt;j，j-1和k一定在回路的不同方向。由递归求解，已知b[k][j-1] //最后封闭[k,j]即可年少有你 //这一步确定了从start-&gt;i+start-&gt;j的路径，但是巡路并不是封闭的 //最后确定b[j-1][j]，即确定线段[j-1,j]，完成巡路封闭。 //这里b[j-1][j]要保证遍历1&lt;=k&lt;j-1中的最小路径，如图中所示 b[j-1][j]=INFINITY; //对每一条线段[j-1,j]两端维护Eucilid巡回路径性质 for(int k=1;k&lt;j-1;k++) &#123; double q=b[k][j-1]+distance(T,k,j); //最后封闭的线段长度[j-1,j]是固定的 //(start-&gt;j-1)+(start-&gt;k)+length(k,j) //由于1&lt;=k&lt;j-1，k和j-1一定是分居在Eucilid旅行图的线段[j-1,j]的两侧 if(q&lt;b[j-1][j]) b[j-1][j]=q; &#125; &#125; b[N][N]=b[N-1][N]+distance(T,N-1,N); return b[N][N];&#125; Eucilid_travel.cpp12345678910111213#include \"Eucilid_travel.h\"int main()&#123; travelnode T[N+1]=&#123;0&#125;; cout&lt;&lt;\"Input the numbers in order : \"&lt;&lt;endl; for(int i=1;i&lt;=N;i++) &#123; cin&gt;&gt;T[i].x&gt;&gt;T[i].y; &#125; cout&lt;&lt;Bitonic_Eucilid(T)&lt;&lt;endl;&#125; 旅行商的重构解Print函数的递归分析 特别注意： 12if(s&lt;k) print_eucilid(solution,s,val); 或者是：12if(s&gt;k) print_eucilid(solution,val,k); 如图中绿色线条所示：递归的过程，无论是$s-&gt;val$还是$val-&gt;s$，均是由较大坐标的点转向较小坐标的点。二者的区别在于：s&lt;k的时候直接取得val=solution[s][k]的值，先输出val，再递归； 而s&gt;k的时候，则先递归输出顺时针方向其余的点，再输出val=solution[k][s]的值。注意这里是solution[k][s] 当然递归和$val$的输出的先后顺序，取决于你是按顺时针还是逆时针输出。 Eucilid_travel_constitute.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#define N 7 //确定有几个点？struct travelnode&#123; double x; double y;&#125;T[N];//计算两个点之间的直线距离double distance(travelnode T[],int i,int j) //T[]的下标，第几个数？1,2....N&#123; return sqrt((T[i].x-T[j].x)*(T[i].x-T[j].x)+(T[i].y-T[j].y)*(T[i].y-T[j].y));&#125;double Bitonic_Eucilid(travelnode T[],int solution[][N+1])&#123; double b[N+1][N+1]=&#123;0&#125;; //初始化b[1][2]，注意初始下标从1开始，1,2.....N b[1][2]=distance(T,1,2); for(int j=3;j&lt;=N;j++) &#123; for(int i=1;i&lt;j-1;i++) //注意1&lt;=i&lt;=j-2 &#123; b[i][j]=b[i][j-1]+distance(T,j-1,j); //巡路系统的初始化，递归求解 //length((start-&gt;j-1)+(start-&gt;i)+length(j-1,j)) //即b[i][j]=b[i][j-1]+distance(T,j-1,j) 这里distance(T,j-1,j)封闭了路径 solution[i][j]=j-1; &#125; //注意：这里递归求解所得到的路径，b[i][j]不一定就是最短的欧几里德旅行商 //必须用min()维护旅行商信息 //用min()维护每一条线段[j-1,j]，保证从length(start-&gt;j-1)+length(start-&gt;k)+length(k,j)均是最小的 //如图所示：对每一个线段[j-1,j]的两端进行维护，保证最短的Eucilid巡回，即维护b[j-1][j] //在维护的过程中b[j-1][j]=min(b[k][j-1]+distance(k,j))，封闭了[k,j]就获取了最佳路径 //因为j是在最远端，1&lt;=k&lt;=j-1&lt;j，j-1和k一定在回路的不同方向。由递归求解，已知b[k][j-1] //最后封闭[k,j]即可 //这一步确定了从start-&gt;i+start-&gt;j的路径，但是巡路并不是封闭的 //最后确定b[j-1][j]，即确定线段[j-1,j]，完成巡路封闭。 //这里b[j-1][j]要保证遍历1&lt;=k&lt;j-1中的最小路径，如图中所示 b[j-1][j]=INFINITY; //对每一条线段[j-1,j]两端维护Eucilid巡回路径性质 for(int k=1;k&lt;j-1;k++) &#123; double q=b[k][j-1]+distance(T,k,j); //最后封闭的线段长度[j-1,j]是固定的 //(start-&gt;j-1)+(start-&gt;k)+length(k,j) //由于1&lt;=k&lt;j-1，k和j-1一定是分居在Eucilid旅行图的线段[j-1,j]的两侧 if(q&lt;b[j-1][j]) &#123; b[j-1][j]=q; solution[j-1][j]=k; &#125; &#125; &#125; b[N][N]=b[N-1][N]+distance(T,N-1,N); solution[N][N]=N-1; return b[N][N];&#125;void print_eucilid(int solution[][N+1],int s,int k)&#123; if(s&lt;k) &#123; int val=solution[s][k]; cout&lt;&lt;val&lt;&lt;\" \"; if(val&gt;1) print_eucilid(solution,s,val); &#125; else &#123; int val=solution[k][s]; if(val&gt;1) &#123; print_eucilid(solution,val,k); &#125; cout&lt;&lt;val&lt;&lt;\" \"; &#125;&#125; Eucilid_travel_constitute.cpp12345678910111213141516171819202122#include \"Eucilid_travel_constitute.h\"int main()&#123; travelnode T[N+1]=&#123;0&#125;; int solution[N+1][N+1]=&#123;0&#125;; cout&lt;&lt;\"Input the numbers in order : \"&lt;&lt;endl; for(int i=1;i&lt;=N;i++) &#123; cin&gt;&gt;T[i].x&gt;&gt;T[i].y; &#125; cout&lt;&lt;Bitonic_Eucilid(T,solution)&lt;&lt;endl; cout&lt;&lt;\"The Eucilid travel is :\"&lt;&lt;endl; cout&lt;&lt;N&lt;&lt;\" \"; print_eucilid(solution,N-1,N); cout&lt;&lt;N-1&lt;&lt;\" \";&#125; 算法运行结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"最长公共子序列","slug":"20170218","date":"2017-02-18T05:05:00.000Z","updated":"2018-03-02T17:38:14.000Z","comments":true,"path":"2017/02/18/20170218/","link":"","permalink":"https://www.fogsail.net/2017/02/18/20170218/","excerpt":"Biological applications often need to compare the DNA of two (or more) different organisms. A strand of DNA consists of a string of molecules called bases, where the possible bases are adenine, guanine, cytosine, and thymine. Representing each of these bases by its initial letter, we can express a strand of DNA as a string over the ﬁnite set {A,C,G,T}. 这是生物学应用中最为常见的“最长公共子序列问题”。","text":"Biological applications often need to compare the DNA of two (or more) different organisms. A strand of DNA consists of a string of molecules called bases, where the possible bases are adenine, guanine, cytosine, and thymine. Representing each of these bases by its initial letter, we can express a strand of DNA as a string over the ﬁnite set {A,C,G,T}. 这是生物学应用中最为常见的“最长公共子序列问题”。 动态规划原理能够用动态规划解决的问题，通常具有两种属性：第一，存在最优子结构，即可以用“剪切，粘帖”的方法来证明；第二，具有重叠子问题。 递归和穷举算法分析在矩阵链乘法的问题中，可以使用递归和穷举两种方法来解决最优的括号化方案。其中，对每一种方案计算乘法运算次数。 用穷举法的时候，表中的每一个节点都必须访问，记访问一个节点的时间为$b_k$则有递推式：$b_n= \\sum_{k=0}^{n-1}b_kb_{n-1-k}$ 该递推式符合卡特兰数，可以推出通项公式为：$b(n)=\\frac{4^n}{\\sqrt{\\pi}n^{3/2}}(1+O(1/n))$阶是关于n的指数函数。 用Recursive-Matrix-Chain递归求解，递推式符合$T(n)\\geq1+\\sum_{k=1}^{n-1}(T(k)+T(n-k)+1) \\qquad n&gt;1$可以求得递推公式为：$T(n)\\geq2^{n-1}$ 可见朴素递归算法比穷举好一些。 动态规划问题和分治法区别在merge-sort过程中，可以发现，问题不具有重叠字问题的性质，如下图所示，所有的子问题均不重叠。 最大化矩阵括号方案最大化矩阵括号化方案，问题仍然具有最优子结构性质。因为“剪切，粘帖”的处理方式没有变。 假设最大括号化方案能够使结果最优，则其中的划分为：$A_1A_2\\dots \\dots A_kA_{k+1}\\dots A_j$如果该方案不是最优的，总可以找到另外一种方案如下：$A_1A_2\\dots A_iA_{i+1}\\dots \\dots A_j$来替代该方案，使得结果最优。 贪心和动态规划的区别贪心算法的原理是：我们不必计算原问题的最优解，总是可以在求解子问题的时候划分出$A_iA_{i+1}\\dots A_j$，选定的k使得$p_{i-1}p_{k}p_{j}$最小。这样的贪心算法并不能够得到最优解。原因如下： 虽然我们求出来的最优解如红色的图，但很有可能$p_{u-1}p_wp_v&lt;p_{u-1}p_xp_v$ 原因如下：最优解的函数表达式与贪心中的$p_k$函数表达式不同，所以贪心算法并不能够用于最优解问题。 编程验证： 贪心策略如下： 12345678910111213141516171819202122232425262728//下面这是用错误的贪心算法求解的问题：Matrix_Chain Matrix_Chain_Order_greedy(int p[])&#123; int N=n-1; Matrix_Chain T_greedy; for(int i=0;i&lt;N;i++) T_greedy.m[i][i]=0; for(int l=2;l&lt;=N;l++) &#123; for(int i=1;i&lt;=N-l+1;i++) &#123; int j=i+l-1; T_greedy.m[i-1][j-1]=INFINITY; int q_min=INFINITY; for(int k=i;k&lt;=j-1;k++) &#123; int q=T_greedy.m[i-1][k-1]+T_greedy.m[k][j-1]+p[i-1]*p[k]*p[j]; if(q_min&gt;p[i-1]*p[k]*p[j]) &#123; q_min=p[i-1]*p[k]*p[j]; T_greedy.m[i-1][j-1]=q; T_greedy.s[i-1][j-1]=k-1; &#125; &#125; &#125; &#125; return T_greedy;&#125; 结果如图： 很显然地看出，greedy_result得到了不同的括号化结果。 钢条切割问题的限制 如果我们限制，在r=4的时候，只能够切割成两段长度为1的钢条，则r=4的时候，最优切割方案1+1+1+1无法成立。 外币兑换问题该问题可以看成是一种矩阵链乘法的变形，当佣金$C_k$为任意值的时候，并不符合最优子结构的性质。 具体的描述见下图： 合并问题的代价，可以描述为$C_k$ 解决每个问题所需要的代价为$R_k$ 总代价的递推式为：$R_k+C_k$$R_{k2}+C_{k_2}$ 如果$C_k$不为常数，假设它可以用一个$f(k)$描述，则问题的代价可以描述为： $R_k+f(k)$ 动态规划算法只能保证$R_k$的最优解，并不能保证$f(k)$的最优解。 最长公共子序列最长公共子序列的求解，如下图所示： 可以看到，最长公共子序列的依赖关系如上图所示，[i,j]的值取决于{[i-1,j-1],[i,j-1],[i-1,j]} 实现方法如下： LCS_len.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;locale&gt;#define M 6#define N 7wchar_t b[N+1][M+1]=&#123;'S'&#125;; //表示起点startint c[N+1][M+1]=&#123;0&#125;;wchar_t northwest=L'\\\\', up=L'|', leftway=L'-';void LCS_length(char *x,char *y)&#123; for(int i1=0;i1&lt;=N;i1++) b[i1][0]='S'; for(int j1=0;j1&lt;=M;j1++) b[0][j1]='S'; for(int i=1;i&lt;=N;i++) &#123; for(int j=1;j&lt;=M;j++) &#123; if(x[i]==y[j]) &#123; c[i][j]=c[i-1][j-1]+1; b[i][j]=northwest; //Northwest往左上 &#125; else &#123; if(c[i-1][j]&gt;=c[i][j-1]) //c[i-1][j-1] 过渡到 c[i][j]，需要将c[i-1][j]和c[i][j-1]比较大小 //取较大的那一个值 &#123; c[i][j]=c[i-1][j]; b[i][j]=up; //Up往上 &#125; else &#123; c[i][j]=c[i][j-1]; b[i][j]=leftway; //Left往左 &#125; &#125; &#125; &#125;&#125;void Print_lcs(char *x,int i,int j)&#123; if(i==0||j==0) return; if(b[i][j]==northwest) &#123; Print_lcs(x,i-1,j-1); std::cout&lt;&lt;x[i]&lt;&lt;\" \"; //当然，按y[j]输出也没有问题，因为是公共序列嘛！ &#125; else &#123; if(b[i][j]==up) Print_lcs(x,i-1,j); else Print_lcs(x,i,j-1); &#125;&#125; 主函数LCS.cpp 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;locale&gt;#include \"LCS_len.h\"int main()&#123; setlocale(LC_ALL,\"chs\"); char x[N+1]=&#123;'\\0','A','B','C','B','D','A','B'&#125;; char y[M+1]=&#123;'\\0','B','D','C','A','B','A'&#125;; LCS_length(x,y); Print_lcs(x,N,M); std::cout&lt;&lt;std::endl; std::cout&lt;&lt;\"Gene Distance:\"&lt;&lt;std::endl; for(int i=0;i&lt;=N;i++) &#123; for(int j=0;j&lt;=M;j++) &#123; std::wcout&lt;&lt;b[i][j]&lt;&lt;\"\\t\"; &#125; std::cout&lt;&lt;std::endl; for(int j=0;j&lt;=M;j++) &#123; std::cout&lt;&lt;c[i][j]&lt;&lt;\"\\t\"; &#125; std::cout&lt;&lt;std::endl; &#125; system(\"pause\"); return 0;&#125; 实现结果输出 问题解答运行上述代码，可以知道和的一个LCS为： 不使用表b重构LCSlcs_len2.h 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#define M 6#define N 7void lcs_len_withouthelp(char *x, char *y,int c[][M+1])&#123; for(int i=1;i&lt;=N;i++) &#123; for(int j=1;j&lt;=M;j++) &#123; if(x[i]==y[j]) c[i][j]=c[i-1][j-1]+1; else &#123; if(c[i-1][j]&gt;=c[i][j-1]) c[i][j]=c[i-1][j]; else c[i][j]=c[i][j-1]; &#125; &#125; &#125;&#125;void print_LCS_withouthelp(int c[][M+1],char *x,int i,int j)&#123; if(i==0||j==0) return; if(c[i][j]==c[i-1][j-1]+1) &#123; print_LCS_withouthelp(c,x,i-1,j-1); std::cout&lt;&lt;x[i]&lt;&lt;\" \"; &#125; else &#123; if(c[i-1][j]&gt;=c[i][j-1]) print_LCS_withouthelp(c,x,i-1,j); else print_LCS_withouthelp(c,x,i,j-1); &#125;&#125; LCS2.CPP 1234567891011#include &lt;iostream&gt;#include \"lcs_len2.h\"int main()&#123; char x[N+1]=&#123;'\\0','A','B','C','B','D','A','B'&#125;; char y[M+1]=&#123;'\\0','B','D','C','A','B','A'&#125;; int c[N+1][M+1]=&#123;0&#125;; lcs_len_withouthelp(x,y,c); print_LCS_withouthelp(c,x,N,M);&#125; 带备忘的LCS-Length基本思路： 一、初始化1Initialize(c)=&#123;0&#125;; 二、带备忘的值，执行判断1234if(i==0||j==0) c[i][j]=0;else if(c[i][j]&gt;0) return c[i][j]; //带备忘的return,执行输出 实现过程 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;#define M 6#define N 7int Max(int a,int b)&#123; return a&gt;b?a:b;&#125;//数组初始化为0的方法：//只要定义第一个元素为0，后面就劝为0了//int c[N+1][M+1]=&#123;0&#125;int lcs_length(char *x,char *y,int c[][M+1],int i,int j) //这里，i,j指下标，就是第几个数//在递归的时候，从最后一个数，就是第N，M个数算起&#123; if(i==0||j==0) c[i][j]=0; else if(c[i][j]&gt;0) return c[i][j]; else &#123; if(x[i]==y[j]) c[i][j]=lcs_length(x,y,c,i-1,j-1)+1; else c[i][j]=Max(lcs_length(x,y,c,i-1,j),lcs_length(x,y,c,i,j-1)); &#125; return c[i][j];&#125;int main()&#123; char x[N+1] = &#123;'\\0','A','B','C','B','D','A','B'&#125;; char y[M+1] = &#123;'\\0','B','D','C','A','B','A'&#125;; int c[N+1][M+1]=&#123;0&#125;; cout&lt;&lt;lcs_length(x,y,c,N,M);&#125; 2×min(m,n)计算LCS长度实际上，根据c[i][j],c[i-1][j-1],c[i][j-1],c[i-1][j]的依赖关系，可以知道：LCS的值仅仅依赖于两行关系，如下图所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;#define M 8#define N 9//仅有的二维数组：/*用第0行作为上一行，第1行作为当前行，一次循环后，把旧的第1行(当前行)的所有数据转移给新的上一行，而新的当前行用来存储新的当前行数据，这样不断循环，最终得到LCS长度*/void copy(int res[][M+1])&#123; for(int i=0;i&lt;=M;i++) res[0][i]=res[1][i];&#125;void LCS_length_2mn(char *x,char *y)&#123; int res[2][M+1]=&#123;0&#125;; for(int i=1;i&lt;=N;i++) &#123; for(int j=1;j&lt;=M;j++) &#123; if(x[i]==y[j]) res[1][j]=res[0][j-1]+1; else &#123; if(res[0][j]&gt;=res[1][j-1]) res[1][j]=res[0][j]; else res[1][j]=res[1][j-1]; &#125; &#125; copy(res); &#125; cout&lt;&lt;\"first line: \"&lt;&lt;res[0][M]&lt;&lt;endl; cout&lt;&lt;\"second line: \"&lt;&lt;res[1][M]&lt;&lt;endl;&#125;int main() &#123; //char x[N+1] = &#123;'\\0','A','B','C','B','D','A','B'&#125;; //char y[M+1] = &#123;'\\0','B','D','C','A','B','A'&#125;; char x[M+1] = &#123;'\\0','1','0','0','1','0','1','0','1'&#125;; char y[N+1] = &#123;'\\0','0','1','0','1','1','0','1','1','0'&#125;; LCS_length_2mn(x,y); return 0; &#125; 最后输出结果为6，公共子序列为{1，0，1，0，1，1} 最长公共单调递增子序列具体实现方法：1、利用快速排序先将原序列排序。2、然后再计算原序列和已排序序列两者公共子序列。3、打印公共子序列。 LCS_quicksort.h123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;using namespace std;int PARTITION(int A[],int p,int r)&#123; int x=A[r]; int i=p-1; for(int j=p;j&lt;=r-1;j++) &#123; if(A[j]&lt;=x) &#123; i++; swap(A[i],A[j]); &#125; &#125; swap(A[i+1],A[r]); return i+1;&#125;void QUICKSORT(int A[],int p,int r)&#123; if(p&lt;r) &#123; int q=PARTITION(A,p,r); QUICKSORT(A,p,q-1); QUICKSORT(A,q+1,r); &#125;&#125; LCS_len.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;locale&gt;#define M 11#define N 11wchar_t b[N+1][M+1]=&#123;'S'&#125;; //表示起点startint c[N+1][M+1]=&#123;0&#125;;wchar_t northwest=L'\\\\', up=L'|', leftway=L'-';void LCS_length(int *x,int *y)&#123; for(int i1=0;i1&lt;=N;i1++) b[i1][0]='S'; for(int j1=0;j1&lt;=M;j1++) b[0][j1]='S'; for(int i=1;i&lt;=N;i++) &#123; for(int j=1;j&lt;=M;j++) &#123; if(x[i]==y[j]) &#123; c[i][j]=c[i-1][j-1]+1; b[i][j]=northwest; //Northwest往左上 &#125; else &#123; if(c[i-1][j]&gt;=c[i][j-1]) //c[i-1][j-1] 过渡到 c[i][j]，需要将c[i-1][j]和c[i][j-1]比较大小 //取较大的那一个值 &#123; c[i][j]=c[i-1][j]; b[i][j]=up; //Up往上 &#125; else &#123; c[i][j]=c[i][j-1]; b[i][j]=leftway; //Left往左 &#125; &#125; &#125; &#125;&#125;void Print_lcs(int *x,int i,int j)&#123; if(i==0||j==0) return; if(b[i][j]==northwest) &#123; Print_lcs(x,i-1,j-1); std::cout&lt;&lt;x[i]&lt;&lt;\" \"; //当然，按y[j]输出也没有问题，因为是公共序列嘛！ &#125; else &#123; if(b[i][j]==up) Print_lcs(x,i-1,j); else Print_lcs(x,i,j-1); &#125;&#125; LCS_increase.cpp123456789101112131415161718192021222324252627282930313233343536373839#include \"LCS_quicksort.h\"#include \"LCS_len.h\"#include &lt;iostream&gt;#include &lt;locale&gt;#include &lt;cstdlib&gt;int main()&#123; setlocale(LC_ALL,\"chs\"); srand((unsigned)time(NULL)); int x[N+1]=&#123;0&#125;; int y[N+1]=&#123;0&#125;; //一般，第一个位置放0，第二个位置放1 //i的循环，从i=1 to N for(int i=1;i&lt;=N;i++) &#123; y[i]=x[i]=rand()%10+1; std::cout&lt;&lt;x[i]&lt;&lt;\" \"; &#125; std::cout&lt;&lt;std::endl; QUICKSORT(y,0,N); LCS_length(x,y); Print_lcs(x,N,N); std::cout&lt;&lt;std::endl; std::cout&lt;&lt;\"15-8\"&lt;&lt;std::endl; for(int i=0;i&lt;=N;i++) &#123; for(int j=0;j&lt;=N;j++) std::wcout&lt;&lt;b[i][j]&lt;&lt;\"\\t\"; std::cout&lt;&lt;std::endl; for(int j=0;j&lt;=N;j++) std::cout&lt;&lt;c[i][j]&lt;&lt;\"\\t\"; std::cout&lt;&lt;std::endl; &#125; system(\"pause\"); return 0;&#125; 输出结果： 最长公共单调递增子序列的改进可以把算法的运行时间缩短到$O(nlgn)$ 具体的实现方法如下图： 可能常见的错误： bisearch.h1234567891011121314151617181920212223#include &lt;iostream&gt;//使用二分查找寻找合适的位置//要插入的位置，是比该数大的第一个数值int bisearch(int *b,int len,int w)&#123; int left=0,right=len-1; int mid; while(left&lt;=right) &#123; mid=left+(right-mid)/2; if(b[mid]&gt;w) right=mid-1; else if(b[mid]&lt;w) left=mid+1; else return mid; &#125; return left;&#125;//二分查找最后返回的值，是b[mid+1]//当然，如果找不到该值，最后返回的是b[0+1]，或者是b[len+1] LIS.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stdlib.h&gt;#include \"bisearch.h\"#define N 9int B[N];int len; //用来标注数组B中元素的个数struct node&#123; int data; int prev; //存放上一个prev的下标&#125;;int LIS(int *array,node *result,int n)&#123; int len=1; //B[]数组的长度 B[0]=array[0]; int i,pos=0; result[0].data=B[0]; result[0].prev=-1; for(int i=1;i&lt;n;i++) //为什么下标从1开始？ //[i]要和[i-1]比较，然后执行替换，原来array[0]作为初始值 &#123; if(array[i]&gt;B[len-1]) &#123; B[len]=array[i]; result[len].data=array[i]; result[len].prev=len-1; len++; &#125; else &#123; int pos=bisearch(B,len,array[i]); B[pos]=array[i]; result[pos+1].prev=pos; &#125; &#125; return len;&#125;//这里，result提供用于回溯的另一组数值 LCS_increase_imple.cpp123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include \"LIS.h\"using namespace std;#define N 9int main()&#123; int array[N]=&#123;2,1,6,3,5,4,8,7,9&#125;; node *result=new node[N+1]; int cur_len=LIS(array,result,N); cout&lt;&lt;cur_len&lt;&lt;endl; for(int i=0;i&lt;cur_len;i++) &#123; cout&lt;&lt;B[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; cout&lt;&lt;\"wrong answer:\"&lt;&lt;endl; int temp[cur_len]=&#123;0&#125;; int id=cur_len-1; for(int i=cur_len-1;i&gt;=0;i--) &#123; temp[i]=result[id].data; id=result[id].prev; &#125; cout&lt;&lt;temp[0]&lt;&lt;\" \"; for(int i=0;i&lt;cur_len;i++) &#123; if(i&gt;0 &amp;&amp; temp[i]&gt;=temp[i-1]) cout&lt;&lt;temp[i]&lt;&lt;\" \"; &#125; delete[] result; return 0;&#125; 最优二叉搜索树最优二叉搜索树的动态规划由最优二叉搜索树期望搜索代价的递推公式： 因此，若$k_r$为包含关键字$k_i \\cdots k_j$的最优二叉搜索树的根节点，我们的递推公式可以这样理解：$e$作为期望代价，当选定一个新的根节点$k_r$的时候，左右子树的深度均$+1$。 而$w(i,j)=\\sum_{l=i}^{j}p_l+\\sum_{l=i-1}^{j}q_l$ 根据期望的公式可以这么理解：$e[i,j]$为期望代价，指定新的节点作为根节点的时候，所有的节点都必须重新排列。由$(15.11)$公式可知，左右子树节点的深度都$+1$的时候，$E[search \\, cost \\, in \\, T]$增加的值为$w(i,j)=\\sum_{l=i}^{j}p_l+\\sum_{l=i-1}^{j}q_l$。 同时，还要加上根节点的期望$p_r$。 $e[i,j]=p_r+(e[i,r-1]+w(i,r-1))+(e[r+1,j]+w(r+1,j))$$w(i,j)=w(i,r-1)+p_r+w(r+1,j)$ 因此$e[i,j]$可以重写为$e[i,j]=e[i,r-1]+e[r+1,j]+w(i,j)$如果选取期望搜索代价最低的为根节点，可以有递推公式： e[i,j]= \\begin{cases} q_{i-1}& \\text{j=i-1}\\\\ \\min \\limits_{i \\leq r \\leq j} (e[i,r-1]+e[r+1,j]+w(i,j))& \\text{i","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"动态规划概论","slug":"20170202","date":"2017-02-01T17:00:00.000Z","updated":"2018-03-02T17:14:12.000Z","comments":true,"path":"2017/02/02/20170202/","link":"","permalink":"https://www.fogsail.net/2017/02/02/20170202/","excerpt":"动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。","text":"动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。 钢条切割问题算法运行时间分析如果采用最平凡的递推算法，由$r_n= \\underset{1 \\leq i \\leq n}{\\max} (p_i+r_{n-i})$令$T(n)$表示算法第二个参数值为n的时候CUT-ROD的调用次数，可以推出：$T(n)=1+ \\sum_{j=0}^{n-1}T(j)$ $T(n)=1+T(1)+T(2)+\\cdots+T(n-1)$$T(n-1)=1+T(1)+T(2)+\\cdots+T(n-2)$ 即$T(n)=2+2T(1)+\\cdots+2T(n-2)=2T(n-1)$ $\\frac{T(n)}{T(n-1)}=2$ 由等比数列的递推公式，$T(n)=2^n$所以，平凡的递归算法反复求解相同的子问题，耗费了大量的时间。 使用动态规划 求解子问题的两种方法：使用memorized_cut_rod方法的时候，memorized_cut_rod_aux(p,n,r)的递归，最多递归到r[]的下标为n-1，因为在循环中执行的是for(int i=0;i&lt;n;i++) 使用自底向上递归求解。 由上图所示，在递归过程中：1234567891011121314151617r[0]=0;for(int j=0;j&lt;n;j++)&#123; int result=-INFINITY; for(int i=0;i&lt;=j;i++) &#123; //获取scale=j时候的max值，即最大收益result //随着j++，我们获取最大收益的时候要返回r[j+1]的值，这样 //scale=scale+1时候的最大收益，即r[j+1]，即为上一步求出的 //result值，即r[j+1]=result result=max(result,p[i]+r[j-1]); &#125; r[j+1]=result;&#125;return r[n];//返回的r[n]这里的n指问题的规模 算法实现过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#define INFINITY 0x7fffffffusing namespace std;int max(int a,int b)&#123; return a&gt;b?a:b;&#125;int memorized_cut_rod_aux(int p[],int n,int r) //n表示问题的规模&#123; //注意，这里p[i]的意义和r[i]的意义不一样 //p[i]表示对应的数组元素，i表示下标 //r[i]表示问题的规模为i所对应的解 //p[i]对应的问题是第i个，其规模为i+1，剩余的问题规模是n-(i+1) //从另一个角度，0&lt;=i&lt;=n-1 0&lt;=r&lt;=n-1，所以递归的时候是(p,n-1-i,r) int result; if(r[n]&gt;=0) return r[n]; //表示问题已经被求解完毕了，返回该值 if(n==0) result=0; //表示没有切割 else &#123; result=-INFINITY; for(int i=0;i&lt;n;i++) &#123; result=max(result,p[i]+memorized_cut_rod_aux(p,n-1-i,r)); &#125; &#125; //表示规模为n的问题求解完毕 r[n]=result; return result;&#125;int memorized_cut_rod(int p[],int n)&#123; int *r=new int[n]; for(int i=0;i&lt;n;i++) &#123; r[i]=-INFINITY; &#125; return memorized_cut_rod_aux(p,n,r); //这里(p,n,r) //r[]的递归标最多为n-1&#125;int BOTTOM_UP_CUT_ROD(int p[],int n)&#123; int *r=new int [n]; r[0]=0; for(int j=0;j&lt;n;j++) &#123; int result=-INFINITY; for(int i=0;i&lt;=j;i++) &#123; //获取scale=j时候的max值，即最大收益result //随着j++，我们获取最大收益的时候要返回r[j+1]的值，这样 //scale=scale+1时候的最大收益，即r[j+1]，即为上一步求出的 //result值，即r[j+1]=result result=max(result,p[i]+r[j-1]); &#125; r[j+1]=result; &#125; return r[n]; //返回的r[n]这里的n指问题的规模&#125; 主函数：1234567int main()&#123; const int n=10; int p[10]=&#123;1,5,8,9,10,17,17,20,24,30&#125;; cout&lt;&lt;memorized_cut_rod(p,9)&lt;&lt;endl; cout&lt;&lt;BOTTOM_UP_CUT_ROD(p,9)&lt;&lt;endl;&#125; 子问题图与重构解这里特别说明一种表示方式1array *EXTENDED_BOTTOM_UP_CUT_ROD(int p[],int n) 这里p[]表示指向数组第一个元素的指针，注意区分以下两种表示方法：当表示第n个元素的时候12*(p+n)-&gt;elementp[n].element 这两种表示方式不同，一种是指针，一种是结构体表示。 具体的说明见下图： 动态规划解决钢条切割问题，问题的输出：注意让规模逐渐减小。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;#define INFINITY 0x7fffffffstruct rod&#123; int result; //代表最大收益 int solution; //代表切割方案&#125;;rod *EXTENDED_BOTTOM_UP_CUT_ROD(int p[], int n)&#123; rod *res=new rod[n]; res[0].result=0; //初始化，钢条规模为0，收益为0 int q; for(int j=0;j&lt;n;j++) &#123; q=-INFINITY; for(int i=0;i&lt;=j;i++) &#123; if(q&lt;p[i]+res[j-i].result) &#123; q=p[i]+res[j-i].result; res[j+1].solution=i+1; //保存切割方式 &#125; //这里的i表示切割下来的片段，规模有多大？ &#125; //此时已经完成了从1---j的循环 res[j+1].result=q; &#125; return res+n; //注意：这里res表示指向第一个元素的指针&#125;//res+n表示指针移动n位，新的指针指向n之后的那个位置//rod *res=new rod[n] res[i].result (res+i)-&gt;result//两种用法注意区分//特别注意：这里res[0].result=0 最后res[j+1].result//res[j+1].solution，意味这res[]的存储范围如下：//res[1]，res[2],......,res[n]//res初始指针位置为res[0]，res末指针的位置为res[n]void PRINT_CUT_ROD_SOLUTION(int p[], int n)&#123; rod *res=EXTENDED_BOTTOM_UP_CUT_ROD(p,n); //注意这里函数的返回值为res+n，即最后一个数组元素的地址 while(n&gt;0) &#123; cout&lt;&lt;(*res).solution&lt;&lt;\" \"; n=n-(*res).solution; //注意返回的res指的是res[n]的位置 //返回的是规模为n时候的切割方法,从最大规模往最小规模输出 //这里从大规模往小规模输出，指针也要调整 //从规模为n的位置逐渐减小到i，再逐渐减小到1，0 res=res-(*res).solution; &#125;&#125;void main()&#123; const int n=10; int p[10]=&#123;1,5,8,9,10,17,17,20,24,30&#125;; cout&lt;&lt;(*EXTENDED_BOTTOM_UP_CUT_ROD(p,4)).result&lt;&lt;endl; PRINT_CUT_ROD_SOLUTION(p,4);&#125; 其他问题15.1-2 反例如下图： 15.1-3 钢条切割的时候考虑固定成本为c 特别注意，这里的固定成本为c，在执行循环的时候，存在表达式的不同！ 1234567891011121314151617181920212223242526272829303132333435//当j==i的时候有不同！for(int j=0;j&lt;n;j++)&#123; //省略的code for(int i=0;i&lt;j;i++) &#123; //i&lt;j时候表示钢条一定会进行切割！ if(q&lt;=p[i]+res[j-i].result-c) &#123; q=p[i]+res[j-i].result-c; res[j+1].solution=i+1; cut_or_not=true; //表示进行切割了 &#125; &#125; //当i==j时候的情况不一样了！ //此时已经保存的最大收益是q //很有可能 //p[i]+res[j-i].result-c&lt;q&lt;=p[i]+res[j-i].result //这个时候j==i可能没有发生切割，没有发生切割和发生切割 //收益的表达式不同，一个减去成本，一个没有 if(j==i) &#123; if(q&lt;=p[i]+res[j-i].result &amp;&amp; cut_or_not==false) &#123; res[j+1].solution=i+1; &#125; &#125; //j求解完毕 res[j+1].result=q;&#125;return res+n; 具体实现的过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;#define INFINITY -0x7fffffff#define cost 2int max(int a, int b)&#123; return a&gt;b?a:b;&#125;struct rod_cost&#123; int result; int solution; bool cut_or_not;&#125;;rod_cost *EXTENDED_BOTTOM_UP_CUT_ROD(int p[], int n)&#123; rod_cost *res=new rod_cost[n]; res[0].result=0; int q; for(int j=0;j&lt;n;j++) &#123; q=-INFINITY; bool cut_or_not=false; for(int i=0;i&lt;j;i++) &#123; if(q&lt;=p[i]+res[j-i].result-cost) &#123; q=p[i]+res[j-i].result-cost; res[j+1].solution=i+1; cut_or_not=true; &#125; &#125; //每一次循环，j=0----j=n-1，表示问题的规模从1---n //每一个规模，cut_or_not都初始化为false，最后看是否切割？ //如果发生了切割，在i的循环中，也就是j的子问题中 //让cut_or_not=true，最后判断是否切割？ if(j==i) &#123; if(q&lt;=p[i]+res[j-i].result &amp;&amp; cut_or_not==false) &#123; res[j+1].solution=i+1; &#125; &#125; //求解完毕 res[j+1].result=q; &#125; return res+n;&#125;void PRINT_CUT_ROD_SOLUTION(int p[], int n)&#123; rod_cost *res=EXTENDED_BOTTOM_UP_CUT_ROD(p,n); while(n) &#123; cout&lt;&lt;(*res).solution&lt;&lt;\" \"； n=n-(*res).solution; res=res-(*res).solution; &#125;&#125;void main()&#123; const int n=10; int p[10]=&#123;1,5,8,9,10,17,17,20,24,30&#125;; cout&lt;&lt;(*EXTENDED_BOTTOM_UP_CUT_ROD(p,10)).result&lt;&lt;endl; PRINT_CUT_ROD_SOLUTION(p,10);&#125; 15.1-4修改memorized_cut_rod，使之返回最优收益值和切割方案 实现函数如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;using namespace std;#define INFINITY 0x7fffffffstruct rod&#123; int result; int solution;&#125;;int max(int a, int b)&#123; return a&gt;b?a:b;&#125;rod *memorized_cut_rod_aux(int p[], int n, rod res[])&#123; int q; if(res[n].result&gt;=0) return res+n; if(n==0) q=0; //规模为0的时候，自然收益为0 else &#123; q=-INFINITY; for(int i=0;i&lt;n;i++) &#123; //会犯错误的地方： //这里不能够直接写 //q=max(q,p[i]+(memorized_cut_rod(p,n-1-i,res))-&gt;solution) //因为还要进行储存切割方案，在子问题规模为i+1的时候，有可能进行切割，也有可能不切割 int tmp=p[i]+memorized_cut_rod_aux(p,n-1-i,res)-&gt;solution; //在p[i]处的最优方案是tmp，tmp和q进行比较判断后，推出在i+1处的最优方案 //这里把n分解成更小的子问题，怎么解决？通过递归解决 //memorized_cut_rod_aux(p,n-1-i,res)把n-1的子问题转化为n-1-i if(q&lt;tmp) &#123; q=tmp; res[n].solution=i+1; //我们这里返回的就是问题规模为n时候的切割方案，这里的切割方案是： //切割一次or无切割！ //i&lt;n-1时候，q=tmp表示切割 //i==n-1的时候，tmp=p[n-1]+memorized_cut_rod(p,0,res)-&gt;solution //如果此时还满足q&lt;tmp，res[n].solution=n-1+1=n，表示无切割 //这一步的目的在于保存每一个循环过程中i的最优方案 &#125; &#125; &#125; res[n].result=q; return res+n;&#125;rod *memorized_cut_rod(int p[], int n)&#123; rod *res=new rod[n]; for(int i=0;i&lt;=n;i++) &#123; res[i].result=-INFINITY; &#125; return memorized_cut_rod_aux(p,n,res);&#125;void PRINT_CUT_ROD_SOLUTION(int p[], int n)&#123; rod *res=memorized_cut_rod(p,n); cout&lt;&lt;\"max result\"&lt;&lt;res-&gt;result&lt;&lt;endl; cout&lt;&lt;\"solution: \"&lt;&lt;endl; while(n) &#123; cout&lt;&lt;(*res).solution&lt;&lt;\" \"; n=n-(*res).solution; res=res-(*res).solution; &#125;&#125;//重点：在于区分数组下标和子问题的规模，数组下标为i-1，子问题的规模为ivoid main()&#123; const int n=10; int p[10]=&#123;1,5,8,9,10,17,17,20,24,30&#125;; PRINT_CUT_ROD_SOLUTION(p,10); cout&lt;&lt;endl;&#125; 15.1-5斐波那契数列 子问题图： 实现方法： 12345678910111213141516#include &lt;iostream&gt;using namespace std;int fibonacci(int array[],int n)&#123; if(n&gt;=0) array[0]=0; if(n&gt;=1) array[1]=1; for(int i=2;i&lt;n;i++) &#123; array[i]=array[i-1]+array[i-2]; &#125; return array[n];&#125; 特别说明： 1234567891011for(int j=0;j&lt;n;j++)&#123; //code for(int i=0;i&lt;=j;i++) &#123; q=max(q,p[i]+r[j-i]); &#125; r[j]=q; //这样写也是可\\ \\;\\;以的&#125;return r[n-1]; //只是返回值会不一样 矩阵链乘法矩阵规模序列 $A1 \\qquad\\ \\;\\;|A2 \\qquad\\ \\;\\;|A3 \\qquad\\ \\;\\;|$$\\underline{10}\\times100\\;\\;|100\\times5\\;\\;\\;|\\underline{5\\times50}\\quad\\;\\;\\,|$ $A1A2 \\qquad\\times A3=10\\times5\\times50$ 由此可以推出：$A_{i \\ldots k} \\qquad \\qquad \\times \\qquad \\qquad A_{k+1 \\ldots j}$$=\\underline{p_{i-1}} \\times p_i \\times p_{i+1} \\times \\qquad\\quad \\underline{p_k} \\times p_{k+1}\\times\\underline{p_j}$$=p_{i-1} \\times p_k \\times p_j$ 由矩阵规模序列推出矩阵链乘法，如上图所示，相乘的代价是：把有下划线的项相乘的值。可以得到递推式如下： m[i,j]= \\begin{cases} 0& \\text{i=j}\\\\ min(m[i,k]+m[k+1,j]+p_{i-1}p_kp_j)& \\text{i","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"约瑟夫环","slug":"20170130","date":"2017-01-29T21:27:00.000Z","updated":"2018-03-02T17:06:28.000Z","comments":true,"path":"2017/01/30/20170130/","link":"","permalink":"https://www.fogsail.net/2017/01/30/20170130/","excerpt":"Josephus问题的定义如下：假设n个人排成环形，且有以正整数m&lt;=n。从某个制定的人开始，沿环报数，每遇到第m个人就让其出列，且报数进行下去。这个过程一直进行到所有人都出列为止。每个人出列的次序定义了整数1，2，…，n的(n, m)-Josephus排列。例如，(7,3)-Josephus排列为。 a)假设m为整数。请描述一个O(n)时间的算法，使之对给定的整数n，输出(n, m)-Josephus排列。b)假设m不是个常数。请描述一个O(nlgn)时间的算法，使给定的整数n和m，输出(n, m)-Josephus排列。","text":"Josephus问题的定义如下：假设n个人排成环形，且有以正整数m&lt;=n。从某个制定的人开始，沿环报数，每遇到第m个人就让其出列，且报数进行下去。这个过程一直进行到所有人都出列为止。每个人出列的次序定义了整数1，2，…，n的(n, m)-Josephus排列。例如，(7,3)-Josephus排列为。 a)假设m为整数。请描述一个O(n)时间的算法，使之对给定的整数n，输出(n, m)-Josephus排列。b)假设m不是个常数。请描述一个O(nlgn)时间的算法，使给定的整数n和m，输出(n, m)-Josephus排列。 递归求解约瑟夫环约瑟夫序列从0,1,2…..,N-1中报数为M-1的出列，从M开始又重新从1开始报数，这可以用典型的递归来求解，递归的具体过程如下图所示： 不妨用$f(i)$表示问题规模$size=i$的时候，数的下标的排列，值得注意的是，从$size=i$问题规模递减为$size=i-1$的时候，同一个数的下标发生变化，其实是对应函数的映射，不妨用$f(i)$表示这种映射。 如上图所示，在Josephus排列中，满足$f(i)=(f(i-1)+k)\\ mod\\ i$ 根据这种算法，可以使用递归求解： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; int N; int M; cin&gt;&gt;N; cin&gt;&gt;M; int result=0; for(int i=2; i&lt;=N;i++) result=(result+M)%i; //值得注意的是，这里的i表示规模，递推关系 //表示从i递推到i-1，问题规模数组大小 //最小就为1，所以i的初值为2 std::cout &lt;&lt; \"最后输出的元素是\" &lt;&lt;result+1&lt;&lt;endl; return 0;&#125; 递归算法的局限性：用这样的递归算法，无法获得一个Josephus的(n,m)排列，我们只知道最后一个出队的人，在初始时候的下标，并不知道所有的人，分别什么时候出队。 使用循环链表输出不删除结点的时候，我们需要给每一个节点加上status属性，判断这个结点是否已经处理过？或者就采用最普通的删除结点的方式来处理。每当完成报数的时候，删除节点让报数的人退出Josephus环。 这里给出两种实现函数，XXX_stus用status属性判断是否出队，但不删除节点，不带_stus的函数每隔m删除一个人。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;iostream&gt;using namespace std;#define n 30#define m 3#define LEN sizeof(struct circular_list)#define LEN_status sizeof(struct circular_list_status)struct circular_list&#123; int key; //存储数据 circular_list *next;&#125;;struct circular_list_status&#123; int key; bool status; //用来存储该节点的状态，出队没有？ circular_list_status *next; circular_list(int k,circular_list *init):key(k),status(TRUE),next(init)&#123;&#125;&#125;;struct circular_list *tail=NULL;struct circular_list_status *tail_status=NULL;circular_list *insert(circular_list *head, int k)&#123; circular_list *z=new circular_list[LEN]; z-&gt;key=k; if(head==NULL) &#123; head=tail=z; head-&gt;next=tail; //自循环 &#125; else &#123; //插入表尾 tail-&gt;next=z; z-&gt;next=head; tail=z; &#125; return head;&#125;circular_list_status *insert_stus(circular_list_status *head,int k)&#123; circular_list_status *z=new circular_list_status[LEN_status]; z-&gt;key=k; z-&gt;status=TRUE; if(head==NULL) &#123; head=tail=z; head-&gt;next=tail; //自循环 &#125; else &#123; //插入表尾 tail-&gt;next=z; z-&gt;next=head; tail=z; &#125; return head;&#125;circular_list *delete(circular_list *head, circular_list *z)&#123; circular_list *p=head; //先是要寻找到z这个结点的位置 while(p-&gt;next!=z) //要删除的是p-&gt;next这个节点 p=p-&gt;next; if(head==tail) p-&gt;next=NULL; else &#123; if(p-&gt;next==head) head=p-&gt;next-&gt;next; else if(p-&gt;next==tail) tail=p; p-&gt;next=p-&gt;next-&gt;next; &#125; return p-&gt;next;&#125;circular_list_status *delete_stus(circular_list_status *head, circular_list_status *z)&#123; circular_list_status *p=head; while(p-&gt;next!=z) //要删除的是p-&gt;next这个节点 p=p-&gt;next; if(head==tail) p-&gt;next=NULL; else &#123; if(p-&gt;next==head) head=p-&gt;next-&gt;next; else if(p-&gt;next==tail) tail=p; p-&gt;next=p-&gt;next-&gt;next; &#125; return p-&gt;next; //返回的值，是更新后的p-&gt;next&#125;void Josephus_n_m(circular_list_status *head, int n,int m)&#123; struct circular_list_status *p=head; //p作为遍历指针 int count=0; while(p &amp;&amp; count&lt;=n) &#123; int i=0; while(i!=m-1) &#123; if(p-&gt;status==TRUE) &#123; p=p-&gt;next; i++; &#125; else p=p-&gt;next; &#125; //循环到最后，i报数报M-1 p-&gt;status=false; count++; p=p-&gt;next; &#125;&#125;void Josephus_link_imple(circular_list *head,int m)&#123; circular_list *p=head; while(p) &#123; int i=0; while(i!=m-1) &#123; p=p-&gt;next; i++; &#125; circular_list *z=p; cout&lt;&lt;z-&gt;key&lt;&lt;\" \"; p=delete(head,z); &#125;&#125;int main()&#123; int a[n]=&#123;0&#125; for(int i=0;i&lt;n;i++) a[i]=i+1; int j=0; circular_list *head=NULL; while(j!=n) &#123; head=insert(head,a[j]); j++; &#125; circular_list *p=head; do &#123; cout&lt;&lt;p-&gt;key; p=p-&gt;next; /* code */ &#125; while(p!=head); cout&lt;&lt;endl; Josephus_link_imple(head,m);&#125; 算法分析：时间复杂度是$O(mn)=O(n)$ 是两个循环的嵌套，在m值不大的情况下可以使用该算法实现。 使用顺序统计树实现假设m不是一个常数，用$O(nlgn)$的算法实现 这里采用顺序统计树来存储Josephus环中的点，通过映射关系查找每次需要删除的节点的坐标并执行删除。映射关系如下图所示： 相关的递推表示为： t=1k=(t+m-1)\\ mod\\ it=k主要的实现函数12345678910111213141516171819202122232425void Josephus_imple(os_tree *T, int m, int n)&#123; os_node *x=T-&gt;root; int k=0, i=n; int t=1; while(T-&gt;root!=NULL &amp;&amp; i&gt;0) &#123; k=(t+m-1)%i; //k就是我们需要删除的点，注意到我们对一个点执行删除之后 //这个点原来的下标是k，删除了之后k+1就自动补到k的位置上 //这样新的k重新编号的话就是1，相当于原来的t=1 if(k==0) k=i; os_node *del=os_select(T,k); //这里del表示要删除的结点 cout&lt;&lt;del-&gt;key&lt;&lt;\" \"; //输出节点 RB_delete(del); t=k; i--; &#125;&#125; 这里采用的数据结构是一种顺序统计量，能够计算出rank值。但值得注意的是，在顺序统计量中，计算一个节点的rank值的函数的写法： 1234567891011121314151617int Interative_os_rank(os_tree *T,os_node *x)//确定x这个节点的顺序统计树的rank&#123; int r=x-&gt;left-&gt;size+1; os_node *y=x; //沿左脊柱上升，r=x-&gt;left-&gt;size+1 while(y!=T-&gt;root) //如果是沿着右脊柱上升？y-&gt;size=y-&gt;left-&gt;size+1+sum&#123;y-&gt;parent-&gt;size&#125; &#123; //沿左脊柱上升，r保持不变；一旦拐弯到了右脊柱，要关注y-&gt;parent-&gt;left-&gt;size+1 if(y==y-&gt;parent-&gt;right) r=r+y-&gt;parent-&gt;left-&gt;size+1; y=y-&gt;parent; //不管是左脊柱还是右脊柱，都要沿树上升 &#125; return r;&#125; 特别说明，当函数沿左脊柱上升的时候，r的值是r=x-&gt;left-&gt;size+1,但是，沿右脊柱，情形就变成了r=r+y-&gt;parent-&gt;left-&gt;size+1，具体的说明请看下图： ** $O(lgn)$算法的实现os_tree.h123456789101112131415161718192021222324252627282930#define RED 0#define BLACK 1#define NIL -1#define LEN sizeof(struct os_node)#define LENTREE sizeof(struct os_tree)struct os_node&#123; os_node *left; os_node *right; os_node *parent; int key; int color; int size; //用于顺序统计量 os_node(os_node *init,int num) :left(init),right(init),parent(init),key(num),color(RED),size(0)&#123;&#125;&#125;;struct os_tree&#123; os_node *root; os_node *nil; os_tree() &#123; nil=new os_node(NULL,NIL); root=nil; &#125;&#125;; rotate.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include \"os_tree.h\"void left_rotate(os_tree *T,os_node *x)&#123; os_node *y=x-&gt;right; //左孩子结点 x-&gt;right=y-&gt;left; //这一部处理的是加在x，y之间的“内结点”，y-&gt;left原先 //夹在x-&gt;left和y-&gt;right之间，旋转之后子树的相对顺序不变，最外边的结点是 //x-&gt;left和y-&gt;right，注意是围绕x和y进行的旋转，所以子树的相对位置保持不变 if(y!=T-&gt;nil &amp;&amp; y-&gt;left!=T-&gt;nil) y-&gt;left-&gt;parent=x; //旋转之后需要重新更新parent结点信息 y-&gt;parent=x-&gt;parent; //这个时候y作为子树的根了，y要连到祖先中！ if(x-&gt;parent==T-&gt;nil) T-&gt;root=y; else if(x-&gt;parent-&gt;left==x) x-&gt;parent-&gt;left=y; else x-&gt;parent-&gt;right=y; //保证x与祖先结点相连接 //最后处理x和y的关系 y-&gt;left=x; x-&gt;parent=y; //顺序统计树新增部分 y-&gt;size=x-&gt;size; //旋转之后，y代替原来x的位置，而x的位置在树的高处 //直接将原来x的size值赋值给y就可以了 x-&gt;size=x-&gt;left-&gt;size+x-&gt;right-&gt;size+1;&#125;//右旋，对称的代码void right_rotate(os_tree *T,os_node *x)&#123; //只需要把上述代码的相对位置，right和left互换就可以了 os_node *y=x-&gt;left; x-&gt;left=y-&gt;right; if(y!=T-&gt;nil &amp;&amp; y-&gt;right!=T-&gt;nil) y-&gt;right-&gt;parent=x; //旋转之后需要重新更新parent结点信息 y-&gt;parent=x-&gt;parent; if(x-&gt;parent==T-&gt;nil) T-&gt;root=y; else if(x-&gt;parent-&gt;left==x) x-&gt;parent-&gt;left=y; else x-&gt;parent-&gt;right=y; //保证x与祖先结点相连接 //最后处理x和y的关系 y-&gt;right=x; x-&gt;parent=y; y-&gt;size=x-&gt;size; x-&gt;size=x&gt;left-&gt;size+x-&gt;right-&gt;size;&#125; delete.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include \"os_tree.h\"#include \"rotate.h\"#include \"succ_and_other.h\"//删除调整，这个时候x有两重黑色void RB_delete_fixup(os_tree *T, os_node *x)&#123; os_node *w=T-&gt;nil; while (x!=T-&gt;root &amp;&amp; x-&gt;color==BLACK) &#123; if(x==x-&gt;parent-&gt;left) &#123; w=x-&gt;parent-&gt;right; //w为x的兄弟结点 if(w-&gt;color==RED) &#123; w-&gt;color=BLACK; //将这种情况划归为下面一种情况 w-&gt;parent-&gt;color=RED; left_rotate(T,x-&gt;parent); w=x-&gt;parent-&gt;right; &#125; if(w-&gt;left-&gt;color==BLACK &amp;&amp; w-&gt;right-&gt;color==BLACK) &#123; w-&gt;color=RED; x=x-&gt;parent; //x和w的黑色沿树上升，注意到x有双重黑色，所以x的颜色不变 &#125; //变得是w，x-&gt;parent的颜色 else &#123; if(w-&gt;right-&gt;color==BLACK) &#123; w-&gt;left-&gt;color=BLACK; w-&gt;color=RED; //同样，内节点变为外节点 right_rotate(T,w); w=x-&gt;parent-&gt;right; &#125; w-&gt;color=x-&gt;parent-&gt;color; //这里x-&gt;parent的颜色不确定，但是w的颜色是黑色 //x有双重黑色，通过改变颜色加上旋转，可以将双重黑色表现在图中，这样完成了红黑树的局部平衡 x-&gt;parent-&gt;color=BLACK; w-&gt;right-&gt;color=BLACK; left_rotate(T,x-&gt;parent); //红黑树局部平衡了 x=T-&gt;root; &#125; &#125; else &#123; w=x-&gt;parent-&gt;left; if(w-&gt;color==RED) &#123; w-&gt;color=BLACK; x-&gt;parent-&gt;color=RED; right_rotate(T,x-&gt;parent); w=x-&gt;parent-&gt;left; &#125; &#125; if(w-&gt;left-&gt;color==BLACK &amp;&amp; w-&gt;right-&gt;color==BLACK) &#123; w-&gt;color=RED; x=x-&gt;parent; &#125; else &#123; if(w-&gt;left-&gt;color==BLACK) &#123; w-&gt;right-&gt;color=BLACK; w-&gt;color=RED; left_rotate(T,w); w=x-&gt;parent-&gt;left; &#125; w-&gt;color=x-&gt;parent-&gt;color; x-&gt;parent-&gt;color=BLACK; w-&gt;left-&gt;color=BLACK; right_rotate(T,x-&gt;parent); x=T-&gt;root; &#125; &#125; x-&gt;color=BLACK;&#125;void transplant(os_tree *T, os_node *u, os_node *v)&#123; if(u-&gt;parent==T-&gt;nil) T-&gt;root=v; else if(u==u-&gt;parent-&gt;left) u-&gt;parent-&gt;left=v; else u-&gt;parent-&gt;right=v; if(v!=T-&gt;nil) v-&gt;parent=u-&gt;parent;&#125;void RB_delete(os_tree *T, os_node *z)&#123; os_node *y=z, *x; int y_original_color=y-&gt;color; os_node *par=z-&gt;parent; //par作为被删除节点的双亲 if(z-&gt;left==T-&gt;nil) &#123; //删除一个节点的时候，size会发生变化 while(par!=T-&gt;nil) &#123; //删除节点后，z的双亲的size值会减小 par-&gt;size--; par=par-&gt;parent; //自底向上遍历，所有的节点的size都减小 &#125; x=z-&gt;right; transplant(T,z,z-&gt;right); &#125; else if(z-&gt;right==T-&gt;nil) &#123; while(par!=T-&gt;nil) &#123; //删除节点后，z的双亲的size值会减小 par-&gt;size--; par=par-&gt;parent; //自底向上遍历，所有的节点的size都减小 &#125; x=z-&gt;left; transplant(T,z,z-&gt;left); &#125; else &#123; y=tree_minimum(T,z-&gt;right); //这里是查找z的后继，为y，用y来代替z的位置 y_original_color=y-&gt;color; os_node *par=y-&gt;parent; //这里用y嫁接到z处，原先y位置往上所有的节点相当于 //少了一个y结点，所以par往上遍历的过程中所有的size都为size-- //特别地，当用y来代替z的时候，并不是y-&gt;size=z-&gt;size //因为子树中少了一个y，所以size-1 //特别注意，实际上，从y结点到z节点之间的节点，少了一个y //从z节点往上，少了一个z，由于size结点是不包括当前节点的 //所以y-&gt;size=z-&gt;size-1 /*y-&gt;size=z-&gt;size-1; while(par!=T-&gt;nil) &#123; //删除节点后，z的双亲的size值会减小 par-&gt;size--; par=par-&gt;parent; //自底向上遍历，所有的节点的size都减小 &#125;*/ //还有一种方法：完成transplant之后自底向上调整！ x=y-&gt;right; if(y-&gt;parent==z) &#123; x-&gt;parent=y; &#125; else &#123; transplant(T,y,y-&gt;right); y-&gt;right=z-&gt;right; y-&gt;right-&gt;parent=y; &#125; transplant(T,z,y); y-&gt;left=z-&gt;left; y-&gt;left-&gt;parent=y; y-&gt;color=z-&gt;color; //这里进行size属性的维护 while(par!=T-&gt;nil) &#123; //删除节点后，z的双亲的size值会减小 par-&gt;size--; par=par-&gt;parent; //自底向上遍历，所有的节点的size都减小 &#125; &#125; if(y_original_color==BLACK) RB_delete_fixup(T,x); //x为y的孩子结点，y的删除会影响x的相关性质&#125; insert.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include \"os_tree.h\"#include \"rotate.h\"void RB_insert_fixup(os_tree *T, os_node *z);void RB_insert(os_tree *T, os_node *z)&#123; os_node *y=T-&gt;nil; //y作为遍历指针的双亲 RB_node *x=T-&gt;root; while(x!=T-&gt;nil) &#123; y=x; if(z-&gt;key&lt;x-&gt;key) x-&gt;x-&gt;left; else x=x-&gt;right; &#125; z-&gt;parent=y; //y作为遍历指针x的母结点，x遍历寻找合适的插入位置 if(y==T-&gt;nil) T-&gt;root=z; else if(z-&gt;key&lt;y-&gt;key) y-&gt;left=z; else y-&gt;right=z; z-&gt;left=T-&gt;nil; z-&gt;right=T-&gt;nil; z-&gt;parent=RED; //新插入节点的信息 z-&gt;size=1; z-&gt;left-&gt;size=0; z-&gt;right-&gt;size=0; RB_insert_fixup(T,z); //最后插入的结点是红色的，与此同时进行红黑树性质的调整&#125;void RB_insert_fixup(os_tree *T,os_node *z)&#123; while(z-&gt;parent-&gt;color==RED) &#123; if(z-&gt;parent==z-&gt;parent-&gt;parent-&gt;left) &#123; os_node *y=z-&gt;parent-&gt;parent-&gt;right; //设置叔结点 if(y-&gt;color==RED) &#123; z-&gt;parent-&gt;color=BLACK; //父节点的黑色可以下放给两个结点 y-&gt;color=BLACK; z-&gt;parent-&gt;parent-&gt;color=RED; z=z-&gt;parent-&gt;parent; //z沿树上升 &#125; else &#123; if(z==z-&gt;parent-&gt;right) //内结点先旋转成外节点 &#123; z=z-&gt;parent; left_rotate(T,z); &#125; z-&gt;parent-&gt;color=BLACK; //改变颜色之后，z的兄弟结点和z颜色相同 z-&gt;parent-&gt;parent-&gt;color=RED; //红黑树局部恢复平衡 right_rotate(T,z-&gt;parent-&gt;parent); //这个技巧是：改变颜色之后，然后旋转，这样不破坏红黑树性质 &#125; //与此同时，结点沿树上升 &#125; else &#123; os_node *y=z-&gt;parent-&gt;parent-&gt;left; if(y-&gt;color==RED) &#123; z-&gt;parent-&gt;color=BLACK; y-&gt;color=BLACK; z-&gt;parent-&gt;parent-&gt;color=RED; z=z-&gt;parent-&gt;parent; &#125; else &#123; if(z==z-&gt;parent-&gt;left) &#123; z=z-&gt;parent; right_rotate(T,z); &#125; z-&gt;parent-&gt;color=BLACK; z-&gt;parent-&gt;parent-&gt;color=RED; left_rotate(T,z-&gt;parent-&gt;parent); &#125; &#125; &#125; T-&gt;root-&gt;color=BLACK;&#125; succ_and_other.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include \"os_tree.h\"os_node *tree_maxinum(os_tree *T, os_node *x)&#123; while(x!=T-&gt;nil &amp;&amp; x-&gt;right!=T-&gt;nil) x=x-&gt;right; return x;&#125;os_node *tree_minimum(os_tree *T,os_node *x)&#123; while (x-&gt;left!=T-&gt;nil) &#123; x=x-&gt;left; &#125; return x;&#125;os_node *tree_successor(os_tree *T, os_node *x)&#123; if(x-&gt;right!=T-&gt;nil) &#123; return tree_minimum(x-&gt;right); &#125; os_node *y=x-&gt;parent; //后继在根节点处 while(y!=T-&gt;nil &amp;&amp; x==y-&gt;right) &#123; x=y; y=y-&gt;parent; &#125; return y;&#125;os_node *tree_predecessor(os_tree *T, os_node *x)&#123; if(x-&gt;left!=T-&gt;nil) &#123; return tree_maxinum(x-&gt;left); &#125; os_node *y=x-&gt;parent; while(y!=T-&gt;nil &amp;&amp; x==y-&gt;left) &#123; x=y; y=y-&gt;parent; &#125; return y;&#125;os_node *Iterative_tree_search(os_tree *T,os_node *x, int k)&#123; while(x!=T-&gt;nil &amp;&amp; k!=x-&gt;key) &#123; if(k&lt;x-&gt;key) x=x-&gt;left; else x=x-&gt;right; &#125; return x;&#125;void in_order_traverse(os_tree *T, os_node *p)&#123; if(p!=T-&gt;nil) &#123; in_order_traverse(p-&gt;left); cout&lt;&lt;p-&gt;key&lt;&lt;\" \"&lt;&lt;p-&gt;color&lt;&lt;\" \"&lt;&lt;p-&gt;size&lt;&lt;endl; in_order_traverse(p-&gt;right); &#125;&#125;os_node *os_select_rank(os_tree *T, os_node *x, int i)&#123; int r=x-&gt;left-&gt;size+1; if(i==r) return x; else if(i&lt;r) return os_select_rank(T,x-&gt;left,i); else return os_select_rank(T,x-&gt;right,i-r);&#125;int Interative_os_rank(os_tree *T,os_node *x)//确定x这个节点的顺序统计树的rank&#123; int r=x-&gt;left-&gt;size+1; os_node *y=x; //沿左脊柱上升，r=x-&gt;left-&gt;size+1 while(y!=T-&gt;root) //如果是沿着右脊柱上升？y-&gt;size=y-&gt;left-&gt;size+1+sum&#123;y-&gt;parent-&gt;size&#125; &#123; //沿左脊柱上升，r保持不变；一旦拐弯到了右脊柱，要关注y-&gt;parent-&gt;left-&gt;size+1 if(y==y-&gt;parent-&gt;right) r=r+y-&gt;parent-&gt;left-&gt;size+1; y=y-&gt;parent; //不管是左脊柱还是右脊柱，都要沿树上升 &#125; return r;&#125; Josephus_circle.h12345678910111213141516171819202122232425262728#include \"delete.h\"#include \"succ_and_other.h\"void Josephus_imple(os_tree *T, int m, int n)&#123; os_node *x=T-&gt;root; int k=0, i=n; int t=1; while(T-&gt;root!=NULL &amp;&amp; i&gt;0) &#123; k=(t+m-1)%i; //k就是我们需要删除的点，注意到我们对一个点执行删除之后 //这个点原来的下标是k，删除了之后k+1就自动补到k的位置上 //这样新的k重新编号的话就是1，相当于原来的t=1 if(k==0) k=i; os_node *del=os_select(T,k); //这里del表示要删除的结点 cout&lt;&lt;del-&gt;key&lt;&lt;\" \"; //输出节点 RB_delete(del); t=k; i--; &#125;&#125; 主函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include \"Josephus_circle.h\"#include &lt;iostream&gt;#include \"time.h\"#include \"os_tree.h\"#include \"delete.h\"#include \"insert.h\"using namespace std;int main()&#123; srand((unsigned)time(NULL)); int m=0,n=0; cout&lt;&lt;\"输入Josephus排列的m和n值\"&lt;&lt;endl; cout&lt;&lt;\"m=\"; cin&gt;&gt;m; cout&lt;&lt;\"n=\"; cin&gt;&gt;n; int *array_jose=new int [n]; //对数组进行赋值和初始化 for(int j=0;j&lt;n;j++) &#123; array_jose[j]=j+1; cout&lt;&lt;array_jose[j]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; os_node *nilnode=new os_node [LEN]; os_tree *T=new os_tree [LENTREE]; os_node *newroot=new os_node [LEN]; nilnode-&gt;key=-1; nilnode-&gt;color=BLACK; T-&gt;nil=nilnode; int i=0; newroot-&gt;key=array_jose[i++]; RB_insert(T,newroot); T-&gt;root=newroot; while(i!=n) &#123; os_node *z=new os_node[LEN]; z-&gt;key=array_jose[i]; RB_insert(T,z); i++; &#125; in_order_traverse(T,T-&gt;root); cout&lt;&lt;\"Josephus排列\"&lt;&lt;\" \"; Josephus_imple(T,m,n);&#125;","categories":[{"name":"data_structure","slug":"data-structure","permalink":"https://www.fogsail.net/categories/data-structure/"}],"tags":[{"name":"data_structure","slug":"data-structure","permalink":"https://www.fogsail.net/tags/data-structure/"}]},{"title":"聊聊红黑树","slug":"20170129","date":"2017-01-29T15:00:00.000Z","updated":"2018-03-02T16:55:28.000Z","comments":true,"path":"2017/01/29/20170129/","link":"","permalink":"https://www.fogsail.net/2017/01/29/20170129/","excerpt":"第一部分：红黑树表示与旋转红黑树是一种平衡二叉树，其性质不再赘述。红黑树的数据结构如下：","text":"第一部分：红黑树表示与旋转红黑树是一种平衡二叉树，其性质不再赘述。红黑树的数据结构如下： 123456789101112131415161718192021222324#define RED 0#define BLACK 1#define INFINITY 345879790struct RB_node&#123; RB_node *left; //左孩子 RB_node *right; //右孩子 RB_node *parent; //父节点 int color; //结点的颜色 int key; RB_node(RB_node* init,int c_init,int num):left(init),right(init),parent(init),color(c_init),key(num)&#123;&#125;&#125;;struct RB_tree&#123; RB_tree *root; RB_tree *nil; RB_tree() &#123; nil=new RB_node(NULL,BLACK,INFINITY); //树的哨兵必然为黑色 root=nil; &#125;&#125;; 值得特别说明的是，这里的T-&gt;nil表示的是哨兵结点，是为了方便之后的运算。 红黑树的旋转过程，如下图所示： 注意旋转的前后，从左到右，子树依次是y-&gt;left y-&gt;right x-&gt;right，但是y-&gt;right的parent变成了x了！ 红黑树旋转的过程如下给出：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include \"RB_tree.h\"void left_rotate(RB_tree *T,RB_node *x)&#123; RB_node *y=x-&gt;right; //左孩子结点 x-&gt;right=y-&gt;left; //这一部处理的是加在x，y之间的“内结点”，y-&gt;left原先 //夹在x-&gt;left和y-&gt;right之间，旋转之后子树的相对顺序不变，最外边的结点是 //x-&gt;left和y-&gt;right，注意是围绕x和y进行的旋转，所以子树的相对位置保持不变 if(y!=NULL &amp;&amp; y-&gt;left!=NULL) y-&gt;left-&gt;parent=x; //旋转之后需要重新更新parent结点信息 y-&gt;parent=x-&gt;parent; //这个时候y作为子树的根了，y要连到祖先中！ if(x-&gt;parent==NULL) T-&gt;root=y; else if(x-&gt;parent-&gt;left==x) x-&gt;parent-&gt;left=y; else x-&gt;parent-&gt;right=y; //保证x与祖先结点相连接 //最后处理x和y的关系 y-&gt;left=x; x-&gt;parent=y;&#125;//右旋，对称的代码void right_rotate(RB_tree *T,RB_node *x)&#123; //只需要把上述代码的相对位置，right和left互换就可以了 RB_node *y=x-&gt;left; x-&gt;left=y-&gt;right; if(y!=NULL &amp;&amp; y-&gt;right!=NULL) y-&gt;right-&gt;parent=x; //旋转之后需要重新更新parent结点信息 y-&gt;parent=x-&gt;parent; if(x-&gt;parent==NULL) T-&gt;root=y; else if(x-&gt;parent-&gt;left==x) x-&gt;parent-&gt;left=y; else x-&gt;parent-&gt;right=y; //保证x与祖先结点相连接 //最后处理x和y的关系 y-&gt;right=x; x-&gt;parent=y;&#125; 红黑树的旋转左旋和右旋是对称的。 第二部分：红黑树的插入和性质的维护具体程序：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include \"RB_tree.h\"void RB_insert_fixup(RB_tree *T, RB_node *z);void RB_insert(RB_tree *T, RB_node *z)&#123; RB_node *y=NULL; //y作为遍历指针的双亲 RB_node *x=T-&gt;root; while(x!=NULL) &#123; y=x; if(z-&gt;key&lt;x-&gt;key) x-&gt;x-&gt;left; else x=x-&gt;right; &#125; z-&gt;parent=y; //y作为遍历指针x的母结点，x遍历寻找合适的插入位置 if(y==NULL) T-&gt;root=z; else if(z-&gt;key&lt;y-&gt;key) y-&gt;left=z; else y-&gt;right=z; z-&gt;left=NULL; z-&gt;right=NULL; z-&gt;parent=RED; RB_insert_fixup(T,z); //最后插入的结点是红色的，与此同时进行红黑树性质的调整&#125;void RB_insert_fixup(RB_tree *T,RB_node *z)&#123; while(z-&gt;parent-&gt;color==RED) &#123; if(z-&gt;parent==z-&gt;parent-&gt;parent-&gt;left) &#123; RB_node *y=z-&gt;parent-&gt;parent-&gt;right; //设置叔结点 if(y-&gt;color==RED) &#123; z-&gt;parent-&gt;color=BLACK; //父节点的黑色可以下放给两个结点 y-&gt;color=BLACK; z-&gt;parent-&gt;parent-&gt;color=RED; z=z-&gt;parent-&gt;parent; //z沿树上升 &#125; else &#123; if(z==z-&gt;parent-&gt;right) //内结点先旋转成外节点 &#123; z=z-&gt;parent; left_rotate(T,z); &#125; z-&gt;parent-&gt;color=BLACK; //改变颜色之后，z的兄弟结点和z颜色相同 z-&gt;parent-&gt;parent-&gt;color=RED; //红黑树局部恢复平衡 right_rotate(T,z-&gt;parent-&gt;parent); //这个技巧是：改变颜色之后，然后旋转，这样不破坏红黑树性质 &#125; //与此同时，结点沿树上升 &#125; else &#123; RB_node *y=z-&gt;parent-&gt;parent-&gt;left; if(y-&gt;color==RED) &#123; z-&gt;parent-&gt;color=BLACK; y-&gt;color=BLACK; z-&gt;parent-&gt;parent-&gt;color=RED; z=z-&gt;parent-&gt;parent; &#125; else &#123; if(z==z-&gt;parent-&gt;left) &#123; z=z-&gt;parent; right_rotate(T,z); &#125; z-&gt;parent-&gt;color=BLACK; z-&gt;parent-&gt;parent-&gt;color=RED; left_rotate(T,z-&gt;parent-&gt;parent); &#125; &#125; &#125; T-&gt;root-&gt;color=BLACK;&#125; 实现过程说明：红黑树的插入是比较容易理解的，下面着重来讨论红黑树插入的调整： 情形一：这个时候只要把根部A这个点的黑色，下放给两个孩子结点，这样红黑树的性质得到保持，这个时候刚插入的节点沿树上升就可以了。 情形二：如果z是内节点，要首先旋转成外结点，因为外节点的相对位置是不变的，内节点在旋转的过程中还会更换parent！所以用外节点处理方便，值得注意的是，在旋转过程中，z的相对高度要保持不变，所以要执行z=z-&gt;parent，然后再旋转！这样沿树上升的时候，保证所有的结点都得到处理！ 最后一步改变颜色，做到了红黑树的局部平衡，这个时候改变颜色之后再执行旋转，不破坏红黑树的平衡性，与此同时，z结点沿树上升，这样局部平衡得到保持。最后只要树根置为black就可以了。 第三部分：红黑树的删除红黑树删除的代码和普通二叉树的删除没有多少区别，主要是要关注：删除一个结点之后，记得寻找这个结点的后继，后继不一定是right，而是min(x-&gt;right) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include \"RB_tree.h\"//删除调整，这个时候x有两重黑色void RB_delete_fixup(RB_tree *T, RB_node *x)&#123; RB_node *w=NULL; while (x!=T-&gt;root &amp;&amp; x-&gt;color==BLACK) &#123; if(x==x-&gt;parent-&gt;left) &#123; w=x-&gt;parent-&gt;right; //w为x的兄弟结点 if(w-&gt;color==RED) &#123; w-&gt;color=BLACK; //将这种情况划归为下面一种情况 w-&gt;parent-&gt;color=RED; left_rotate(T,x-&gt;parent); w=x-&gt;parent-&gt;right; &#125; if(w-&gt;left-&gt;color==BLACK &amp;&amp; w-&gt;right-&gt;color==BLACK) &#123; W-&gt;color=RED; x=x-&gt;parent; //x和w的黑色沿树上升，注意到x有双重黑色，所以x的颜色不变 &#125; //变得是w，x-&gt;parent的颜色 else &#123; if(w-&gt;right-&gt;color==BLACK) &#123; w-&gt;left-&gt;color=BLACK; w-&gt;color=RED; //同样，内节点变为外节点 right_rotate(T,w); w=x-&gt;parent-?right; &#125; w-&gt;color=x-&gt;parent-&gt;color; //这里x-&gt;parent的颜色不确定，但是w的颜色是黑色 //x有双重黑色，通过改变颜色加上旋转，可以将双重黑色表现在图中，这样完成了红黑树的局部平衡 x-&gt;parent-&gt;color=BLACK; w-&gt;right-&gt;color=BLACK; left_rotate(T,x-&gt;parent); //红黑树局部平衡了 x=T-&gt;root; &#125; &#125; else &#123; w=x-&gt;parent-&gt;left; if(w-&gt;color==RED) &#123; w-&gt;color=BLACK; x-&gt;parent-&gt;color=RED; right_rotate(T,x-&gt;parent); w=x-&gt;parent-&gt;left; &#125; &#125; if(w-&gt;left-&gt;color==BLACK &amp;&amp; w-&gt;right-&gt;color==BLACK) &#123; w-&gt;color=RED; x=x-&gt;parent; &#125; else &#123; if(w-&gt;left-&gt;color==BLACK) &#123; w-&gt;right-&gt;color=BLACK; W-&gt;color=RED; left_rotate(T,w); w=x-&gt;parent-&gt;left; &#125; w-&gt;color=x-&gt;parent-&gt;color; x-&gt;parent-&gt;color=BLACK; w-&gt;left-&gt;color=BLACK; right_rotate(T,x-&gt;parent); x=T-&gt;root; &#125; &#125; x-&gt;color=BLACK;&#125;void transplant(RB_tree *T, RB_node *u, RB_node *v)&#123; if(u-&gt;parent==T-&gt;nil) T-&gt;root=v; else if(u==u-&gt;parent-&gt;left) u-&gt;parent-&gt;left=v; else u-&gt;parent-&gt;right=v; if(v!=NULL) v-&gt;parent=u-&gt;parent;&#125;RB_node *tree_minimum(RB_tree *T,RB_node *x)&#123; while (x-&gt;left!=NULL) &#123; x=x-&gt;left; &#125; return x;&#125;void RB_delete(RB_tree *T, RB_node *z)&#123; RB_node *y=z, *x; int y_original_color=y-&gt;color; if(z-&gt;left==NULL) &#123; x=z-&gt;right; transplant(T,z,z-&gt;right); &#125; else if(z-&gt;right==NULL) &#123; x=z-&gt;left; transplant(T,z,z-&gt;left); &#125; else &#123; y=tree_minimum(T,z-&gt;right); //这里是查找z的后继，为y，用y来代替z的位置 y_original_color=y-&gt;color; x=y-&gt;right; if(y-&gt;parent==z) &#123; x-&gt;parent=y; &#125; else &#123; transplant(T,y,y-&gt;right); y-&gt;right=z-&gt;right; y-&gt;right-&gt;parent=y; &#125; transplant(T,z,y); y-&gt;left=z-&gt;left; y-&gt;left-&gt;parent=y; y-&gt;color=z-&gt;color; &#125; if(y_original_color==BLACK) RB_delete_fixup(T,x); //x为y的孩子结点，y的删除会影响x的相关性质&#125; 具体来看红黑树删除的调整： 情形一这个时候x的兄弟节点w是red，一个红节点必然跟着两个黑节点，这个时候改变颜色，并且执行旋转，可以将这种情况划归为第二种情况，就是x和w都是黑色。为什么要这么做？主要的原因是x有双重黑色，我们需要让x的黑色沿树上升，w的黑色也沿树上升，w为白色，要想办法让它变成黑色。改变颜色+旋转是常用的方法。 情形二 这个时候需要让x和w的黑色都沿树上升。注意到这个时候x有双重黑色，所以x的黑色不改变。 情形三 这个时候和插入调整一样，内节点要转化成外节点。值得注意的是，这个时候w-&gt;left的颜色一定是red，因为不是的话就变成了第二种情况啦！这个时候红色的结点是内结点，要将它旋转成外节点处理，理由在插入调整的过程中已经说了很清楚了。 情形四 这个时候要注意的是：x-&gt;parent的颜色没有确定下来，但是w的颜色一定是black。交换颜色的代码是：123w-&gt;color=x-&gt;parent-&gt;color;x-&gt;parent-&gt;color=BLACK;w-&gt;right-&gt;color=BLACK; 如图所示，改变颜色+完成旋转之后，x的双重黑色已经体现出来了。这个时候红黑树达到了局部平衡。所以将x置为根节点，确定颜色就可以了。 第四部分：算法导论课后习题解答13.1红黑树的性质13.1-1 13.1-21、不行，违反性质42、不行，违反性质5 13.1-3是，我们在调整过程中就是利用松弛红黑树的性质，最后将T-&gt;root-color置为black。 13.1-4红黑树的黑高为从该点开始，所含有的黑节点的个数，所以红黑树的黑高保持不变。可能的度为：2 这个时候它的两个子节点原来都是黑色3 这个时候一个子节点为红色，另一个为黑色，红色子节点又跟随两个黑色子节点，度为34 两个子节点都是红色 13.1-5 $rh(x) \\leq bh(x)$$h(x) = rh(x)+bh(x) \\leq 2bh(x)$其中，rh(x)表示红高，bh(x)表示黑高 所以最长的一条最多是最短一条的两倍 13.1-6 黑高为k，内部节点最少为：$2^k-1$最多为：由13.1-5的结论，最长路径$ \\leq 2k+1$最多节点为： $2^ {2k+1} -1$ 13.1-7 比值最小为0，结点全部为黑色。比值最大为2：1参见13.1-1图，一个black两个结点都是红的，每个红节点又有两个黑节点，红节点和黑节点的比值为：4：2=2（内部节点，不算根节点） 13.2旋转13.2-1已写出 13.2-2 n个节点有n-1条边，所以可能有n-1种旋转 13.2-3 可以发现b的深度不变，a的深度增加，c的深度减少 13.2-4 最坏的情况，仅有左子树，假设左子树有n个节点，可以看出左子树旋转成右子树需要n-1次。这样左子树变成一条右侧伸展的链。 从左侧伸展的链旋转成为右侧伸展的链，最坏需要n-1的时间，其余任何一种情况，所需时间均少于n-1 13.2-5 T1可以右转成T2，可知若有i个结点，需要旋转i-1条边 $\\sum_{i=1}^n i = O(n^2)$ 13.3插入13.3-1 如果将z染色成黑色，很显然违反红黑树性质5，违反红黑树性质5，做调整的时候是针对高度来调整。这个时候红黑树还必须满足一种高度平衡：就是任意路径，从root到nil，红黑树的黑高差恒等于0在调整的时候比较麻烦。实际上这是属于类AVL树了。 高度平衡的二叉树，是AVL树，这是另外一种平衡二叉树。 13.3-2 13.3-3 13.3-4 z为叶子节点，则z-&gt;parent为根节点。根节点的颜色肯定恒为黑色，这个时候退出循环while(z-&gt;parent-&gt;color==RED)那么也就遍历不到z-&gt;parent-&gt;parent了。 13.3-5 插入的n-1个节点都为black，当插入第n个节点的时候，新插入的节点为红色，满足红黑树性质。 13.3-6 123456789101112131415161718192021222324252627RB_node *tree_search(RB_tree *T, RB_node *x, int k, RB_node *par, RB_node *p_par)&#123; //人为定义一个tree_search函数，从根节点遍历，寻找x的parent和parent-&gt;parent while(x!=T-&gt;nil &amp;&amp; k!=x-&gt;key) &#123; par=x; if(k&lt;x-&gt;key) x=x-&gt;left; else x=x-&gt;right; if(k!=x-&gt;key) //如果没有找到待查找的值，此时x=x-&gt;child &#123; //记录下遍历前的x=p_par，遍历后的x=par，返回x，此时用par和p_par表示 p_par=par; par=x; &#125; &#125; return x；&#125;void RB_insert_fixup(RB_tree *T, RB_node *z)&#123; //相关代码 RB_node *par=T-&gt;nil, *p_par=T-&gt;nil; tree_search(T,T-&gt;root,z-&gt;key,par,p_par); //将原来的z-&gt;parent用par代替，z-&gt;parent-&gt;parent用p_par代替&#125; 13.4删除13.4-1在执行RB_delete_fixup之后，可以发现，x=root, x-&gt;color=BLACK，所以树根一定是黑色的 13.4-2 此时不进入循环，x-&gt;color=BLACK，恢复性质4 13.4-3 13.4-4 1) 1、4、5行检查哨兵，因为被删除的节点没有孩子，所以检查T-&gt;nil的情况2) 左旋，右旋的时候，w的兄弟没有孩子，此时检查哨兵 13.4-5检查在稿纸上进行 13.4-6 情况一，w的颜色为红色，所以x-&gt;parent的颜色一定是黑色 13.4-7 不一样如下图 其中，灰色的节点代表刚刚插入又删除的节点。","categories":[{"name":"data_structure","slug":"data-structure","permalink":"https://www.fogsail.net/categories/data-structure/"}],"tags":[{"name":"data_structure","slug":"data-structure","permalink":"https://www.fogsail.net/tags/data-structure/"}]}]}