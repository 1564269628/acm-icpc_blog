{"meta":{"title":"步履不停","subtitle":null,"description":"Your past does not define you. It is what you decide to be that does.","author":"Fogsail Chen","url":"http://www.fogsail.net","root":"/"},"pages":[{"title":"关于我","date":"2019-03-06T08:46:36.000Z","updated":"2019-03-06T08:53:55.006Z","comments":true,"path":"about/index.html","permalink":"http://www.fogsail.net/about/index.html","excerpt":"","text":"极客，文艺青年"},{"title":"文章分类","date":"2019-03-06T08:46:36.000Z","updated":"2019-03-06T08:47:43.098Z","comments":true,"path":"categories/index.html","permalink":"http://www.fogsail.net/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-03-06T08:48:34.000Z","updated":"2019-03-06T08:49:10.505Z","comments":true,"path":"tags/index.html","permalink":"http://www.fogsail.net/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"算法竞赛中常用的c++ stl技巧","slug":"20190421","date":"2019-04-21T13:23:37.000Z","updated":"2019-04-30T13:04:43.635Z","comments":true,"path":"2019/04/21/20190421/","link":"","permalink":"http://www.fogsail.net/2019/04/21/20190421/","excerpt":"这篇文章主要针对一些复杂的模拟题，给出stl处理模拟题的一些思路以及一部分模版","text":"这篇文章主要针对一些复杂的模拟题，给出stl处理模拟题的一些思路以及一部分模版 栈，队列与优先队列求抽象数据结构的ID(), 并且构建map映射策略1：线程池MemPool策略2：用vector.size()值作为哈希 相关的实现如下： The SetStack Computer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//// main.cpp// LA3634//// Created by zhangmin chen on 2019/4/21.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)template &lt;typename T&gt;class MemPool &#123;public: vector&lt;T*&gt; buf; T* create() &#123; buf.push_back(new T()); return buf.back(); &#125; void dispose() &#123; for(int i = 0; i &lt; buf.size(); i++) delete buf[i]; buf.clear(); &#125;&#125;;map&lt;set&lt;int&gt;, int&gt; IDCache;vector&lt;set&lt;int&gt; &gt; setCache;MemPool&lt;set&lt;int&gt; &gt; pool;void fresh() &#123; IDCache.clear(); setCache.clear();&#125;int ID(const set&lt;int&gt;&amp; st) &#123; if(IDCache.count(st)) return IDCache[st]; setCache.push_back(st); return IDCache[st] = (int)setCache.size() - 1;&#125;// importantvoid solve() &#123; stack&lt;int&gt; stk; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; string cmd; cin &gt;&gt; cmd; if(cmd[0] == 'P') &#123; set&lt;int&gt; cur = *(pool.create()); int pid = ID(cur); stk.push(pid); &#125; else if (cmd[0] == 'D') &#123; stk.push(stk.top()); &#125; else &#123; set&lt;int&gt; st1 = setCache[stk.top()]; stk.pop(); set&lt;int&gt; st2 = setCache[stk.top()]; stk.pop(); set&lt;int&gt; combine; if(cmd[0] == 'U') set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(combine, combine.begin())); if(cmd[0] == 'I') set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(combine, combine.begin())); if(cmd[0] == 'A') &#123; combine = st2; combine.insert(ID(st1)); &#125; stk.push(ID(combine)); &#125; cout &lt;&lt; setCache[stk.top()].size() &lt;&lt; endl; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase; cin &gt;&gt; kase; while(kase--) &#123; solve(); printf(\"***\\n\"); pool.dispose(); &#125;&#125; 大整数类BigIntegerA + B Problem II 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;string.h&gt;using namespace std;typedef long long llong;struct BigInteger&#123; static const int BASE = 100000000; static const int WIDTH = 8; vector&lt;int&gt; bit; BigInteger(llong num = 0) &#123; *this = num; &#125; BigInteger operator= (llong num)&#123; bit.clear(); do&#123; bit.push_back(num % BASE); num /= BASE; &#125;while(num &gt; 0); return *this; &#125; BigInteger operator= (const string&amp; str)&#123; bit.clear(); int x; int len = (str.length()-1)/WIDTH + 1; for(int i = 0; i &lt; len; i++)&#123; int end = str.length()-i*WIDTH; //end :[start..end-1] end empty int start = max(0,end-WIDTH); sscanf(str.substr(start,end-start).c_str(),\"%d\",&amp;x); bit.push_back(x); &#125; return *this; &#125; BigInteger operator+ (const BigInteger&amp; b) const&#123; BigInteger sum; sum.bit.clear(); for(int i = 0, carry = 0; ;i++)&#123; if(carry == 0 &amp;&amp; i &gt;= bit.size() &amp;&amp; i &gt;= b.bit.size()) break; int x = carry; if(i &lt; bit.size()) x += bit[i]; if(i &lt; b.bit.size()) x += b.bit[i]; sum.bit.push_back(x % BASE); carry = x / BASE; &#125; return sum; &#125; BigInteger operator+= (const BigInteger&amp; b)&#123; *this = *this + b; return *this; &#125; bool operator &lt; (const BigInteger&amp; b) const &#123; if(bit.size() != b.bit.size()) return bit.size() &lt; b.bit.size(); for(int i = bit.size()-1; i &gt;= 0; i--)&#123; if(bit[i] != b.bit[i]) return bit[i] &lt; b.bit[i]; &#125; return false; &#125;&#125;;ostream&amp; operator&lt;&lt; (ostream &amp;out, const BigInteger&amp; x)&#123; out &lt;&lt; x.bit.back(); for(int i = x.bit.size()-2; i &gt;= 0; i--)&#123; char buffer[20]; sprintf(buffer,\"%08d\",x.bit[i]); for(int j = 0; j &lt; strlen(buffer); j++) out &lt;&lt; buffer[j]; &#125; return out;&#125;istream&amp; operator&gt;&gt; (istream &amp;in, BigInteger&amp; x)&#123; string s; if(!(in &gt;&gt; s)) return in; x = s; return in;&#125;int main()&#123; int kase, pid = 0; cin &gt;&gt; kase; while(kase--)&#123; BigInteger a,b; cin &gt;&gt; a &gt;&gt; b; printf(\"Case %d:\\n\",++pid); cout &lt;&lt; a &lt;&lt; \" + \" &lt;&lt; b &lt;&lt; \" = \" &lt;&lt; a+b &lt;&lt; endl; if(kase != 0) printf(\"\\n\"); &#125;&#125; map等stl高级用法Database 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//// main.cpp// LA4592//// Created by zhangmin chen on 2019/4/24.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)typedef pair&lt;int, int&gt; pii;int m, n;map&lt;string, int&gt; idx;const int maxr = 10000 + 10;const int maxc = 100 + 10;int db[maxr][maxc], cnt = 0;void init() &#123; memset(db, 0, sizeof(db)); idx.clear();&#125;int getID(const string&amp; str) &#123; if(!idx.count(str)) return idx[str] = ++cnt; return idx[str];&#125;void solve() &#123; for(int c1 = 0; c1 &lt; m; c1++) for(int c2 = c1+1; c2 &lt; m; c2++) &#123; map&lt;pii, int&gt; group; // group[c1, c2] = ith row // const pii&amp; pr = make_pair(); for(int i = 0; i &lt; n; i++) &#123; // group[(i,c1), (i,c2)] = ith row const pii&amp; pr = make_pair(db[i][c1], db[i][c2]); if(group.count(pr)) &#123; // printf(\"NO\\n\"); printf(\"%d %d\\n\", group[pr]+1, i+1); printf(\"%d %d\\n\", c1+1, c2+1); return; &#125; group[pr] = i; &#125; &#125; printf(\"YES\\n\"); return;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(cin &gt;&gt; n &gt;&gt; m) &#123; init(); string str; getline(cin, str); for(int i = 0; i &lt; n; i++) &#123; getline(cin, str); // cout &lt;&lt; str &lt;&lt; endl; // split by ',' int k = -1; for(int j = 0; j &lt; m; j++) &#123; int p = (int)str.find(',', k+1); if(p == string::npos) p = (int)str.length(); int hashv = getID(str.substr(k+1, p-k-1)); db[i][j] = hashv; k = p; // db[i][j] = hash(substr) &#125; &#125; // get data finished! // then we solve the problem solve(); &#125;&#125; 复杂模拟：比赛排名，并列情况有一类模拟题比较复杂，涉及以下情形1、比赛成绩有并列情况；2、比赛涉及到奖金发放，业余选手不得奖金 PGA Tour Prize Money 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329//// main.cpp// PGA//// Created by zhangmin chen on 2019/4/26.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)// const int maxn = 145;const int przn = 70;class Player &#123;public: string name; double prize; bool amat; bool t; int rnd[4]; int dq; int rank; int pre, tot; // pre used to decide which one can be in round[3, 4], make the cut // tot used to divide money // only made the cut plyer can get money // divide prize: // 1 parallel // 2 amt don't get prize // 3 get prize? Not amter &amp;&amp; rank[1,70] // DQ: // 1 DQ &gt; 2, plyer can make the cut // 2 but not rank in rnd[3,4] // make the cut: // DQ == 0 || DQ &gt; 2 ---&gt; make the cut // rank: // only DQ == 0 rank Player() &#123; name.clear(); prize = 0.0; amat = t = false; memset(rnd, 0, sizeof(rnd)); dq = 4; rank = 0; pre = tot = 0; &#125; void init() &#123; prize = 0.0; amat = t = false; memset(rnd, 0, sizeof(rnd)); dq = 4; rank = 0; pre = tot = 0; &#125;&#125;;int n;vector&lt;Player&gt; plyers;double priz[przn];double sum;int str2num(const string&amp; str) &#123; int val = 0; for(int i = 0; i &lt; str.length(); i++) &#123; val = val * 10 + str[i] - '0'; &#125; //debug(val); return val;&#125;void init() &#123; // //for(int i = 0; i &lt; n; i++) plyers[i].init(); plyers.clear(); memset(priz, 0, sizeof(priz)); scanf(\"%lf\", &amp;sum); for(int i = 0; i &lt; 70; i++) &#123; scanf(\"%lf\", &amp;priz[i]); priz[i] = priz[i] / 100.0 * sum; &#125;&#125;void initPlyer() &#123; //scanf(\"%d\", &amp;n); cin &gt;&gt; n; plyers.resize(n+1); string str; getline(cin, str); for(int i = 0; i &lt; n; i++) &#123; plyers[i].tot = 0; getline(cin, str); plyers[i].name = str.substr(0, 20); str = str.substr(20); if(plyers[i].name.find('*') != string::npos) &#123; plyers[i].amat = true; &#125; stringstream ss(str); //string data; // is &gt;&gt; data for(int j = 0; j &lt; 4; j++) &#123; string data; ss &gt;&gt; data; if(data == \"DQ\") &#123; plyers[i].dq = j; break; &#125; else &#123; plyers[i].rnd[j] = str2num(data); &#125; if(j &lt; 2) &#123; plyers[i].pre += str2num(data); &#125; plyers[i].tot += str2num(data); &#125; // debug(\"----\"); &#125;&#125;bool cmp1(const Player&amp; lhs, const Player&amp; rhs) &#123; if(lhs.dq &gt; 1 &amp;&amp; rhs.dq &gt; 1) return lhs.pre &lt; rhs.pre; return lhs.dq &gt; rhs.dq;&#125;int makeCut() &#123; sort(plyers.begin(), plyers.begin() + n, cmp1); int pos = 0; while (pos &lt; min(70, n) &amp;&amp; plyers[pos].dq &gt; 1) &#123; pos++; &#125; // [0, 69] --&gt; 70 while (plyers[pos].dq &gt; 1 &amp;&amp; plyers[pos].pre == plyers[pos-1].pre) &#123; pos++; &#125; return pos;&#125;// usage: int pos = makeCut// getRank(pos)bool cmp2(const Player&amp; lhs, const Player&amp; rhs) &#123; if(lhs.dq != rhs.dq) return lhs.dq &gt; rhs.dq; if(lhs.tot != rhs.tot) return lhs.tot &lt; rhs.tot; return lhs.name &lt; rhs.name;&#125;// important!// difficult: parallel situationvoid getRank(int num) &#123; // sort(plyers.begin(), plyers.begin() + num, cmp2); // divide money // 1. parallel // 2. amte cannot get money // no amte and rank from [0, 70] // now: plyers[0...num-1] int k = 0, rkp = 0; int rk = 0; while(k &lt; num) &#123; if(plyers[k].dq &lt; 4) break; // parallel: [k, p) rank: rk int p = k, cnt = 0; double sum = 0.0; int prll = 0; while(plyers[p].dq == 4 &amp;&amp; plyers[p].tot == plyers[k].tot) &#123; // if(!plyers[p].amat) &#123; // sum += priz[rkp + cnt]; cnt++; // &#125; p++; prll++; &#125; sum /= cnt; // assign prize: for(int i = k; i &lt; p; i++) &#123; plyers[i].rank = rk + 1; // prize is not enough if(rkp &gt; 69) &#123; plyers[i].amat = true; plyers[i].t = false; &#125; if(!plyers[i].amat) &#123; plyers[i].prize = sum; plyers[i].t = cnt &gt; 1; &#125; &#125; // [k, p) rank: rk // rk [0, 70) // [p, ...) rank: rk += cnt // plyers[].rank = rk + 1; k = p; rkp += cnt; rk += prll; &#125; &#125;void printAns(int num) &#123; // printf(\"Player Name Place RD1 RD2 RD3 RD4 TOTAL Money Won\\n\"); printf(\"-----------------------------------------------------------------------\\n\"); for(int i = 0; i &lt; num; i++) &#123; printf(\"%-21s\", plyers[i].name.c_str()); if(plyers[i].dq &lt; 4) printf(\" \"); else &#123; char t[5]; sprintf(t, \"%d%c\", plyers[i].rank, plyers[i].t ? 'T' : ' '); printf(\"%-10s\", t); &#125; for(int j = 0; j &lt; plyers[i].dq; j++) printf(\"%-5d\", plyers[i].rnd[j]); for(int j = plyers[i].dq; j &lt; 4; j++) printf(\" \"); if(plyers[i].dq &lt; 4) printf(\"DQ\"); else if(!plyers[i].amat) printf(\"%-10d\", plyers[i].tot); else printf(\"%d\", plyers[i].tot); if(plyers[i].dq &lt; 4 || plyers[i].amat) &#123; printf(\"\\n\"); continue; &#125; printf(\"$%9.2lf\\n\", plyers[i].prize); //int ans = floor((plyers[i].prize + 0.0050001) * 100); //plyers[i].prize = ans / 100.0; //cout.setf(ios::right); //cout &lt;&lt; \"$\" &lt;&lt; setw(9) &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; plyers[i].prize &lt;&lt; endl; //int ans = (int)((plyers[i].prize + 0.0005) * 10000); //printf(\"$%9.2lf\\n\", ans / 1000.0); &#125; &#125;// attend rnd[3,4], we need plyer.dq &gt; 2int main() &#123; freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout); int kase; scanf(\"%d\", &amp;kase); while(kase--) &#123; init(); // get prize data initPlyer(); int num = makeCut(); getRank(num); printAns(num); if(kase) printf(\"\\n\"); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"}]},{"title":"csapp实践（五）：存储器层次结构","slug":"20190403","date":"2019-04-03T11:28:31.000Z","updated":"2019-04-03T11:57:48.131Z","comments":true,"path":"2019/04/03/20190403/","link":"","permalink":"http://www.fogsail.net/2019/04/03/20190403/","excerpt":"存储器层次结构的部分难理解的内容总结如下","text":"存储器层次结构的部分难理解的内容总结如下 存储技术","categories":[{"name":"csapp","slug":"csapp","permalink":"http://www.fogsail.net/categories/csapp/"}],"tags":[{"name":"csapp","slug":"csapp","permalink":"http://www.fogsail.net/tags/csapp/"}]},{"title":"csapp实践（二）：程序的机器级表示","slug":"20190402","date":"2019-04-02T07:28:31.000Z","updated":"2019-04-09T07:02:29.267Z","comments":true,"path":"2019/04/02/20190402/","link":"","permalink":"http://www.fogsail.net/2019/04/02/20190402/","excerpt":"csapp第三章中，对汇编指令的要求比较高这里把常见的指令整理一下","text":"csapp第三章中，对汇编指令的要求比较高这里把常见的指令整理一下 1g++ -Og -S -masm=intel xxx.cpp 得到反汇编文件查阅 程序编码代码示例和解释： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;long mult2(long a, long b) &#123; return a*b;&#125;void multstore(long x, long y, long* des) &#123; long t = mult2(x, y); *des = t;&#125;int main() &#123; long a = 100, b = 150; long dest; multstore(a, b, &amp;dest); cout &lt;&lt; dest &lt;&lt; endl;&#125; 反汇编代码示例：1234567891011121314151617181920212223__Z9multstorellPl: ## @_Z9multstorellPl .cfi_startproc## %bb.0: ## rdx第三个参数，rsi第2个参数，rdi第一个参数 push rbp ## rbp为基指针寄存器(base pointer),存取调用堆栈中的数据 .cfi_def_cfa_offset 16 .cfi_offset rbp, -16 mov rbp, rsp ## rsp为堆栈指针(stack pointer)寄存器，只可访问堆栈顶 .cfi_def_cfa_register rbp push rbx ## rbx操作数寄存器，用来存放运算结果 push rax ## 用来临时存放函数mult2()的返回值，rax一般都是来存放返回值的 .cfi_offset rbx, -24 mov rbx, rdx ## rdx是第三个参数，copy dest to rbx, 最后*dest = mult2(x, y), 要先把dest存储在寄存器中，稍后访问 call __Z5mult2ll mov qword ptr [rbx], rax ## 运行的结果，将mult2(x, y)存入[rbx]即*dest中 add rsp, 8 pop rbx ## 可以这么理解: rbx = rax, rbx may be the left value, rax may be the right value, 一般来说， rax是返回值 pop rbp ## restore rbp ret .cfi_endproc ## -- End function .globl _main ## -- Begin function main .p2align 4, 0x90_main: ## @main 数据传输寄存器第一个参数：rdi， 第二个参数：rsi， 第三个参数：rdx， 第四个参数：rcx 汇编器常见的错误 12movl %rax, %(rsp) ## wrong, it is moveq %rax, %(rsp)movl %eax, %rdx ## 原来应该是movzlq，但是并没有这样的指令，rdx应该对应movq 数据传送示例 1234567char -&gt; intchar类型4字，转int需要符号扩展，4字用movl，这里需要符号扩展用movsblmovsbl (%rdi), %eaxmovl %eax, (%rsi) 123456char -&gt; unsigned同样4字对4字，需要符号扩展movsblmovsbl (%rdi), %eaxmovl %eax, (%rsi) 1234567unsigned char -&gt; long0扩展，转成8字存储，操作的是unsigned char，本来用的是movl, 需要0扩展用movzblmovzbl (%rdi), %eax;movq %rax, (%rsi) 123456int -&gt; char操作数是int, 直接用movl即可, int是4字，存放到eax中movl (%rdi), %eaxmovb %al, (%rsi)char只需要低位的，所以用movb %al, (%rsi) 12345unsigned -&gt; unsigned char操作数unsigned，4字，movl存放在eax中movl (%rdi), %eaxmovb %al, (%rsi) 1234567char -&gt; short需要做符号扩展，并且char要截断，取低位，存放在ax中，本来用movw这里涉及到符号扩展，用movsbwmovsbw (%rdi), %axmovw %ax, (%rsi) 移位操作移位量是由%cl寄存器的低m位决定的，高位会被忽略 1234567891011long shift_left4_rightn(long x, long n) &#123; x &lt;&lt;= 4; x &gt;&gt;= n; return x;&#125;shift_left4_rightn: movq %rdi, %rax salq $4, %rax movl %esi, %ecx ## get n (4 bytes) sarq %cl, %rax ## 本来应该是sarq %ecx, %rax, 因为移位操作取的是低位%cl 特殊的算术操作乘法，乘积低位放在%rax中，高位放在%rdx中除法，需要用到%rdx寄存器来存放参数，商放在%rax中，余数放在%rdx中 控制条件控制实现条件分支1setnle D &lt;-- ~(SF ^ OF) &amp; ~ZF 溢出的处理，用xor，看作是不进位的加法如果有符号溢出，相应的值要变化，比如SF: t &lt; 0溢出的话，要xor OF实际上SF 0-&gt;1 注意跳转指令前面有符号，f8表示符号位是-1，所以是0xd-0x8 1234560xffffff73所代表的跳转值，首先最高位为负值为8位16进制数所以最高位为-16^7-16^7 + 0xfffff73 = -141即为跳转偏移量 跳转指令翻译123456789cmpq xxx1, xxx2jge .L2code....means:if(xxx2 &lt; xxx1) code...else .L2 用条件传送来实现条件分支12345678testq %rdi, %rdicmovns %rdi, %rax## 实现方法：cmovns表示非负数## if( &gt;= 0) rax &lt;-- rdi## 条件中的值为testq %rdi的值，即if(x &gt;= 0) v = x; 用循环来实现条件分支for循环1234567891011fun_a: movl $0, %eax jmp .L5.L6: xorq %rdi, %rax shrq %rdi.L5: testq %rdi, %rdi jne .L6 andl $1, %eax ret 转换成c语言代码，可以发现L5是循环的主体12345678while(%rdi != 0) &#123; .L6&#125;return %eax &amp; 0x1.L6的实现如下val ^= xx &gt;&gt;= 1 该实现如下：12345678long fun_a(unsigned long x) &#123; long val = 0; while(x) &#123; val ^= x; x &gt;&gt;= 1; &#125; return val &amp; 0x1;&#125; 代码功能：奇数个1， 每一位取出来xor，其值还是1偶数个1，每一位取出来，其值是0如果有奇数个1，返回1，偶数个1，返回0 123456789101112fun_b: movl $64, %edx movl $0, %eax.L10: movq $rdi, %rcx andl $1, %ecx addq %rax, %rax orq %rcx, %rax shrq %rdi subq $1, %rdx jne .L10 rep; ret for循环主体12345678910111213subq $1, %rdxeax = val = 0;for(edx = 64; edx != 0; edx--) &#123; .L10&#125;.L10: val in rax tmp = x; tmp &amp;= 1; (tmp in rcx) val &lt;&lt; 1; val |= tmp x &gt;&gt; = 1 综上：123456789long fun_b(unsigned long x) &#123; long val = 0; long i; for(i = 64; i != 0; i--) &#123; val = (x &amp; 0x1) | (val &lt;&lt; 1) x &gt;&gt;= 1; &#125; return val;&#125; 这个代码的作用很有意思如图所示，创造x的镜像 switch语句 12345switch2: addq $1, %rdi cmpq $8, %rdi ja .L2 jmp *.L4(, %rdi, 8) start: rdi+1 $ x+1 = 0 $$ x+1 &gt; 8 \\quad (default) $$ x+1 &lt; 8 $$ x = -1, 0, 1, 2, 3, 4, 5, 6, 7 $ 函数调用过程转移控制函数调用的具体分析如下 stack上的局部存储 寄存器中的局部存储空间 数组的分配和访问定长数组 异质的数据结构，联合，结构体联合123456789101112131415161718typedef union &#123; struct &#123; long u; short v; char w; &#125; t1; struct &#123; int a[2]; char* p; &#125; t2;&#125; u_type;void get(u_type *up, type* dest) &#123; *dest = expr;&#125;// up in %rdi, dest in %rsi 具体的内存分配如下： 数据对齐 数据对齐的时候，start位置必须是类型的整数倍如果不满足，则会填充 这里又一个优化技巧结构体对数据类型进行降序排列 12345678struct P &#123; char* x1; long x2; float x3; int x4; short x5; ...&#125;; 指针与缓冲区溢出 对抗缓冲区溢出攻击 支持变长栈帧123long vframe(long n, long idx, long *q) &#123; long *p[n];&#125;","categories":[{"name":"csapp","slug":"csapp","permalink":"http://www.fogsail.net/categories/csapp/"}],"tags":[{"name":"csapp","slug":"csapp","permalink":"http://www.fogsail.net/tags/csapp/"}]},{"title":"字符串算法：后缀数组与后缀自动机","slug":"20190306","date":"2019-03-06T14:28:31.000Z","updated":"2019-03-06T15:42:26.031Z","comments":true,"path":"2019/03/06/20190306/","link":"","permalink":"http://www.fogsail.net/2019/03/06/20190306/","excerpt":"字符串算法非常常见，并且在一般的算法竞赛中，往往都是以压轴题的形式出现这里先研究字符串和它的子串的一些关系 常用的字符串和它的子串的处理工具主要有后缀数组和后缀自动机","text":"字符串算法非常常见，并且在一般的算法竞赛中，往往都是以压轴题的形式出现这里先研究字符串和它的子串的一些关系 常用的字符串和它的子串的处理工具主要有后缀数组和后缀自动机 后缀数组初步算法思想概述后缀数组的思想理解起来并不复杂具体的见下图： 其中精妙的地方在于：比如后缀$ { a, abra, abracadabra } $都存在a这个前缀，这个时候用基数排序，把频次转换成索引然后跟高考成绩排名一样，依次对字符串排序下来 然后接着处理第二个字符 具体的程序实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//// main.cpp// suffixArray//// Created by zhangmin chen on 2019/2/14.// Copyright © 2019 zhangmin chen. All rights reserved.#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;stdexcept&gt;using namespace std;/* string sort test:int main() &#123; freopen(\"input.txt\", \"r\", stdin); string tmp; vector&lt;string&gt; ans; while(getline(cin, tmp)) &#123; ans.push_back(tmp); &#125; sort(ans.begin(), ans.end()); for(auto&amp; i : ans) cout &lt;&lt; i &lt;&lt; endl;&#125;*/class suffixArray &#123;private: string* str; int N; int lcp(string s, string t) &#123; int len = (int) min(s.length(), t.length()); for(int i = 0; i &lt; len; i++) if(s[i] != t[i]) return i; return len; &#125; public: suffixArray(string text) &#123; // N = (int)text.length(); str = new string[N+1]; for(int i = 0; i &lt; N; i++) str[i] = text.substr(i); sort(str, str+N); &#125; ~suffixArray() &#123; delete[] str; &#125; int length() &#123; return N; &#125; string select(int i) &#123; return str[i]; &#125; int index(int i) &#123; return (int) (N - str[i].length()); &#125; int lcp(int i) &#123; return lcp(str[i], str[i-1]); &#125; int rank(string key) &#123; int lo = 0, hi = N-1; while(lo &lt;= hi) &#123; int mid = lo + (hi-lo)/2; int cmp = strcmp(key.c_str(), str[mid].c_str()); if(cmp &lt; 0) hi = mid-1; else if(cmp &gt; 0) lo = mid+1; else return mid; &#125; return lo; &#125;&#125;;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string tmp; cin &gt;&gt; tmp; suffixArray sa(tmp); printf(\" i ind lcp rnk select\\n\"); printf(\"---------------------------\\n\"); for(int i = 0; i &lt; tmp.length(); i++) &#123; int idx = sa.index(i); string ith = \"\\\"\" + tmp.substr(idx) + \"\\\"\"; assert(tmp.substr(idx) == sa.select(i)); // most important! int rk = sa.rank(tmp.substr(idx)); if(i == 0) printf(\"%3d %3d %3s %3d %s\\n\", i, idx, \"-\", rk, ith.c_str()); else &#123; int lcp = sa.lcp(i); printf(\"%3d %3d %3d %3d %s\\n\", i, idx, lcp, rk, ith.c_str()); &#125; &#125; &#125; 后缀数组Manber-Myers算法思想概述上述朴素算法，效率是比较低的我们每一次都对字符串从头到尾扫描一遍最坏情况下，算法的效率是$O(n^2/2)$ 如何改进呢？能不能在基数排序str[0]完成之后，利用str[0]的信息，来接着处理str[1], str[2]…呢先这样想，我们把第一位的结果，当成是第二位的可以不可以呢？字符串右移一位，会是什么情况呢？ 具体的算法图解如下： 其实就相当于把串整体下移一位利用第一次的结果排序第二次这样前缀的值就可以确定下来，我们可以尝试求解LCP LCP求解最后的结果是： UVA11107来看一道题目 Life Forms 分析： 实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159//// main.cpp// uva11107//// Created by zhangmin chen on 2019/2/16.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1001 * 100 + 10;struct suffixArray &#123; int str[maxn], sa[maxn], rank[maxn], lcp[maxn]; int c[maxn], t1[maxn], t2[maxn]; int n; void init() &#123; n = 0; memset(sa, 0, sizeof(sa)); &#125; void buildSa(int Rdx) &#123; int i, *x = t1, *y = t2; for(i = 0; i &lt; Rdx; i++) c[i] = 0; for(i = 0; i &lt; n; i++) c[x[i] = str[i]]++; for(i = 1; i &lt; Rdx; i++) c[i] += c[i-1]; for(i = n-1; i &gt;= 0; i--) sa[--c[x[i]]] = i; for(int offset = 1; offset &lt;= n; offset &lt;&lt;= 1) &#123; int p = 0; for(i = n-offset; i &lt; n; i++) y[p++] = i; for(i = 0; i &lt; n; i++) if(sa[i] &gt;= offset) y[p++] = sa[i] - offset; // radix sort for(i = 0; i &lt; Rdx; i++) c[i] = 0; for(i = 0; i &lt; n; i++) c[x[y[i]]]++; for(i = 1; i &lt; Rdx; i++) c[i] += c[i-1]; for(i = n-1; i &gt;= 0; i--) &#123; sa[--c[x[y[i]]]] = y[i]; y[i] = 0; &#125; // rebuild x and y swap(x, y); x[sa[0]] = 0; p = 1; for(i = 1; i &lt; n; i++) x[sa[i]] = y[sa[i-1]] == y[sa[i]] &amp;&amp; y[sa[i-1]+offset] == y[sa[i]+offset] ? p-1 : p++; if(p &gt;= n) break; Rdx = p; &#125; &#125; void getLcp() &#123; int k = 0; for(int i = 0; i &lt; n; i++) rank[sa[i]] = i; for(int i = 0; i &lt; n; i++) &#123; if(rank[i] == 0) continue; if(k) k--; int j = sa[rank[i] - 1]; while(str[i+k] == str[j+k]) k++; lcp[rank[i]] = k; &#125; &#125;&#125;;const int maxl = 1000 + 10;const int maxc = 100 + 10;suffixArray sa;int n;char word[maxl];int flag[maxc];int idx[maxn];void add(int ch, int wid) &#123; // add alpha in sa idx[sa.n] = wid; sa.str[sa.n++] = ch;&#125;bool judge(int left, int right) &#123; memset(flag, 0, sizeof(flag)); if(right-left &lt;= n/2) return false; int cnt = 0; for(int i = left; i &lt; right; i++) &#123; int wid = idx[sa.sa[i]]; if(wid != n &amp;&amp; flag[wid] == 0) &#123; flag[wid] = 1; cnt++; &#125; &#125; return cnt &gt; n/2;&#125;void printSub(int l, int r) &#123; for(int i = l; i &lt; r; i++) &#123; printf(\"%c\", sa.str[i]-1+'a'); &#125; printf(\"\\n\");&#125;bool okForLength(int len, bool print) &#123; // binary search int left = 0; for(int right = 1; right &lt;= sa.n; right++) if(right == sa.n || sa.lcp[right] &lt; len) &#123; // a new block if(judge(left, right)) &#123; if(print) printSub(sa.sa[left], sa.sa[left]+len); // is sa.sa[left], printout original str[] else return true; &#125; left = right; &#125; return false;&#125;void solve(int maxlen) &#123; // if(!okForLength(1, false)) printf(\"?\\n\"); else &#123; int l = 1, r = maxlen, mid; while(l &lt; r) &#123; mid = l + (r-l+1)/2; if(okForLength(mid, false)) l = mid; else r = mid-1; &#125; okForLength(l, true); &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); int kase = 0; while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; if(kase++ &gt; 0) printf(\"\\n\"); int maxlen = 0; sa.init(); for(int i = 0; i &lt; n; i++) &#123; scanf(\"%s\", word); int sz = (int)strlen(word); maxlen = max(maxlen, sz); for(int j = 0; j &lt; sz; j++) add(word[j]-'a'+1, i); add(100+i, n); &#125; add(0, n); if(n == 1) printf(\"%s\\n\", word); else &#123; sa.buildSa(100+n); sa.getLcp(); solve(maxlen); &#125; &#125; return 0;&#125; 这道题目的后缀数组模版比较常用 后缀自动机理论后缀自动机则是比后缀数组更为强大的工具它能够在线性时间内求出子串 后缀自动机的构造方式endpos()函数 后缀链接 实现中重复添加字符的处理方法 hihocoder1445具体的题目见后缀自动机二·重复旋律5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//// main.cpp// hiho1445//// Created by zhangmin chen on 2019/2/22.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define REP(i, l, r) for(int i = (l); i &lt;= (r); i++)#define FOR(i, l, r) for(int i = (l); i &lt; (r); i++)typedef long long llong;using namespace std;const int maxl = 1000000 + 10;const int maxn = 2 * maxl;struct SAM &#123; int maxlen[maxn], trans[maxn][26], link[maxn], size, last; SAM() &#123; Set(maxlen, 0); Set(trans, 0); Set(link, 0); size = last = 1; &#125; void extend(int ch) &#123; // int cur = ++size, p = last; maxlen[cur] = maxlen[p] + 1; for(; p &amp;&amp; !trans[p][ch]; p = link[p]) trans[p][ch] = cur; // then, we try to change the link of cur, link[cur] = ? if(!p) link[cur] = 1; else &#123; int q = trans[p][ch]; if(maxlen[p] + 1 == maxlen[q]) link[cur] = q; else &#123; int clone = ++size; maxlen[clone] = maxlen[p] + 1; Cpy(trans[clone], trans[q]); link[clone] = link[q]; for(; p &amp;&amp; trans[p][ch] == q; p = link[p]) trans[p][ch] = clone; link[q] = link[cur] = clone; &#125; &#125; last = cur; &#125;&#125;;SAM sam;char str[maxl];int main() &#123; freopen(\"input.txt\", \"r\", stdin); scanf(\"%s\", str); for(int i = 0; str[i]; i++) sam.extend(str[i] - 'a'); llong ans = 0; for(int i = 1; i &lt;= sam.size; i++) &#123; if(i == 1) continue; ans += sam.maxlen[i] - sam.maxlen[sam.link[i]]; &#125; cout &lt;&lt; ans;&#125; 求任意的长度为k的子串出现的次数 hihocoder1449后缀自动机三·重复旋律6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//// main.cpp// hiho1449//// Created by zhangmin chen on 2019/2/22.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define REP(i, l, r) for(int i = (l); i &lt;= (r); i++)#define FOR(i, l, r) for(int i = (l); i &lt; (r); i++)typedef long long llong;using namespace std;const int maxl = 1000000 + 10;const int maxn = 2 * maxl;llong cnt[maxn];struct SAM &#123; int maxlen[maxn], trans[maxn][26], link[maxn], size, last; SAM() &#123; Set(maxlen, 0); Set(trans, 0); Set(link, 0); size = last = 1; &#125; void extend(int ch) &#123; // int cur = ++size, p = last; maxlen[cur] = maxlen[p] + 1; cnt[cur] = 1; for(; p &amp;&amp; !trans[p][ch]; p = link[p]) trans[p][ch] = cur; if(!p) link[cur] = 1; else &#123; int q = trans[p][ch]; if(maxlen[p] + 1 == maxlen[q]) link[cur] = q; else &#123; int clone = ++size; maxlen[clone] = maxlen[p] + 1; Cpy(trans[clone], trans[q]); link[clone] = link[q]; for(; p &amp;&amp; trans[p][ch] == q; p = link[p]) trans[p][ch] = clone; link[cur] = link[q] = clone; &#125; &#125; last = cur; &#125;&#125;;SAM sam;char str[maxl];vector&lt;int&gt; G[maxn];int indeg[maxn];llong ans[maxn];void build() &#123; REP(i, 1, sam.size) &#123; G[i].push_back(sam.link[i]); indeg[sam.link[i]]++; &#125;&#125;void topo() &#123; queue&lt;int&gt; que; build(); REP(i, 0, sam.size) if(!indeg[i]) que.push(i); while(!que.empty()) &#123; int u = que.front(); que.pop(); for(int v : G[u]) &#123; // ans[sam.maxlen[u]] = max(ans[sam.maxlen[u]], cnt[u]); cnt[v] += cnt[u]; if(!(--indeg[v])) que.push(v); &#125; &#125; REP(i, 1, sam.size) ans[sam.maxlen[i]] = max(ans[sam.maxlen[i]], cnt[i]); // FOR(i, 1, sam.size) debug(cnt[i]);&#125;int main() &#123; // freopen(\"input.txt\", \"r\", stdin); string str; cin &gt;&gt; str; for(int i = 0; i &lt; str.length(); i++) sam.extend(str[i] - 'a'); topo(); for(int i = (int)str.length(); i &gt;= 1; i--) ans[i] = max(ans[i], ans[i+1]); for(int i = 1; i &lt;= str.length(); i++) cout &lt;&lt; ans[i] &lt;&lt; endl;&#125; 连接不同的子串，标识符分隔，再拓扑排序这样可以把所有不同的串整合到一起 hihocoder1457后缀自动机四·重复旋律7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//// main.cpp// hiho1457//// Created by zhangmin chen on 2019/2/23.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define REP(i, l, r) for(int i = (l); i &lt;= (r); i++)#define FOR(i, l, r) for(int i = (l); i &lt; (r); i++)typedef long long llong;using namespace std;const int maxl = 1000000 + 10;const int maxn = 2 * maxl;const llong MOD = 1000000007;struct SAM &#123; int maxlen[maxn], trans[maxn][26], link[maxn], size, last; SAM() &#123; Set(maxlen, 0); Set(trans, 0); Set(link, 0); size = last = 1; &#125; void extend(int ch) &#123; int cur = ++size, p = last; maxlen[cur] = maxlen[p] + 1; for(; p &amp;&amp; !trans[p][ch]; p = link[p]) trans[p][ch] = cur; if(!p) link[cur] = 1; else &#123; int q = trans[p][ch]; if(maxlen[p] + 1 == maxlen[q]) link[cur] = q; else &#123; int clone = ++size; maxlen[clone] = maxlen[p] + 1; Cpy(trans[clone], trans[q]); link[clone] = link[q]; for(; p &amp;&amp; trans[p][ch] == q; p = link[p]) trans[p][ch] = clone; link[cur] = link[q] = clone; &#125; &#125; last = cur; &#125;&#125;;SAM sam;const int spc = 10;int indeg[maxn];llong cnt[maxn], val[maxn];int main() &#123; freopen(\"input.txt\", \"r\", stdin); // llong ans = 0; Set(cnt, 0); Set(val, 0); Set(indeg, 0); int n; scanf(\"%d\", &amp;n); string str; while(n--) &#123; cin &gt;&gt; str; for(int i = 0; i &lt; str.length(); i++) sam.extend(str[i]-'0'); if(n != 0) sam.extend(10); &#125; queue&lt;int&gt; que; que.push(1); cnt[1] = 1; REP(i, 1, sam.size) REP(j, 0, spc) ++indeg[sam.trans[i][j]]; while(!que.empty()) &#123; int u = que.front(); que.pop(); REP(i, 0, spc) &#123; int v = sam.trans[u][i]; if(!v) continue; if(i != 10) &#123; (cnt[v] += cnt[u]) %= MOD; (val[v] += val[u] * 10 % MOD + (llong)(i * cnt[u] % MOD)) %= MOD; &#125; if(!(--indeg[v])) que.push(v); &#125; &#125; llong ans = 0; for(int i = 1; i &lt;= sam.size; i++) ans = (ans + val[i]) % MOD; printf(\"%lld\\n\", ans);&#125; 串T在串S中的出现次数这个简单，如果是循环同构串，就比较复杂了 hihocoder1465后缀自动机五·重复旋律8 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//// main.cpp// hiho1465-2//// Created by zhangmin chen on 2019/2/25.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define REP(i, l, r) for(int i = (l); i &lt;= (r); i++)#define FOR(i, l, r) for(int i = (l); i &lt; (r); i++)typedef long long llong;const int maxl = 1000000 + 10;const int maxn = 2 * maxl;struct SAM &#123; int maxlen[maxn], trans[maxn][26], link[maxn], size, last; int tag[maxn], indeg[maxn], endpos[maxn]; SAM() &#123; Set(maxlen, 0); Set(trans, 0); Set(link, 0); Set(tag, 0); Set(indeg, 0); Set(endpos, 0); size = last = 1; &#125; void extend(int ch) &#123; int cur = ++size, p = last; tag[cur] = 1; maxlen[cur] = maxlen[p] + 1; for(; p &amp;&amp; !trans[p][ch]; p = link[p]) trans[p][ch] = cur; // relink cur if(!p) link[cur] = 1; else &#123; int q = trans[p][ch]; if(maxlen[p] + 1 == maxlen[q]) link[cur] = q; else &#123; int clone = ++size; tag[clone] = 0; maxlen[clone] = maxlen[p] + 1; Cpy(trans[clone], trans[q]); link[clone] = link[q]; for(; p &amp;&amp; trans[p][ch] == q; p = link[p]) trans[p][ch] = clone; link[cur] = link[q] = clone; &#125; &#125; last = cur; &#125; void build() &#123; for(int i = 1; i &lt;= size; i++) ++indeg[link[i]]; queue&lt;int&gt; que; for(int i = 1; i &lt;= size; i++) if(indeg[i] == 0) &#123; que.push(i); endpos[i] = 1; &#125; while(!que.empty()) &#123; int x = que.front(); que.pop(); if(x == 0) continue; int y = link[x]; indeg[y]--; endpos[y] += endpos[x]; if(indeg[y] == 0) &#123; if(tag[y]) endpos[y]++; que.push(y); &#125; &#125; &#125;&#125;;SAM sam;int version[maxn];llong solve(string&amp; str, int num) &#123; int len = (int)str.length(); int base = len; string str2 = str.substr(0, len-1); str += str2; len = 2*len - 1; int u = 1, lcs = 0; llong ans = 0; for(int i = 0; i &lt; len; i++) &#123; int ch = str[i] - 'a'; if(sam.trans[u][ch]) &#123; u = sam.trans[u][ch]; lcs++; &#125; else &#123; for(; u &amp;&amp; !sam.trans[u][ch]; u = sam.link[u]); if(!u) &#123; u = 1; lcs = 0; &#125; else &#123; lcs = sam.maxlen[u] + 1; u = sam.trans[u][ch]; &#125; &#125; if(lcs &gt; base) &#123; while(sam.maxlen[sam.link[u]] &gt;= base) &#123; u = sam.link[u]; lcs = sam.maxlen[u]; &#125; &#125; if(lcs &gt;= base &amp;&amp; version[u] != num) &#123; version[u] = num; ans += sam.endpos[u]; &#125; &#125; return ans;&#125;string str;int main() &#123; freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; str; for(int i = 0; i &lt; str.length(); i++) sam.extend(str[i] - 'a'); sam.build(); int kase; scanf(\"%d\", &amp;kase); for(int k = 1; k &lt;= kase; k++) &#123; cin &gt;&gt; str; llong res = solve(str, k); printf(\"%lld\\n\", res); &#125;&#125; 后缀自动机+SG函数这个题目难度比较大，和博弈论综合 hihocoder1466后缀自动机六·重复旋律9 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224//// main.cpp// hiho1466//// Created by zhangmin chen on 2019/2/28.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define REP(i, l, r) for(int i = (l); i &lt;= (r); i++)#define FOR(i, l, r) for(int i = (l); i &lt; (r); i++)const int maxl = 100000 + 10;const int maxn = 2*maxl;const int N = 27;// cnt(pre, SG())struct SAM &#123; int len[maxn], trans[maxn][26], link[maxn], size, last; // other arr[] int sg[maxn]; llong cnt[maxn][N+1]; SAM() &#123; Set(len, 0); Set(trans, 0); Set(link, 0); Set(sg, -1); size = 1; last = 1; &#125; void extend(int ch) &#123; int cur = ++size, p = last; // 1 is the \" \" len[cur] = len[p] + 1; //debug(cur); for(; p &amp;&amp; !trans[p][ch]; p = link[p]) trans[p][ch] = cur; // relink cur if(!p) link[cur] = 1; else &#123; int q = trans[p][ch]; if(len[p] + 1 == len[q]) link[cur] = q; else &#123; int clone = ++size; len[clone] = len[p] + 1; Cpy(trans[clone], trans[q]); link[clone] = link[q]; for(; p &amp;&amp; trans[p][ch] == q; p = link[p]) trans[p][ch] = clone; link[cur] = link[q] = clone; &#125; &#125; last = cur; &#125; int SG(int x) &#123; if(sg[x] != -1) return sg[x]; bool flag[28]; for(int i = 0; i &lt; 27; i++) flag[i] = 0; for(int i = 0; i &lt; 26; i++) &#123; int to = trans[x][i]; //debug(to); if(to == 0) continue; flag[SG(to)] = 1; for(int j = 0; j &lt; 27; j++) cnt[x][j] += cnt[to][j]; // I made a bug here, is j &#125; for(int i = 0; i &lt; 27; i++) if(!flag[i]) &#123; sg[x] = i; break; &#125; cnt[x][sg[x]]++; for(int i = 0; i &lt; 27; i++) cnt[x][27] += cnt[x][i]; return sg[x]; &#125; void Debug() &#123; for(int i = 0; i &lt;= size; i++) &#123; printf(\"i: %d:\\n\", i); for(int j = 0; j &lt; 28; j++) /*printf(\"%lld \", cnt[i][j]);*/ debug(cnt[i][j]); printf(\"sg:: %d\\n\", sg[i]); /* for(int j = 0; j &lt; 26; j++) debug(trans[i][j]); */ &#125; &#125; &#125;;SAM A, B;char res[2][maxn];llong k;// cntA[u][sg()] cntB[v][sg()]// (sa_u, sb_v)llong cost(int u, int v) &#123; llong ans = 0; for(int i = 0; i &lt; 27; i++) ans += 1LL * A.cnt[u][i] * (B.cnt[v][27] - B.cnt[v][i]); return ans;&#125;// p is the item of resA[p]// A.sg[x] x = &#123;_, a, b, ab&#125;int dfsA(int p, int x) &#123; llong ct = B.cnt[1][27] - B.cnt[1][A.sg[x]]; //debug(ct); //debug(k); //cout &lt;&lt; endl; // B from 0 to match if(k &lt;= ct) return x; else &#123; k -= ct; for(int i = 0; i &lt; 26; i++) &#123; int to = A.trans[x][i]; if(to == 0) continue; //debug(to); llong ct2 = cost(to, 1); if(ct2 &lt; k) k -= ct2; else &#123; res[0][p] = 'a' + i; return dfsA(p+1, to); // return dfsA(next) &#125; &#125; return -1; &#125; /* // follow the path in SAM for(int i = 0; i &lt; 26; i++) &#123; int to = A.trans[x][i]; if(to == 0) continue; llong ct2 = cost(to, 1); if(ct2 &lt; k) k -= ct2; else &#123; // ct2 &gt;= k, we follow the path and extend char // to reduce ct2 res[0][p] = 'a' + i; debug(res[0]); dfsA(p+1, to); &#125; &#125; if(k &gt; ct) return -1; else return x; */&#125;void dfsB(int p, int x, int T) &#123; k -= A.sg[T] != B.sg[x]; if(k == 0) return; for(int i = 0; i &lt; 26; i++) &#123; int to = B.trans[x][i]; if(to == 0) continue; llong ct = B.cnt[to][27] - B.cnt[to][A.sg[T]]; if(ct &lt; k) k -= ct; else &#123; // reduce ct res[1][p] = 'a' + i; dfsB(p+1, to, T); return; &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); string a, b; cin &gt;&gt; k; cin &gt;&gt; a &gt;&gt; b; //debug(a[0]); for(int i = 0; i &lt; a.length(); i++) A.extend(a[i] - 'a'); A.SG(1); //A.Debug(); for(int i = 0; i &lt; b.length(); i++) B.extend(b[i] - 'a'); B.SG(1); //B.Debug(); int T = dfsA(0, 1); //debug(T); if(T == -1) &#123; printf(\"NO\\n\"); return 0; &#125; dfsB(0, 1, T); puts(res[0]); puts(res[1]);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"}]},{"title":"c++ STL一些小技巧(int和string的相互转换)","slug":"20181024","date":"2018-10-24T12:42:35.000Z","updated":"2018-10-24T13:35:41.924Z","comments":true,"path":"2018/10/24/20181024/","link":"","permalink":"http://www.fogsail.net/2018/10/24/20181024/","excerpt":"c++中的STL在企业的笔试，面试中有一些常见的技巧，string和int的相互转换用的比较多","text":"c++中的STL在企业的笔试，面试中有一些常见的技巧，string和int的相互转换用的比较多 int转stringto_string()12345678910int main() &#123; string pi = \"pi is \" + to_string(3.1415926); float val = 8.967; string num = to_string(val); string perfect = to_string(1+2+4+7+14) + \" is a perfect number\"; cout &lt;&lt; pi &lt;&lt; \"\\n\"; cout &lt;&lt; num &lt;&lt; \"\\n\"; cout &lt;&lt; perfect &lt;&lt; \"\\n\";&#125; 输出结果： 123pi is 3.1415938.96700028 is a perfect number sstream12345678910111213#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;using namespace std;int main() &#123; ostringstream os; int i = 12; os &lt;&lt; i; cout &lt;&lt; \"the data is \" + os.str() &lt;&lt; endl;&#125; 输出结果： 1the data is 12 string转int使用stoi/stol/stoll123456789101112int stoi (const string&amp; str, size_t* idx = 0, int base = 10);idx:Pointer to an object of type size_t, whose value is set by the function to position of the next character in str after the numerical value.This parameter can also be a null pointer, in which case it is not used.idx获取string中，isdigit(str[i])所在位置的next位置值 方法如下：123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; string str_dec = \"2001, A Space Odyssey\"; string str_hex = \"40c3\"; string str_bin = \"-10010110001\"; string str_auto = \"0x7f\"; string::size_type sz; // intention: 解引用 // int *p = &amp;a; int i_dec = stoi(str_dec, &amp;sz); int i_hex = stoi(str_dec, nullptr, 16); int i_bin = stoi(str_bin, nullptr, 2); int i_auto = stoi(str_auto, nullptr, 0); cout &lt;&lt; str_dec &lt;&lt; \": \" &lt;&lt; i_dec &lt;&lt; \"and [ \" &lt;&lt; str_dec.substr(sz) &lt;&lt; \"]\\n\"; cout &lt;&lt; str_hex &lt;&lt; \": \" &lt;&lt; i_hex &lt;&lt; \"\\n\"; cout &lt;&lt; str_bin &lt;&lt; \": \" &lt;&lt; i_bin &lt;&lt; \"\\n\"; cout &lt;&lt; str_auto &lt;&lt; \": \" &lt;&lt; i_auto &lt;&lt; \"\\n\";&#125; 结果： 12342001, A Space Odyssey: 2001and [ , A Space Odyssey]40c3: 8193-10010110001: -12010x7f: 127 atoi()1234567891011#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; string s = \"12\"; int a = atoi(s.c_str()); cout &lt;&lt; a &lt;&lt; endl;&#125; sstream12345678910111213#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;using namespace std;int main() &#123; istringstream is(\"12\"); int i; is &gt;&gt; i; cout &lt;&lt; i &lt;&lt; endl;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"},{"name":"c++","slug":"algorithm/c","permalink":"http://www.fogsail.net/categories/algorithm/c/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"},{"name":"c++","slug":"c","permalink":"http://www.fogsail.net/tags/c/"}]},{"title":"TCP/IP实践(一)：Internet地址结构","slug":"20181008","date":"2018-10-08T10:28:39.000Z","updated":"2018-10-18T17:16:38.111Z","comments":true,"path":"2018/10/08/20181008/","link":"","permalink":"http://www.fogsail.net/2018/10/08/20181008/","excerpt":"目前Internet的地址涉及到IPv4、IPv6和MAC地址这里重点介绍一下IPv6地址的构成，以及和相关地址的转换。","text":"目前Internet的地址涉及到IPv4、IPv6和MAC地址这里重点介绍一下IPv6地址的构成，以及和相关地址的转换。 IPv6地址和接口标识符EUI是唯一扩展标识符，EUI-48和EUI-64由IEEE定义。这些都是用于IPv6的地址，它们是通过将接口标识符取反u位来形成的。 如下图所示： 1234567891011121314step1: 00:30:48:2A:19:89转换为EUI-64，在第三子节后加入ff:fe形成00:30:48:ff:fe:2a:19:89step2: u位被取反0x00 -&gt; 0b 0000 0000 -&gt; 0b 0000 0010即为0x0202:30:48:ff:fe:2a:19:89step3: 完成链路本地的IPv6地址使用保留链路的本地前缀fe80::/10形成完整地址fe80::230:48ff:fe2a:1989(每2个字节为1组，最高位0不写) 获取本机的IPv4/IPv6/MAC地址具体的实现方法如下：mac os获取MAC地址的方法和Linux不同我这里写的是mac os版的Linux更简单了，参见注释就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289//// main.c// GetLocalMAC-IP//// Created by zhangmin chen on 2018/10/8.// Copyright © 2018年 zhangmin chen. All rights reserved.//#include &lt;sys/types.h&gt;#include &lt;ifaddrs.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;net/if.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;//------------now we try to Get MAC Address------#include &lt;CoreFoundation/CoreFoundation.h&gt;#include &lt;IOKit/IOKitLib.h&gt;#include &lt;IOKit/network/IOEthernetInterface.h&gt;#include &lt;IOKit/network/IONetworkInterface.h&gt;#include &lt;IOKit/network/IOEthernetController.h&gt;static kern_return_t FindEthernetInterfaces(io_iterator_t *matchingServices);static kern_return_t GetMACAddress(io_iterator_t intfIterator, UInt8 *MACAddress, UInt8 bufferSize);// Returns an iterator containing the primary (built-in) Ethernet interface. The caller is responsible for// releasing the iterator after the caller is done with it.static kern_return_t FindEthernetInterfaces(io_iterator_t *matchingServices)&#123; kern_return_t kernResult; CFMutableDictionaryRef matchingDict; CFMutableDictionaryRef propertyMatchDict; // Ethernet interfaces are instances of class kIOEthernetInterfaceClass. // IOServiceMatching is a convenience function to create a dictionary with the key kIOProviderClassKey and // the specified value. matchingDict = IOServiceMatching(kIOEthernetInterfaceClass); // Note that another option here would be: // matchingDict = IOBSDMatching(\"en0\"); // but en0: isn't necessarily the primary interface, especially on systems with multiple Ethernet ports. if (NULL == matchingDict) &#123; printf(\"IOServiceMatching returned a NULL dictionary.\\n\"); &#125; else &#123; // Each IONetworkInterface object has a Boolean property with the key kIOPrimaryInterface. Only the // primary (built-in) interface has this property set to TRUE. // IOServiceGetMatchingServices uses the default matching criteria defined by IOService. This considers // only the following properties plus any family-specific matching in this order of precedence // (see IOService::passiveMatch): // // kIOProviderClassKey (IOServiceMatching) // kIONameMatchKey (IOServiceNameMatching) // kIOPropertyMatchKey // kIOPathMatchKey // kIOMatchedServiceCountKey // family-specific matching // kIOBSDNameKey (IOBSDNameMatching) // kIOLocationMatchKey // The IONetworkingFamily does not define any family-specific matching. This means that in // order to have IOServiceGetMatchingServices consider the kIOPrimaryInterface property, we must // add that property to a separate dictionary and then add that to our matching dictionary // specifying kIOPropertyMatchKey. propertyMatchDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); if (NULL == propertyMatchDict) &#123; printf(\"CFDictionaryCreateMutable returned a NULL dictionary.\\n\"); &#125; else &#123; // Set the value in the dictionary of the property with the given key, or add the key // to the dictionary if it doesn't exist. This call retains the value object passed in. CFDictionarySetValue(propertyMatchDict, CFSTR(kIOPrimaryInterface), kCFBooleanTrue); // Now add the dictionary containing the matching value for kIOPrimaryInterface to our main // matching dictionary. This call will retain propertyMatchDict, so we can release our reference // on propertyMatchDict after adding it to matchingDict. CFDictionarySetValue(matchingDict, CFSTR(kIOPropertyMatchKey), propertyMatchDict); CFRelease(propertyMatchDict); &#125; &#125; // IOServiceGetMatchingServices retains the returned iterator, so release the iterator when we're done with it. // IOServiceGetMatchingServices also consumes a reference on the matching dictionary so we don't need to release // the dictionary explicitly. kernResult = IOServiceGetMatchingServices(kIOMasterPortDefault, matchingDict, matchingServices); if (KERN_SUCCESS != kernResult) &#123; printf(\"IOServiceGetMatchingServices returned 0x%08x\\n\", kernResult); &#125; return kernResult;&#125;// Given an iterator across a set of Ethernet interfaces, return the MAC address of the last one.// If no interfaces are found the MAC address is set to an empty string.// In this sample the iterator should contain just the primary interface.static kern_return_t GetMACAddress(io_iterator_t intfIterator, UInt8 *MACAddress, UInt8 bufferSize)&#123; io_object_t intfService; io_object_t controllerService; kern_return_t kernResult = KERN_FAILURE; // Make sure the caller provided enough buffer space. Protect against buffer overflow problems. if (bufferSize &lt; kIOEthernetAddressSize) &#123; return kernResult; &#125; // Initialize the returned address bzero(MACAddress, bufferSize); // IOIteratorNext retains the returned object, so release it when we're done with it. while ((intfService = IOIteratorNext(intfIterator))) &#123; CFTypeRef MACAddressAsCFData; // IONetworkControllers can't be found directly by the IOServiceGetMatchingServices call, // since they are hardware nubs and do not participate in driver matching. In other words, // registerService() is never called on them. So we've found the IONetworkInterface and will // get its parent controller by asking for it specifically. // IORegistryEntryGetParentEntry retains the returned object, so release it when we're done with it. kernResult = IORegistryEntryGetParentEntry(intfService, kIOServicePlane, &amp;controllerService); if (KERN_SUCCESS != kernResult) &#123; printf(\"IORegistryEntryGetParentEntry returned 0x%08x\\n\", kernResult); &#125; else &#123; // Retrieve the MAC address property from the I/O Registry in the form of a CFData MACAddressAsCFData = IORegistryEntryCreateCFProperty(controllerService, CFSTR(kIOMACAddress), kCFAllocatorDefault, 0); if (MACAddressAsCFData) &#123; CFShow(MACAddressAsCFData); // for display purposes only; output goes to stderr // Get the raw bytes of the MAC address from the CFData CFDataGetBytes(MACAddressAsCFData, CFRangeMake(0, kIOEthernetAddressSize), MACAddress); CFRelease(MACAddressAsCFData); &#125; // Done with the parent Ethernet controller object so we release it. (void) IOObjectRelease(controllerService); &#125; // Done with the Ethernet interface object so we release it. (void) IOObjectRelease(intfService); &#125; return kernResult;&#125;//print Hex datavoid pHx(unsigned char* p, int len) &#123; printf(\"Hex: \"); for(int i = 0; i &lt; len; i++) &#123; printf(\"%02X:\", p[i]); &#125; printf(\"\\b\\n\");&#125;// get local mac// For Linux/* * for linux * * char* getMac(char* mac, char* dv) &#123; struct ifreq ifr; int sock; if(!mac || dv) return mac; if( (sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0 ) &#123; perror(\"socket \"); return mac; &#125; strcpy(ifr.ifr_name, dv); if(ioctl(sock, SIOCGIFHWADDR, &amp;ifr) &lt; 0) &#123; //SIOCGIFHWADDR perror(\"ioctl \"); return mac; &#125; pHx( (unsigned char*)ifr.ifr_ifru.ifru_addr.sa_data, sizeof(ifr.ifr_ifru.ifru_addr.sa_data) ); //eth length of MAC is 48bits sprintf(mac, \"%02X:%02X:%02X:%02X:%02X:%02X\", (unsigned char)ifr.ifr_ifru.ifru_addr.sa_data[0], (unsigned char)ifr.ifr_ifru.ifru_addr.sa_data[1], (unsigned char)ifr.ifr_ifru.ifru_addr.sa_data[2], (unsigned char)ifr.ifr_ifru.ifru_addr.sa_data[3], (unsigned char)ifr.ifr_ifru.ifru_addr.sa_data[4], (unsigned char)ifr.ifr_ifru.ifru_addr.sa_data[5]); return mac; &#125; */int main(int argc, const char* argv[]) &#123; char hostname[128]; struct hostent* hostent1; // int i; gethostname(hostname, sizeof(hostname)); hostent1 = gethostbyname(hostname); printf(\"Hostname: %s\\n\", hostent1-&gt;h_name); printf(\"\\n\"); // char mac[30]; struct ifaddrs* ifap0 = NULL, *ifap = NULL; void* addPtr = NULL; getifaddrs(&amp;ifap0); ifap = ifap0; while(ifap != NULL) &#123; if(ifap-&gt;ifa_addr-&gt;sa_family == AF_INET) &#123; // is a valid IPv4 address addPtr = &amp; ((struct sockaddr_in *)ifap-&gt;ifa_addr)-&gt;sin_addr; char addressBuffer[INET_ADDRSTRLEN]; inet_ntop(AF_INET, addPtr, addressBuffer, INET_ADDRSTRLEN); if(strcmp(addressBuffer, \"127.0.0.1\") != 0) &#123; printf(\"%s IPv4: %s\\n\", ifap-&gt;ifa_name, addressBuffer); &#125; &#125; else if(ifap-&gt;ifa_addr-&gt;sa_family == AF_INET6) &#123; // is a valid IPv6 address addPtr = &amp; ((struct sockaddr_in *)ifap-&gt;ifa_addr)-&gt;sin_addr; char addressBuffer[INET6_ADDRSTRLEN]; inet_ntop(AF_INET6, addPtr, addressBuffer, INET6_ADDRSTRLEN); if(strcmp(addressBuffer, \"::\") != 0) &#123; printf(\"%s IPv6: %s\\n\", ifap-&gt;ifa_name, addressBuffer); &#125; &#125; ifap = ifap-&gt;ifa_next; &#125; if(ifap0) &#123; freeifaddrs(ifap0); ifap0 = NULL; &#125; printf(\"\\n\\n\"); printf(\"--------Now we try to get MAC address----------------\\n\"); printf(\"\\n\"); kern_return_t kernResult = KERN_SUCCESS; io_iterator_t intfIterator; UInt8 MACAddress[kIOEthernetAddressSize]; kernResult = FindEthernetInterfaces(&amp;intfIterator); if(KERN_SUCCESS != kernResult) &#123; printf(\"FindEthernetInterfaces returned 0x%08x\\n\", kernResult); &#125; else &#123; kernResult = GetMACAddress(intfIterator, MACAddress, sizeof(MACAddress)); if(KERN_SUCCESS != kernResult) &#123; printf(\"GetMACAddress return 0x%08x\\n\", kernResult); &#125; else &#123; printf(\"This system's built-in MAC address is %02x:%02x:%02x:%02x:%02x:%02x.\\n\", MACAddress[0], MACAddress[1], MACAddress[2], MACAddress[3], MACAddress[4], MACAddress[5]); &#125; &#125; (void) IOObjectRelease(intfIterator); return kernResult; &#125; IPv4组播地址常见的组播地址： 123224.0.0.0 - 224.0.0.255本地网络控制，不转发，相当于是组播的范围边界发送到这些地址的数据报不被转发 12224.0.1.0 - 224.0.1.255例：NTP(网络时间协议)组播组(224.0.1.1) 123224.0.2.0 - 224.0.255.255Ad hoc块1保留一些地址 1234224.2.0.0 - 224.2.255.255SDP/SAP会话描述工具 12345232.0.0.0 - 232.255.255.255源特定组播(SSM)例：某些应用使用SSM块实现SSM结合自己的单源地址形成一个SSM信道 123456233.0.0.0 - 233.251.255.255GLOP块，组播地址基于主机的AS号将AS号放入IPv4地址的第2、3字节中例: 233.__.__.255__填充的是16bits的AS number 12345678910234.0.0.0 - 234.255.255.255235.0.0.0 - 238.255.255.255基于单播前缀的IPv4组播地址保留什么意思呢？就是给单播地址分配一个相关的UBM地址例: 192.0.2.0/24 --&gt; 234.192.0.2看下图，如果我们知道组播地址234.128.32.0/24去掉前缀234，然后左移8位，128.32.0.0/16分配给加州大学伯克利分校 IPv6组播 123456789一个组织分配了单播前缀3ffe:ffff:1::/48前缀长度: 48 = 0b110000 = 0011 0000第2字段的值为：0000 0000 0011 0000 -&gt; 0x0030 -&gt; 30ff3x:30:3ff3:fff:1::/96(96 = 128-32) 12345678可以根据IID(接口标识符)形成自己的组播地址IID = 02-11-22-33-44-55-66-77使用前缀形式ff3x:0011/32组播地址为：ff3x:0011:0211:2233:4455:6677:gggg:gggg(gggg:gggg为32位组组播组ID的16进制表示 RP的单播IPv6地址嵌入IPv6组播地址 12345678910111、取出64位前缀2、取出RIID字段3、获取RP地址组播地址ff75:940:2001:db8:dead:beef:f00d:face前缀 - 2001:db8:dead:beefRIID - 0x9前缀长度 - 0x40(64)RP地址 - 2001:db8:dead:beef::9 单播地址分配单个供应商/无网络/单个地址这里介绍一些特殊的地址 1、IPv4回送地址：127.0.0.0/8主机和IP堆栈内部的地址，主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回之，不进行任何网络传输。 2、IPv6组播地址: ff02::1ff02表示同一链路/子网中所有的NTP服务器","categories":[{"name":"computer networks","slug":"computer-networks","permalink":"http://www.fogsail.net/categories/computer-networks/"}],"tags":[{"name":"computer networks","slug":"computer-networks","permalink":"http://www.fogsail.net/tags/computer-networks/"}]},{"title":"实现操作系统：BootLoader引导程序(一)","slug":"20180828","date":"2018-08-27T13:08:22.000Z","updated":"2018-08-27T14:06:16.919Z","comments":true,"path":"2018/08/27/20180828/","link":"","permalink":"http://www.fogsail.net/2018/08/27/20180828/","excerpt":"目前国内的很多计算机资料，大多都是讲述《操作系统原理》，涉及到具体操作系统的实现，能够找到的参考资料非常少。 这里我尝试自己独立实现一个操作系统这篇文章主要介绍了操作系统的环境配置并且独立实现一个hello world!","text":"目前国内的很多计算机资料，大多都是讲述《操作系统原理》，涉及到具体操作系统的实现，能够找到的参考资料非常少。 这里我尝试自己独立实现一个操作系统这篇文章主要介绍了操作系统的环境配置并且独立实现一个hello world! Bochs虚拟机的安装官网下载解压什么的，不赘述。 我安装在/opt/bochs-2.6.9下面 1sudo ./configure --with-x11 --with-wx --enable-debugger --enable-disasm 12sudo makesudo make install 安装完成后，在terminal输入bochs如下第一次输入bochs的结果如下： 很显然是因为.bochsrc文件没有配置成功。不过这个问题先放一放，我们稍后解决 往Bochs虚拟机内装软盘用专业一点的话说，就是创建虚拟软盘镜像文件。但实际上就是往虚拟机里面插入一张软盘。 具体的方法1bximage 其实这个一步一步就可以不再赘述，看下图 编程实现引导程序boot.asm123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 org 0x7c00 //start from 0x7c00BaseOfStack equ 0x7c00Label_Start: mov ax, cs mov ds, ax mov es, ax mov ss, ax mov sp, BaseOfStack;======= clear screen mov ax, 0600h mov bx, 0700h mov cx, 0 mov dx, 0184fh int 10h;======= set focus mov ax, 0200h mov bx, 0000h mov dx, 0000h int 10h;======= display on screen : Start Booting...... mov ax, 1301h mov bx, 000fh mov dx, 0000h mov cx, 10 push ax mov ax, ds mov es, ax pop ax mov bp, StartBootMessage int 10h;======= reset floppy xor ah, ah xor dl, dl int 13h jmp $StartBootMessage: db \"Start Boot\" //can be changed, such as \"I love you\";======= fill zero until whole sector times 510 - ($ - $$) db 0 dw 0xaa55 编译上一步的asm文件1sudo dd if=boot.bin of=/opt/bochs-2.6.9/boot.img bs=512 count=1 conv=notrunc 其实，上一步就做了一件事情，我们把引导文件写入软盘镜像传输块的大小为512B，参数count=1指定写入到目标文件的块数量conv=notrunc表示写入数据后不截断输出文件尺寸的大小 启动bochs虚拟机配置bochsrc文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# configuration file generated by Bochsplugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1, iodebug=1config_interface: textconfigdisplay_library: x#memory: host=2048, guest=2048romimage: file=\"/usr/local/share/bochs/BIOS-bochs-latest\"vgaromimage: file=\"/usr/local/share/bochs/VGABIOS-lgpl-latest\"boot: floppyfloppy_bootsig_check: disabled=0floppya: type=1_44, 1_44=\"boot.img\", status=inserted, write_protected=0# no floppybata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14ata0-master: type=noneata0-slave: type=noneata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15ata1-master: type=noneata1-slave: type=noneata2: enabled=0ata3: enabled=0pci: enabled=1, chipset=i440fxvga: extension=vbe, update_freq=5print_timestamps: enabled=0debugger_log: -magic_break: enabled=0port_e9_hack: enabled=0private_colormap: enabled=0clock: sync=none, time0=local, rtc_sync=0# no cmosimage# no loaderlog: -logprefix: %t%e%ddebug: action=ignoreinfo: action=reporterror: action=reportpanic: action=askkeyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=nonemouse: type=ps2, enabled=0, toggle=ctrl+mbuttonspeaker: enabled=1, mode=systemparport1: enabled=1, file=noneparport2: enabled=0com1: enabled=1, mode=nullcom2: enabled=0com3: enabled=0com4: enabled=0megs: 2048 启动文件这里注意一下必须在/opt/bochs-2.6.9目录下执行 12cd /opt/bochs-2.6.9sudo bochs -f '/home/fogsail/Software/os-boot/bochsrc' 最后按下c键，自然出现了start boot，表示操作系统启动啦～","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.fogsail.net/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.fogsail.net/tags/操作系统/"}]},{"title":"用vscode打造macOS下c/c++编译利器","slug":"20180827","date":"2018-08-26T16:04:05.000Z","updated":"2018-08-26T16:26:45.569Z","comments":true,"path":"2018/08/27/20180827/","link":"","permalink":"http://www.fogsail.net/2018/08/27/20180827/","excerpt":"在macOS环境下写c/c++， 如果是大型项目的话，可以考虑用IDE比如xcode等等但是如果仅仅是写一些小型的模块，或者说是研究一些算法，刷leetcode等等，用vscode就足够方便了。","text":"在macOS环境下写c/c++， 如果是大型项目的话，可以考虑用IDE比如xcode等等但是如果仅仅是写一些小型的模块，或者说是研究一些算法，刷leetcode等等，用vscode就足够方便了。 测试程序Hello world123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int result; int a = 2; int b = 3; result = a + b; cout &lt;&lt; result&lt;&lt; endl; return 0;&#125; 写配置文件tasks.json用快捷键shift+command+p打开Tasks: Configure Tasks选择Create tasks.json file from templates此时会蹦出一个下拉列表，在下拉列表中选择Others 自动生成一个task.json文件 配置如下： 12345678910111213141516171819202122&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ &#123; \"label\": \"helloworld\", \"type\": \"shell\", \"command\": \"g++\", \"args\": [ \"$&#123;file&#125;\", \"-o\", \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out\", \"-g\" ], \"group\": &#123; \"kind\": \"build\", \"isDefault\": true &#125; &#125; ]&#125; launch.json找到虫子的图标，如下图所示 简单修改之后，配置launch.json如下 1234567891011121314151617181920&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"(lldb) Launch\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"$&#123;workspaceFolder&#125;\", \"environment\": [], \"externalConsole\": true, \"MIMode\": \"lldb\" &#125; ]&#125; 设置断点，F5调试切换到helloworld.cpp快捷键command+shift+b对源文件进行编译编译成功后，F5调试 调试成功的图案如下：","categories":[{"name":"杂乱的技术","slug":"杂乱的技术","permalink":"http://www.fogsail.net/categories/杂乱的技术/"}],"tags":[{"name":"杂乱的技术","slug":"杂乱的技术","permalink":"http://www.fogsail.net/tags/杂乱的技术/"},{"name":"c/c++","slug":"c-c","permalink":"http://www.fogsail.net/tags/c-c/"}]},{"title":"算法竞赛入门：基础算法(二)","slug":"20180824","date":"2018-08-24T13:46:16.000Z","updated":"2019-04-11T20:57:37.265Z","comments":true,"path":"2018/08/24/20180824/","link":"","permalink":"http://www.fogsail.net/2018/08/24/20180824/","excerpt":"这里介绍几种非常有意思的技巧，比如剥洋葱法。","text":"这里介绍几种非常有意思的技巧，比如剥洋葱法。 Image is Everything剥洋葱，k from 1 to 6, means k view123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define REP(i,n) for(int i = 0; i &lt; (n); i++)const int maxn = 10;int n;char pos[maxn][maxn][maxn];char view[maxn][maxn][maxn];char read_char()&#123; char ch; for(;;)&#123; ch = getchar(); if( (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || ch == '.' ) return ch; &#125;&#125;void getxyz(int k, int i, int j, int depth, int&amp; x, int&amp; y, int&amp; z)&#123; if(k == 0)&#123; x = depth; y = j; z = i; &#125; if(k == 1)&#123; x = n-1-j; y = depth; z = i; &#125; if(k == 2)&#123; x = n-1-depth; y = n-1-j; z = i; &#125; if(k == 3)&#123; x = j; y = n-1-depth; z = i; &#125; if(k == 4)&#123; x = n-1-i; y = j; z = depth; &#125; if(k == 5)&#123; x = i; y = j; z = n-1-depth; &#125;&#125;void init(int n)&#123; REP(i,n) REP(k,6) REP(j,n)&#123; view[k][i][j] = read_char(); &#125; //k视图 REP(i,n) REP(j,n) REP(l,n)&#123; pos[i][j][l] = '#'; &#125;&#125;int cntempty()&#123; int ans = 0; REP(i,n) REP(j,n) REP(k,n)&#123; if(pos[i][j][k] != '.') ans++; &#125; return ans;&#125;int cal() &#123; REP(k,6) REP(i,n) REP(j,n)&#123; if(view[k][i][j] == '.')&#123; REP(dep,n)&#123; int x,y,z; getxyz(k,i,j,dep,x,y,z); pos[x][y][z] = '.'; &#125; &#125; &#125; // finished clean position // //循环一层一层删除，到最后不能删除为止 //每次删除一层，就得到一个新的立方体 //新的立方体作为start，继续执行删除，直到不能删除为止 for(;;)&#123; bool finished = true; REP(k,6) REP(i,n) REP(j,n)&#123; if(view[k][i][j] != '.')&#123; REP(dep,n)&#123; //一层一层检查，一层一层剥开你的心 int x,y,z; getxyz(k,i,j,dep,x,y,z); if(pos[x][y][z] == '.') continue; if(pos[x][y][z] == '#')&#123; pos[x][y][z] = view[k][i][j]; break; &#125; if(pos[x][y][z] == view[k][i][j]) break; pos[x][y][z] = '.'; finished = false; //所有视图删除完之后，作为一个新的立方体 //重新进入循环 //删除！一直删到不能删为止 &#125; &#125; &#125; if(finished) break; &#125; return cntempty();&#125;int main()&#123; while(scanf(\"%d\",&amp;n) == 1 &amp;&amp; n)&#123; memset(pos,0, sizeof(pos)); memset(view,0, sizeof(view)); init(n); int ans = cal(); printf(\"Maximum weight: %d gram(s)\\n\",ans); &#125;&#125; graveyard 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n,m; while(scanf(\"%d%d\",&amp;n,&amp;m) == 2)&#123; double ans = 0.0; for(int i = 0; i &lt; n; i++)&#123; double pos = (double) i / n * (n+m); ans += fabs(pos-floor(pos+0.5)) / (n+m); &#125; printf(\"%.4lf\\n\",ans*10000); &#125;&#125; even-parity算法分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;const int maxn = 20;int data[maxn][maxn], buffer[maxn][maxn];int n;int check(int val)&#123; memset(buffer,0, sizeof(buffer)); for(int c = 0; c &lt; n; c++)&#123; if(val &amp; (1&lt;&lt;c)) buffer[0][c] = 1; //enumerate else&#123; // the number in high bits is 0 if(data[0][c] == 1) // not 0，contradict with default // enumerate default --&gt; binary bits return INF; &#125; &#125; for(int r = 1; r &lt; n; r++)&#123; for(int c = 0; c &lt; n; c++)&#123; int sum = 0; if(r &gt; 1) sum += buffer[r-2][c]; if(c &gt; 0) sum += buffer[r-1][c-1]; if(c+1 &lt; n) sum += buffer[r-1][c+1]; buffer[r][c] = sum % 2; if(data[r][c] == 1 &amp;&amp; buffer[r][c] == 0) return INF; &#125; &#125; int cnt = 0; for(int r = 0; r &lt; n; r++)&#123; for(int c = 0; c &lt; n; c++)&#123; if(data[r][c] != buffer[r][c]) cnt++; &#125; &#125; return cnt;&#125;int main()&#123; int kase; int k = 0; scanf(\"%d\",&amp;kase); while(kase--)&#123; scanf(\"%d\",&amp;n); for(int r = 0; r &lt; n; r++)&#123; for(int c = 0; c &lt; n; c++) scanf(\"%d\",&amp;data[r][c]); &#125; int ans = INF; for(int v = 0; v &lt; (1 &lt;&lt; n); v++)&#123; ans = min(ans,check(v)); &#125; if(ans == INF) ans = -1; printf(\"Case %d: %d\\n\",++k,ans); &#125;&#125; RAID算法分析图解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 6500;char data[8][maxn];bool parity;int d,s,b,w;char type;bool fix()&#123; w = s*b; for(int i = 0; i &lt; w; i++)&#123; int sum = 0; int bro_cnt = 0, bro_id = 0; for(int j = 0; j &lt; d; j++)&#123; if(data[j][i] == '1')&#123; sum++; &#125; if(data[j][i] == 'x')&#123; bro_cnt++; bro_id = j; &#125; &#125; sum %= 2; if(bro_cnt &gt;= 2) return false; else if(bro_cnt == 1)&#123; if(sum)&#123; if(parity) data[bro_id][i] = '0'; else data[bro_id][i] = '1'; &#125;else&#123; if(parity) data[bro_id][i] = '1'; else data[bro_id][i] = '0'; &#125; &#125;else if(bro_cnt == 0)&#123; if(parity == 0 &amp;&amp; sum == 1) return false; if(parity == 1 &amp;&amp; sum == 0) return false; &#125; &#125; return true;&#125;void printdata()&#123; int sum = 0; int bit_cnt = 0; for(int i = 0; i &lt; b; i++)&#123; int except = i % d; for(int j = 0; j &lt; d; j++)&#123; if(j == except) continue; for(int k = i*s; k &lt; i*s+s; k++)&#123; bit_cnt = (bit_cnt+1) % 4; if(data[j][k] == '0') sum = sum &lt;&lt; 1; if(data[j][k] == '1') sum = (sum &lt;&lt; 1) + 1; if(bit_cnt == 0)&#123; // bit finish! printf(\"%X\",sum); sum = 0; &#125; &#125; &#125; &#125; if(bit_cnt)&#123; // complete 0 int add_0 = 4 - bit_cnt; sum = sum &lt;&lt; add_0; printf(\"%X\",sum); &#125; printf(\"\\n\");&#125;int main()&#123; int kase = 0; while(cin &gt;&gt; d &amp;&amp; d)&#123; memset(data, 0, sizeof(data)); cin &gt;&gt; s &gt;&gt; b &gt;&gt; type; parity = type == 'O'; for(int i = 0; i &lt; d; i++) cin &gt;&gt; data[i]; if(!fix()) printf(\"Disk set %d is invalid.\\n\",++kase); else&#123; printf(\"Disk set %d is valid, contents are: \",++kase); printdata(); &#125; &#125; return 0;&#125; 非常重要的一种枚举思想: Colored Cubes枚举的核心，在于相对位置的变化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240//// main.cpp// coloredCubes//// Created by zhangmin chen on 2019/4/11.// Copyright © 2019 zhangmin chen. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long llong;#define Cpy(a, b) memcpy(a, b, sizeof(a))#define Set(a, v) memset(a, v, sizeof(a))#define debug(x) cout &lt;&lt; #x &lt;&lt; \": \" &lt;&lt; x &lt;&lt; endl#define _rep(i, l, r) for(int i = (l); i &lt;= (r); i++)#define _for(i, l, r) for(int i = (l); i &lt; (r); i++)#define debug_(ch, i) printf(#ch\"[%d]: %d\\n\", i, ch[i])#define debug_m(mp, p) printf(#mp\"[%d]: %d\\n\", p-&gt;first, p-&gt;second)/*int Left[6] = &#123;4, 0, 2, 3, 5, 1&#125;;int Up[6] = &#123;2, 1, 5, 0, 4, 3&#125;;void rot(int* trans, int* pos) &#123; int q[6]; memcpy(q, pos, sizeof(q)); for(int i = 0; i &lt; 6; i++) &#123; pos[i] = trans[q[i]]; &#125;&#125;void enumerate() &#123; int p0[6] = &#123;0, 1, 2, 3, 4, 5&#125;; printf(\"dice24[24][6]: \\n\"); for(int i = 0; i &lt; 6; i++) &#123; int q[6]; memcpy(q, p0, sizeof(q)); if(i == 0) rot(Up, q); if(i == 1) &#123; rot(Left, q); rot(Up, q); &#125; if(i == 3) &#123; rot(Up, q); rot(Up, q); &#125; if(i == 4) &#123; rot(Left, q); rot(Left, q); rot(Left, q); rot(Up, q); &#125; if(i == 5) &#123; rot(Left, q); rot(Left, q); rot(Up, q); &#125; for(int k = 0; k &lt; 4; k++) &#123; printf(\"&#123;%d, %d, %d, %d, %d, %d&#125;,\\n\", q[0], q[1], q[2], q[3], q[4], q[5]); rot(Left, q); &#125; &#125; cout &lt;&lt; endl;&#125;int main() &#123; enumerate();&#125; *//* * dice24[24][6]: &#123;2, 1, 5, 0, 4, 3&#125;, &#123;2, 0, 1, 4, 5, 3&#125;, &#123;2, 4, 0, 5, 1, 3&#125;, &#123;2, 5, 4, 1, 0, 3&#125;, &#123;4, 2, 5, 0, 3, 1&#125;, &#123;5, 2, 1, 4, 3, 0&#125;, &#123;1, 2, 0, 5, 3, 4&#125;, &#123;0, 2, 4, 1, 3, 5&#125;, &#123;0, 1, 2, 3, 4, 5&#125;, &#123;4, 0, 2, 3, 5, 1&#125;, &#123;5, 4, 2, 3, 1, 0&#125;, &#123;1, 5, 2, 3, 0, 4&#125;, &#123;5, 1, 3, 2, 4, 0&#125;, &#123;1, 0, 3, 2, 5, 4&#125;, &#123;0, 4, 3, 2, 1, 5&#125;, &#123;4, 5, 3, 2, 0, 1&#125;, &#123;1, 3, 5, 0, 2, 4&#125;, &#123;0, 3, 1, 4, 2, 5&#125;, &#123;4, 3, 0, 5, 2, 1&#125;, &#123;5, 3, 4, 1, 2, 0&#125;, &#123;3, 4, 5, 0, 1, 2&#125;, &#123;3, 5, 1, 4, 0, 2&#125;, &#123;3, 1, 0, 5, 4, 2&#125;, &#123;3, 0, 4, 1, 5, 2&#125;, */const int dice24[24][6] = &#123; // &#123;2, 1, 5, 0, 4, 3&#125;, &#123;2, 0, 1, 4, 5, 3&#125;, &#123;2, 4, 0, 5, 1, 3&#125;, &#123;2, 5, 4, 1, 0, 3&#125;, &#123;4, 2, 5, 0, 3, 1&#125;, &#123;5, 2, 1, 4, 3, 0&#125;, &#123;1, 2, 0, 5, 3, 4&#125;, &#123;0, 2, 4, 1, 3, 5&#125;, &#123;0, 1, 2, 3, 4, 5&#125;, &#123;4, 0, 2, 3, 5, 1&#125;, &#123;5, 4, 2, 3, 1, 0&#125;, &#123;1, 5, 2, 3, 0, 4&#125;, &#123;5, 1, 3, 2, 4, 0&#125;, &#123;1, 0, 3, 2, 5, 4&#125;, &#123;0, 4, 3, 2, 1, 5&#125;, &#123;4, 5, 3, 2, 0, 1&#125;, &#123;1, 3, 5, 0, 2, 4&#125;, &#123;0, 3, 1, 4, 2, 5&#125;, &#123;4, 3, 0, 5, 2, 1&#125;, &#123;5, 3, 4, 1, 2, 0&#125;, &#123;3, 4, 5, 0, 1, 2&#125;, &#123;3, 5, 1, 4, 0, 2&#125;, &#123;3, 1, 0, 5, 4, 2&#125;, &#123;3, 0, 4, 1, 5, 2&#125;&#125;;const int maxn = 4;int colors[maxn][6];int n;int dice[maxn][6];int posD[maxn];int ans;// posD[i] = val, means No.i dice choose posture// dice24[val][...]void painting(int colors[][6], int dice[][6]) &#123; // posD[i] = val, means No.i dice choose posture // dice24[val][..] for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; 6; j++) &#123; // No.i dice surface j // dice[i][j] changed to position p = posD[i][j]; // subscript is postion p // color[i][p] = dice[i][j] int p = dice24[posD[i]][j]; colors[i][p] = dice[i][j]; &#125;&#125;void solve() &#123; // posD[i] = val, means No.i dice choose posture // dice24[val][..] painting(colors, dice); int tot = 0; for(int k = 0; k &lt; 6; k++) &#123; int cnt[maxn * 6]; memset(cnt, 0, sizeof(cnt)); int maxface = 0; for(int i = 0; i &lt; n; i++) &#123; maxface = max(maxface, ++cnt[colors[i][k]]); //debug(maxface); &#125; tot += n-maxface; &#125; ans = min(ans, tot); //debug(ans);&#125;vector&lt;string&gt; nColor;int getID(const char* name) &#123; // string str(name); int id = (int)nColor.size(); for(int i = 0; i &lt; nColor.size(); i++) &#123; if(nColor[i] == str) return i; &#125; nColor.push_back(str); return id;&#125;void dfs(int d) &#123; if(d == n) solve(); else &#123; for(int i = 0; i &lt; 24; i++) &#123; // dice[24][..] // choose one posture of dice[24][..] // depth d cubes choose posture dice[i] posD[d] = i; //_for(i, 0, maxn) debug_(posD, i); dfs(d+1); &#125; &#125;&#125;int main() &#123; freopen(\"input.txt\", \"r\", stdin); while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; // nColor.clear(); //memset(posD, 0, sizeof(posD)); //memset(colors, 0, sizeof(colors)); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; 6; j++) &#123; char name[30]; scanf(\"%s\", name); dice[i][j] = getID(name); //debug(dice[i][j]); &#125; // solve() //posD[0] = 0; ans = n*6; dfs(1); printf(\"%d\\n\", ans); &#125;&#125; IP地址与二进制 IP Networks具体涉及到二进制的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;assert.h&gt;using namespace std;#define _for(i,a,b) for( int i = (a); i &lt; (b); i++ )#define _rep(i,a,b) for( int i = (a); i &lt;= (b); i++ )const int W = 8, IPW = 4*W;bool inrange(int val, int a, int b)&#123; if(a &gt; b) return inrange(val, b, a); return a &lt;= val &amp;&amp; val &lt;= b;&#125;void toBinary(int val, int* bin, int pos)&#123; assert(inrange(val,0,255)); _for(i,0,W)&#123; bin[pos+W-1-i] = val % 2; val /= 2; &#125;&#125;void printip(const int* bin)&#123; bool first = true; for(int i = 0; i &lt; 4; i++)&#123; int x = 0; for(int k = i*W; k &lt; (i+1)*W; k++)&#123; x = (x &lt;&lt; 1) | bin[k]; &#125; if(first) first = false; else printf(\".\"); printf(\"%d\",x); &#125; puts(\"\");&#125;const int maxn = 1024;int subip[maxn][IPW+5];int main()&#123; int subNet[IPW]; int n, ip[4]; while(scanf(\"%d\",&amp;n) == 1)&#123; _for(i,0,n)&#123; scanf(\"%d.%d.%d.%d\",&amp;ip[0],&amp;ip[1],&amp;ip[2],&amp;ip[3]); _for(j,0,4)&#123; toBinary(ip[j],subip[i],j*W); &#125; &#125; //finished! Get ip binary presentation memset(subNet,0,sizeof(subNet)); //enumerate int len; for(len = 0; len &lt; IPW; len++)&#123; bool same = true; //erogodic for(int p = 1; p &lt; n; p++)&#123; if(subip[p-1][len] != subip[p][len])&#123; same = false; break; &#125; &#125; if(!same) break; &#125; //len: position-&gt; the first different element //len start from 0, it means the longest length fill_n(subNet,len,1); fill_n(subip[0]+len,IPW-len,0); printip(subip[0]); printip(subNet); &#125;&#125; Morse Mismatches表的建立： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;unordered_map&lt;char, string&gt; morse;unordered_map&lt;string, vector&lt;string&gt; &gt; context;bool isprefix(const string&amp; A, const string&amp; B)&#123; return A.size() &lt; B.size() &amp;&amp; B.compare(0,A.size(),A) == 0;&#125;void solve(const string&amp; m)&#123; if(context.count(m))&#123; const auto&amp; word_v = context[m]; cout &lt;&lt; word_v.front(); if(word_v.size() &gt; 1)&#123; cout &lt;&lt; \"!\"; &#125; cout &lt;&lt; endl; return; &#125; map&lt;int, string&gt; ans; for(const auto&amp; it: context)&#123; const string&amp; m_ext = it.first; if(isprefix(m, m_ext)) ans[m_ext.size()-m.size()] = it.second.front(); else if(isprefix(m_ext, m)) ans[m.size()-m_ext.size()] = it.second.front(); &#125; cout &lt;&lt; ans.begin() -&gt; second &lt;&lt; \"?\" &lt;&lt; endl;&#125;int main()&#123; string alpha,M; while(cin &gt;&gt; alpha &amp;&amp; alpha != \"*\")&#123; cin &gt;&gt; M; morse[alpha[0]] = M; &#125; while(cin &gt;&gt; alpha &amp;&amp; alpha != \"*\")&#123; M.clear(); for(auto p : alpha)&#123; M += morse[p]; &#125; context[M].push_back(alpha); &#125; while(cin &gt;&gt; M &amp;&amp; M != \"*\")&#123; solve(M); &#125; return 0;&#125; extraordinarily tired students 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;struct stu&#123; int a; int b; int c;&#125;;#define MAX_TIME 1000000int n;istream&amp; operator&gt;&gt; (istream&amp; is, stu&amp; s) &#123; return is &gt;&gt; s.a &gt;&gt; s.b &gt;&gt; s.c;&#125;stu stus[10+5];bool action(int kase,int t)&#123; int wake = 0, sleep = 0; for(int i = 0; i &lt; n; i++)&#123; if(stus[i].c &lt;= stus[i].a) wake++; &#125; sleep = n-wake; if(sleep == 0)&#123; cout &lt;&lt; \"Case \" &lt;&lt; kase &lt;&lt; \": \" &lt;&lt; t &lt;&lt; endl; return true; &#125; for(int i = 0; i &lt; n; i++)&#123; stu&amp; s = stus[i]; s.c++; if(s.c == s.a + s.b + 1) s.c = 1; if(s.c == s.a + 1 &amp;&amp; wake &gt;= sleep) s.c = 1; &#125; return false;&#125;int main()&#123; int kase = 1; while(scanf(\"%d\",&amp;n) &amp;&amp; n)&#123; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; stus[i]; &#125; int t; for(t = 1; t &lt; MAX_TIME; t++)&#123; if(action(kase, t)) break; &#125; if(t == MAX_TIME) cout &lt;&lt; \"Case \" &lt;&lt; kase &lt;&lt; \": \" &lt;&lt; \"-1\" &lt;&lt; endl; kase++; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"}]},{"title":"算法竞赛入门：基础算法(一)","slug":"20180823","date":"2018-08-23T12:18:00.000Z","updated":"2019-03-07T03:58:14.441Z","comments":true,"path":"2018/08/23/20180823/","link":"","permalink":"http://www.fogsail.net/2018/08/23/20180823/","excerpt":"函数的嵌套，加上递归处理，能够解决非常多生活背景下的模拟问题","text":"函数的嵌套，加上递归处理，能够解决非常多生活背景下的模拟问题 Ancient Cipher核心算法图解： 实现方法：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;int cmp(const void *a,const void *b)&#123; return *(int *)a - *(int *)b;&#125;int main()&#123; char s1[200], s2[200]; while((scanf(\"%s%s\",s1,s2)==2)) &#123; int n = strlen(s1); int cnt1[26]=&#123;0&#125;, cnt2[26]=&#123;0&#125;; for(int i = 0; i &lt; n; i++) cnt1[ s1[i]-'A' ]++; for(int i = 0; i &lt; n; i++) cnt2[ s2[i]-'A' ]++; qsort(cnt1,26,sizeof(int),cmp); qsort(cnt2,26,sizeof(int),cmp); int flag = 1; for(int i = 0 ; i &lt; 26; i++) &#123; if(cnt1[i] != cnt2[i]) flag = 0; &#125; if(flag) printf(\"YES\\n\"); else printf(\"NO\\n\"); &#125; return 0;&#125; message-decoding算法图解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;stdio.h&gt;#include &lt;string.h&gt;int code[8][1&lt;&lt;8];//二进制编码//code[len][val]，len表示编码长度//val表示二进制编码所对应的十进制的值//code[len][val]表示这个编码所对应的字符‘//处理换行读入问题int readchar()&#123; for(;;) &#123; int ch = getchar(); if(ch != '\\n' &amp;&amp; ch != '\\r') return ch; &#125;&#125;//执行功能：一个一个字母读入//绕过'\\n' '\\r'执行输出//按位读入二进制数并且转换为十进制整数int getint(int bits)&#123; int val = 0; while(bits--) &#123; // v = v * 2 means v &lt;&lt; 1 val = val * 2 + readchar() - '0'; &#125; return val;&#125;int readcodes()&#123; memset(code,0,sizeof(code)); code[1][0] = readchar(); //用来储存编码头代表的译码 for(int len = 2; len &lt;= 7; len++) &#123; for(int v = 0; v &lt; (1&lt;&lt;len)-1; v++) &#123; int ch = getchar(); if(ch == EOF) return 0; if(ch == '\\n' || ch == '\\r') return 1; code[len][v] = ch; &#125; &#125; return 1;&#125;//对编码头信息的解码//表示编码内容读取的长度void printcodes()&#123; for(int len = 1; len &lt;= 7; len++) &#123; for(int v = 0; v &lt; (1&lt;&lt;len)-1; v++) &#123; if(code[len][v] == 0) return; //printf(\"code[%d][%d] = %c\\n\",len,v,code[len][v]); &#125; &#125;&#125;int main()&#123; while(readcodes()) //input codes，输入第一行的编码 &#123; printcodes(); for(;;) &#123; int len = getint(3); if(len == 0) break; // 000 quit //printf(\"len = %d\\n\",len); for(;;) &#123; int val = getint(len); if(val == (1&lt;&lt;len)-1 ) break; putchar(code[len][val]); //printf(\" \"); &#125; &#125; putchar('\\n'); &#125; return 0;&#125; spreadsheet-tracking 用2种方法，用flag简化计算直接模拟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;string.h&gt;#define maxd 100#define BIG 10000using namespace std;int sh[maxd][maxd], sh_buf[maxd][maxd], ans[maxd][maxd];int row, col;int begr, begc;int change[maxd];// int oldr,oldc;// int newr,newc;void init()&#123; for(int i = 1; i &lt;= row; i++) &#123; for(int j = 1; j &lt;= col; j++) sh[i][j] = i*BIG+j; &#125;&#125;void movesh(char type,int fresh,int old)&#123; if(type == 'R') &#123; for(int i = 1; i &lt;= col; i++) sh[fresh][i] = sh_buf[old][i]; &#125; else &#123; for(int i = 1; i &lt;= row; i++) sh[i][fresh] = sh_buf[i][old]; &#125;&#125;//算法处理一：用type=='R'，选择的方式，来把行变换和列变换统一起来void del(char type)&#123; // memset(sh_buf,0,sizeof(sh_buf)); //memset(change,0,sizeof(change)); memcpy(sh_buf,sh,sizeof(sh)); int cnt = 0; int way = (type == 'R' ? row : col); for(int i = 1; i &lt;= way; i++) &#123; if(change[i] == 0) movesh(type,++cnt,i); &#125; if(type == 'R') &#123; row = cnt; for(int i = row+1; i &lt;= way; i++) for(int j = 1; j &lt;= col; j++) sh[i][j] = 0; &#125; else &#123; col = cnt; for(int i = 1; i &lt;= row; i++) for(int j = col+1; j &lt;= way; j++) sh[i][j] = 0; &#125;&#125;void printsheet()&#123; for(int i = 0; i &lt;= row+2; i++) &#123; for(int j = 0; j &lt;= col+2; j++) cout &lt;&lt; sh[i][j] &lt;&lt;\" \"; cout &lt;&lt; endl; &#125;&#125;void insert(char type)&#123; // memset(sh_buf,0,sizeof(sh_buf)); memcpy(sh_buf,sh,sizeof(sh)); int cnt = 0; int way = (type == 'R' ? row : col); for(int i = 1; i &lt;= way; i++) &#123; if(change[i] == 1) movesh(type,++cnt,0); movesh(type,++cnt,i); //这一步卡住了 &#125; if(type == 'R') row = cnt; else col = cnt;&#125;// void reset()// &#123;// memcpy(sh_buf,sh,sizeof(sh));// for(int i = 1; i &lt;= maxd; i++)// &#123;// for(int j = 1; j &lt;= maxd; j++)// &#123;// if(i &gt; row || j &gt; col)// sh_buf[i][j] = 0;// &#125;// &#125;// &#125;int main()&#123; // cin &gt;&gt; row &gt;&gt; col; // // begr = row, begc = col; // init(); // memset(change,0,sizeof(change)); // printsheet(); // // string cmd; // cin &gt;&gt; cmd; // // int op_row; // cin &gt;&gt; op_row; // change[op_row] = 1; // del(cmd[1]); // // reset(); // printsheet(); // memset(change,0,sizeof(change)); // cmd.clear(); // // cin &gt;&gt; cmd; // int op_col; // cin &gt;&gt; op_col; // change[op_col] = 1; // insert(cmd[1]); // // reset(); // printsheet(); // 操作数必须和原来的值保持一致 int kase; char cmd[10]; int sit = 0; memset(sh,0,sizeof(sh)); while(scanf(\"%d%d%d\",&amp;row,&amp;col,&amp;kase)==3 &amp;&amp; row) &#123; init(); while (kase--) &#123; scanf(\"%s\",cmd); int r1,c1,r2,c2; if(cmd[0] == 'E') &#123; scanf(\"%d%d%d%d\",&amp;r1,&amp;c1,&amp;r2,&amp;c2); swap(sh[r1][c1],sh[r2][c2]); // printsheet(); &#125; else &#123; int oper; scanf(\"%d\",&amp;oper); memset(change,0,sizeof(change)); //算法处理二：用change[]来标记需要处理的行/列 //把要操作的数全部选出来 for(int i = 0; i &lt; oper; i++) &#123; //memset(change,0,sizeof(change)); int cur; // int r1,c1,r2,c2; scanf(\"%d\",&amp;cur); change[cur] = 1; &#125; //将change标记预先选出来 if(cmd[0] == 'D') &#123; //change[cur] = 1; del(cmd[1]); &#125; if(cmd[0] == 'I') &#123; //change[cur] = 1; insert(cmd[1]); &#125; // printsheet(); // printsheet(); &#125; &#125; memset(ans,0,sizeof(ans)); //这是一个好习惯！ //所有全局变量在赋值之前需要初始化 for(int i = 0; i &lt;= row; i++) &#123; for(int j = 0; j &lt;= col; j++) &#123; ans[sh[i][j]/BIG][sh[i][j]%BIG] = i*BIG+j; //算法处理三：ans相当于一个hash map //将原来的坐标ans[sh[r]/BIG][sh[c]%BIG] --&gt; newr*BIG+newc //这样最后查询(qr,qc),直接用ans[qr][qc]就可以了 //ans[qr][qc]/BIG --- ans[qr][qc]%BIG就是最后的结论 &#125; &#125; if(sit &gt; 0) printf(\"\\n\"); printf(\"Spreadsheet #%d\\n\",++sit); int query; int rq,cq; scanf(\"%d\",&amp;query); while(query--) &#123; if(scanf(\"%d%d\",&amp;rq,&amp;cq) == 2 &amp;&amp; rq) &#123; printf(\"Cell data in (%d,%d) \",rq,cq); int data = ans[rq][cq]; if(data == 0) printf(\"GONE\\n\"); else printf(\"moved to (%d,%d)\\n\",data/BIG,data%BIG); &#125; &#125; &#125;&#125; 使用结构体简化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;cstring&gt;#define maxd 10000using namespace std;struct Command&#123; char c[5]; int r1, c1, r2, c2; int op_n, change[20];&#125; cmd[maxd];int row, col, cn;int oldr, oldc;int rq,cq;// int flag = 1;bool operation(int* rq, int* cq)&#123; for(int i = 0; i &lt; cn; i++) &#123; if(cmd[i].c[0] == 'E') &#123; if(cmd[i].r1 == *rq &amp;&amp; cmd[i].c1 == *cq) &#123; *rq = cmd[i].r2; *cq = cmd[i].c2; &#125; else if(cmd[i].r2 == *rq &amp;&amp; cmd[i].c2 == *cq) &#123; *rq = cmd[i].r1; *cq = cmd[i].c1; &#125; &#125; //other Command else &#123; int dr = 0, dc = 0; if(cmd[i].c[0] == 'I') //INSERT &#123; for(int j = 0; j &lt; cmd[i].op_n; j++) &#123; if(cmd[i].c[1] == 'R' &amp;&amp; cmd[i].change[j] &lt;= *rq) //cmd[i].change[j] --&gt; row insert dr++; if(cmd[i].c[1] == 'C' &amp;&amp; cmd[i].change[j] &lt;= *cq) //col insert; dc++; &#125; &#125; if(cmd[i].c[0] == 'D') //delete &#123; for(int j = 0; j &lt; cmd[i].op_n; j++) &#123; if(cmd[i].c[1] == 'R' &amp;&amp; cmd[i].change[j] == *rq) return 0; if(cmd[i].c[1] == 'C' &amp;&amp; cmd[i].change[j] == *cq) return 0; if(cmd[i].c[1] == 'R' &amp;&amp; cmd[i].change[j] &lt; *rq) dr--; if(cmd[i].c[1] == 'C' &amp;&amp; cmd[i].change[j] &lt; *cq) dc--; &#125; &#125; *rq += dr; *cq += dc; &#125; &#125; return 1;&#125;int main()&#123; // int row,col,cn; // int rq, cq; int kase = 0; while(scanf(\"%d%d%d\",&amp;row,&amp;col,&amp;cn) == 3 &amp;&amp; row) &#123; for(int i = 0; i &lt; cn; i++) &#123; scanf(\"%s\",cmd[i].c); // cout &lt;&lt; cmd[i].c[0] &lt;&lt; endl; if(cmd[i].c[0] == 'E') &#123; scanf(\"%d%d%d%d\",&amp;cmd[i].r1,&amp;cmd[i].c1,&amp;cmd[i].r2,&amp;cmd[i].c2); &#125; else &#123; scanf(\"%d\",&amp;cmd[i].op_n); for(int j = 0; j &lt; cmd[i].op_n; j++) scanf(\"%d\",&amp;cmd[i].change[j]); &#125; &#125; //QUERY: if(kase &gt; 0) printf(\"\\n\"); printf(\"Spreadsheet #%d\\n\",++kase); int query; scanf(\"%d\",&amp;query); while(query--) &#123; scanf(\"%d%d\",&amp;rq,&amp;cq); oldr = rq; oldc = cq; printf(\"Cell data in (%d,%d) \",oldr,oldc); int flag = operation(&amp;rq,&amp;cq); if(flag == 0) printf(\"GONE\\n\"); else printf(\"moved to (%d,%d)\\n\",rq,cq); &#125; &#125;&#125; A Typical Homework这题目我AC了整整十几次！ 记录一下自己弄错的地方 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define EPS 1e-5#define maxs 105//105 students#define maxid 105//15 digitsusing namespace std;//int n;//int removed[maxs] = &#123;0&#125;;int subject[6];//subject[1] pass subject 1 --&gt; subject[2] pass subject 2int lastid = 0;typedef struct Students&#123; bool removed; char sid[maxid]; int cid; char name[maxid]; int chinese; int math; int english; int coding;// int rank; int totscore; bool operator &lt; (const Students&amp; s) const&#123; return totscore &gt; s.totscore; &#125; Students() &#123; memset(this,0,sizeof(Students)); &#125;&#125;students;typedef struct Klass&#123; int totstu; int score[4]; int pass[4]; Klass() &#123; memset(this,0,sizeof(Klass)); &#125;&#125;klass;//vector&lt;klass&gt; kl(maxs);klass kl[maxs + 5];vector&lt;students&gt; stu;bool valid(students fresh)&#123; vector&lt;students&gt;::iterator it; for(it = stu.begin(); it != stu.end(); it++) &#123; if(! (*it).removed ) &#123; if(strcmp((*it).sid, fresh.sid) == 0) return 0; &#125; &#125; return 1;&#125;void add()&#123; for(;;) &#123; students fresh; printf(\"Please enter the SID, CID, name and four scores. Enter 0 to finish.\\n\"); scanf(\"%s\",fresh.sid); if(strcmp(fresh.sid, \"0\") == 0) break; scanf(\"%d%s%d%d%d%d\",&amp;fresh.cid,fresh.name,&amp;fresh.chinese,&amp;fresh.math,&amp;fresh.english,&amp;fresh.coding); if(valid(fresh)) &#123; fresh.totscore = fresh.chinese + fresh.math + fresh.english + fresh.coding; fresh.removed = 0; int k = fresh.cid; kl[k].score[0] += fresh.chinese; kl[k].score[1] += fresh.math; kl[k].score[2] += fresh.english; kl[k].score[3] += fresh.coding; if(fresh.chinese &gt;= 60) kl[k].pass[0]++; if(fresh.math &gt;= 60) kl[k].pass[1]++; if(fresh.english &gt;= 60) kl[k].pass[2]++; if(fresh.coding &gt;= 60) kl[k].pass[3]++; kl[k].totstu++; stu.push_back(fresh); &#125; else printf(\"Duplicated SID.\\n\"); &#125;&#125;//add() finished!int getrank(students cur)&#123; int r = 0; vector&lt;students&gt;::iterator it; for(it = stu.begin(); ((*it).sid != cur.sid) &amp;&amp; it != stu.end(); it++) &#123; if(!((*it).removed) &amp;&amp; (*it).totscore &gt; cur.totscore) r++; &#125; return r+1;&#125;//rank() finishedvoid DQ(int isq)&#123; for(;;) &#123; char choose[maxs]; printf(\"Please enter SID or name. Enter 0 to finish.\\n\"); scanf(\"%s\",choose); if(strcmp(choose,\"0\") == 0) break; int cal = 0; vector&lt;students&gt;::iterator it; for(it = stu.begin(); it != stu.end(); it++) &#123; if(!(*it).removed) &#123;// cout &lt;&lt; stu[i].sid &lt;&lt; \"--&gt;\" &lt;&lt; choose &lt;&lt; endl;// cout &lt;&lt; stu[i].name &lt;&lt; \"--&gt;\" &lt;&lt; choose &lt;&lt; endl; if(strcmp((*it).sid,choose) == 0 || strcmp((*it).name,choose) == 0 ) &#123; if(isq) //printf(\"%d %s %d %s %d %d %d %d %d %.2f\\n\", stu[i].rank, stu[i].sid, stu[i].cid, stu[i].name,stu[i].chinese,stu[i].math,stu[i].english,stu[i].coding,stu[i].totscore,stu[i].totscore/4.0+EPS); printf(\"%d %s %d %s %d %d %d %d %d %.2f\\n\",getrank(*it),(*it).sid, (*it).cid, (*it).name,(*it).chinese,(*it).math,(*it).english,(*it).coding,(*it).totscore,(*it).totscore/4.0+EPS); else &#123; (*it).removed = 1; //removed students also infect klass int rid = (*it).cid; kl[rid].totstu--; kl[rid].score[0] -= (*it).chinese; kl[rid].score[1] -= (*it).math; kl[rid].score[2] -= (*it).english; kl[rid].score[3] -= (*it).coding; if((*it).chinese &gt;= 60) kl[rid].pass[0]--; if((*it).math &gt;= 60) kl[rid].pass[1]--; if((*it).english &gt;= 60) kl[rid].pass[2]--; if((*it).coding &gt;= 60) kl[rid].pass[3]--; cal++; &#125; &#125;// if(!isq)// printf(\"%d student(s) removed.\\n\",cal); &#125; &#125; if(!isq) printf(\"%d student(s) removed.\\n\",cal); &#125;&#125;//DQ test finished!void overall_stat(int check)&#123; memset(subject, 0, sizeof(subject)); vector&lt;students&gt;::iterator it; for(it = stu.begin(); it != stu.end(); it++) &#123; if(!(*it).removed &amp;&amp; (check == 0 || (*it).cid == check)) &#123; int k = 0; if((*it).chinese &gt;= 60) k++; if((*it).math &gt;= 60) k++; if((*it).english &gt;= 60) k++; if((*it).coding &gt;= 60) k++; subject[k]++; &#125; &#125;// for(int i = 0; i &lt; 6; i++)// printf(\"pass %d : %d \", i , subject[i]);&#125;//test finishedvoid stat()&#123; int check; printf(\"Please enter class ID, 0 for the whole statistics.\\n\"); scanf(\"%d\",&amp;check); if(check != 0) &#123; printf(\"Chinese\\n\"); printf(\"Average Score: %.2f\\n\",(double)kl[check].score[0]/(double)kl[check].totstu+EPS); printf(\"Number of passed students: %d\\n\",kl[check].pass[0]); printf(\"Number of failed students: %d\\n\",kl[check].totstu-kl[check].pass[0]); printf(\"\\n\"); printf(\"Mathematics\\n\"); printf(\"Average Score: %.2f\\n\",(double)kl[check].score[1]/(double)kl[check].totstu+EPS); printf(\"Number of passed students: %d\\n\",kl[check].pass[1]); printf(\"Number of failed students: %d\\n\",kl[check].totstu-kl[check].pass[1]); printf(\"\\n\"); printf(\"English\\n\"); printf(\"Average Score: %.2f\\n\",(double)kl[check].score[2]/(double)kl[check].totstu+EPS); printf(\"Number of passed students: %d\\n\",kl[check].pass[2]); printf(\"Number of failed students: %d\\n\",kl[check].totstu-kl[check].pass[2]); printf(\"\\n\"); printf(\"Programming\\n\"); printf(\"Average Score: %.2f\\n\",(double)kl[check].score[3]/(double)kl[check].totstu+EPS); printf(\"Number of passed students: %d\\n\",kl[check].pass[3]); printf(\"Number of failed students: %d\\n\",kl[check].totstu-kl[check].pass[3]); printf(\"\\n\"); &#125; else &#123; int s1=0, s2=0, s3=0, s4=0; int p1=0, p2=0, p3=0, p4=0; int m = 0; vector&lt;students&gt;::iterator it; for(it = stu.begin(); it != stu.end(); it++) &#123; if(!(*it).removed ) &#123; m++; s1 += (*it).chinese; s2 += (*it).math; s3 += (*it).english; s4 += (*it).coding; if((*it).chinese &gt;= 60) p1++; if((*it).math &gt;= 60) p2++; if((*it).english &gt;= 60) p3++; if((*it).coding &gt;= 60) p4++; &#125; &#125; printf(\"Chinese\\n\"); printf(\"Average Score: %.2f\\n\",(double)s1/(double)m+EPS); printf(\"Number of passed students: %d\\n\",p1); printf(\"Number of failed students: %d\\n\",m-p1); printf(\"\\n\"); printf(\"Mathematics\\n\"); printf(\"Average Score: %.2f\\n\",(double)s2/(double)m+EPS); printf(\"Number of passed students: %d\\n\",p2); printf(\"Number of failed students: %d\\n\",m-p2); printf(\"\\n\"); printf(\"English\\n\"); printf(\"Average Score: %.2f\\n\",(double)s3/(double)m+EPS); printf(\"Number of passed students: %d\\n\",p3); printf(\"Number of failed students: %d\\n\",m-p3); printf(\"\\n\"); printf(\"Programming\\n\"); printf(\"Average Score: %.2f\\n\",(double)s4/(double)m+EPS); printf(\"Number of passed students: %d\\n\",p4); printf(\"Number of failed students: %d\\n\",m-p4); printf(\"\\n\"); &#125; overall_stat(check); printf(\"Overall:\\n\"); printf(\"Number of students who passed all subjects: %d\\n\",subject[4]); printf(\"Number of students who passed 3 or more subjects: %d\\n\",subject[3]+subject[4]); printf(\"Number of students who passed 2 or more subjects: %d\\n\",subject[2]+subject[3]+subject[4]); printf(\"Number of students who passed 1 or more subjects: %d\\n\",subject[1]+subject[2]+subject[3]+subject[4]); printf(\"Number of students who failed all subjects: %d\\n\",subject[0]); printf(\"\\n\");&#125;void print_menu()&#123; printf(\"Welcome to Student Performance Management System (SPMS).\\n\"); printf(\"\\n\"); printf(\"1 - Add\\n\"); printf(\"2 - Remove\\n\"); printf(\"3 - Query\\n\"); printf(\"4 - Show ranking\\n\"); printf(\"5 - Show Statistics\\n\"); printf(\"0 - Exit\\n\"); printf(\"\\n\");&#125;//void printdata(int n)//&#123;// for(int i = 0; i &lt; n; i++)// &#123;// printf(\"%s %d %s %d %d %d %d %d rank: %d\\n\",stu[i].sid,stu[i].cid,stu[i].name,stu[i].chinese,stu[i].math,stu[i].english,stu[i].coding,stu[i].totscore,stu[i].rank);// &#125;//&#125;int main()&#123; for( ; ; ) &#123; int choice; print_menu(); scanf(\"%d\",&amp;choice); if(choice == 0) break; if(choice == 1) &#123; add();// cout &lt;&lt; stucnt;// getrank(cnt);// getklass(cnt);// cout &lt;&lt; cnt &lt;&lt; \" students \"&lt;&lt; endl; &#125;// for(int i = 0; i &lt; cnt; i++)// printf(\"students %s \",stu[i].name);// printf(\"\\n removed: \");// for(int i = 0; i &lt; cnt; i++)// printf(\"%d \",removed[i]);// sort(stu,stu+cnt);// printdata(cnt);// printf(\"\\n\");// printf(\"enter check : \");// int check;// scanf(\"%d\",&amp;check);// overall_stat(cnt,check,subject); if(choice == 2) DQ(0); if(choice == 3) DQ(1); if(choice == 4) printf(\"Showing the ranklist hurts students' self-esteem. Don't do that.\\n\"); if(choice == 5) stat(); &#125;&#125; Xiangqi这个题我也纠结了好久，就是判断是否将军，这很关键 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef struct Points&#123; int x; int y; Points(int x = 0, int y = 0): x(x), y(y) &#123;&#125;&#125;points;points operator+ (const points&amp; A, const points&amp; B) &#123; return points(A.x+B.x,A.y+B.y); &#125;points operator- (const points&amp; A, const points&amp; B) &#123; return points(A.x+B.x,A.y+B.y); &#125;points operator* (const points&amp; A, int m) &#123; return points(A.x*m,A.y*m); &#125;points operator/ (const points&amp; A, int m) &#123; return points(A.x/m,A.y/m); &#125;//运算符重载，判断马腿，容易写错bool operator== (const points&amp; A, const points&amp; B) &#123; return (A.x == B.x &amp;&amp; A.y == B.y); &#125;bool operator&lt; (const points&amp; A, const points&amp; B) &#123; return (A.x &lt; B.x) || (A.x == B.x &amp;&amp; A.y &lt; B.y) ; &#125;char grid[16][16] = &#123;0&#125;;points dirs[4] = &#123;points(-1,0),points(0,1),points(1,0),points(0,-1)&#125;;points hdirs[8] = &#123;points(2,1),points(1,2),points(-1,2),points(-2,1),points(2,-1),points(1,-2),points(-1,-2),points(-2,-1)&#125;;//红子吃掉黑子的情况要单独判断//要把原来的那个位置放置什么类型的棋子给放到buffer中//每判断一种情况后进行复原，再进行新一轮棋子的判断points blackG, redG;vector &lt;points&gt; redcheck;bool valid(const points&amp; p)&#123; bool flagx = (p.x&gt;=1 &amp;&amp; p.x&lt;=3); bool flagy = (p.y&gt;=4 &amp;&amp; p.y&lt;=6); return (flagx &amp;&amp; flagy);&#125;bool straight(const points&amp; p1,const points&amp; p2, int between)// chariot and cannon&#123; int lx = min(p1.x,p2.x); int hx = max(p1.x,p2.x); int ly = min(p1.y,p2.y); int hy = max(p1.y,p2.y); int cnt = 0; if(p1.x == p2.x) &#123; for(int y = ly+1; y &lt; hy; y++) &#123; if(grid[p1.x][y]) cnt++; if(cnt &gt; between) return false; &#125; return cnt == between; &#125; if(p1.y == p2.y) &#123; for(int x = lx+1; x &lt; hx; x++) &#123; if(grid[x][p1.y]) cnt++; if(cnt &gt; between) return false; &#125; return cnt == between; &#125; return false;&#125;bool checkmate(const points&amp; r, const points&amp; b)&#123; switch(grid[r.x][r.y]) &#123; case 'G': return r.y == b.y &amp;&amp; straight(r,b,0); case 'R': return (r.y == b.y || r.x == b.x) &amp;&amp; straight(r,b,0); case 'C': return (r.x == b.x || r.y == b.y) &amp;&amp; straight(r,b,1); case 'H': for(int i = 0; i &lt; 8; i++) &#123; points hnext = r + hdirs[i]; points leg = r + hdirs[i]/2; if(hnext == b &amp;&amp; grid[leg.x][leg.y] == 0) return true; &#125; return false; default: return false; &#125;&#125;//将军的判断，是否完成了一次成功的将军bool canwin()&#123; if(blackG.y == redG.y &amp;&amp; straight(blackG,redG,0)) return false;// bool live = true; for(int i = 0; i &lt; 4; i++) &#123; points bnext = blackG + dirs[i]; bool live = true; if(!valid(bnext)) continue; char buffer = grid[bnext.x][bnext.y]; grid[bnext.x][bnext.y] = 0; //红子吃掉黑子的情况要单独判断 //要把原来的那个位置放置什么类型的棋子给放到buffer中 //每判断一种情况后进行复原，再进行新一轮棋子的判断 //这里是特别需要注意的 for(vector&lt;points&gt;::iterator it = redcheck.begin(); it != redcheck.end(); it++) &#123; points rcur = *it; if(grid[rcur.x][rcur.y] &amp;&amp; checkmate(rcur,bnext)) &#123; live = false; break; &#125; &#125; grid[bnext.x][bnext.y] = buffer; if(live) return false; &#125; return true;&#125;int main()&#123; int kase; while(scanf(\"%d%d%d\",&amp;kase,&amp;(blackG.x),&amp;(blackG.y))==3 &amp;&amp; kase) &#123; redcheck.clear(); memset(grid,0,sizeof(grid)); char type; int x,y; while(kase) &#123;// cout &lt;&lt; \"kase: \" &lt;&lt; kase &lt;&lt; endl; cin &gt;&gt; type &gt;&gt; x &gt;&gt; y; points p(x,y); redcheck.push_back(p); grid[p.x][p.y] = type; if(type == 'G') redG = p; kase--; &#125; if(canwin()) printf(\"YES\\n\"); if(!canwin()) printf(\"NO\\n\"); &#125;&#125; othello这是我当时最快速度ac的题目，纪念一下 特别注意一下优先队列和一些排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;typedef struct points&#123; int row; int col; points(int row = 0, int col = 0):row(row),col(col) &#123;&#125;&#125;pos;bool operator&lt; (const pos&amp; A,const pos&amp; B) &#123;return (A.row&lt;B.row) || (A.row==B.row &amp;&amp; A.col&lt;B.col);&#125;bool operator== (const pos&amp; A,const pos&amp; B) &#123;return (A.row==B.row) &amp;&amp; (A.col==B.col);&#125;bool operator!= (const pos&amp; A,const pos&amp; B) &#123;return (A.row!=B.row) || (A.col!=B.col);&#125;pos operator+ (const pos&amp; A,const pos&amp; B) &#123;return pos(A.row+B.row,A.col+B.col);&#125;pos operator- (const pos&amp; A,const pos&amp; B) &#123;return pos(A.row-B.row,A.col-B.col);&#125;char board[16][16];bool mark[16][16];char player;pos dr1[4] = &#123;pos(-1,0),pos(-1,1),pos(0,1),pos(1,1)&#125;;pos dr2[4] = &#123;pos(1,0),pos(1,-1),pos(0,-1),pos(-1,-1)&#125;;pos walk[8] = &#123;pos(-1,0),pos(-1,1),pos(0,1),pos(1,1),pos(1,0),pos(1,-1),pos(0,-1),pos(-1,-1)&#125;;set&lt;pos&gt; res;map&lt;pos,int&gt; dir;//remember clear()!bool valid(const pos&amp; p)&#123; bool flag1 = p.row &gt;= 1 &amp;&amp; p.row &lt;= 8; bool flag2 = p.col &gt;= 1 &amp;&amp; p.col &lt;= 8; return flag1 &amp;&amp; flag2;&#125;bool empty(const pos&amp; p)&#123; return board[p.row][p.col] == '-';&#125;char getboard()&#123; for(int i = 1; i &lt;= 8; i++)&#123; for(int j = 1; j &lt;= 8; j++)&#123; cin &gt;&gt; board[i][j]; &#125; &#125; cin &gt;&gt; player; return player;&#125;void printboard(int kase)&#123; for(int i = 1; i &lt;= 8; i++)&#123; for(int j = 1; j &lt;= 8; j++)&#123; cout &lt;&lt; board[i][j]; &#125; cout &lt;&lt; endl; &#125; if(kase) cout &lt;&lt; endl;&#125;void checkdisk(char opp,char curp)&#123; for(int i = 1; i &lt;= 8; i++)&#123; for(int j = 1; j &lt;= 8; j++)&#123; if(board[i][j] == opp)&#123; pos cur(i,j);// pos up = cur, down = cur; for(int k = 0; k &lt; 4; k++)&#123; pos up = cur, down = cur; do&#123; up = up + dr1[k]; if(!valid(up)) break; &#125;while(board[up.row][up.col] == opp); do&#123; down = down + dr2[k]; if(!valid(down)) break; &#125;while(board[down.row][down.col] == opp); if(!valid(up) || !valid(down)) continue; char flag1 = board[up.row][up.col]; char flag2 = board[down.row][down.col]; if(flag1 == '-' &amp;&amp; flag2 == curp)&#123; res.insert(up); dir[up] = k; &#125; if(flag1 == curp &amp;&amp; flag2 == '-')&#123; res.insert(down); dir[down] = k; &#125; &#125; &#125; &#125; &#125;&#125;void printpos()&#123; set&lt;pos&gt;::iterator it; int cnt = 0; if(!res.size())&#123; printf(\"No legal move.\"); &#125; else&#123; for(it = res.begin(); it != res.end(); it++)&#123; cnt++; printf(\"(%d,%d)\",(*it).row,(*it).col); if(cnt!=res.size()) printf(\" \"); &#125; &#125; printf(\"\\n\");&#125;void change(const pos&amp; p, char opp, char curp)&#123; pos start = p; mark[start.row][start.col] = 1; for(int i = 0; i &lt; 8; i++)&#123; pos next = p + walk[i]; if(empty(next)) continue; while(board[next.row][next.col] == opp)&#123; next = next + walk[i]; &#125; if(board[next.row][next.col] == curp)&#123; for(next = next-walk[i]; next!=start; next = next-walk[i])&#123; if(!mark[next.row][next.col])&#123; mark[next.row][next.col] = 1; &#125; &#125; &#125; &#125; for(int i = 1; i &lt;= 8; i++)&#123; for(int j = 1; j &lt;= 8; j++)&#123; if(mark[i][j] == 1)&#123; board[i][j] = curp; &#125; &#125; &#125;&#125;pos getmove()&#123; int row,col; cin &gt;&gt; row &gt;&gt; col; return pos(row,col);&#125;void list()&#123; int w = 0,b = 0; for(int i = 1; i &lt;= 8; i++)&#123; for(int j = 1; j &lt;= 8; j++)&#123; if(board[i][j] == 'W') w++; if(board[i][j] == 'B') b++; &#125; &#125; printf(\"Black - %2d White - %2d\\n\",b,w);&#125;int main()&#123; /*char curp = getboard(); char opp; if(curp == 'B') opp = 'W'; if(curp == 'W') opp = 'B'; checkdisk(opp,curp);// printdir(); printpos(); pos disk = getmove(); change(disk,opp,curp); printboard();// char cmd;// cin &gt;&gt; cmd;//// if(cmd == 'L')// printpos();*/ int kase; scanf(\"%d\",&amp;kase); while(kase--)&#123; memset(board,0, sizeof(board)); memset(mark,0, sizeof(mark)); res.clear(); dir.clear(); char gamer[2]; gamer[0] = getboard();//cur if(gamer[0] == 'B') gamer[1] = 'W'; //another if(gamer[0] == 'W') gamer[1] = 'B'; int flag = 0; char cmd[5]; for(;;)&#123; scanf(\"%s\",cmd); if(cmd[0] == 'Q')&#123; printboard(kase); break; &#125; if(cmd[0] == 'L')&#123; checkdisk(gamer[1-flag],gamer[flag]); printpos(); if(!res.size())&#123;// memset(mark,0, sizeof(mark)); flag = 1-flag; checkdisk(gamer[1-flag],gamer[flag]); &#125; res.clear(); &#125; if(cmd[0] == 'M')&#123; int x = cmd[1]-'0'; int y = cmd[2]-'0'; pos move = pos(x,y); memset(mark,0,sizeof(mark)); change(move,gamer[1-flag],gamer[flag]); list();// printboard(); flag = 1-flag; &#125;// flag = 1-flag; &#125; &#125;&#125; squares 这里重点了解一下方形网格的结构体设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string.h&gt;using namespace std;const int MAXN = 16;int vexp[MAXN][MAXN],hexp[MAXN][MAXN];int hstart[MAXN][MAXN], vstart[MAXN][MAXN];int square[MAXN];int min(int a, int b)&#123; return a &lt; b ? a : b;&#125;void getdata(int&amp; kase)&#123; while(kase--) &#123; char type; int x,y; cin &gt;&gt; type &gt;&gt; x &gt;&gt; y; if(type == 'H') hstart[x][y] = 1; if(type == 'V') vstart[y][x] = 1; &#125;&#125;void stretch(int n)&#123; for(int i = n; i &gt;= 1; i--)&#123; for(int j = n; j &gt;= 1; j--)&#123; if(hstart[i][j])&#123; hexp[i][j] = hexp[i][j+1] + 1; &#125; if(vstart[i][j])&#123; vexp[i][j] = vexp[i+1][j] + 1; &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; int mins = min(hexp[i][j],vexp[i][j]); for(int len = 1; len &lt;= mins; len++)&#123; if(hexp[i+len][j] &gt;= len &amp;&amp; vexp[i][j+len] &gt;= len)&#123; square[len]++; &#125; &#125; &#125; &#125;&#125;int main()&#123; int n; for(int t = 1; scanf(\"%d\",&amp;n)==1; t++) &#123; if(t &gt; 1) printf(\"\\n**********************************\\n\\n\"); memset(vexp,0,sizeof(vexp)); memset(hexp,0,sizeof(hexp)); memset(hstart,0,sizeof(hstart)); memset(vstart,0,sizeof(vstart)); memset(square,0, sizeof(square)); int kase; scanf(\"%d\",&amp;kase); getdata(kase); stretch(n);// for(int i = 0; i &lt;= n; i++)&#123;// for(int j = 0; j &lt;= n; j++)// cout &lt;&lt; hexp[i][j] &lt;&lt; \" \";// cout &lt;&lt; endl;// &#125;// for(int i = 0; i &lt;= n; i++)&#123;// for(int j = 0; j &lt;= n; j++)// cout &lt;&lt; vexp[i][j] &lt;&lt; \" \";// cout &lt;&lt; endl;// &#125; printf(\"Problem #%d\\n\\n\",t); bool flag = false; for(int i = 1; i &lt;= n; i++)&#123; if(square[i])&#123; flag = true; printf(\"%d square (s) of size %d\\n\",square[i],i); &#125; &#125; if(!flag) printf(\"No completed squares can be found.\\n\"); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"}]},{"title":"hexo个人站点收录百度熊掌号","slug":"20180303","date":"2018-03-02T21:42:47.000Z","updated":"2018-03-02T22:07:32.000Z","comments":true,"path":"2018/03/03/20180303/","link":"","permalink":"http://www.fogsail.net/2018/03/03/20180303/","excerpt":"百度熊掌号是内容和服务提供者入驻百度生态的实名账号，致力于帮助内容和服务提供者方便、快捷、高效地连接百度用户，并充分利用搜索生态开放的优势，获得流量和沉淀用户，实现自身价值的快速增长。","text":"百度熊掌号是内容和服务提供者入驻百度生态的实名账号，致力于帮助内容和服务提供者方便、快捷、高效地连接百度用户，并充分利用搜索生态开放的优势，获得流量和沉淀用户，实现自身价值的快速增长。 粉丝关注改造粉丝关注改造中有两个功能，一是添加熊掌号ID声明，而是添加关注功能代码。 添加熊掌号ID声明的时候，只需要在页面&lt;/head&gt;标签前添加代码1&lt;script src=\"//msite.baidu.com/sdk/c.js?appid=1593711792635024\"&gt;&lt;/script&gt; 在本地的路径为1blog/themes/next/layout/_layout.swig 找到如下代码： 12345678910&lt;html class=\"&#123;&#123; html_class | lower &#125;&#125;\" lang=\"&#123;&#123; config.language &#125;&#125;\"&gt;&lt;head&gt; &#123;&#123; partial('_partials/head/head.swig', &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125; &#123;% include '_partials/head/head-unique.swig' %&#125; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &#123;% include '_third-party/analytics/index.swig' %&#125; &#123;% include '_scripts/noscript.swig' %&#125; &lt;script src=\"//msite.baidu.com/sdk/c.js?appid=1593711792635024\"&gt;&lt;/script&gt; &lt;/head&gt; 在&lt;/head&gt;前加上去就可以了。 添加关注功能代码这里为添加的是底部bar 1&lt;script&gt;cambrian.render('tail')&lt;/script&gt; 在路径：1&lt;script&gt;cambrian.render('tail')&lt;/script&gt; 1234567891011121314&lt;main id=\"main\" class=\"main\"&gt; &lt;div class=\"main-inner\"&gt; &lt;div class=\"content-wrap\"&gt; &lt;div id=\"content\" class=\"content\"&gt; &#123;% block content %&#125;&#123;% endblock %&#125; &lt;script&gt;cambrian.render('tail')&lt;/script&gt; &lt;/div&gt; &#123;% include '_partials/comments.swig' %&#125; &lt;/div&gt; &#123;% if theme.sidebar.display !== 'remove' %&#125; &#123;% block sidebar %&#125;&#123;% endblock %&#125; &#123;% endif %&#125; &lt;/div&gt;&lt;/main&gt; 结构化改造添加canonical标签只要在12345/themes/next/_config.yml``` 令```bashcanonical=true 添加JSON_LD数据注意，这里站点的路径名称不能出现中文所以我后来在写文章的时候，1hexo new EN-title/Num-title 找到路径1/themes/next/layout/_macro/post.swig 123456789101112131415161718192021&lt;span hidden itemprop=\"author\" itemscope itemtype=\"http://schema.org/Person\"&gt; &lt;meta itemprop=\"name\" content=\"&#123;&#123; theme.author &#125;&#125;\"&gt; &lt;meta itemprop=\"description\" content=\"&#123;&#123; theme.signature &#125;&#125;\"&gt; &lt;meta itemprop=\"image\" content=\"&#123;&#123; url_for( theme.avatar | default(theme.images + '/avatar.gif') ) &#125;&#125;\"&gt;&lt;/span&gt; &lt;!--baidu-ldjson--&gt; &lt;!--问题容易出在@id上--&gt; &lt;!--以下是新添加的内容--&gt; &lt;script type=\"application/ld+json\"&gt; &#123; \"@context\":\"https://ziyuan.baidu.com/contexts/cambrian.jsonld\", \"@id\":\"&#123;&#123; config.url &#125;&#125;&#123;&#123; url_for(post.path) &#125;&#125;\", \"appid\":\"1593711792635024\", \"title\":\"&#123;&#123; post.title &#125;&#125;\", \"images\":[ \"&#123;&#123; config.url &#125;&#125;&#123;&#123; url_for(post.path) &#125;&#125;01.jpg\" ], \"pubDate\":\"&#123;&#123; moment(post.date).format('YYYY-MM-DD') &#125;&#125;T&#123;&#123; moment(post.date).format('HH:mm:ss') &#125;&#125;\" &#125; &lt;/script&gt; 值得注意的是，这里post为变量，变量参数的调用方法，有1234post.pathpost.datepost.title特别注意url_for(post.path)不能有中文","categories":[{"name":"杂乱的技术","slug":"杂乱的技术","permalink":"http://www.fogsail.net/categories/杂乱的技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.fogsail.net/tags/hexo/"},{"name":"杂乱的技术","slug":"杂乱的技术","permalink":"http://www.fogsail.net/tags/杂乱的技术/"}]},{"title":"hexo博客部署到腾讯云服务器上","slug":"20180222","date":"2018-02-22T13:20:00.000Z","updated":"2018-03-02T21:32:22.000Z","comments":true,"path":"2018/02/22/20180222/","link":"","permalink":"http://www.fogsail.net/2018/02/22/20180222/","excerpt":"这里主要讲一下云服务器端的配置。我使用的是腾讯云CVM服务器。操作系统使用的是centOS 7.3 64位。因为ubuntu给的并不是root权限，所以改成centOS 7.3，给的是root权限。","text":"这里主要讲一下云服务器端的配置。我使用的是腾讯云CVM服务器。操作系统使用的是centOS 7.3 64位。因为ubuntu给的并不是root权限，所以改成centOS 7.3，给的是root权限。 云服务器端的配置Nginx配置ssh连接服务器。安装Nginx 1yum install -y nginx 启动Nginx服务1service nginx start 测试Nginx服务器1wget http://127.0.0.1 能够正常获取欢迎页面说明Nginx安装成功。1234567--2013-02-20 17:07:26-- http://127.0.0.1/Connecting to 127.0.0.1:80... connected.HTTP request sent, awaiting response... 200 OKLength: 151 [text/html]Saving to: `index.html'100%[===================================&gt;] 151 --.-K/s in 0s2013-02-20 17:07:26 (37.9 MB/s) - `index.html' saved [151/151] 以上表示安装配置成功。 在浏览器中输入服务器ip地址我的是123.207.245.97 建立仓库我这里是把项目仓库放在git中新建了一个git用户 1adduser git 建立代码仓库12345678cd /home/git //nginx网站指向/home/git中mkdir hexo.gitgit init --bare hexo.git //这一步是建立裸仓库chown -R 755 git:git hexo.gitchown 755 git:git hexo.gitchown 755 /home/git//755表示赋予权限访问 将本地机器的ssh公钥填入/home/git/.ssh/authorized_keys文件在服务器端123cd /home/gitmkdir .sshnano /home/git/.ssh/authorized_keys 1ctrl+x保存，输入y，然后回车 配置Nginx查找Nginx配置文件1nginx -t 我的配置文件位于1/etc/nginx/nginx.conf 如下图： 12345678910server&#123; listen 80 default_server; listen [::]:80 default_server; server_name localhost; root /home/git; location / &#123; index index.html index.htm; &#125;&#125; 注意一定要给1chown -R 755 /home/git 给予/home/git权限这样才可以访问。 最后保存后重启Nginx服务器1service nginx restart 实现自动部署自动部署是通过Git钩子实现的接下来，在服务器上的裸仓库 hexo.git 创建一个钩子，在满足特定条件时将静态 HTML 文件传送到 Web 服务器的目录下，即 /home/git。 在第二步建立的裸仓中（即hexo.git文件夹中），找到hooks目录下的post-update.sample,重命名为post-update 1git --work-tree=/home/git --git-dir=/home/git/hexo.git checkout -f 修改权限让其可执行1chmod +x post-update 部署hexo本地站点配置文件中修改： 12345deploy: type: git repo: git@123.207.245.97:/home/git/hexo.git branch: master 就可以成功地把github博客迁移到腾讯云啦～别忘了备案！","categories":[{"name":"杂乱的技术","slug":"杂乱的技术","permalink":"http://www.fogsail.net/categories/杂乱的技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.fogsail.net/tags/hexo/"},{"name":"杂乱的技术","slug":"杂乱的技术","permalink":"http://www.fogsail.net/tags/杂乱的技术/"}]},{"title":"《csapp》实践：信息的表示和处理","slug":"20180206","date":"2018-02-06T03:00:00.000Z","updated":"2019-03-06T10:04:55.726Z","comments":true,"path":"2018/02/06/20180206/","link":"","permalink":"http://www.fogsail.net/2018/02/06/20180206/","excerpt":"阅读深入理解计算机系统，书中的很多实践的练习值得尝试。","text":"阅读深入理解计算机系统，书中的很多实践的练习值得尝试。 show bytes1234void show_bytes(byte_pointer start, size_t len)//这里的len表示从start开始//包括start，例如ab ed 这样，每2个数字为一个单位//总共有几个单位？ show_bytes的使用，具体能够打印类型为short、long和double的c语言对象的字节表示：具体实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169/* $begin show-bytes */#include &lt;stdio.h&gt;/* $end show-bytes */#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;/* $begin show-bytes */using namespace std;typedef unsigned char *byte_pointer;//unsigned char * 显示一位void show_bytes(byte_pointer start, size_t len) &#123; size_t i; //int k=0; for (i = 0; i &lt; len; i++) printf(\" %.2x\", start[i]); //line:data:show_bytes_printf //buf[k++]=start[i]; printf(\"\\n\");&#125;void show_int(int x) &#123; show_bytes((byte_pointer) &amp;x, sizeof(int)); //line:data:show_bytes_amp1&#125;void show_float(float x) &#123; show_bytes((byte_pointer) &amp;x, sizeof(float)); //line:data:show_bytes_amp2&#125;void show_pointer(void *x) &#123; show_bytes((byte_pointer) &amp;x, sizeof(void *)); //line:data:show_bytes_amp3&#125;void show_short(short x)&#123; show_bytes((byte_pointer) &amp;x, sizeof(short));&#125;void show_long(long x)&#123; show_bytes((byte_pointer) &amp;x, sizeof(long));&#125;void show_double(double x)&#123; show_bytes((byte_pointer) &amp;x, sizeof(double));&#125;/* $end show-bytes *//* $begin test-show-bytes */void test_show_bytes(int val) &#123; int ival = val; float fval = (float) ival; int *pval = &amp;ival; show_int(ival); show_float(fval); show_pointer(pval);&#125;/* $end test-show-bytes */void simple_show_a() &#123;/* $begin simple-show-a */int val = 0x87654321;byte_pointer valp = (byte_pointer) &amp;val;show_bytes(valp, 1); /* A. */show_bytes(valp, 2); /* B. */show_bytes(valp, 3); /* C. */show_bytes(valp, 4);/* $end simple-show-a */&#125;void simple_show_b() &#123;/* $begin simple-show-b */int val = 0x12345678;byte_pointer valp = (byte_pointer) &amp;val;show_bytes(valp, 1); /* A. */show_bytes(valp, 2); /* B. */show_bytes(valp, 3); /* C. *//* $end simple-show-b */&#125;void float_eg() &#123; int x = 3490593; float f = (float) x; printf(\"For x = %d\\n\", x); show_int(x); show_float(f); x = 3510593; f = (float) x; printf(\"For x = %d\\n\", x); show_int(x); show_float(f);&#125;void string_ueg() &#123;/* $begin show-ustring */const char *s = \"ABCDEF\";show_bytes((byte_pointer) s, strlen(s));/* $end show-ustring */&#125;void string_leg() &#123;/* $begin show-lstring */const char *s = \"abcdef\";show_bytes((byte_pointer) s, strlen(s));/* $end show-lstring */&#125;void show_twocomp()&#123;/* $begin show-twocomp */ short x = 12345; short mx = -x; show_bytes((byte_pointer) &amp;x, sizeof(short)); show_bytes((byte_pointer) &amp;mx, sizeof(short));/* $end show-twocomp */&#125;//check is_litter_endianbool is_litter_endian()&#123; int a = 0x123456; if( *((char*)&amp;a) == 0x56) return 1; else return 0;&#125;int main(int argc, char *argv[])&#123; int val = 12345; if (argc &gt; 1) &#123; if (argc &gt; 1) &#123; val = strtol(argv[1], NULL, 0); &#125; printf(\"calling test_show_bytes\\n\"); test_show_bytes(val); &#125; else &#123; printf(\"calling show_twocomp\\n\"); show_twocomp(); printf(\"Calling simple_show_a\\n\"); simple_show_a(); printf(\"Calling simple_show_b\\n\"); simple_show_b(); printf(\"Calling float_eg\\n\"); float_eg(); printf(\"Calling string_ueg\\n\"); string_ueg(); printf(\"Calling string_leg\\n\"); string_leg(); //exercise 2.59 if(is_litter_endian()) cout&lt;&lt;\"litter endian\"&lt;&lt;endl; else cout&lt;&lt;\"big endian\"&lt;&lt;endl; &#125; return 0;&#125; 结果见图： 可以发现，我的电脑是小端法机器，浮点数的编码方法，和二进制的编码方法不太一样，浮点数的编码方法，我在浮点数编码方法最后一个例子有详细说明。 其中值得一提的是，取最低有效字节的方法：1234x &amp; 0xFF //取出x的最低有效字节y &amp; ~0xFF //取出y的最低有效字节((x &amp; 0xff) | (y &amp; ~0xff)) //能够实现x的最低有效字节和//y除了最低有效字节外的其他字节合并 12345678910111213#include &lt;stdio.h&gt;//注意：不要打0x作为输入int main()&#123; int x,y; int res; printf(\"Please int x(H) and y(H): \"); scanf(\"%x%x\",&amp;x,&amp;y); res = ((x &amp; 0x000000ff) | (y &amp; 0xffffff00)); printf(\"The result is %.8x(H)\\n\",res);&#125; 类似的方法，常常用于处理某一个字节替换问题： 结论见图： 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;unsigned replace_byte(unsigned x, unsigned char b, int i)&#123; return (x &amp; ~(0xff&lt;&lt;(i&lt;&lt;3))) | (b&lt;&lt;(i&lt;&lt;3));&#125;int main()&#123; printf(\"0x%x\\n\",replace_byte(0x12345678,0xab,2)); printf(\"0x%x\\n\",replace_byte(0x12345678,0xab,0));&#125;` 位级整数编码原则算术右移和逻辑右移的关系算术右移和逻辑右移是不一样的算术右移需要考虑符号位，右移一位，若符号位为1，在左边补1逻辑右移，补0就可以 这里以-1为例，-1算术右移一位，所产生的二进制码代表的数值不变；而逻辑右移则会使最高位为0，变成（1&lt;&lt;63）-1，最大值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int judge_if_all_1(int x)&#123; return !(~x);&#125;int judge_if_all_0(int x)&#123; return !x;&#125;int judge_low_is_0(int x)&#123; //最低有效字节：x &amp; 0xff return !(x &amp; 0xff);&#125;int judge_low_is_1(int x)&#123; return (x &amp; 0xff);&#125;int judge_high_is_0(int x)&#123; //除最高字节以外的位数 //howmanybit=(sizeof(int)-1)&lt;&lt;3 // a&lt;&lt;3表示a*8，因为一位有8个比特 //右移howmanybit位 return !( (x&gt;&gt;((sizeof(x)-1)&lt;&lt;3)) );&#125;int main()&#123; int a; scanf(\"%x\",&amp;a); cout&lt;&lt;judge_low_is_0(a)&lt;&lt;endl; cout&lt;&lt;judge_low_is_1(a)&lt;&lt;endl; cout&lt;&lt;judge_high_is_0(a)&lt;&lt;endl; cout&lt;&lt;judge_if_all_0(a)&lt;&lt;endl; cout&lt;&lt;judge_if_all_1(a)&lt;&lt;endl;&#125; 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;//int_shifts_are_arithmetic()//对int类型数使用算术右移返回1，否则返回0；//显然，只需考虑负数即可（非负数算术右移与逻辑右移相同）。//显这里以-这里以-这里以-这里以-1为例，//-1算术右移一位，所产生的二进制码代表的数值不变；//-而逻辑右移则会使最高位为0，变成（1&lt;&lt;31）-1，最大值。int int_shifts_are_arithmetic()&#123; printf(\"%x %x\\n\", ((-1)&gt;&gt;1),-1); return ((-1)&gt;&gt;1)==-1;&#125;int main()&#123; cout&lt;&lt;int_shifts_are_arithmetic()&lt;&lt;endl; return 0;&#125; 算术右移有一个特点，移几位，补几个最高位举一个例子$[x_{w-1},x_{w-1}…x_{w-1},x_{w-2}…x_{k}]$ 算术右移和逻辑右移相互表示这里先提一点：算术右移和逻辑右移，其中涉及到有符号数和无符号数的相互转换，这个问题比较重要，公式如下： T2U_w(x)= \\begin{cases} x+2^w& \\text{x=0} \\end{cases}一个无符号数，转换成对应的有符号数，依据是：补码原则 U2T_w(x)= \\begin{cases} u& \\text{uTMaxw} \\end{cases}其中$TMax_w$表示符号类型如$int$最大的位数 基于以上公式，我们发现从$int$类型向$unsigned$类型转换的时候，只有x为负数，逻辑右移和算术右移才能够体现出区别，我们这里仅研究$x&lt;0$的情况 12sra()表示用逻辑右移完成算术右移srl()表示用算术右移完成逻辑右移 原理表示如下(仅仅研究$x&lt;0$情况)： 123456789101112131415int sra(int x,int k)&#123; //Perform shift logically int xsrl = (unsigned)x &gt;&gt; k; //转换成为无符号数 int w = (sizeof(int))&lt;&lt;3; returnx xsrl |= (-1 &lt;&lt; (w-k));&#125;unsigned srl(unsigned x, int k)&#123; //Perform shift arithmetically unsigned xsra = (int) x &gt;&gt; k; int w = (sizeof(int)) &lt;&lt; 3; return xsra &amp;= ~(-1 &lt;&lt; (w-k));&#125; 判断奇数位是否为11234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;iostream&gt;bool any_odd_one(unsigned x)&#123; //将所有的奇数位全部置为0，偶数位不变 //考虑&amp;...01010101 //&amp;0x55555555(32bits) //若奇数位有1，则提取奇数位，结果不为0 return 0!=(x&amp;0x55555555);&#125;int main()&#123; printf(\"%d\\n\",any_odd_one(0x5) ); printf(\"%d\\n\",any_odd_one(0x25) ); printf(\"%d\\n\",any_odd_one(0x7) ); return 0;&#125; 二分法位运算：有多少个位包含1注意：^异或运算，相当于无进位的加法，可以消除位中的1 有两种方法：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;//不用位运算的方法int even_ones_without_bit(unsigned x)&#123; int result = 0; for(int i=0;i&lt;(sizeof(int)&lt;&lt;3);i++) &#123; int y = x&gt;&gt;i; y=y&amp;1; if(y) result++; &#125; if(result%2) return 1; else return 0;&#125;int odd_ones(unsigned x)&#123; //用异或运算消除偶数 x ^= (x&gt;&gt;16); x ^= (x&gt;&gt;8); x ^= (x&gt;&gt;4); x ^= (x&gt;&gt;2); x ^= (x&gt;&gt;1); return (x&amp;1);&#125;int main()&#123; int x; scanf(\"%x\",&amp;x); int res=odd_ones(x); printf(\"%d\\n\",res);&#125; 二分法运算：只保留最高位的1 函数功能如下：10xFF00--&gt;0x8000 0x6600--&gt;0x4000 实现方法：123456789101112131415161718192021#include &lt;stdio.h&gt;int leftmost_one(unsigned x)&#123; x |= (x&gt;&gt;1); x |= (x&gt;&gt;2); x |= (x&gt;&gt;4); x |= (x&gt;&gt;8); x |= (x&gt;&gt;16); x &amp;= ~(x&gt;&gt;1); return x;&#125;int main()&#123; int x; scanf(\"%x\",&amp;x); int res=leftmost_one(x); printf(\"%x\\n\",res);&#125; 移位运算需要注意的可以知道：移位运算，移位的量，区间是$(0,w-1)$通过移位运算，使得在32位的机器上可以运行 这里说一下移位运算的溢出：注意第一位是符号位1234560000 -- 00001 -- 10010 -- 2...0111 -- 71000 -- -8 以32位机器举例，int的最大值位$2^{32-1}=2147483648$int型，若为正数，可以表示的最大的数为123450111 1111 1111 1111 1111 1111 1111 1111//最高位是符号位，为0,值为2147483647//加上1之后1000 0000 0000 0000 0000 0000 0000 0000//值为负数，-2147483648 判断一个机器是否为32位，只要用上述方法可以判断。具体实现如下： 12345678910111213#include &lt;stdio.h&gt;bool int_size_is_32()&#123; int set_msb = ~(1&lt;&lt;31); return (set_msb+1&lt;0);&#125;int main()&#123; bool res = int_size_is_32(); printf(\"%d\\n\",res);&#125; 位级运算完成置位lower_one_mask使用位级运算完成置位的过程，通常需要将二进制转换成如下形式：12345600000 111111//即前几个数都为0，后几个数都为1的形式//lower_one_mask函数的实现//0xFFFFFFFF&gt;&gt;(32-n)//00...011...1形式，最后就有n位为1 12345678910111213141516#include &lt;stdio.h&gt;int lower_one_mask(int n)&#123; unsigned mark = 0xffffffff; mark = mark &gt;&gt; (32-n); return mark;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); int res = lower_one_mask(n); printf(\"%x\",res);&#125; 旋转：rotate_left123//取最高m位和最低n位的方法：x&gt;&gt;(32-m)x&lt;&lt;(32-n) 123456789101112131415161718192021#include &lt;stdio.h&gt;unsigned rotate_left(unsigned x, int n)&#123; if(n==0) return x; else &#123; unsigned low = x&lt;&lt;n; unsigned high = x&gt;&gt;(32-n); return low | high; &#125;&#125;int main()&#123; int x,n; scanf(\"%x%d\",&amp;x,&amp;n); int res=rotate_left(x,n); printf(\"%x\\n\",res);&#125; 补码运算的原理1、补码中取反，反码的求法。 1234反码，以下讨论不包括符号位010110的反码111111-010110 = 101001这里不讨论符号位 2、补码原理： 假设计算机字长为n，源码、反码和补码的关系如下： 原码：123456[+1]_源 = 0000 0001[-1]_源 = 1000 0001其中第一位为符号位取值范围[1111 1111, 01111 1111]--&gt;[-127,127] 从公式上看，当$x&gt;0$时，很显然x的源码就是x自身$x&lt;0$时候，除去最高位外，剩下的位数的值等于$|x|=-x$，再加上最高位的1，即加上$2^{n-1}$，最后的值为$2^{n-1}-x$ 反码：123456正数反码不变负数反码，符号位不变，各位取反[+1]=[0000 0001]_源=[0000 0001]_反[-1]=[1000 0001]_源=[1111 1110]_反可以用[1000 0000]表示-128 负数的反码，除了符号位，各位取反，其实是12仅看数值位(n-1)11...1 - xxxxx 数值位取反即为$2^{(n-1)}-1-(-x)=2^{(n-1)}-1+x$解释：10xffffffff-(-x) 最高位，即符号位为$2^{n-1}$，数值位全部为1，表示为$2^{n-1}-1$数值位取反$2^{n-1}-1-(-x)$ 最后我们再加上符号位$2^{n-1}$所以答案为$2^{n-1}+(2^{n-1}-1+x)=2^n+x-1$ 补码：为什么是取反码加一？假设我们有正数 0000 0000 0000 1111，我们如何表示其相反数呢？一般我们的思路是，找一个数，跟它相加的结果等于0，但是我们发现，要找出一个与它相加后结果等于0的数还是要略加思考一下的（因为要计算进位），所以，为何不找出一个与它相加后结果是1111 1111 1111 1111的数，然后该数+1即是我们所要的答案啦。 A+(相加等于全部是11111的数)+1 = 0所以A的相反数等于：求出与A相加全部是11…1的数，然后加1于是就推出：补码等于反码+1 缩进后再暴露最高位的方法，来看看补码是否等于原来的数 123456789101112131415161718#include &lt;stdio.h&gt;//一个数能够用二进制补码表示//可以知道这个数为正数int fits_bits(int x, int n)&#123; //对最高位进行缩进表示 int bias = (sizeof(int) &lt;&lt; 3)-n; return ((x&lt;&lt;bias)&gt;&gt;bias)==x;&#125;int main()&#123; int x,n; scanf(\"%d%d\",&amp;x,&amp;n); int res = fits_bits(x,n); printf(\"%d\\n\",res);&#125; xbyte123456789101112131415161718192021222324#include &lt;stdio.h&gt;typedef unsigned packed_t;int xbyte(packed_t word, int bytenum)&#123; int move_to_high = (3-bytenum)&lt;&lt;3; //将要处理的字节移动到首字节 unsigned mask = (0xff) &lt;&lt; 24; //第一个字节设置掩码 int res = (word &lt;&lt; move_to_high) &amp; mask; res = res &gt;&gt; 24; return res;&#125;int main()&#123; int hex,n; scanf(\"%x%d\",&amp;hex,&amp;n); printf(\"%x\\n\",xbyte(hex,n)); return 0;&#125; 特别注意的地方：12345678if(maxbytes-sizeof(val)&gt;=0)&#123; //&#125;条件是恒正的，因为结果是无符号数，无符号数大于0是肯定的正确写法：if(maxbytes&gt;=sizeof(val)) 位运算实现饱和加法饱和加法，在正溢出的时候，返回$TMax$。 先来看正常情况下的加法123两个正数加法溢出011...1 + 1 = 100...0最后sum的符号位被置为1 所以最后的$TMax$会是一个绝对值比较大的负数 这里我们要返回$TMax$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int saturating_add(int x, int y)&#123; int mask = INT_MIN; //INT_MIN所有位均为1，构成了掩码 int sum = x+y; int w = sizeof(int)&lt;&lt;3; //负溢出的时候，获取最小值 //负溢出的情况，原来x,y的第一位为1 //即有(x &amp; mask) (y &amp; mask) //注意&amp;&amp;运算，() &amp;&amp; ()， //注意&amp;&amp;运算，连接两个非0数， //结果也只为0或者1 //(x &amp; mask) &amp;&amp; (y &amp; mask) &amp;&amp; !(sum &amp; mask) //在负溢出的时候为1，1&lt;&lt;(w-1)&gt;&gt;(w-1) //会把所有的位置为1，因为有符号数要补上符号位 //最后 &amp; INT_MIN，保证INT_MIN正确输出 int tmin = ( ((x&amp;mask) &amp;&amp; (y&amp;mask) &amp;&amp; !(sum&amp;mask)) &lt;&lt;(w-1)&gt;&gt;(w-1) ) &amp; INT_MIN; //这一步，关键是如果前半部分的值为1，说明溢出，溢出返回的是INT_MIN //不用if语句，我们要得到INT_MIN，需要INT_MIN &amp; 11...1 //前半部分的值为1，要让所有的位值都是1，需要&lt;&lt;(w-1)&gt;&gt;(w-1) //算术右移，前面是带上符号位的 int tmax = ( ((~x&amp;mask) &amp;&amp; (~y&amp;mask) &amp;&amp; (sum&amp;mask)) &lt;&lt;(w-1)&gt;&gt;(w-1) ) &amp; INT_MAX; return (sum&amp; ~(!(tmin | tmax))) | tmin | tmax; //这里重点说明一下没有溢出的情况： //[tmin,tmax) 其中tmin=11...1 tmax=011...1 //tmin|tmax = 11...1，这样的目的是把符号位的1也参与进运算中 //--&gt; !(tmin | tmax)=00...0 --&gt; ~(!(tmin|tmax))=11...1 //sum &amp; res = sum，符号位也原封不动地包含下来&#125;void show_saturating_add(int x,int y)&#123; printf(\"satuarating_add(0x%08x,0x%08x)=0x%08x--&gt;%d\\n\",x,y,saturating_add(x,y),saturating_add(x,y)); printf(\"%d+%d=%d\\n\",x,y,x+y); printf(\"\\n\");&#125;int main()&#123; int x,y; scanf(\"%x%x\",&amp;x,&amp;y); show_saturating_add(x,y);&#125; 同样，怎么判断减法是否溢出呢？减法的溢出会导致一个非常大的正数，用这样的思路来分析。1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;//判断x-y溢出，返回1int tsub_ok(int x,int y)&#123; return ( (y&gt;0 &amp;&amp; x-y&gt;x) || (y&lt;0 &amp;&amp; x-y&lt;x) );&#125;void show_tsub_ovf(int x, int y)&#123; printf(\"%d-%d=%d %s\\n\",x,y,x-y,tsub_ok(x,y)?\"overflow\":\"not_overflow\");&#125;int main()&#123; int x,y; scanf(\"%x%x\",&amp;x,&amp;y); show_tsub_ovf(x,y);&#125; 理解定点数的乘法对于位模式$x$，我们计算$B2U_w(x)-B2T_w(x)=x_{w-1}(2^{w-1}-(-2^{w-1}))=x_{w-1}2^w$$B2U_w(T2B_w(x))=T2U_w(x)=x+x_{w-1}2^w$$x’=x+x_{w-1}2^w$$y’=y+y_{w-1}2^w$$(x’\\times y’)mod 2^w =$$[(x+x_{w-1}2^w)\\times (y+y_{w-1}2^w)]mod 2^w=[x \\times y+(x_{w-1}y+y_{w-1}x)2^w+x_{w-1}y_{w-1}2^{2w}]mod 2^{w}$$=(x \\times y)mod2^w$ 重点看一下定点数乘法的运算过程 原码乘法原码乘法的原理可以用下图表示： 原码乘法的计算过程，如上面的公式表示的那样，$w$位的两个数相乘，最后得到的数是$2w$位。所以用“部分积寄存器”来表示积的高位，用“乘数寄存器”来表示低位。其中，乘数的位为0或者1，0表示不加任何数，1表示加上被乘数。乘数的位值，仅仅是一个标志，表示是否加上被乘数。被乘数保持不变。 具体的实现方法如下： 值得注意的是，原码乘法执行的是逻辑右移 补码乘法补码乘法有两种：第一是校正法，注意在末尾加上$[-x]_{complement}$ 第二种方法是booth方法，booth方法，最后一步不移位，那怎么判断乘积是否结束了呢？看看在乘数寄存器中，新更新的位数，是不是恰好为$w$位？ 位运算与定点数乘法从上面的分析可以看出，定点数乘法，$w$位的两个数相乘，我们可以得到$2w$位。如果$x$和$y$都是无符号数，并且运行在数据类型是unsigned的$w$位机器上。乘积的低$w$位能够用表达式$x\\times y$计算。我们需要一个具有下列原型的函数：12unsigned unsigned_high_prod(unsigned x,unsigned y);//计算无符号变量x*y的高w位 12int signed_high_prod(int x,int y)//计算x和y采用补码形式的情况下，x*y的高w位 针对上面的公式，我们不妨把计算结果用$2w$来表示$[(x+x_{w-1}2^w)\\times (y+y_{w-1}2^w)]mod 2^w=[x \\times y+(x_{w-1}y+y_{w-1}x)2^w+x_{w-1}y_{w-1}2^{2w}]mod 2^{w}$ 将计算结果对$2^w$取余，比如64位的量，可以对$2^64$取mod，最后的结果是有64位：位分别为0,1,2…63 我们要获得高$32$位，可以1234unsigned unsigned_high_prod(unsigned x, unsigned y) &#123; int sig_x = x &gt;&gt; 31; int sig_y = y &gt;&gt; 31; int signed_prod = signed_high_prod(x, y); 上述运算实现了：$[x \\times y+(x_{w-1}y+y_{w-1}x)2^w]mod 2^{w}$ 我们将上述值同时移位$w$，就可以实现$[(x \\times y) (&gt;&gt;w)+(x_{w-1}y+y_{w-1}x)]$ 其中$x_{w-1}$就是$x$的符号位12int sig_x = x &gt;&gt; 31//获取x_(w-1)的值 其中$x\\times y$表示int类型的值，是有符号数。 实现如下： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;inttypes.h&gt;int signed_high_prod(int x,int y)&#123; int64_t mul = (int64_t) x*y; return mul &gt;&gt; 32;&#125;unsigned unsigned_high_prod(unsigned x,unsigned y)&#123; int sig_x = x &gt;&gt; 31; int sig_y = y &gt;&gt; 31; int signed_prod = signed_high_prod(x,y); return signed_prod + sig_x * y + sig_y * x;&#125;unsigned compared_high_prod(unsigned x,unsigned y)&#123; uint64_t mul = (uint64_t) x*y; return mul &gt;&gt; 32;&#125;int main()&#123; unsigned x = 0x12345678; unsigned y = 0xffffffff; int test = unsigned_high_prod(x,y); int compared = compared_high_prod(x,y); printf(\"Test: %8x\\n\",test); printf(\"compared: %8x\\n\",compared);&#125; 本章中的其他一些问题(库函数)calloc.c1void* calloc(size_t nmemb, size_t size); 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;void* my_calloc(size_t nmemb,size_t size)&#123; if(nmemb==0 || size==0) return NULL; size_t buf_size = nmemb * size; if(nmemb == buf_size/size) &#123; void* ptr = malloc(buf_size); memset(ptr,0,buf_size); return ptr; &#125; return NULL;&#125;int main()&#123; void* p; p = my_calloc(0x1234,1); //一共有0x1234个元素，每个元素1字节 bool flag = (p!=NULL); if(flag) printf(\"Case 1 :Not Null \\n\"); else printf(\"Case 1 :Null\\n\"); free(p); p = my_calloc(SIZE_MAX,2); flag = (p==NULL); if(flag) printf(\"Case 2 :NULL\\n\"); else printf(\"Case 2 :Not Null\\n\");&#125; 使用移位运算完成倍乘123456//注意乘数为负数的时候怎么表示？int A(int x)&#123; return x - (x &lt;&lt; 3); //表示-7x&#125; 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;iostream&gt;using namespace std;int A(int x)&#123; return x + (x &lt;&lt; 4);&#125;int B(int x)&#123; return x - (x &lt;&lt; 3);&#125;int C(int x)&#123; return (x &lt;&lt; 6) - (x &lt;&lt; 2);&#125;int D(int x)&#123; return (x &lt;&lt; 4) - (x &lt;&lt; 7);&#125;int main()&#123; int x = 0x1; printf(\"Case A: %d\\n\",A(x)); printf(\"Case B: %d\\n\",B(x)); printf(\"Case C: %d\\n\",C(x)); printf(\"Case D: %d\\n\",D(x));&#125; 移位运算与舍入问题仅有乘法或除法 移位运算的舍入问题，遵循以下不等式：$[x]+[x+\\frac{1}{n}]+[x+\\frac{2}{n}]+\\cdots+[x+\\frac{n-1}{n}]=[nx]$ 观察上图：从上表中可以看到，当右移8位的时候，得到-49，这与向零舍入的结果-48并不吻合。右移总是向下舍入，而对于向零舍入的负数来说是向上舍入，因此为了保证结果吻合，需要进行一个偏置。 bias偏移规律如下： 123if(A&lt;0) A+=(1&lt;&lt;k)-1;A&gt;&gt;n; 实现方法：123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;limits.h&gt;int divide_power2(int x, int k)&#123; int is_neg = x &amp; INT_MIN; if(is_neg) x += (1&lt;&lt;k)-1; return x&gt;&gt;k;&#125;int mul3div4(int x)&#123; int mul3 = x+(x&lt;&lt;1); return divide_power2(mul3,2);&#125;int main()&#123; int x; scanf(\"%x\",&amp;x); printf(\"%8x\\n\",divide_power2(x,2)); printf(\"%8x\\n\",x/4); int y; scanf(\"%x\",&amp;y); printf(\"mul3div4: %x\\n\",mul3div4(y)); printf(\"check: %x\\n\",3*y/4); return 0;&#125; 乘除法相结合可以发现我们需要：1、最后$k$位置为0，得到$low$。2、将前面$w-k$位置为0，得到$high$ 12345678//例如：x*(6/8),8=2^3int low = x &amp; 0x7;//仅仅保留最后3位，用掩码(111 &amp; x)int high = x &amp; ~0x7//掩码获得x的高位，将低3位置为0//low high分别计算 具体实现：1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;limits.h&gt;int threefourths(int x)&#123; int is_neg = x &amp; INT_MIN; int low = x &amp; 0x3; int high = x &amp; ~0x3; int highd4 = high &gt;&gt; 2; int highd4m3 = highd4 + (highd4 &lt;&lt; 1); int lowm3 = low + (low &lt;&lt; 1); int bias = (1&lt;&lt;2) - 1; if(is_neg) lowm3 += bias; int lowm3d4 = lowm3 &gt;&gt; 2; return lowm3d4 + highd4m3;&#125;int main()&#123; int x; scanf(\"%d\",&amp;x); printf(\"Test: %d\\n\",threefourths(x)); printf(\"Real: %d\\n\",x*3/4);&#125; 位模式的表示方式$1^{w-k}0^k$$0^{w-k-j}1^k0^j$ 这两种都可以用移位来表示 其中$0^{w-k-j}1^k0^j$可以分成三步走：第一步：获取$1^{w-k}0^k$，通过右移实现第二步：获取$0^{w-k}1^k$，通过取反实现第三部：再右移$j$位 实现方法：123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;iostream&gt;int A(int k)&#123; return -1 &lt;&lt; k; //表示-1重复k次&#125;int B(int k,int j)&#123; return (~A(k)) &lt;&lt; j;&#125;int main()&#123; int x; scanf(\"%d\",&amp;x); printf(\"%8x\\n\",A(x)); printf(\"0xFFFFFF00\\n\"); printf(\"%8x\\n\",B(16,8)); printf(\"0x00FFFF00\\n\");&#125; 移位运算时候常见的错误12345int x = random();int y = random();unsigned ux = (unsigned) x;unsigned uy = (unsigned) y; 补码的非位级表示：对于任意数值1-x == ~x+1 从数学上解释这一点： -^{t}_{w}x= \\begin{cases} TMin_{w}& \\text{x=TMinw}\\\\ -x& \\text{x>TMinw} \\end{cases}$2^w-x=-x$$-x$表示$x$的相反数 $2^w-x-1=-x-1$$2^w-1-x$表示全1的位减去$x$，得到~x 1-x=~x+1 成立 12345(x&lt;y) == (-x&gt;-y)//wrong! x=INT_MIN//此时-x = ~x + 1//~x=011...1//~x+1 = 100...0 仍然为INT_MIN 1((x+y)&lt;&lt;4)+y-x == 17*y+15*x 123~x+~y+1=(~x+1)+(~y+1)-1=-x+-y-1=-(x+y)-1 123(ux-uy)==-(unsigned)(y-x)--&gt; -(ux-uy)==(unsigned)(y-x)--&gt; (uy-ux)==(unsigned)(y-x) 显然成立 1234(x&gt;&gt;2)&lt;&lt;2--&gt; x&amp; ~(0x3)--&gt; x + -num(00/01/10/11)--&gt; (x&gt;&gt;2)&lt;&lt;2 &lt;= x 特殊的二进制无穷串一些数字的二进制表示是$0.yyy\\cdots$，其中$y$是一个$k$位的序列。 1234n = 0.yyy...n&lt;&lt;k = y.yyy...=Y+n--&gt; n&lt;&lt;k-n=Y--&gt; n = Y/(2^k-1) 1234567应用：a) 101 Y=5 k=3 n=5/7b) 0110 Y=6 k=4 n=6/15=2/5c) 010011 Y=19 k=6 n=19/63 用unsigned测试float型数据的大小1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;unsigned f2u(float x)&#123; return *(unsigned*) &amp;x;&#125;int float_le(float x,float y)&#123; unsigned ux = f2u(x); unsigned uy = f2u(y); unsigned sx = ux &gt;&gt; 31; unsigned sy = uy &gt;&gt; 31; return sx==sy ? (sx==0 ? ux&lt;=uy : ux&gt;=uy) : sx&gt;sy;&#125;int main()&#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); int flag = float_le(x,y); printf(\"%d\\n\",flag);&#125; 浮点数概论 为什么要引入$bias$？因为就小数部分而言，比如$0.1010$，计算机是按照二进制编码来计算$1010=10$，无法表示$2^{-k}$，所以我们引入$bias$来表示。因为没有负值的符号位啊！$e_{k-1}e_{k-2}\\cdots e_{0}$，要表示$(-1)00\\cdots 0$，只要$0-2^{k-1}$，表示把符号位置为$-1$。可是为什么bias取$2^{k-1}-1$而不是$2^{k-1}$直观上可以这么理解，$00\\cdots 0$表示0，而$11\\cdots 1 \\ 00\\cdots0$表示无穷大。所以要除掉那个无穷大的，即为$2^{k-1}-1$ 几个问题：1、32位ieee 754的阶码偏移量为何用127?而不是128为了让表示的范围能够对称起来。 当阶码E为全0且尾数M也为全0时，表示的真值x为零，结合符号位S为0或1，有正零和负零之分。当阶码E为全1且尾数M为全0时，表示的真值x为无穷大，结合符号位S为0或1，也有+∞和-∞之分。这样在32位浮点数表示中，要除去E，用全0和全1(255)表示零和无穷大的特殊情况，指数的偏移值不选128(10000000)，而是127(01111111)。对于规格化浮点数，阶码E范围是1~254。 非规格化数$E=1-bias$规格化数$E=e-bias$，其中$e=e_{k-1}e_{k-2}\\cdots e_{0}$ 对于规格化的值当$exp$的位模式既不全为0，也不全为1，$E=e-bias$$e=e_{k-1}e_{k-2}\\cdots e_{0}$$bias=2^{k-1}-1$很显然$e_{min}=1$，则$E_{min}=1-2^{k-1}+1=2-2^{k-1}\\geq 2-1=1$同理$e_{max}=2^k-2$，(扣除全部为1的值),$E_{max}=2^k-2-2^{k-1}+1=2^{k-1}-1$ $127=2^{8-1}-1$，此时$k=8$想一想，如果我们让偏移值为128，而不是127，会是什么样？$E_{min}=1-2^7=-127$，所表示的值为$2^{-127}=5.877471754111438\\times 10^{-39}$$E_{max}=2^7-2=126$，所表示的值$2^126=8\\times 10^{37.9297}$不对称。 而相反，我们让偏移值为127，可以得到取值范围为：$E_{min}=1-2^{7}+1=-126$，$2^{-126}=1.1754943508222875\\times 10^{-38}$$E_{max}=2^7-1=127$，$2^{127}=1.7 \\times 10^{38.23080944932561}$ 很显然，偏移值为127的时候上下对称。 非规格化数的平滑处理为什么要将$E$定义为$1-bias$,这样的方法归功于平滑性的设计。你肯定想问，1是哪里来的？ 浮点数编码表示方法注意《深入理解计算机系统》这本书中，尾数的表示方法，和现行的中文教材不太一样。在《深入理解计算机系统》这本书中提到：尾数的范围是$[1,2-\\epsilon)$而在我们现行的教材上，尾数的范围是$[0,1-\\epsilon)$ 浮点数编码能够表示的范围 注意在尾数部分，小数点是跟在数符后面的。 浮点数的规格化浮点数的规格化表示，要求小数点后的第一位必须是$1$(基数$r=2$)，其他情况如果$r=4$，则小数点后最高2位不全为0。 举例1 特别注意，在这个例子中，阶码是正数，它的补码保持不变，尾数的补码要取反加一 在《深入理解计算机系统》这本书中，规定尾数M是二进制小数，它的范围是$[1,2-\\epsilon)$如果按照这样的规定：$7.0=111.0$$111.0=1.11\\times 2^{10}$，特别说明这里$2^{10}$表示小数点往右移动2位，$10$是二进制数。可以知道阶码用2位来表示，$E=2$，$M=1.11$，$f=0.11$，$e=bias+E$ 举例2与Intel兼容的处理器采用“扩展精度”浮点形式。这种格式具有80位字长，1个符号位，k=15个阶码位，1个单独的整数位和n=63个小数位。注意，阶码位15个，其中一个位用来保存阶符。所以如果阶码部分全部为1，其阶码值为$bias=2^{14}-1$最小的正非规格化数$1,11\\cdots 1(14) \\; 00\\cdots 0(62)1$，括号表示位值重复了多少次。相对应的十进制值为$2^{-bias}\\times 2 \\times 2^{-63}=2^{1-bias-63}$特别注意，非规格化数的偏置值为$1-bias$而不是$-bias$，多乘了一个2，为什么？这个是为了表示非规格化值平滑转换到规格化值。 最小的正规格化数$1,11\\cdots 1(14) \\; 100\\cdots 0(62)=2^{-bias}\\times 2^{-1}=2^{-(bias+1)}$ 最大的规格化数$0,11\\cdots 1(14) \\; 11\\cdots 1(63)=2^{bias}\\times (1-2^{-63})$ 举例3在2008版的IEEE浮点数标准中，为了表示数$\\frac{7}{8}$，很显然$s=0$，表示正数，$7=111.0$，$\\frac{7}{8}$表示小数点左移3位。$\\frac{7}{8}=\\frac{7}{4} \\times 2^{-1}$，其中$V=(-1)^{s}\\times M \\times 2^{E}$，对比一下可以推出$M=\\frac{7}{4}$，$E=-1$$bias=2^{4}-1=15$，$e=E+bias=-1+15=14$，14用二进制表示为$01110$，这是阶码字段。尾数字段计算如下：$1.11 \\times 2^{E}$，其中1.11扩充成10位。$1100000000$表示尾数字段。$01110 \\ combined \\ with \\ 1100000000=hex(3b00)$ 由此我们可以填表：情况1：机器0$bias=2^{4}-1=15$-0，表示机器0，机器0的$M$值为0，由于规格化表示隐含小数点后的第一位是1，所以$e=XXX.100\\cdots 0$，即$e=1$，$E=e-bias=1-15=-14$$V=-0 \\ D=-0.0$$hex(0b10000 \\ 0000000000)=0x8000$ 情况2：最小的大于2的值$(-1)^{s} \\times M \\times 2^{E}$，要使得最小，很显然$E=1$，并且使得$s=0$并且$M$最小。$e=E+bias=1+15=16$，所以阶码部分可以表示成$10000$，再来看$M$，$M$要尽可能小，怎么样才能让$M$尽可能小，$M$为正数。$M=0000000001$，这样该值的二进制表示为$100000000000001$，十六进制为$0x4001$注意到由于是规格化表示，这个数的尾数数值部分应该是$1.000000001$，如果看成是小数点移动，则$10000000001=2^{10}+1=1025$，可以看作小数点向左移动10位，所以$1.000000001=1025/2^{10}=1025/1024$，所对应的$V=\\frac{1025}{1024} \\times 2^{E}=\\frac{1025}{512}=2.001953125$ 情况3:512$512.0=2^{9} \\times 1$，$1=2^{0}$，可以看作不移动小数点。$M=1.0000000000$，这里只研究小数部分，所以为$.0000000000$$M=1 \\; E=9 \\quad e=E+bias=9+15=24=0b11000$组合起来$11000 \\; 0000000000=0x6000$ 最大的非规格化数此时$M$不包括开头的1，最大的值对应的尾数部分是$0.0111111111=001111111111 \\times 2^{-10}=\\frac{1023}{1024}$再看阶码部分，非规格化数的阶码恒为$E=1-bias=1-15=-14$，综合看来，$\\frac{1023}{1024} \\times 2^{-14}=\\frac{1023}{2^{24}}$上述结果为$6.097555160522461e-05$十六进制的值为$00000001111111111=0x3ff$ 负无穷负无穷就是阶码值全部为1，尾数字段全部为0$1111110000000000=0xfc00$ 十六进制为3bb0的数$3bb0=011101110110000$，可以去除阶码部分的5位数$01110=14 \\quad e=14 \\quad E=e-bias=14-15=-1$再看$M=1110110000=$，其实，实际上表示的数为$1.111011$，规格化数中这里的1省略，$.111011=\\frac{111011}{2^{6}}=59/64$综上$\\frac{59}{64} \\times 2^{E}=\\frac{59}{128}$ 举例4对于第一行的例子：$\\frac{9}{16}$要凑成一个大于1的数$\\frac{9}{16}=\\frac{9}{8} \\times \\frac{1}{2}=(1+\\frac{1}{8}) \\times 2^{-1}=(1+\\frac{2}{16}) \\times 2^{-1}$$E=-1 \\quad e=E+bias=-1+7=6$可以写成是：$f \\quad 0010 \\quad \\quad e \\quad 0110$$1 \\ 0110 \\ 0010$ 对于1阶码为$10110$，$e=22 \\quad E=e-bias=22-15=7 \\quad f=\\frac{0b101}{2^{3}}=\\frac{1+4}{8}=\\frac{5}{8}$$M=1+\\frac{5}{8}=\\frac{13}{8} \\quad V=(-1)^{s} \\times M \\times 2^{E}=13 \\times 2^{4}$ 先确定下在格式B中的$frac=1010$，$f=\\frac{0b1010}{2^{4}}=\\frac{5}{8} \\quad M=\\frac{13}{8}$$V=(-1)^{s} \\times \\frac{13}{8} times 2^{E} \\quad E-3=4 \\quad e=7+bias=14$$14=0b1110$$0 \\ 1110 \\ 1010$ 对于2$e=00111=7 \\quad E-7-bias=7-15=-8$$f=\\frac{0b110}{8}=\\frac{6}{8} \\quad M=1+f=\\frac{7}{4}$$V=(-1)^{s} \\times 2^{E} \\times M=- \\frac{7}{2^{10}}$ 在格式B下：$frac=1100$$f=\\frac{0b1100}{16}=\\frac{12}{16}=\\frac{3}{4} \\quad M=1+f=\\frac{7}{4}$$M \\times 2^{E}=\\frac{7}{2^{10}} \\quad E=-8 \\quad e=E+bias=-8+7=-1$推出在格式B下为非规格化数由此$e=0b0000 \\quad E=1-bias=1-7=-6 \\quad 2^{-6} \\times M = 7 \\times 2^{-10}$$f=M=7 \\times \\frac{1}{2^{4}}$$frac=f \\times 16 = 7 = 0b0111$$1 \\ 0000 \\ 01111$ 对于3$e=0b00000 \\quad E=1-bias=1-15=-14$$f=M=\\frac{0b101}{8}=\\frac{1+4}{8}=\\frac{5}{8} \\quad V=\\frac{5}{8} \\times 2^{-14}=\\frac{5}{2^{17}}$ 对于非规格化数$e=0b0000 \\quad E=1-bias=1-7=-6$$M \\times 2^{E}=\\frac{5}{2^{17}} \\quad M=f=5 \\times 2^{-11}$$frac=f \\times 2^4=\\frac{5}{2^{7}}$，舍入到1，结果为$0 \\ 0000 \\ 0001$ $e=0b0000 \\quad E=1-bias=1-7=-6$$f=M=\\frac{1}{16}$$V=M \\times 2^{-6}=\\frac{1}{2^{10}}$ 对于4$e=0b11011=27 \\quad E=e-bias=27-15=12$$f=\\frac{0b000}{2^3}=0 \\quad M=1$$V=-M \\times 2^{12}=-2^{12}$ $frac=0b0000$肯定是不行的，会出现溢出，仅靠e的部分无法表示$2^{12}$阶码位最大为$4$位，能够取得的最大值为$0b1111$，$e=15 \\quad E=e-bias=15-7=8$但注意到在IEEE标准中，$1111 \\ 0000$表示$\\infty$，所以我们让$e=14$$e=14 \\quad e=0b1110 \\quad E=e-bias=14-7=7$$V=-2^{12}=-2^{5} \\times 2^{7}$$-2^{5}$舍入到$-31$，所以$V=-31 \\times 2^{7}$ $0000$要向上舍入，而原来的A&lt;0，所以取绝对值减一，舍入到$0000-1=1111$$frac=1111 \\quad f=\\frac{1111}{16}=\\frac{15}{16} \\quad M=1+f=\\frac{31}{16}$$V=(-1)^{s} \\times \\frac{31}{16} \\times 2^{E}$$\\frac{31}{16} \\times 2^{E}=31 \\times 2^{7}$$e \\leq 14$，所以$e \\leq 1110 \\quad E \\leq (e-bias=7)$$\\frac{31}{16}$舍入到$31$$E=7 \\quad e=1110$$e=1110 \\quad frac=1111$$1 \\ 1110 \\ 1111 \\quad V=- \\frac{31}{16} \\times 2^{7}=-31 \\times 2^{3}$ 对于5$frac=0b100 \\quad f=\\frac{0b100}{8}=\\frac{4}{8}=\\frac{1}{2} \\quad M=\\frac{3}{2}$$e=0b11000=24 \\quad E=e-bias=24-15=9$$V=(-1)^{s} \\times 2^{E} \\times M=3 \\times 2^{8}$ 对于B，$frac=0b1000=8$$f=\\frac{8}{16}=\\frac{1}{2} \\quad M=1+f=\\frac{3}{2}$$V=3 \\times 2^{8}$$3 \\times 2^{8}=\\frac{3}{2} \\times 2^{E} \\quad 2^{8}=2^{E-1} \\quad E=9$$e=9+7=16$，很显然溢出了。向正无穷舍入$\\frac{3}{2}$舍入到$\\frac{6}{2}$，即有$3 \\times 2^{8}=\\frac{3}{2} \\times 2^{E}$$E=8 \\quad e=8+7=15 \\quad e=0b1111$$e=0b1111$，很显然结果为$\\infty$$0 \\ 1111 \\ 0000 \\quad V=\\infty$ 举例5float类型的值使用32位的IEEE格式，double类型的值使用64位IEEE格式。随机数转换成为double类型的值，来测试精度的转换。 这里值得注意的是，浮点运算一般是不能结合的。主要是因为舍入的问题，容易出错。1234567890.2+0.3=0.5-&gt;11+0.5=1.5-&gt;20.3+0.5=0.8-&gt;10.2+1=1.2-&gt;1(0.2+0.3)+0.5=1+0.5-&gt;20.2+(0.3+0.5)=0.2+1-&gt;1二者并不相等 在本机上，运行相关代码得到的结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;limits.h&gt;#include &lt;assert.h&gt;#include &lt;ctime&gt;using namespace std;/*int create_random()&#123; srand((unsigned)time(NULL)); return rand();&#125;*/int A(int x,double dx)&#123; return (float) x == (float) dx;&#125;int B(int x,int y,double dx,double dy)&#123; return (dx-dy) == (double) (x-y);&#125;int C(double dx,double dy,double dz)&#123; return (dx+dy)+dz == dx+(dy+dz);&#125;int D(double dx,double dy,double dz)&#123; return (dx*dy)*dz == dx*(dy*dz);&#125;int E(double dx,double dz)&#123; return dx/dx == dz/dz;&#125;int main()&#123; srand( (unsigned)time(NULL) ); int x = rand(); int y = rand(); int z = rand(); printf(\"x: %d\\n\",x); printf(\"y: %d\\n\",y); printf(\"z: %d\\n\",z); double dx = (double) x; double dy = (double) y; double dz = (double) z; printf(\"check:\\n\"); cout&lt;&lt;\"A: \"&lt;&lt;A(x,dx)&lt;&lt;endl; cout&lt;&lt;\"Another A: \"&lt;&lt;A(0x20001,(double)0x20001)&lt;&lt;endl; cout&lt;&lt;\"B: \"&lt;&lt;B(0,INT_MIN,(double)0,(double)INT_MIN)&lt;&lt;endl; dx = (double)0x2001; dy = (double)INT_MIN; dz = (double)100; cout&lt;&lt;\"C: \"&lt;&lt;C(dx,dy,dz)&lt;&lt;endl; cout&lt;&lt;\"rand c:\"&lt;&lt;endl; dx = (double)rand(); dy = (double)rand(); dz = (double)rand(); cout&lt;&lt;C(dx,dy,dz)&lt;&lt;endl; dx = (double)rand(); dy = (double)0xFFFFFFFF; dz = (double)INT_MIN; cout&lt;&lt;\"D: \"&lt;&lt;D(dx,dy,dz)&lt;&lt;endl; dx = (double)rand(); cout&lt;&lt;\"E: \"&lt;&lt;E(dx,(double)0)&lt;&lt;endl;&#125; 从以上代码可以看出：减法行为，在12x=0;y=INT_MIN; 会出现溢出错误。 除法行为，在除数为0的时候会发生错误。 举例6编写一个C函数来计算$2^{x}$的浮点表示。完成这个任务最好的方法是直接创建结果的IEEE单精度表示。当$x$太小时，你的程序会返回$0.0$，当x太大时，它会返回$+ \\infty$。填写代码的空白部分，计算正确结果。假设函数$u2f$返回的浮点值与它的无符号参数有相同的位表示。 浮点值和无符号参数的位表示相同1234567float u2f(unsigned x)&#123; return *(float*) &amp;x; // &amp;x是变量x的地址 // (float*) &amp;x 获取float型指针 // *(float*) &amp;x 对指针解引用，得到float型的值&#125; $2^{x}$的浮点表示，最终结果是IEEE的单精度表示，如下图所示： 先确定偏置量，$bias$等于$exp$中的位数。1234567bias=1&lt;&lt;(8-1)-1=pow(2,7)-1=127//DenormalizedE=1-bias=2-pow(2,7)//NormalizedE=e-bias=e-pow(2,7) 1234float fpwr2(int x)&#123; // x仅仅表示指数，只需要观察指数部分&#125; 浮点表示：$(-1)^{s} \\times frac \\times 2^{E}$ 1、x小于最小的非规格化数此时$E=1-bias=2-pow(2,7)$，而frac部分有23位，全部清0，相当于$2^E&gt;&gt;23$，右移23位可以让$frac$部分清0，这样得到的数比最小的非规格化数还小$2^{E}&gt;&gt;23$，此时满足的条件是：$x&lt;2-pow(2,7)-23$ 2、x小于最小的规格化数，此时$2^x$表示非规格化数此时$e=1$，$bias=pow(2,7)-1$，$E=e-bias=2-pow(2,7)$$x&lt;2-pow(2,7)$，此时仅有frac部分。 很显然，此时$E=0$，$2^{E}=1$，所以$2^{x}=frac$$frac=2^{x}=2^{b}$，$b$此时的值是$x$相对于最小基准$2-pow(2,7)-23$，即只取超出$2-pow(2,7)-23$的部分。1frac=1&lt;&lt;(unsigned)(x-(2-pow(2,7)-23)) 3、x小于最大的规格化数，此时$2^x$表示规格化数最大的规格化数，此时指数$E=bias=pow(2,7)-1$，注意到此时E可以取到$pow(2,7)-1$ 此时取$frac=0$$2^{x}=2^{E}$，$x=E=exp-bias$，可以得到$exp=x+bias=x+pow(2,7)-1$ 4、剩余情况，取无穷$exp=0xFF$$frac=0$ 实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;float u2f(unsigned x)//这里涉及到无符号数转换成浮点数//使用引用&#123; return *(float*) &amp;x; // &amp;x是变量x的地址 // (float*) &amp;x 获取float型指针 // *(float*) &amp;x 对指针解引用，得到float型的值&#125;float fpwr2(int x)&#123; unsigned expr,frac; unsigned u; if(x &lt; 2-pow(2,7)-23) &#123; expr = 0; frac = 0; &#125; else if(x &lt; 2-pow(2,7)) &#123; expr = 0; frac = 1 &lt;&lt; (unsigned)(x - (2-pow(2,7)-23) ); &#125; else if(x &lt; pow(2,7)-1+1) &#123; expr = x + pow(2,7) - 1; frac = 0; &#125; else &#123; expr = 0xFF; frac = 0; &#125; u = expr &lt;&lt; 23 | frac; return u2f(u);&#125;int main()&#123; cout&lt;&lt;\"calculate: \"&lt;&lt;powf(2,0)&lt;&lt;\" test: \"&lt;&lt;fpwr2(0)&lt;&lt;endl; cout&lt;&lt;\"calculate: \"&lt;&lt;powf(2,100)&lt;&lt;\" test: \"&lt;&lt;fpwr2(100)&lt;&lt;endl; cout&lt;&lt;\"calculate: \"&lt;&lt;powf(2,-100)&lt;&lt;\" test: \"&lt;&lt;fpwr2(-100)&lt;&lt;endl; cout&lt;&lt;\"calculate: \"&lt;&lt;powf(2,10000)&lt;&lt;\" test: \"&lt;&lt;fpwr2(10000)&lt;&lt;endl; cout&lt;&lt;\"calculate: \"&lt;&lt;powf(2,-10000)&lt;&lt;\" test: \"&lt;&lt;fpwr2(-10000)&lt;&lt;endl; return 0;&#125; 举例7$\\pi$的单精度浮点值的十六进制表示为$0x40490FDB$注意，给的数为单精度浮点型的小数，frac部分有23位，exp部分有8位。1、二进制小数表示的二进制小数的小数部分为：$100 \\ 1001 \\ 0000 \\ 1111 \\ 1101 \\ 1011$二进制小数的阶码部分为：$1000 \\ 0000$$bias=2^{8-1}-1=127$$E=exp-bias=128-127=1$由于二进制的阶码部分不为0，所以二进制小数是规格化数，二进制小数可以如下表示：$1.100 \\ 1001 \\ 0000 \\ 1111 \\ 1101 \\ 1011$二进制小数可以表示成：$1.100 1001 0000 1111 1101 1011 \\times 2^{1}=11.0010010000111111011011$ 2、$\\frac{22}{7}$的二进制小数表示是什么$\\frac{22}{7}=3+\\frac{1}{7}$$3=0b11$$\\frac{1}{7}$的二进制小数表示是：$\\frac{Y}{2^{k}-1}$，可以知道$Y=1 \\ k=3$，$y$是一个3位的序列。可以看作$1&gt;&gt;3=\\frac{1}{2^{3}-1}=0.001$综上$\\frac{22}{7}$的二进制表示是：$0b11.001001001(001)$ 3、这两个$\\pi$的近似值从小数点后第九位开始不同 位级浮点编码规则对于参数$f$，如果$f$是非规格化的，该函数返回$\\pm0$12345678910111213141516171819float_bits float_denorm_zero(float_bits f)&#123; unsigned sign = f &gt;&gt; 31; //相当于把小数点放置在第31位后面，这样就得到符号位 unsigned exp = f &gt;&gt; 23 &amp; 0xFF; //相当于把小数点放置在exp位置之后，这样就得到了阶码部分 //取出相应的值，只要&amp;ff就可以 unsigned frac = f &amp; 0x7FFFFF; //只取小数位，共23位 if(exp == 0) &#123; frac = 0; &#125; return (sign &lt;&lt; 31) | (exp &lt;&lt; 23) | frac; //这里移动小数点，相当于右移小数点&#125; 例1对于浮点数$f$，计算$-f$，如果$f=\\infty$，函数返回$f$1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include \"float_negate.h\"#include &lt;math.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt;#include &lt;cstring&gt;#include &lt;limits.h&gt;#include &lt;climits&gt;using namespace std;float_bits float_negate(float_bits f)&#123; unsigned sign = f &gt;&gt; 31; cout &lt;&lt; sign &lt;&lt; endl; unsigned exp = f &gt;&gt; 23 &amp; 0xFF; cout &lt;&lt; exp &lt;&lt; endl; unsigned frac = f &amp; 0x7FFFFF; cout &lt;&lt; frac &lt;&lt; endl; if(exp == 0xFF &amp;&amp; frac != 0) //NAN return f; return (~sign &lt;&lt; 31) | (exp &lt;&lt; 23) | (frac);&#125;int main()&#123; unsigned testV; cin &gt;&gt; testV; unsigned res = float_negate(testV); cout &lt;&lt; \"test value is \" &lt;&lt; *(float*) (&amp;res) &lt;&lt; endl; cout &lt;&lt; \"The real value is \" &lt;&lt; -(*(float*)(&amp;testV)) &lt;&lt; endl; &#125; 实现结果： 例2遵循位级浮点编码规则，实现具有如下原型的函数：1float_bits float_absval(float_bits f); 实现方法如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;limits.h&gt;#include &lt;math.h&gt;using namespace std;/* * float-absval.h */typedef unsigned float_bits;float_bits float_absval(float_bits f);float_bits float_absval(float_bits f)&#123; unsigned sign = f &gt;&gt; 31; unsigned exp = f &gt;&gt; 23 &amp; 0xFF; unsigned frac = f &amp; 0x7FFFFF; int is_NAN = (exp == 0xFF) &amp;&amp; (frac != 0); if(is_NAN) return f; return 0 &lt;&lt; 31 | exp &lt;&lt; 23 | frac;&#125;float u2f(unsigned u)&#123; return *(float*) &amp;u;&#125;unsigned f2u(float u)&#123; return *(unsigned*) &amp;u;&#125; int main()&#123; unsigned testV; float f_test; cin &gt;&gt; testV &gt;&gt; f_test; float testF = u2f(testV); unsigned u_test = f2u(f_test); if(isnan(testF)) &#123; cout &lt;&lt; \"test \" &lt;&lt; testF; cout &lt;&lt; \"real \" &lt;&lt; testV; &#125; else &#123; cout &lt;&lt; \"test1= \" &lt;&lt; u2f(float_absval(testV)) &lt;&lt; endl; cout &lt;&lt; \"real1= \" &lt;&lt; fabs(testF) &lt;&lt; endl; cout &lt;&lt; \"test2= \" &lt;&lt; u2f(float_absval(u_test)) &lt;&lt; endl; cout &lt;&lt; \"real2= \" &lt;&lt; fabs(f_test) &lt;&lt; endl; &#125;&#125; 结果： 例3实现能够计算$2.0 \\times f$的函数。 实现函数如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;limits.h&gt;using namespace std;typedef unsigned float_bits;float_bits float_half(float_bits f);/* 本例中要求舍入到偶数 0b00 --&gt; 0b00 + addition(0) = 0b00 0b01 --&gt; 0b00 + addition(0) = 0b00 0b10 --&gt; 0b01 + addition(0) = 0b01 0b11 --&gt; /2=1.5=2 --&gt; 0b01 + addition(1) = 0b10 only 0b11 --&gt; addition = 1 if &amp;0b11 == 0b11 addition = 1 else addition = 0 addition = (frac &amp; 0x3) == 0x3*/float_bits float_half(float_bits f)&#123; unsigned sign = f &gt;&gt; 31; unsigned exp = f &gt;&gt; 23 &amp; 0xFF; unsigned frac = f &amp; 0x7FFFFF; unsigned remain = f &amp; 0x7FFFFFFF; int is_NAN_or_infinity = (exp == 0xFF); if(is_NAN_or_infinity)&#123; return f; &#125; int addition = (frac &amp; 0x3) == 0x3; if(exp == 0) &#123; //Denormalized frac &gt;&gt;= 1; frac += addition; &#125; else if(exp == 1) &#123; //Normalized to Denormalized remain &gt;&gt;= 1; remain += addition; exp = (remain &gt;&gt; 23) &amp; 0xFF; frac = remain &amp; 0x7FFFFF; &#125; else &#123; //include factor 2 exp -= 1; &#125; return sign &lt;&lt; 31 | exp &lt;&lt; 23 | frac;&#125;float u2f(unsigned u)&#123; return *(float*) &amp;u;&#125;unsigned f2u(float u)&#123; return *(unsigned*) &amp;u;&#125;int main()&#123; float f_test; cout &lt;&lt; \"input float : \"; cin &gt;&gt; f_test; unsigned u_test = f2u(f_test); float real = f_test / 2; cout &lt;&lt; \"real: \" &lt;&lt; real &lt;&lt; endl; cout &lt;&lt; \"test: \" &lt;&lt; u2f(float_half(u_test)) &lt;&lt; endl;&#125; 结果： 例4对于浮点数f，这个函数计算(int)f，如果f是NaN，你的函数应该向0舍入。如果f不能用整数表示，例如，超出表示范围，或者它是一个NaN，那么函数应该返回0x800000000 我们这里仅仅考虑正数的情况：有如下几种： 第一种：1230 00000000 00000000000000000000000 ===&gt;0 01111111 00000000000000000000000 值所能表示的范围是：$1.0 \\times 2^{0}$，此时$2^{E}=2^0$，对应的指数的值为$E=exp-bias=0$，可以求出$exp=7$ 取值范围为：$0 \\leq f \\leq 1$，值舍入到0 第二种：1230 01111111 00000000000000000000000 ===&gt;0 (01111111+31) 00000000000000000000000 此时，我们得到的上界为$NaN$，浮点数可以表示32为整数，其中最高位为符号位，能够表示的最大的值为$2^{31}-1$，所以最大的$int$用浮点数表示就是：0 (01111111+31) 00000000000000000000000 第三种：12340 (01111111+31) 00000000000000000000000 ===&gt;infinityreturn 0x80000000 值得注意的是，把浮点数转换成整形，必须1frac | 0x80000000 来获取整数部分，如何最后我们如何舍去小数部分？采用移位的方式：$\\pm \\ 1.frac \\times 2^{exp-bias}$，用移位的方式去掉frac部分，如下图： 最后我们得到$M \\times 2^{E}$，相当于我们在$M$的基础上，执行M&lt;&lt;E运算。 如果$E&gt;23$，则执行$ M \\times 2^E $，相当于小数点右移23位，除去小数点，然后再整体执行左移(E-23)位，即M&lt;&lt;(E-23) 如果$E&lt;23$，则执行$M \\times 2^{E}$之后还会有小数点，小数点并不能完全消除掉。我们要人为地把小数点后的数全部抛弃，此时小数点的位置在距离末尾(23-E)处，此时M&gt;&gt;(23-E)，即可舍去小数点后的部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* * float-f2i.h */#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;limits.h&gt;using namespace std;typedef unsigned float_bits;int float_f2i(float_bits f);int float_f2i(float_bits f)&#123; unsigned sign = f &gt;&gt; 31; unsigned exp = f &gt;&gt; 23 &amp; 0xFF; unsigned frac = f &amp; 0x7FFFFF; unsigned bias = 0x7F; /* consider positive numbers 0 00000000 00000000000000000000000 ===&gt; 0 01111111 00000000000000000000000 1.0*(2^0),now E=exp-bias=0,means exp=7 exp=1111111 now 0&lt;=f&lt;=1 we get integer 0 0 01111111 00000000000000000000000 now E=exp-bias=0 2^E=1 ===&gt; NaN的取值为多少？我们注意到浮点数可以表示32位整数，最高位是符号位 所以能表示的最大的值是2^&#123;31&#125;-1 上面这个数用浮点数表示是： 0 (01111111+31) 00000000000000000000 */ unsigned M; unsigned E; int val; if(exp &gt;=0 &amp;&amp; exp &lt; 0 + bias) &#123; val = 0; &#125; else if(exp &gt;= 31 + bias) &#123; //overflow val = 0x80000000; &#125; else &#123; E = exp - bias; M = frac | 0x800000; if(E &gt; 23) val = M &lt;&lt; (E - 23); else val = M &gt;&gt; (23 - E); &#125; return sign ? -val : val;&#125;int u2i(unsigned u)&#123; return *(int*) &amp;u;&#125;unsigned i2u(int u)&#123; return *(unsigned*) &amp;u;&#125;unsigned f2u(float u)&#123; return *(unsigned*) &amp;u;&#125;int main()&#123; float f_test; cout &lt;&lt; \"input float : \"; cin &gt;&gt; f_test; unsigned u_test = f2u(f_test); int real = (int)f_test; //注意，float转换为int，要舍入，直接(int) float_v //而不是*(int*) float_v cout &lt;&lt; \"real : \" &lt;&lt; real &lt;&lt; endl; cout &lt;&lt; \"test : \" &lt;&lt; float_f2i(u_test) &lt;&lt; endl;&#125; 注意，float转换为int，要舍入，直接(int) float_v而不是(int) float_v 例5给出一个函数计算(float) i的位级表示。浮点数向偶数舍入的问题有效数字超出规定数位，例如，多余数字是1001，超出了规定最低位的一半，(规定最低位的一半为：1000)，故最低位进1.如果多余数字是0111，它小于最低位的一半，则舍掉多余数字（截断尾数）即可如果对于数字是1000，正好是最低位一半的特殊情况，例如：0 1000，最低位为0，舍掉多余位，1 1000，最低位为1，则舍掉多余位后加1，使得最低位为0(偶数)。 举例，要求保留小数点后3位。 对于1.0011001，舍入处理后为1.010（去掉多余的4位，加0.001）对于1.0010111，舍入处理后为1.001（去掉多余的4位）对于1.0011000，舍入处理后为1.010（去掉多余的4位，加0.001，使得最低位为0） 对于1.1001001，舍入处理后为1.101（去掉多余的4位，加0.001）对于1.1000111，舍入处理后为1.100（去掉多余的4位）对于1.1001000，舍入处理后为1.100（去掉多余的4位，不加，因为最低位已经为0） 对于1.01011，舍入处理后为1.011（去掉多余的2位，加0.001）对于1.01001，舍入处理后为1.010（去掉多余的2位）对于1.01010，舍入处理后为1.010（去掉多余的2位，不加） 对于1.01111，舍入处理后为1.100（去掉多余的2位，加0.001）对于1.01101，舍入处理后为1.011（去掉多余的2位）对于1.01110，舍入处理后为1.100（去掉多余的2位，加0.001） 在整数向浮点数转换的过程中，很重要的一点是，浮点数写成$2^{E}$，一定是规格化数，所以$exp$不为0。因为$exp$等于0的情况我们单独考虑。 整数转换成浮点数，需要以下几个函数：$bit-length()$判断int型有几位，是否超过了最大的32位frac的位数可能会超过23位，这个时候我们要把特定的舍入位数，比如低xx位取出来，完成这个取出任务所需要的函数是$bits-mask()$，给位数盖一个面罩，然后取出值得注意的是，由于int转换成float，必定为规格化数，所以最后的fbits=bits-1，float型的frac部分要减去最开始的1 比较难以理解的是$i=0xffffffff$的情况，此时整数转换成浮点数，是一个$-2^{E}$，注意此时frac为0，因为整数并不包含小数点后的部分，frac部分为1.0000…，是一个绝对值非常非常大的负数，指数expe要尽可能大，如果把指数看成是小数点移位的话，指数最大可以取多少呢？可以移动多少位呢？最多为31位。expe=bias+31 我们让expe=bias+fbits，这样可以看成是小数点在最左边，然后往右移动fbits位。唯一要考虑的就是23位够不够放int型的整数？int型的整数，罩上mask，获取val值，来进行移位操作val=i &amp; bits_mask(fbits) 如果值为负数，记得取反加1 思路1、首先考虑符号位，然后讲i取绝对值，当成一个正数转化即可。然后判断i是2的几次幂，可以通过类似于二分法的方式判断。即右移16位判断是否不为0，如果不为0则exp+16，然后判断右移16位后剩余的位数有几位，否则右移8位判断依次类推。2、因为是正数，小数点左边存在一个隐式的1，所以num=( ~ (1&lt;&lt; exp ) ) &amp; num ;把最高的1去掉，然后把剩余的数放进frac中，同时要考虑向偶数取整的问题。3、如果num不足23位，直接移动相应位数，放入frac中，否则截掉多余的位数，如果最后一位并且舍去一段中的最高也为1或者舍去的东西超过0.5那么就给frac+1，判断一下frac时候有溢出，溢出的话给exp+1，然后取剩余的23位的值即可。最后就是给exp加上bias偏置值，前提是如果num不为0。 重要思路：12345678910111213141516171819202122232425262728293031323334353637383940414243unsigned val = i;unsigned sign = i &lt; 0 ? 1 : 0;if(sign) val = ~val + 1;unsigned exp = 0;unsigned frac = 0;unsigned temp = val;if(val &gt;&gt; 16)&#123; exp += 0x10; //除以16，再加回来 val = val &gt;&gt; 0x10;&#125;if(val &gt;&gt; 8)&#123; exp += 0x8; val = val &gt;&gt; 0x8;&#125;if(val &gt;&gt; 4)&#123; exp += 0x4; val = val &gt;&gt; 0x4;&#125;if(val &gt;&gt; 2)&#123; exp += 0x2; val = val &gt;&gt; 0x2;&#125;if(val &gt;&gt; 1)&#123; exp += 0x1; val = val &gt;&gt; 0x1;&#125;//此时exp表示小数点从右边开始，往左多少位//去掉小数点最高位1val = temp;val = (~(1 &lt;&lt; exp)) &amp; val;//此时val为小数点后面的部分// (temp &gt;&gt; 23)判断temp大于23位 最终$\\times 2^{expe}$小数点在最右边，所以expe实际上表示小数点的实际位置：即从最右边开始，向左移动expe位就是小数点实际位置 舍入原则上面说明了，值得注意的是，向偶数舍入，frac+=1，可能会造成frac溢出例如： frac=111 1111 1111 1111 1111 1111frac+1=1000 0000 0000 0000 0000 0000相当于小数点从右边开始移动到实际位置要多移动1位，所以是expe+=1frac=frac &amp; 0x7fffff取最后23位 可能遇到的情况描述如下图： 实现方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;math.h&gt;using namespace std;typedef unsigned float_bits;float_bits float_i2f(int i);unsigned mask(unsigned bits)&#123; return (1 &lt;&lt; bits) - 1;&#125;unsigned leftmost(unsigned bits)&#123; return 1 &lt;&lt; bits;&#125;float_bits float_i2f(int i)&#123; unsigned val = i; unsigned sign = i &lt; 0 ? 1 : 0; if(sign) val = ~val + 1; unsigned expe = 0; unsigned frac = 0; unsigned temp = val; if(val &gt;&gt; 16) &#123; expe += 0x10; //除以16，再加回来 val = val &gt;&gt; 0x10; &#125; if(val &gt;&gt; 8) &#123; expe += 0x8; val = val &gt;&gt; 0x8; &#125; if(val &gt;&gt; 4) &#123; expe += 0x4; val = val &gt;&gt; 0x4; &#125; if(val &gt;&gt; 2) &#123; expe += 0x2; val = val &gt;&gt; 0x2; &#125; if(val &gt;&gt; 1) &#123; expe += 0x1; val = val &gt;&gt; 0x1; &#125; //此时expe表示小数点从右边开始，往左多少位 //去掉小数点最高位1 val = temp; val = (~(1 &lt;&lt; expe)) &amp; val; //此时val为小数点后面的部分 if(temp &gt;&gt; 23) &#123; unsigned offset = expe - 23; //溢出部分 frac = val &gt;&gt; offset; unsigned roundv = 0; unsigned round_bits = val &amp; mask(offset); int cond1 = ( (val &amp; mask(offset)) &gt; leftmost(offset-1)); int cond2 = ( (frac &amp; 0x1) &amp;&amp; (round_bits == leftmost(offset-1)) ); if( (expe != 23) &amp;&amp; (cond1 || cond2) ) &#123; frac += 1; &#125; //向偶数舍入溢出了怎么办？ //小数点从右边开始，往左边多移动1位 if(frac &gt;&gt; 23) &#123; expe += 1; frac = frac &amp; 0x7fffff; &#125; &#125; else frac = val &lt;&lt; (23 - expe); if(temp) expe += 127; return sign &lt;&lt; 31 | expe &lt;&lt; 23 | frac;&#125;float u2f(unsigned u)&#123; return *(float*)&amp;u;&#125;int main()&#123; int i_test; cout &lt;&lt; \"input int: \"; scanf(\"%d\",&amp;i_test); float real = (float) i_test; printf(\"real: %f\\n\",real); printf(\"test: %f\\n\",u2f(float_i2f(i_test)));&#125;","categories":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"http://www.fogsail.net/categories/计算机系统结构/"}],"tags":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"http://www.fogsail.net/tags/计算机系统结构/"}]},{"title":"儿时游戏：数组和字符串模拟","slug":"20180204","date":"2018-02-04T09:37:00.000Z","updated":"2018-03-02T21:15:44.000Z","comments":true,"path":"2018/02/04/20180204/","link":"","permalink":"http://www.fogsail.net/2018/02/04/20180204/","excerpt":"对于90后一代，小学时候我们没有微信，没有王者荣耀，也没有大吉大利，今晚吃鸡的喜悦。小时候我们玩的很多游戏，都是一些拼图，连接线段等等。这些问题，我们可以尝试用数组和字符串模拟。","text":"对于90后一代，小学时候我们没有微信，没有王者荣耀，也没有大吉大利，今晚吃鸡的喜悦。小时候我们玩的很多游戏，都是一些拼图，连接线段等等。这些问题，我们可以尝试用数组和字符串模拟。 我们以刘汝佳的《算法竞赛》来探讨一些这样的问题 Puzzle (Uva227)问题描述如下图： c++ STL vector 字母矩阵常用的方法字母矩阵常常用string来表示主要是要实现字母坐标值，和具体字母的分离。$grid[i][j]$表示字母具体值$i=node[k].x\\quad j=node[k].y$ 下面介绍两种常用的数据结构$string\\quad map$的使用 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;cctype&gt;using namespace std;const int size = 5;typedef struct point&#123; int x; int y; point(int x=0,int y=0):x(x),y(y) &#123;&#125;&#125;pos;pos empty;vector&lt;string&gt; puzzle;map&lt;char,pos&gt; dir;//重载运算符pos operator+ (const pos&amp; A,const pos&amp; B) &#123;return pos(A.x+B.x,A.y+B.y);&#125;pos operator- (const pos&amp; A,const pos&amp; B) &#123;return pos(A.x-B.x,A.y-B.y);&#125;pos operator* (const pos&amp; A,int m) &#123;return pos(A.x*m,A.y*m);&#125;pos operator/ (const pos&amp; A,int m) &#123;return pos(A.x/m,A.y/m);&#125;bool operator== (const pos&amp; A,const pos&amp; B) &#123;return A.x==B.x &amp;&amp; A.y==B.y;&#125;bool operator&lt; (const pos&amp; A,const pos&amp; B) &#123;return A.x&lt;B.x || (A.x==B.x &amp;&amp; A.y&lt;B.y);&#125;void printpuzzle()&#123; for(int i=0;i&lt;size;i++) &#123; for(int j=0;j&lt;size;j++) &#123; if(j) cout&lt;&lt;' '; cout&lt;&lt;puzzle[i][j]; &#125; cout&lt;&lt;endl; &#125;&#125;void getdir()&#123; dir['A']=pos(-1,0); dir['B']=pos(1,0); dir['L']=pos(0,-1); dir['R']=pos(0,1);&#125;bool GetPuzzle()&#123; puzzle.clear(); string line; bool flag=true; for(int i=0;i&lt;size;i++) &#123; getline(cin,line); if(line==\"Z\") &#123; flag=false; break; &#125; for(int j=0;j&lt;size;j++) &#123; if(line[j]==' ') &#123; empty.x=i; empty.y=j; &#125; &#125; puzzle.push_back(line); //puzzle为输入的值 &#125; if(flag) return true; else return false;&#125;bool valid(const pos&amp; p)&#123; return p.x&gt;=0 &amp;&amp; p.x&lt;size &amp;&amp; p.y&gt;=0 &amp;&amp; p.y&lt;size;&#125;bool move(char op)&#123; if(!dir.count(op)) return false; pos next = empty+dir[op]; if(!valid(next)) return false; swap(puzzle[empty.x][empty.y],puzzle[next.x][next.y]); empty=next; //结构体可以直接赋值 return true;&#125;bool getmoves()&#123; string moves; string line; while(true) &#123; getline(cin,line); bool end= *(line.rbegin())=='0'; if(!end) moves.append(line); else moves.append(line,0,line.size()-1); if(end) break; &#125; bool legal = true; for(int i=0;i&lt;moves.size();i++) &#123; if(move(moves[i])==false) &#123; legal=false; break; &#125; &#125; if(legal) return true; else return false;&#125;int main()&#123; int flag=1; getdir(); while(GetPuzzle()) &#123; bool ok = getmoves(); if(flag&gt;1) cout&lt;&lt;endl; cout&lt;&lt;\"Puzzle #\"&lt;&lt;flag++&lt;&lt;\":\"&lt;&lt;endl; if(ok) printpuzzle(); else cout&lt;&lt;\"This puzzle has no final configuration.\"&lt;&lt;endl; &#125;&#125; Digit counting uva1225题目描述： 本题陈锋的答案写的过于繁琐，这里给出一种一维数组的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;//#define maxn 10005#define data 15void calculate()&#123; //int cnt[maxn][data]; int cnt[data]=&#123;0&#125;; int maxn; scanf(\"%d\",&amp;maxn); for(int i=1;i&lt;=maxn;i++) &#123; //id=i int cur = i; //int id = i; //第id个数 while(cur&gt;0) &#123; int val = cur%10; cnt[val]++; cur/=10; &#125; &#125; for(int i=0;i&lt;9;i++) printf(\"%d \",cnt[i]); printf(\"%d\\n\",cnt[9]);&#125;int main()&#123; int kase; scanf(\"%d\",&amp;kase); while(kase--) &#123; calculate(); &#125; return 0;&#125; crossword answers uva232题目如下： 这里我谈一谈我编程的心得体会吧：分享一些编程的技巧，就是main函数不宜写的很长，比如上面你要去模拟那个矩阵，怎么移动的，你不宜把main函数写太长，你要想：如果是你来移动这个矩阵，你会怎么做？第一步，当然是获取数据，所以你要写一个获取数据的函数getpuzzle()第二部是移动操作，往左？往右？于是你需要一个移动函数getmoves()如果更细致一点？越界？不越界？这更细一点的在getmoves()里面再写一个move()来判断每一步怎么走？下一步可能出现的情况？层层递进～这是编程最难的一点，就是把一个很复杂的问题，分解，在分解，然后，看到不同子问题之间的逻辑性，抽离出来。不同的抽离方法，会导致编程的难易程度不一样。如果你先入为主地想，怎么移动？万一越界了怎么办？万一不合法的移动怎么办？问题会变得很复杂，当然很难编程。如果你先入为主，首先不要考虑太多细节。然后，逐渐加入某些细节，再写代码。至于每一步，每一层，要加入哪些细节，可以减少编程难度呢？这就是编程艺术性所在的地方，跟画画一样。首先你要描绘一个轮廓，然后，近景？远景的布局是怎么样的，画出来有什么样的效果？这就是编程艺术所在的地方。 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef struct point&#123; int r; int c; point(int r=0,int c=0):r(r),c(c) &#123;&#125;&#125;pos;pos operator+ (const pos&amp; A,const pos&amp; B) &#123;return pos(A.r+B.r,A.c+B.c);&#125;const pos dLeft(0,-1),dUp(-1,0),dRight(0,1),dDown(1,0);int row,col;const int maxn = 16;char grid[maxn][maxn];char buf[maxn];queue&lt;pos&gt; Crossletter;queue&lt;pos&gt; Downletter;map&lt;int,int&gt; Crossid;map&lt;int,int&gt; Downid;bool valid(const pos&amp; p)&#123; return p.r&gt;=0 &amp;&amp; p.r&lt;row &amp;&amp; p.c&gt;=0 &amp;&amp; p.c&lt;col;&#125;bool getgrid()&#123; memset(grid,'0',sizeof(grid)); if(scanf(\"%d%d\",&amp;row,&amp;col)==2 &amp;&amp; row) &#123; for(int i=0;i&lt;row;i++) scanf(\"%s\",grid[i]); return true; &#125; else return false;&#125;/*void printgrid()&#123; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) cout&lt;&lt;grid[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125;&#125;*/void CheckQueueEmpty(queue&lt;pos&gt; letter)&#123; while(!letter.empty()) &#123; letter.pop(); &#125;&#125;void GetWordBegin()&#123; CheckQueueEmpty(Crossletter); CheckQueueEmpty(Downletter); int crosscnt=0,downcnt=0; Crossid.clear(); Downid.clear(); int k = 1; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) &#123; if(grid[i][j]=='*') continue; pos cur(i,j); pos left = cur+dLeft; pos up = cur+dUp; bool IsCrossBeg = !valid(left) || grid[left.r][left.c]=='*'; bool IsDownBeg = !valid(up) || grid[up.r][up.c]=='*'; if(IsCrossBeg) &#123; Crossletter.push(cur); Crossid[++crosscnt]=k; &#125; if(IsDownBeg) &#123; Downletter.push(cur); Downid[++downcnt]=k; &#125; if(IsCrossBeg || IsDownBeg) k++; &#125; &#125;&#125;void GetCrossWord()&#123; int i=0; while(!Crossletter.empty()) &#123; int buflen=0; memset(buf,0,sizeof(buf)); pos p = Crossletter.front(); //id = PosCross[p]; while(grid[p.r][p.c]!='*' &amp;&amp; valid(p)) &#123; buf[buflen++]=grid[p.r][p.c]; p=p+dRight; &#125; printf(\"%3d.%s\\n\",Crossid[++i],buf); Crossletter.pop(); &#125;&#125;void GetDownWord()&#123; int i=0; while(!Downletter.empty()) &#123; int buflen=0; memset(buf,0,sizeof(buf)); pos p = Downletter.front(); while(grid[p.r][p.c]!='*' &amp;&amp; valid(p)) &#123; buf[buflen++]=grid[p.r][p.c]; p=p+dDown; &#125; printf(\"%3d.%s\\n\",Downid[++i],buf); Downletter.pop(); &#125;&#125;int main()&#123; for(int kase=1;getgrid();kase++) &#123; if(kase&gt;1) cout&lt;&lt;endl; printf(\"puzzle #%d:\\n\",kase); GetWordBegin(); cout&lt;&lt;\"Across\"&lt;&lt;endl; GetCrossWord(); cout&lt;&lt;\"Down\"&lt;&lt;endl; GetDownWord(); &#125; return 0;&#125; Repeating Decimals uva202 这里我给出一种重要的数据处理技巧：1char example[maxn] 输入的时候1scanf(\"%s\",example) 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 30000;int pos[maxn];//int len;//string ans;char shang[maxn];int solve(int a,int b)&#123; int len; int Integer = a/b; int r = a%b; memset(pos,0,sizeof(pos)); memset(shang,0,sizeof(shang)); //int pos[maxn]; //char shang[maxn]; printf(\"%d/%d = %d\",a,b,Integer); shang[0]='.'; if(r==0) &#123; //ans+=\"(0)\"; printf(\".(0)\"); len=1; &#125; else &#123; //小数部分 int d = r*10; int cnt = 0; while(d &amp;&amp; pos[d]==0) &#123; pos[d]=++cnt; int cur_r = d%b; //ans+=(char) (d/b+'0'); shang[cnt]=(char)(d/b+'0'); d = cur_r*10; &#125; if(d==0) &#123; //ans+=\"(0)\"; //shang[cnt]='('; //flag! if(shang[i]==-1) printf(\"(0)\"); for(int i=0;i&lt;=cnt;i++) //cout&lt;&lt;shang[i]; printf(\"%c\",shang[i]); //cout&lt;&lt;\"(0)\"; printf(\"(0)\"); len=1; &#125; if(pos[d]) &#123; int p = pos[d]; len = cnt-p+1; /*if(len&gt;50) &#123; ans.erase(p+50,cnt-1); ans+=\"...\"; &#125; ans.insert(p,\"(\"); ans+=\")\";*/ if(len&gt;50) &#123; for(int i=0;i&lt;p;i++) //cout&lt;&lt;shang[i]; printf(\"%c\",shang[i]); //cout&lt;&lt;\"(\"; printf(\"(\"); int k=0; for(int i=p;i&lt;=cnt &amp;&amp; k&lt;50;i++) &#123; //cout&lt;&lt;shang[i]; printf(\"%c\",shang[i]); k++; &#125; //cout&lt;&lt;\"...)\"; printf(\"...)\"); &#125; else &#123; for(int i=0;i&lt;p;i++) //cout&lt;&lt;shang[i]; printf(\"%c\",shang[i]); //cout&lt;&lt;\"(\"; printf(\"(\"); //int k=0; for(int i=p;i&lt;=cnt;i++) //cout&lt;&lt;shang[i]; printf(\"%c\",shang[i]); //cout&lt;&lt;\")\"; printf(\")\"); &#125; &#125; //printf(\"%d/%d = %d%s\\n\",a,b,Integer,ans.c_str()); //printf(\" %d = number of digits in repeating cycle\\n\\n\",len); //cout&lt;&lt;endl; &#125; printf(\"\\n\"); return len;&#125;int main()&#123; int a,b; while(scanf(\"%d%d\",&amp;a,&amp;b)==2 &amp;&amp; b) &#123; int reslen=solve(a,b); printf(\" %d = number of digits in repeating cycle\\n\\n\",reslen); &#125; return 0;&#125; box uva1587这个例子我想分享一下简洁的代码怎样写。 题目如下： 12bool operator&lt; (const point&amp; p1, const point&amp; p2) &#123; return p1.x &lt; p2.x || (p1.x == p2.x &amp;&amp; p1.y &lt; p2.y); &#125; 这里是特别说明的一点：因为排序的时候，默认先比较x成员的大小，再比较y成员的大小，所以默认x成员小于y成员另外涉及排序的时候，我们需要直接输入结构体变量的值，涉及重载运算符用以下方法输入会导致wrong answer 12345678for(int i=0;i&lt;6;i++)&#123; if(scanf(\"%d%d\",&amp;a,&amp;b)==EOF) flag=0; if(a&gt;b) swap(a,b); r.push_back(point(a,b));&#125; 我们在处理结构体数组的时候，最好是直接对结构体数组的元素执行输入操作，重载&gt;&gt;运算符example 123456789typedef struct&#123; //&#125;node;istream&amp; operator&gt;&gt; (istream&amp; is,point&amp; p)&#123; return is&gt;&gt;p.x&gt;&gt;p.y; &#125;node n;cin&gt;&gt;n.x&gt;&gt;n.y 技巧：在处理EOF为终止的输入的时候，用如下方法，很好用 123456789while(true)&#123; r.clear(); for(int i=0;i&lt;6;i++) &#123; if(!(cin&gt;&gt;cur)) return 0; &#125;&#125; 算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct point&#123; int x; int y; point(int x=0,int y=0):x(x),y(y) &#123;&#125;&#125;;bool operator&lt; (const point&amp; p1, const point&amp; p2) &#123; return p1.x &lt; p2.x || (p1.x == p2.x &amp;&amp; p1.y &lt; p2.y); &#125;istream&amp; operator&gt;&gt; (istream&amp; is,point&amp; p)&#123; return is&gt;&gt;p.x&gt;&gt;p.y; &#125;//typedef point rect;vector&lt;point&gt; r;bool judge()&#123; if(r[0].x!=r[1].x || r[0].y!=r[1].y) return false; if(r[2].x!=r[3].x || r[2].y!=r[3].y) return false; if(r[4].x!=r[5].x || r[4].y!=r[5].y) return false; const point &amp;r1 = r[1], &amp;r2 = r[3], &amp;r3 = r[5]; return r1.x == r2.x &amp;&amp; r1.y == r3.x &amp;&amp; r2.y == r3.y;&#125;int main()&#123; point cur; while(true) &#123; r.clear(); for(int i=0;i&lt;6;i++) &#123; if(!(cin&gt;&gt;cur)) return 0; if(cur.x&gt;cur.y) swap(cur.x,cur.y); r.push_back(cur); &#125; sort(r.begin(),r.end()); bool ok = judge(); if(ok) printf(\"POSSIBLE\\n\"); else printf(\"IMPOSSIBLE\\n\"); &#125; return 0;&#125; 字符串匹配：模板链方法 uva1588这里以uva1588为例子，简单讲讲字符串匹配中的模板链方法。 题目描述如下： 模板链方法描述 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;string s1,s2;bool getstring()&#123; if(cin&gt;&gt;s1&gt;&gt;s2) &#123; if(s2.length()&gt;s1.length()) &#123; swap(s1,s2); &#125; return true; &#125; else return false;&#125;int maxv(int a,int b)&#123; return a&gt;b?a:b;&#125;int minv(int a,int b)&#123; return a&lt;b?a:b;&#125;void calculate()&#123; int len1 = s1.length(); int len2 = s2.length(); int inside = 0; int minres = 0x3f3f3f3f; for(int i=-len2;i&lt;=len1+len2-1;i++) &#123; int flag = 1; for(int bias=0;bias&lt;len2;bias++) &#123; if(i+bias&gt;=0 &amp;&amp; i+bias&lt;=len1-1) &#123; if(s1[i+bias]-'0'+s2[bias]-'0'&gt;3) flag=0; &#125; &#125; //bias遍历完成，意味着标签贴完毕了 if(flag &amp;&amp; i&lt;0) minres=min(minres,(-i)+len1); if(flag &amp;&amp; i+len2&gt;=len1) minres=min(minres,i+len2); if(flag &amp;&amp; i&gt;=0 &amp;&amp; i&lt;len1-len2) inside=1; &#125; if(inside==1) cout&lt;&lt;len1&lt;&lt;endl; else cout&lt;&lt;minres&lt;&lt;endl;&#125;int main()&#123; while(getstring()) &#123; calculate(); &#125; return 0;&#125; c++11中涉及精度的问题涉及精度的问题并不难，关键是c++提供了一些非常重要的思路：问题描述： 一些重要的思路c++11中，中提供了一个round()函数，用来做四舍五入操作 strchr是计算机的一个函数，原型为char strchr(const char s,char c)，可以查找字符串s中首次出现字符c的位置strcmp() C/C++函数，比较两个字符串,设这两个字符串为str1，str2，若str1==str2，则返回零；若str1str2，则返回正数。 原型：1*strchr(const char *s,char c) 1234567891011char line[maxn];double A;int B;while(scanf(\"%s\",line)==1 &amp;&amp; strcmp(line,\"0e0\")!=0)&#123; *strchr(line,'e') = ' '; //将line中首次出现‘e’的地方，用‘ ’来代替 sscanf(line,\"%lf%d\",&amp;A,&amp;B); //sscanf()是很重要的输入方法，将line中 //符合%lf %d格式的 //分别输入到A,B中， //其中，%lf--&gt;A %d--&gt;B，A和B用空格分开，表示输入两个变量&#125; 上面注释部分，表示一种非常重要的编程技巧。 算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 256;const double eps = 1e-6;int main()&#123; /*char A[256]; scanf(\"%s\",A); char *ptr = strchr(A,'e'); cout&lt;&lt;ptr&lt;&lt;\" \"&lt;&lt;*ptr&lt;&lt;endl; *strchr(A,'e')='f'; printf(\"%s\\n\",A);*/ char line[maxn]; double lg2 = log10(2); double A,lgV; int B; while(scanf(\"%s\",line)==1 &amp;&amp; strcmp(line,\"0e0\")!=0) //这种输入方式要记住 &#123; *strchr(line,'e')=' '; sscanf(line,\"%lf%d\",&amp;A,&amp;B); //cout&lt;&lt;A&lt;&lt;\" \"&lt;&lt;B&lt;&lt;endl; lgV = log10(A)+B; for(int M=1;M&lt;=10;M++) &#123; int E = round( log10( (lgV+M*lg2-log10(pow(2,M)-1))/lg2+1 )/lg2 ); if( fabs( ((1&lt;&lt;E)-1)*lg2 + log10(pow(2,M)-1) - M*lg2 - lgV ) &lt;= eps ) &#123; printf(\"%d %d\\n\",M-1,E); break; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"data_structure","slug":"data-structure","permalink":"http://www.fogsail.net/categories/data-structure/"}],"tags":[{"name":"data_structure","slug":"data-structure","permalink":"http://www.fogsail.net/tags/data-structure/"}]},{"title":"linux脚本编程：系统软件的安装","slug":"20170630","date":"2017-06-29T19:12:00.000Z","updated":"2018-03-02T21:08:40.000Z","comments":true,"path":"2017/06/30/20170630/","link":"","permalink":"http://www.fogsail.net/2017/06/30/20170630/","excerpt":"Linux的核心是shell，这里先简单阐述一下基本的shell编程的概念。","text":"Linux的核心是shell，这里先简单阐述一下基本的shell编程的概念。 Linux系统中安装java安装python依赖包12sudo apt-get install python-softwaresudo apt-get install software-properties-common 添加ppa源12345sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-j +按两次TABsudo apt-get install oracle-java9-installersudo apt-get install oracle-java9-set-default 查看java安装位置1234567891011apt-cache search openjdk #查看jdk的安装位置apt-file list java #查看包含java的文件，太多了，不建议使用这个命令whereis java#定位可执行文件、源代码文件、帮助文件在文件系统中的位置。which java#java的执行路径ll /usr/bin/java #查看命令链接位置ll /etc/alternatives/java #查看命令可执行文件的实际位置 如图所示： 获取java命令路径 1/usr/lib/jvm/java-9-oracle/bin/java 查看java其他版本123456sudo update-alternatives --install link(java_01版本的绝对路径) name(新命令名字) path(新命令java_02的路径) prioritysudo update-alternatives --install /usr/bin/java java XXX/XXX 300#priority为优先级，系统默认启动priority高的链接#与之对应的删除命令sudo update-alternatives --remove java XXX/XXX(即为上一步中的name path) 12sudo update-alternatives --config javasudo update-alternatives --config javac 环境变量的配置1234567891011#一般我们用~/.bashrc来设置当前用户的环境变量#/etc/profile一般我们不去改变，系统的环境变量不要随便更改sudo gedit ~/.bashrc#在末尾添加export JAVA_HOME=/usr/lib/jvm/java-9-oracleexport JRE_HOME=$&#123;JAVA_HOME&#125;/jre1.8.0_131export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$PATH:$&#123;JAVA_HOME&#125;/bin:$&#123;JRE_HOME&#125;/binsources ~/.bashrc","categories":[{"name":"linux","slug":"linux","permalink":"http://www.fogsail.net/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.fogsail.net/tags/linux/"}]},{"title":"深度学习基础：Linux系统配置","slug":"20170626","date":"2017-06-25T19:12:00.000Z","updated":"2018-05-02T09:24:22.000Z","comments":true,"path":"2017/06/26/20170626/","link":"","permalink":"http://www.fogsail.net/2017/06/26/20170626/","excerpt":"深度学习无疑是2016年下半年到2017年最火的研究方向了。深度学习一般都采用Linux系统作为配置。与Caffe、Theano、Torch、MXNet等框架相比，TensorFlow在Github上Fork数和Star数都是最多的，而且在图形分类、音频处理、推荐系统和自然语言处理等场景下都有丰富的应用。最近流行的Keras框架底层默认使用TensorFlow，著名的斯坦福CS231n课程使用TensorFlow作为授课和作业的编程语言，国内外多本TensorFlow书籍已经在筹备或者发售中，AlphaGo开发团队Deepmind也计划将神经网络应用迁移到TensorFlow中，这无不印证了TensorFlow在业界的流行程度。 首先我先说一下我用的主机配置：","text":"深度学习无疑是2016年下半年到2017年最火的研究方向了。深度学习一般都采用Linux系统作为配置。与Caffe、Theano、Torch、MXNet等框架相比，TensorFlow在Github上Fork数和Star数都是最多的，而且在图形分类、音频处理、推荐系统和自然语言处理等场景下都有丰富的应用。最近流行的Keras框架底层默认使用TensorFlow，著名的斯坦福CS231n课程使用TensorFlow作为授课和作业的编程语言，国内外多本TensorFlow书籍已经在筹备或者发售中，AlphaGo开发团队Deepmind也计划将神经网络应用迁移到TensorFlow中，这无不印证了TensorFlow在业界的流行程度。 首先我先说一下我用的主机配置： CPU参数CPU主频: 3.0GHz及以上CPU型号: Intel I7 6800KCPU核心数: 六核心 显卡参数NVIDIA GTX 1080 Ti 内存类型DDR4 容量8GB*2根 硬盘类型samsung 256GB M.2接口固态硬盘 主板华硕 ATX主板芯片组类型:Intel X99 操作系统Ubuntu 16.04（LTS） Linux下显卡驱动的安装从官方网站上下载GTX 1080 Ti驱动程序一般放置在以下目录中： 1/home/fogsail 打开终端，输入：1fogsail@fogsailPC:~$ pwd 查看当前终端所在的文件目录，看一看是不是/home/fogsail 如下图所示： 接下来，为下载的驱动程序添加可执行权限：1sudo chmod 755 NVIDIA-Linux-x86_64-381.22.run 然后将图形界面切换到命令行界面： 1234Ctrl+Alt+F2login:fogsail(your name)password: your computer password 这样就成功切换到命令行状态下了，如果想从命令行状态切换回图形界面 1Ctrl+Alt+F7 由于这里要装显卡，所以必须把图形界面关掉，在纯字符的页面下输入： 12345678910Ctrl+Alt+F2login:fogsail(your name)password: your computer passwordsudo service lightdm stop##重新换回图形界面命令如下：sudo service lightdm start#如果是Linuxmint系统，则用mdm代替lightdm 这样就切换到纯命令行了 在纯命令行的状态下1sudo ./NVIDIA-Linux-x86_64-381.22.run 然后就是安装过程，特别注意，在安装的时候有几个选项：前几个选项是接受协议什么的分别选accept、continue installation即可 注意最后一个选项，是要不要将NVIDIA GTX1080 Ti的驱动覆盖原来的默认驱动，并且对原驱动进行更新，这里一定要选择yes 安装完成之后，开启图形界面即可。 这样安装就大功告成了。 当然，在ubuntu 16.04下面安装不用这么麻烦，直接有包如图所示： Linux下一些驱动的卸载下载软件包装的驱动如本例所示，用.run赋予可执行权限安装的驱动，卸载的时候，也需要用到原文件 1sudo ./NVIDIA-Linux-x86_64-381.22.run -uninstall 一般来说，使用软件包安装的驱动，卸载的时候都要用到软件包 使用apt包安装的驱动一般来说，先看一下有哪些和驱动相关的软件包，如下命令： 1apt-cache search nvidia ##搜索带nvidia字样的软件包 还有一个常用的命令是 1apt-cache depends nvidia ##查询nvidia的依赖关系 如果需要删除所有和nvidia相关的组件： 1sudo apt-get remove nvidia-* Linux下.deb软件包的安装：网易云音乐第一步，安装包放到/opt从网易云音乐官方网站上下载ubuntu 16.04软件包.deb .deb软件包，可以考虑下载完，把.deb的安装文件，放置在：12/opt ##/opt中一般都放置完整的软件包，没有其他依赖关系 ##一般是额外自己安装的其他应用软件 这里说明一下： /usr: 系统级的目录，可以理解为C:/Windows，/usr/lib理解为C:/Windows/System32 /usr/local: 用户级的程序目录，这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面，我想这应该是个不错的主意。可以理解为C:/Progrem Files/。用户自己编译的软件默认会安装到这个目录下。 /opt:用户级的程序目录，可以理解为D:/Software，opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf即可。在硬盘容量不够时，也可将/opt单独挂载到其他磁盘上使用。举个例子：你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可 以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。 源码放在哪里？/usr/src: 系统级的源码目录/usr/local/src: 用户级的源码目录 第二步：dpkg安装软件包123sudo dpkg -i netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb##--install or -i选项会在安装软件包之前把系统中原有的旧版本删除 所有的软件包在安装之前都必须保证所依赖的库和支持构造已经安装在系统中。不过可以使用—force来强制安装软件包，这个时候系统将忽略一切兼容问题直到软件包安装完毕。大部分情况下不建议这么使用，—force会让问题变得更糟糕。 但是在这里，可以重新配置一下依赖： 12sudo apt-get install -fsudo dpkg -i netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb 第三步：执行检查查看版本信息1dpkg -l | grep netease-cloud-music 运行的结果： 查看软件相关的文件我们有的时候还需要找到软件在安装的时候，向系统复制了哪些文件？这个时候需要—search选项 1dpkg -S netease-cloud-music 运行结果： 卸载软件1dpkg --remove netease-cloud-music 这里注意，—remove后面跟的软件名称和netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb这个deb包版本号之前的名称是一致的。 Linux下使用高级软件包工具APT以安装vlc为例： 安装完成之后，要查看安装的情况，到底装到什么位置了？这里我们使用123sudo apt-get install apt-file ##第一次需要安装apt-fileapt-file updateapt-file list vlc 最后的结果如下： 如果我们要删除，则执行：123sudo apt-get remove vlc browser-plugin-vlc##注意跟intall要对上去啊～就是把install换成remove 卸载命令，就是把sudo apt-get install换成remove 查询软件包信息（不是安装位置）:1apt-cache search vlc ##搜索带\"vlc\"字样的软件包 1apt-cache depends vlc ##查询vlc的依赖关系，查看vlc执行过程中需要依赖什么文件 特别说明：APT-get的配置apt-get的安装源，放在1/etc/apt/sources.list 1gedit /etc/apt/sources.list 打开如下： 一些重要字段的含义： deb和deb-src：表示软件包的类型。Debian类型的软件包使用deb或deb-src。如果是RPM类型的软件包，则应该使用rpm和rpm-src。 特别注意：12deb http://security.ubuntu.com/ubuntu xenial-security universedeb http://security.ubuntu.com/ubuntu xenial-security multiverse 应该作为一个单独的源来列出，以便能够访问到最新的安全补丁。 解压缩安装软件—sublimetext安装方法第一步，从网站上下载得到，并且移动到/opt目录下12345.tar.gz##解压格式tar -jxvf xx.tar.bz2 第二步，自定义图标链接 12cd /opt/sublime_text_3sudo gedit sublime_text.desktop 更改以下内容： 1234Exec=/opt/sublime_text_3/sublime_text %FTerminal=falseStartupNotify=trueIcon=/opt/sublime_text_3/Icon/48*48/sublime-text.png 然后执行 1sudo cp /opt/sublime_text_3/sublime_text.desktop /usr/share/applications 创建快捷方式补充：创建应用程序图标的快捷方法：1234sudo apt-get install gnome-panel#使用gnome-panel gnome-desktop-item-edit [选线][路径] [指令]gnome-desktop-item-edit /usr/share/applications/ --create-new 会弹出对话框，填写name, excu, comment 等信息创建成功了，可以在该目录下看到，而且点击的时候就能打开软件， 其他操作 ln -s 用于建立符号连接（又称软连接）这个可以用一个sublime命令代替sublime_text程序 1sudo ln -s /opt/sublime_text_3/sublime_text /usr/bin/sublime 但是一般不建议这样使用，因为这样在/usr/bin中多出来的命令，不好删除怎么删除/usr/bin中多出来的命令？ 1sudo rm -rf /usr/bin/sublime 但是！！千万小心，会造成错误删除的严重后果 创建软链接：12ln -s /home/zhenwx/htccode-v1/ /home/zhenwx/htccode ##建立/home/zhenwx/htccode-v1 的软连接 删除软链接：12rm -rf /home/zhenwx/htccode ##注意不是rm -rf /home/zhenwx/htccode/ 卸载方法一般来说，如果1tar -zxvf XXXX.tar.gz 解压缩之后，会得到一个文件夹。删除的时候，只要把/opt下面对应的文件夹删除即可。 注意的是，配置的相关信息，在ubuntu中，存储在 1/home/fogsail/.config 中，打开如下： 删除的时候要把对应的./config相关的文件夹也要删除。 如果tar -zxvf之后，是执行./configure和make and make install安装卸载方式在后面。 gtk的安装，实现sublime中文输入窗口gtk的安装方法如下12345678910pkg-config --list-all grep gtk ##查看是否安装了gtksudo apt-get updatesudo apt-get automovesudo apt-get build-essentialsudo apt-get install gnome-devel gnome-devel-doc#装好之后查看gtk库版本：pkg-config --modversion gtk+-2.0pkg-config --modversion gtk+-3.0 使用gtk安装sublime中文输入将下面的代码保存到文件sublime_imfix.c目录12345678910111213141516#include &lt;gtk/gtkimcontext.h&gt;void gtk_im_context_set_client_window(GtkIMContext *context,GdkWindow *window)&#123; GtkIMContextClass *klass; g_return_if_fail(GTK_IS_IM_CONTEXT(context)); klass=GTK_IM_CONTEXT_GET_CLASS(context); if(klass-&gt;set_client_window) klass-&gt;set_client_window(context,window); g_object_set_data(G_OBJECT(context),\"window\",window); if(!GDK_IS_WINDOW(window)) return; int width=gdk_window_get_width(window); int height=gdk_window_get_height(window); if(width!=0 &amp;&amp; height!=0) gtk_im_context_focus_in(context);&#125; 将上面的代码编译成共享库： 123gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPICsudo mv libsublime-imfix.so /opt/sublime_text_3/ 最后在sublime-text.desktop文件中做一些修改： 1234567891011sudo gedit ~/.sublime_text.desktop[Desktop Entry]Exec=bash -c \"LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text %F\"[Desktop Action Window]Exec=bash -c \"LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text -n\"[Desktop Action Document]Exec=bash -c \"LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text --command new_file\" 编译运行： 编译：1gcc -o Hello Hello.c `pkg-config --cflags --libs gtk+-2.0` 运行：1./helloworld 进阶：从源代码编译软件—MPlayer将下载的tar.gz放入/opt下一般地说，通常情况下我们把第三方软件放在/opt中，如果是系统依赖的软件，如非必要，也尽量地安装在/usr/local目录下，这是一个好习惯，可以同安装在/usr目录下的系统工具有效地区分开来。 12tar zxvf MPlayerr-1.1.tar.gzls -F 正确配置软件Linux上面所有的软件都使用configure这个脚本来配置以源代码形式发布的软件。 12./configure --prefix=/usr/local/Games/MPlayer##指定将软件安装在/usr/local/Games/MPlayer的目录下 —prefix指定软件的安装位置。至于configure的其他选项就不好说了，必须阅读README文档，举例如下： 123456789101112cd MPlayer-1.1/ ##进入MPlayer的源代码目录cat READMEstep2: Configuring MPlayerMPlayer can be adapted to all kinds of needs and hardware environments.run./configureto configure MPlayer with the default options. GUI support has to be enabled seperately,run./configure --enable-gui 按提示执行1234./configure --enable-gui...'make' will now compile MPlayer and 'make install' will install it 编译源代码： 1make 1sudo make install 看看有没有出错接下来就是一些细节的处理了。 12345Unpack the archive and put the contents in /usr/local/share/mplayer/skins/ or ~/.mplayer/skins/.mplayer will use the skin in the subdirectory named default of /usr/local/share/mplayer/skins/ or ~/.mplayer/skins/ unless told otherwise via the '-skin' switch.you should rename your skin subdirectory or make a suitable symbolic link..... 把皮肤文件复制到/usr/local/share/mplayer/skins/下面，并且命名为default. 12345cd .. ##返回上一级目录sudo cp -r Blue/ /usr/local/share/mplayer/skins/default##复制皮肤文件##不加-r或者－R的时候，只拷贝文件，不拷贝文件夹；##加上后则会拷贝文件夹——包括下一级的子文件夹，以及子文件夹中的子文件夹。 其他错误：123STEP4: Choose an onscreen display fontJust pass '-font/path/to/font.ttf' on the command line or add 'font=/path/to/font.tff' to your configuration file. The manual page has more details. Alternatively you can create a symbolic link from either ~/.mplayer/subfont.ttf or /usr/local/share/mplayer/subfont.ttf to your TrueType font. 执行： 1cp /usr/share/fonts/truetype/FZSongTi.ttf ~/.mplayer/subfont.ttf 从源代码安装node.js修改目录权限 1sudo chmod -R 755 node 1234cd nodesudo ./configure --prefix=usr/local/binsudo makesudo make install 必要的时候，还需设置环境变量 一般情况下：1234npm --versionnode --version#检查有没有信息？如果没有，则设置环境变量 1234567vim /etc/profile#export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL##上面添加：export NODE_HOME=/usr/local/node/0.10.24export PATH=$NODE_HOME/bin:$PATH 在安装的最后，需要把node安装到系统命令123sudo ln -s /usr/local/node/bin/node /usr/bin/nodesudo ln -s /usr/local/node/lib/node_modules /usr/lib/nodesudo ln -s /usr/local/node/bin/npm /usr/bin/npm 从源代码卸载node.js同样我们需要原来的包含./configure文件的解压包node 1sudo make uninstall 环境变量的配置(源码编译安装这步不必要)这里以安装nodejs为例，来说说配置环境变量的方法。 1、在nodejs官网上下载nodejs源码node-v5.1.0-linux-x64.tar.gz，到/opt目录下；进入/opt目录，输入命令：tar -zxf node-v5.1.0-linux-x64.tar.gz，将文件解压到当前目录 2、输入命令：vim /etc/profile添加以下三行：export NODE_HOME=/opt/nodeexport PATH=$PATH:$NODE_HOME/binexport NODE_PATH=$NODE_HOME/lib/node_modules之后按Esc键，并输入“：wq!”命令保存配置并推出 3、在命令行输入：source /etc/profile，然后在命令行输入：node -v，返回版本信息v5.1.0，说明环境变量配置就生效了；但，你会发现进入root账户，改配置并没有生效 4、在命令行输入：vim /root/.bashrc,并在文件末尾加入一行source etc/profile命令，保存。这样就大功告成了。 /etc/profile等环境变量/etc/profile该文件登录操作系统时，为每个用户设置环境信息，当用户第一次登录时,该文件被执行。也就是说这个文件对每个shell都有效，用于获取系统的环境信息。 /etc/bashrc为每一个运行bash shell的用户执行此文件，当bash shell被打开时,该文件被读取。也就是说，当用户shell执行了bash时，运行这个文件。 ~/.bashrc该文件存储的是专属于个人bash shell的信息，当登录时以及每次打开一个新的shell时,执行这个文件。在这个文件里可以自定义用户专属的个人信息。 那么在用户登录系统时候，相关的文件执行顺序是什么呢。在刚登录linux时，首先启动 /etc/profile 文件，然后再启动用户目录下的 ~/.bash_profile、 ~/.bash_login或 ~/.profile文件中的其中一个，执行的顺序为：~/.bash_profile、 ~/.bash_login、 ~/.profile。如果 ~/.bash_profile文件存在的话，一般还会执行 ~/.bashrc文件。 添加配置项的方法12345678910111213141516171819202122232425添加配置项，共有三种方式方式一：修改/etc/bash.bashrc文件 gedit /etc/bash.bashrc 在最后加上： export PATH＝/usr/local/arm/4.4.3/bin:$PATH方式二：修改/etc/profile文件： gedit /etc/profile 增加路径设置，在末尾添加如下,保存/etc/profile文件： export PATH＝/usr/local/arm/4.4.3/bin:$PATH 注意设置变量后，重新开机才能看见shell运行方式三：修改～/.bashrc gedit ~/.bashrc 增加路径设置，在末尾添加如下,保存~/.bashrc文件： export PATH＝/usr/local/arm/4.4.3/bin:$PATH 运行 source ~/.bashrc 生效 #export PATH＝/usr/local/arm/4.4.3/bin:$PATH 注：(这只能在当前的终端下才是有效的！) node和npm的安装解压安装文件到/opt 安装npm和node命令到系统命令 sudo ln -s /opt/XXXXXX /usr/local/bin/nodesudo ln -s /opt/XXXXXX /usr/local/bin/npm 安装过程中bash的设置 1gedit ~/.bashrc 如图所示： 设置npm为淘宝源 方法一：1npm install cnpm --registry=https://registry.npm.taobao.org 先备份请先备份 cp ~/.bashrc ~/.bashrc.bak在~/.bashrc中添加 1234alias cnpm=\"npm --registry=https://registry.npm.taobao.org \\--cache=$HOME/.npm/.cache/cnpm \\--disturl=https://npm.taobao.org/dist \\--userconfig=$HOME/.cnpmrc\" 输入1source ~/.bashrc ubuntu安装hexo在hexo deploy的时候，可能会遇到权限不够的问题。在安装hexo-deployer-git的时候，一定要cd到你的博客目录下 123cd ~/blognpm install hexo-deployer-git --save 在执行的时候，配置_config.yml如下：12345deploy: type: git repo: https://git.coding.net/fogsail/fogsail.git # 注意，这里要用https，要不然会出现权限不够的问题 branch: master 特别注意，对于ubuntu 16.04系统，repo使用https，这样要求输入用户名和密码，而不是使用git@github.com，如果使用git@github.com，则会造成权限不足的情况","categories":[{"name":"linux","slug":"linux","permalink":"http://www.fogsail.net/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.fogsail.net/tags/linux/"}]},{"title":"数论算法：基础数论概念","slug":"20170529","date":"2017-05-28T22:50:00.000Z","updated":"2018-03-02T20:56:56.000Z","comments":true,"path":"2017/05/29/20170529/","link":"","permalink":"http://www.fogsail.net/2017/05/29/20170529/","excerpt":"数论算法中有几个重要的定理，这里先对这部分定理进行证明。","text":"数论算法中有几个重要的定理，这里先对这部分定理进行证明。 数论基本定理 1）若$a&gt;b&gt;0$，且$c=a+b$，则 $c \\ mod \\ a=b$ 证明：$c \\ mod \\ a \\ =(a+b) \\ mod \\ a = 0+(b \\ mod \\ a) $因为$a&gt;b&gt;0$，所以$b \\ mod \\ a = b$ 2）证明有无穷多个素数 证明： 假设$2,3,4,5, \\cdots ,p$是无穷多个素数组成的集合，并且令$q=2 \\times 3 \\times 5 \\times \\cdots \\times p+1$，则可以发现$q$不能够被$2,3,5 \\cdots , p$中的任何一个整除。 $q$要么是一个素数，要么能够被$p \\cdots q$中的任何一个素数整除。无论哪种情形，肯定有大于$q$的素数存在。 3) 证明：如果$a|b$且$b|c$，则$a|c$ 证明： 可知$b=k_1a$，$c=k_2b$，则$c=k_1k_2a$，原式成立。 4）证明：如果$p$是素数并且$0&lt;k&lt;p$，则$gcd(k,p)=1$ 证明： 这是显然成立的，依据素数的定义 5) 证明: 对任意的正整数$n,a,b$，如果$n|ab$且$gcd(a,n)=1$，则$n|b$ 证明： 由题中条件可以知道：$ab=kn$，存在$x,y$， 使得$ax+ny=1$因为$gcd(a,n)=1$，$k/a$是一个整数。所以$b=n(k/a)=k_1n$，其中$k_1=k/a$所以很显然$n|b$ 6) 证明：如果$p$是素数，且$0&lt;k&lt;p$，则$p|{p \\choose k}$，证明若对所有的整数$a,b$和素数$p$，有$(a+b)^p \\equiv a^p+b^p (mod \\ p)$ 证明：这个结论可以由$(a+b)^p$的二项展开式显然得出 7) 证明：如果$a$和$b$是任意正整数，且满足$a|b$，则对任意$x$$(x \\ mod \\ b) \\ mod \\ a = x \\ mod \\ a$在相同的假设下，证明对任意整数$x,y$，如果$x \\equiv y (mod \\ b)$，则 $x \\equiv y(mod \\ a)$ 证明：从完全剩余系的观点来理解。$x \\ mod \\ a$可以写出$x \\in [\\cdots,l-a,l,l+a,\\cdots]$$(x \\ mod \\ b) = (x \\ mod \\ ka) =l$$(x \\ mod \\ b) \\ mod \\ a = l \\ mod \\ a = l$ $此时x \\equiv y \\equiv l(mod \\ b)$而很显然$x \\in [\\cdots,l-a,l,l+a,\\cdots]$可以得出$x \\equiv l \\ (mod \\ a)$ 8) 证明一系列等式 利用一部分结论：$a= \\prod_p p^{\\alpha} \\quad (\\alpha \\geq 0)$$b= \\prod_p p^{\\beta} \\quad (\\beta \\geq 0)$$gcd(a,b)= \\prod_p p^{min(\\alpha, \\beta)}$ 上述结论的证明，可以利用素数的唯一分解定理。由此可以知道，1)$gcd(a,b)=gcd(b,a)$ 2)$-a=- \\prod_p p^{\\alpha} \\quad (\\alpha \\geq 0)$$b= \\prod_p p^{\\beta} \\quad (\\beta \\geq 0)$$gcd(-a,b)= \\prod_p p^{min(\\alpha, \\beta)}=gcd(a,b)$ 3)$|a|=\\pm \\prod_p p^{\\alpha} \\quad (\\alpha \\geq 0)$$|b|=\\pm \\prod_p p^{\\beta} \\quad (\\beta \\geq 0)$$gcd(a,b)= \\prod_p p^{min(\\alpha, \\beta)}=gcd(|a|,|b|)$ 4)$gcd(a,ka)$可知，$a=\\prod_p p^{\\alpha} \\quad (\\alpha \\geq 0)$$ka=\\prod_p p^{\\alpha+\\alpha_{0}}$$min(\\alpha, \\alpha+\\alpha_{0})=\\alpha$$gcd(a,ka)=|a|$ 9) 证明：最大公约数满足结合律，对所有的整数$a,b,c$有：$gcd(a,gcd(b,c))=gcd(gcd(a,b),c)$ 由以上分析可知：$a=\\prod_p p^{\\alpha} \\quad b=\\prod_p p^{\\beta1} \\quad c=\\prod_p p^{\\beta2}$$gcd(a,gcd(b,c))=gcd(gcd(a,b),c)=\\prod_p p^{min(\\alpha,\\beta1,\\beta2)}$ 10）素数唯一分解定理 证明：如果$p$是素数，并且$p|ab$，那么$p|a$或者$p|b$假设某个数可以被分解成$ab$，那么由于$p|a$，则$a$可以继续往下分解。 更严格的证明表述如下：$n=p_1p_2p_3 \\cdots = q_1q_2 \\cdots \\quad (p_i \\neq q_j)$$p_1$最小，则$p_1^2 \\leq n$$q_1$最小，则$q_1^2 \\leq n$因为$p_1q_1&lt;n$，则$N=n-p_1q_1=p_1q_1(m-1)$可见$N$只有一种分解$p_1,q_1,m-1$ $p_1|n$，则$p_1|N$$q_1|n$，则$q_1|N$$(p_1q_1)|N \\quad (p_1q_1)|n$$q_1|(n/p_1)$则$q_1|(p_2p_3\\cdots)$，但q与p各不相同，矛盾","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"}]},{"title":"签约棒球运动员","slug":"20170523","date":"2017-05-22T16:50:00.000Z","updated":"2019-03-06T09:44:22.942Z","comments":true,"path":"2017/05/23/20170523/","link":"","permalink":"http://www.fogsail.net/2017/05/23/20170523/","excerpt":"假设你是一支棒球大联盟球队的总经理。在赛季休季期间，你需要签入一些自由球员。球队老板给你的预算为X美元，你可以使用少于X美元来签入球员，但如果超支，球队老板就会解雇你。 你正在考虑在N个不同位置签入球员，在每个位置上，有P个该位置的自由球员供你选择。由于你不希望任何位置过于臃肿，因此每个位置最多签入一名球员(如果在某个特定位置上你没有签入任何球员，则意味着计划继续使用现有球员)。","text":"假设你是一支棒球大联盟球队的总经理。在赛季休季期间，你需要签入一些自由球员。球队老板给你的预算为X美元，你可以使用少于X美元来签入球员，但如果超支，球队老板就会解雇你。 你正在考虑在N个不同位置签入球员，在每个位置上，有P个该位置的自由球员供你选择。由于你不希望任何位置过于臃肿，因此每个位置最多签入一名球员(如果在某个特定位置上你没有签入任何球员，则意味着计划继续使用现有球员)。 为了确定一名球员的价值，你决定使用一种称为“VORP”，或“球员替换价值”的统计评价指标。球员的VORP值越高，其价值越高。但VORP值高的球员签约费用并不一定比VORP值低的球员高，因为还有球员价值之外的因素影响签约费用。 对于每个可选择的自由球员，你知道他的三方面信息： 1.他打哪个位置。2.他的签约费用。3.他的VORP。 设计一个球员选择算法，是的总签约费用不超过X美元，而球员的总VORP最大。你可以假定每位球员的签约费用是10万美元的整数倍。算法应输出签约球员的总VORP值，总签约费用，以及球员名单。分析算法的时间和空间复杂度。 算法设计与分析 状态转移函数如下： value[i,x]= \\begin{cases} \\max \\limits_{p \\in S(N,x)} (candidate.vorp) & \\text{i==N}\\\\ \\max {(value[i+1,x],\\max \\limits_{p \\in S(N,x)} (candidate.vorp+value[i+1,x-candidate.cost]))} & \\text{i","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"库存规划","slug":"20170513","date":"2017-05-13T06:07:00.000Z","updated":"2018-03-02T20:45:10.000Z","comments":true,"path":"2017/05/13/20170513/","link":"","permalink":"http://www.fogsail.net/2017/05/13/20170513/","excerpt":"Rinky Dink公司是一家制造溜冰场冰面修整设备的公司。这种设备每个月的需求量都在变化，因此公司希望设计一种策略来规划生产，需求是给定的，即它虽然是波动的，但是是可预测的。公司希望设计接下来的$n$个月的生产计划。 对第$i$个月，公司知道需求$d_i$，即该月能够销售出去的设备的总量。令$D=\\sum_{i=1}^{n}d_i$为后$n$个月的总需求。公司雇佣的全职员工，可以提供一个月制造$m$台设备的劳动力。如果公司希望一个月内制造多于$m$台的设备，可以雇佣额外的兼职劳动力，雇佣的成本为每制造一台机器付出$c$美元。而且，如果在月末还有设备未售出，公司将付出库存成本。","text":"Rinky Dink公司是一家制造溜冰场冰面修整设备的公司。这种设备每个月的需求量都在变化，因此公司希望设计一种策略来规划生产，需求是给定的，即它虽然是波动的，但是是可预测的。公司希望设计接下来的$n$个月的生产计划。 对第$i$个月，公司知道需求$d_i$，即该月能够销售出去的设备的总量。令$D=\\sum_{i=1}^{n}d_i$为后$n$个月的总需求。公司雇佣的全职员工，可以提供一个月制造$m$台设备的劳动力。如果公司希望一个月内制造多于$m$台的设备，可以雇佣额外的兼职劳动力，雇佣的成本为每制造一台机器付出$c$美元。而且，如果在月末还有设备未售出，公司将付出库存成本。 保存$j$台设备的成本可以描述为一个函数$h(j)$，$j=1,2,\\cdots,D$，其中对所有的$1 \\leq j \\leq D$，$h(j) \\geq 0$，对$1 \\leq j \\leq D-1$，$h(j) \\leq h(j+1)$。 设计库存规划算法。 能量守恒的观点分析库存规划的问题，可以用物理学中的能量守恒的观点进行分析 $store \\ cost+HR \\ cost=total \\ value$其中，$total \\ value$表示总能量，总能量在$store \\ cost$和$HR \\ cost$中能够相互转换。 算法分析： inventory_dynamic.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#define m 15#define n 10#define c 3void find_create(int *extra_create,int *create_result,int *d)&#123; for(int i=0;i&lt;=n;i++) create_result[i]=extra_create[i]+d[i];&#125;int min_val(int a ,int b)&#123; return a&lt;b?a:b;&#125;int man_cost(int man_num)&#123; if(man_num&lt;=m) return 0; else return c*(man_num-m);&#125;int store_cost(int store_num)&#123; if(store_num&gt;0) return (int)log((double)store_num); else return 0;&#125;int create_material(int d[],int create[][n+1],int start,int end)//start从0开始&#123; if(start==end) &#123; create[start][end]=0; &#125; if(end==start+1) &#123; create[start][end]=d[end]; &#125; if(end&gt;start) &#123; create[start][end]=create_material(d,create,start,end-1)+d[end]; //实现结果 d[start+1]+d[start+2]+.....+d[end] &#125; else &#123; return 0; &#125; return create[start][end];&#125;void init_create(int create[][n+1],int d[])&#123; for(int i=0;i&lt;n;i++) create_material(d,create,i,n);&#125;int min_cost(int d[],int HR_extra[],int start,int end)&#123; if(start&gt;=end) return 0; int cost=0; //最初cost[]值为0，一开始每一个位置所保存的create[]就是当前需求值 for(int i=start;i&lt;=end;i++) &#123; if(d[i]&lt;=m) &#123; //此时不需要花费额外的人力成本，所有的create[i]==d[i]均会销售出去 cost+=0; //不需要花费任何代价，月末就可以出售完毕，没有库存 HR_extra[i]=m-d[i]; &#125; else &#123; HR_extra[i]=m-d[i]; int HR_cost=d[i]; //人力资源成本超出预算，这部分预算可以考虑转换成库存成本 int HR_cost_copy=d[i]; //副本，用来输出 int cost_original=man_cost(HR_cost); int extra_store=0; //额外付出的库存代价 //注意判断cost_original和cost_adjust哪个大？哪个小？ for(int l=start;l&lt;i;l++) //(l,i) &#123; int cur_extra=HR_extra[l]; if(cur_extra&gt;0 &amp;&amp; HR_cost!=0) //这部分人力资源成本可以用来存放库存，转换成库存成本 &#123; int temp_excess=min_val(cur_extra,HR_cost); //势能守恒来求解 HR_cost-=temp_excess; extra_store+=temp_excess; &#125; &#125; int cost_adjust=man_cost(HR_cost)+store_cost(extra_store); if(cost_adjust&lt;cost_original) &#123; cost+=cost_adjust; //HR_extra也要调整 for(int l=start;l&lt;i;l++) &#123; if(HR_extra[l]&gt;0 &amp;&amp; HR_cost_copy!=0) &#123; int temp_excess_copy=min_val(HR_extra[l],HR_cost_copy); HR_cost_copy-=temp_excess_copy; //保持势能守恒 HR_extra[l]-=temp_excess_copy; HR_extra[i]+=temp_excess_copy; &#125; &#125; &#125; else &#123; cost+=cost_original; &#125; &#125; &#125; return cost;&#125; inventory_dynamic.cpp1234567891011121314151617181920212223242526272829#include \"inventory_dynamic.h\"int main()&#123; int result_cost,original_create; int d[n+1]=&#123;0,10,11,13,14,20,25,29,9,8,7&#125;; //146 int HR_extra[n+1]=&#123;0&#125;; int result[n+1]=&#123;0&#125;; int create[n+1][n+1]=&#123;0&#125;; //int cost[n+1][n+1]=&#123;0&#125;; original_create=create_material(d,create,0,n); init_create(create,d); result_cost=min_cost(d,HR_extra,1,n); cout&lt;&lt;\"The result is :\"&lt;&lt;endl; cout&lt;&lt;result_cost&lt;&lt;endl; cout&lt;&lt;\"The create result is :\"&lt;&lt;endl; for(int i=1;i&lt;=n;i++) &#123; cout&lt;&lt;m-HR_extra[i]&lt;&lt;\" \"; &#125;&#125; 算法运行结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"基于接缝裁剪的图像压缩","slug":"20170512","date":"2017-05-12T01:54:00.000Z","updated":"2018-03-02T20:38:42.000Z","comments":true,"path":"2017/05/12/20170512/","link":"","permalink":"http://www.fogsail.net/2017/05/12/20170512/","excerpt":"给定一幅彩色图像，它由$m\\times n$的像素$A[1\\cdots m,1\\cdots n]$构成，每个像素是一个红绿蓝$(RGB)$亮度的三元组。假定我们希望轻度压缩这幅图像。具体地，我们希望从每一行中删除一个像素，使得图像变窄一个像素。 为了避免影响视觉效果，我们要求删除的像素必须位于同一列或者是相邻列，也就是说，删除的像素构成从底端到顶端的一条“接缝”(seam)，相邻像素均在垂直或对角线方向上相邻。","text":"给定一幅彩色图像，它由$m\\times n$的像素$A[1\\cdots m,1\\cdots n]$构成，每个像素是一个红绿蓝$(RGB)$亮度的三元组。假定我们希望轻度压缩这幅图像。具体地，我们希望从每一行中删除一个像素，使得图像变窄一个像素。 为了避免影响视觉效果，我们要求删除的像素必须位于同一列或者是相邻列，也就是说，删除的像素构成从底端到顶端的一条“接缝”(seam)，相邻像素均在垂直或对角线方向上相邻。 a.证明：可能的接缝数量是$m$的指数函数，假定$n&gt;1$ 证明：第一行有n中可能的取像素的方式，第二行到第m行，每一行有3种可能：$A[i][j-1],A[i][j],A[i][j+1]$。（当j==1或者j==0时，是两种可能)所以至少有$n\\times 2^{(m-1)}$ b.假定现在对每个像素$A[i,j]$我们都已经计算出一个破坏度$d[i,j]$，表示删除像素$A[i,j]$对图像可视化效果的破坏程度。 直观地，一个像素的破坏度越低，它与像素的相似度越高。再假定一条接缝的破坏度定义为包含的响度的破坏度之和。设计算法，寻求破坏度最低的接缝。 seam_carving.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;using namespace std;#define n 6 //数组行#define m 5 //数组列#define INFINITY 0x7fffffff//总共n行 m列void print_seam(int **A,int i,int j); //第i行 第j列int Additional_Min(int **A,int i,int j) //第i行 第j列&#123; int temp=0; if(j==1) &#123; temp=A[i-1][j]&gt;A[i-1][j+1]?A[i-1][j+1]:A[i-1][j]; &#125; else if(j==m) &#123; temp=A[i-1][j]&gt;A[i-1][j-1]?A[i-1][j-1]:A[i-1][j]; &#125; else &#123; if(A[i-1][j]&gt;A[i-1][j-1]) &#123; temp=A[i-1][j-1]; if(A[i-1][j-1]&gt;A[i-1][j+1]) temp=A[i-1][j+1]; &#125; else &#123; temp=A[i-1][j]; if(A[i-1][j]&gt;A[i-1][j+1]) temp=A[i-1][j+1]; &#125; &#125; return temp;&#125;void seam_carving(int **d)&#123; int **A,i; //二维数组表示破坏度之和 A=new int *[n+1]; for(i=0;i&lt;=n;i++) A[i]=new int[m+1]; for(int j=1;j&lt;=m;j++) A[1][j]=d[1][j]; for(i=2;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) A[i][j]=d[i][j]+Additional_Min(A,i,j); &#125; //输出最后接缝的位置 int min_seam=INFINITY; int seam_plot=0; for(int j=1;j&lt;=m;j++) &#123; if(A[n][j]&lt;min_seam) &#123; min_seam=A[n][j]; seam_plot=j; &#125; &#125; cout&lt;&lt;\"MIN break point is \"&lt;&lt;min_seam&lt;&lt;endl; print_seam(A,n,seam_plot); for(int i=0;i&lt;=m;i++) delete [] A[i]; delete[] A;&#125;void print_seam(int **A,int i,int j) //i行 j列，总共n行 m列&#123; int seam_next; if(i==0) return; else &#123; if(j==m) seam_next=A[i][j]&gt;A[i][j-1]?j-1:j; else if(j==1) seam_next=A[i][j]&gt;A[i][j+1]?j+1:j; else &#123; if(A[i][j]&gt;A[i][j-1]) &#123; seam_next=j-1; if(A[i][j-1]&gt;A[i][j+1]) seam_next=j+1; &#125; else &#123; seam_next=j; if(A[i][j]&gt;A[i][j+1]) seam_next=j+1; &#125; &#125; &#125; print_seam(A,i-1,seam_next); cout&lt;&lt;\"ROW: \"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;\"COLUMN: \"&lt;&lt;seam_next&lt;&lt;\"-&gt;\"; //输出方式，注意把这一句放在递归下面，从i=1---&gt;i=n从上往下执行输出 //如果放在递归前面就是从下往上输出&#125; seam_carving.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;using namespace std;#define n 6 //数组行#define m 5 //数组列#define INFINITY 0x7fffffff//总共n行 m列void print_seam(int **A,int i,int j); //第i行 第j列int Additional_Min(int **A,int i,int j) //第i行 第j列&#123; int temp=0; if(j==1) &#123; temp=A[i-1][j]&gt;A[i-1][j+1]?A[i-1][j+1]:A[i-1][j]; &#125; else if(j==m) &#123; temp=A[i-1][j]&gt;A[i-1][j-1]?A[i-1][j-1]:A[i-1][j]; &#125; else &#123; if(A[i-1][j]&gt;A[i-1][j-1]) &#123; temp=A[i-1][j-1]; if(A[i-1][j-1]&gt;A[i-1][j+1]) temp=A[i-1][j+1]; &#125; else &#123; temp=A[i-1][j]; if(A[i-1][j]&gt;A[i-1][j+1]) temp=A[i-1][j+1]; &#125; &#125; return temp;&#125;void seam_carving(int **d)&#123; int **A,i; //二维数组表示破坏度之和 A=new int *[n+1]; for(i=0;i&lt;=n;i++) A[i]=new int[m+1]; for(int j=1;j&lt;=m;j++) A[1][j]=d[1][j]; for(i=2;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) A[i][j]=d[i][j]+Additional_Min(A,i,j); &#125; //输出最后接缝的位置 int min_seam=INFINITY; int seam_plot=0; for(int j=1;j&lt;=m;j++) &#123; if(A[n][j]&lt;min_seam) &#123; min_seam=A[n][j]; seam_plot=j; &#125; &#125; cout&lt;&lt;\"MIN break point is \"&lt;&lt;min_seam&lt;&lt;endl; print_seam(A,n,seam_plot); for(int i=0;i&lt;=m;i++) delete [] A[i]; delete[] A;&#125;void print_seam(int **A,int i,int j) //i行 j列，总共n行 m列&#123; int seam_next; if(i==0) return; else &#123; if(j==m) seam_next=A[i][j]&gt;A[i][j-1]?j-1:j; else if(j==1) seam_next=A[i][j]&gt;A[i][j+1]?j+1:j; else &#123; if(A[i][j]&gt;A[i][j-1]) &#123; seam_next=j-1; if(A[i][j-1]&gt;A[i][j+1]) seam_next=j+1; &#125; else &#123; seam_next=j; if(A[i][j]&gt;A[i][j+1]) seam_next=j+1; &#125; &#125; &#125; print_seam(A,i-1,seam_next); cout&lt;&lt;\"ROW: \"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;\"COLUMN: \"&lt;&lt;seam_next&lt;&lt;\"-&gt;\"; //输出方式，注意把这一句放在递归下面，从i=1---&gt;i=n从上往下执行输出 //如果放在递归前面就是从下往上输出&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"投资策略规划","slug":"20170508","date":"2017-05-07T21:03:00.000Z","updated":"2018-03-02T18:23:26.000Z","comments":true,"path":"2017/05/08/20170508/","link":"","permalink":"http://www.fogsail.net/2017/05/08/20170508/","excerpt":"你所掌握的算法知识帮助你从Acme计算机公司获得了一份令人兴奋的工作，签约奖金为1万美元。你决定利用这笔钱进行投资，目标是10年后获取最大回报。你决定请Amalgamated投资公司管理你的投资，该公司投资回报规则如下：","text":"你所掌握的算法知识帮助你从Acme计算机公司获得了一份令人兴奋的工作，签约奖金为1万美元。你决定利用这笔钱进行投资，目标是10年后获取最大回报。你决定请Amalgamated投资公司管理你的投资，该公司投资回报规则如下： 该公司提供$n$种不同的投资，从1～n编号。在第$j$年，第$i$种投资的回报率为$r_{ij}$。换句话说，如果你在第$j$年在第$i$种投资中投入$d$美元，那么你在第j年年底，你会得到$dr_{ij}$美元。回报率是有保证的，即未来10年每种投资的回报率均为已知。 你每年只能做出一次的投资决定。在每年的年底，你既可以将钱投入到上一年的投资种类中，也可以转移到其他的投资中。如果跨年时候你不做投资转移，需要支付$f_1$的费用，否则，需要支付$f_2$的投资费用。 $f_2&gt;f_1$ 算法设计与分析 可以看出，投资策略规划问题具有最优子结构。如图所示，红色部分的$V[j][k]$是从$V[j][k1] \\ V[j][k2] \\ V[j][k3] \\ V[j][k4] \\ V[j][k5]$中选择出最大的值。 能量守恒观点分析$V[j-1][check]$具有的总能量为total total经过$f1 \\ f2 \\ f3 \\ f4 \\ f5$不同的路径的流动，最后流动到$V[j][k]$，必然存在一条流量最大的路径。 这可以用反证法，假设$f_i$不是流量最大的那个，那必然可以用$f_j$这条流量更大的路径来代替它。 如果Amalgamated公司在上述规则上又加入了新的限制条款，在任何时候单一的投资种类不得超过15000元，那么该问题就失去了最优子结构性质。 举个例子： 假设最优子结构是通过$f3$这个流量来获取的。但是对$f3$执行限流，有约束条件，则这条$f3$路径就“走不通”了，自然取不到最优解。 investment_program.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;ctime&gt;using namespace std;#define n 10#define m 8void best_investment(double **r)&#123; double increase[n+1][m+1]; //二维数组increase[i][j]表示第i年购买第j种投资 double f1=0.01,f2=0.04; double addition; for(int i=1;i&lt;=m;i++) &#123; increase[1][i]=r[i][1]+1.0; //第一年为初始状态，最大值就是本年每一种投资的值 &#125; for(int j=2;j&lt;=n;j++) //表示第j年 &#123; for(int k=1;k&lt;=m;k++) //表示第k种投资 &#123; increase[j][k]=-0x7fffffff; //从第一种投资开始检查，看看是否有和k相等类型的投资？ //类似的问题可以这样解决：两个for循环，然后从第一种投资一次开始检查 //第二种投资类型，只有几种状态：A B C等等。依次检查，看看addition值属于哪种类型 for(int check=1;check&lt;=m;check++) &#123; if(check==k) addition=f1; else addition=f2; if((increase[j-1][check]-addition)*(1.0+r[k][j])&gt;increase[j][k]) &#123; //r[k][j]第j年第k种投资 increase[j][k]=(increase[j-1][check]-addition)*(1.0+r[k][j]); &#125; &#125; &#125; &#125; cout&lt;&lt;\"year i, investment j, total: \"&lt;&lt;endl; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; cout&lt;&lt;setprecision(5)&lt;&lt;showpoint&lt;&lt;increase[i][j]&lt;&lt;\"\\t\"; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;\"after 10 years, the investment is :\"&lt;&lt;endl; double total_10=-0x7fffffff; for(int k=1;k&lt;=m;k++) //表示第k种投资 &#123; if(increase[n][k]&gt;total_10) total_10=increase[n][k]; &#125; cout&lt;&lt;total_10&lt;&lt;endl;&#125; investment_program.cpp12345678910111213141516171819202122232425262728293031323334#include \"investment_program.h\"int main()&#123; srand( (unsigned)time(NULL)); double **r; r=new double*[m+1]; for(int i=0;i&lt;=m;i++) &#123; r[i]=new double[n+1]; &#125; cout&lt;&lt;\"year j, investment i, return: \"&lt;&lt;endl; for(int i=1;i&lt;=m;i++) //共有i种投资类型 &#123; for(int j=1;j&lt;=n;j++) //年份从j=1到n，共n年 &#123; r[i][j]=(((rand()%1000+1)/1000.0+1)-1)/10.0; cout&lt;&lt;setprecision(3)&lt;&lt;showpoint&lt;&lt;r[i][j]&lt;&lt;\"\\t\"; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; best_investment(r); for(int i=0;i&lt;=m;i++) &#123; delete[] r[i]; &#125; delete[] r; return 0;&#125; 算法实现结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"字符串拆分","slug":"20170419","date":"2017-04-19T14:20:00.000Z","updated":"2018-03-02T17:51:06.000Z","comments":true,"path":"2017/04/19/20170419/","link":"","permalink":"http://www.fogsail.net/2017/04/19/20170419/","excerpt":"字符串拆分概论某种字符串处理语言能够允许程序员将一个字符串拆分成为两段。由于此操作需要复制字符串，因此需要$n$个时间单位来将一个$n$个字符串拆分为两段。假定一个程序员希望将一个20个字符的字符串在第2个，第8个，以及第10个字符串进行从左到右拆分。","text":"字符串拆分概论某种字符串处理语言能够允许程序员将一个字符串拆分成为两段。由于此操作需要复制字符串，因此需要$n$个时间单位来将一个$n$个字符串拆分为两段。假定一个程序员希望将一个20个字符的字符串在第2个，第8个，以及第10个字符串进行从左到右拆分。 主要的拆分方式如下； 自底向上非递归求解算法分析： break_string2.h1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;#define n 7 //为L[]的数组元素的个数int break_string_array(int L[],int cut[][n+1])&#123; int cost[n+1][n+1]=&#123;0&#125;; for(int len=2;len&lt;=n;len++) &#123; for(int i=1;i&lt;=n-len+1;i++) &#123; int j=i+len-1; if(j-i&gt;1) cost[i][j]=0x7fffffff; for(int part=i+1;part&lt;j;part++) &#123; int value=cost[i][part]+cost[part][j]+(L[j-1]-L[i-1]); //注意，这里cost[start][part]+cost[part+1][end]会发生错误 if(value&lt;cost[i][j]) &#123; cost[i][j]=value; cut[i][j]=part; &#125; &#125; &#125; &#125; return cost[1][n];&#125;void print_breaks(int L[],int cut[][n+1],int i,int j)&#123; if(j-i&gt;=2) &#123; int k=cut[i][j]; cout&lt;&lt;L[k-1]&lt;&lt;\" \"; print_breaks(L,cut,i,k); print_breaks(L,cut,k,j); &#125;&#125; break_string2.cpp1234567891011121314#include \"break_string2.h\"int main()&#123; //int L[n]=&#123;0,2,8,10,20&#125;; int L[n]=&#123;0,11,14,17,20,25,30&#125;; int cut[n+1][n+1]=&#123;0&#125;; int result=break_string_array(L,cut); cout&lt;&lt;\"result is : \"&lt;&lt;endl; cout&lt;&lt;result&lt;&lt;endl; print_breaks(L,cut,1,n);&#125; 算法实现结果 自顶向下递归算法记得带备忘机制 break_string.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//L[]表示拆分点数组//cost[][]表示花费#include &lt;iostream&gt;#define INFINITY 0x7fffffffusing namespace std;#define m 5#define n 30using namespace std;//int position[n+1][n+1]=&#123;0&#125;;int cost[n+1][n+1]=&#123;0&#125;;int exist[n+1][n+1]=&#123;0&#125;;int total_cost=INFINITY;int part=0;int cut_point=0;void INITIATE(int cost[][n+1])&#123; for(int i=0;i&lt;=n-1;i++) &#123; for(int j=i+1;j&lt;=n;j++) cost[i][j]=INFINITY; &#125;&#125;//break_point中，start,end分别表示下标起始坐标，尾坐标int break_point(int L[],int cost[][n+1],int start,int end,int cut[][n+1]) //start end表示第几个数，而不是数组下标&#123; //使用递归判断的时候要先看看在start和end之间是否存在这样的值 if(end-start&lt;2) &#123; cost[start][end]=0; return cost[start][end]; &#125; if(cost[start][end]!=INFINITY) return cost[start][end]; for(int i=0;i&lt;m;i++) &#123; if(L[i]&gt;start &amp;&amp; L[i]&lt;end) &#123; exist[start][end]=1; break; &#125; &#125; if(exist[start][end]==0) &#123; cost[start][end]=0; return cost[start][end]; &#125; else &#123; int total_cost=INFINITY; for(int i=0;i&lt;m;i++) &#123; if(L[i]&gt;start &amp;&amp; L[i]&lt;end) &#123; part=L[i]; if(break_point(L,cost,start,part,cut)+break_point(L,cost,part+1,end,cut)+(end-start+1)&lt;=total_cost) &#123; total_cost=break_point(L,cost,start,part,cut)+break_point(L,cost,part+1,end,cut)+(end-start+1); cut_point=i; &#125; &#125; &#125; if(total_cost&lt;=cost[start][end]) &#123; cost[start][end]=total_cost; cut[start][end]=cut_point; &#125; &#125; return cost[start][end];&#125;void print_breaks(int L[],int cut[][n+1],int start,int end)&#123; if(exist[start][end]==1) &#123; cout&lt;&lt;L[cut[start][end]]&lt;&lt;\" \"; print_breaks(L,cut,start,L[cut[start][end]]); print_breaks(L,cut,L[cut[start][end]]+1,end); &#125;&#125; break_string.cpp12345678910111213141516171819202122#include \"break_string.h\"int main()&#123; //int L[m]=&#123;2,8,10&#125;; int L[m]=&#123;11,14,17,20,25&#125;; int cost[n+1][n+1]; int cut[n+1][n+1]=&#123;0&#125;; INITIATE(cost); //初始化完毕 int result=break_point(L,cost,1,n,cut); print_breaks(L,cut,1,n); cout&lt;&lt;endl; cout&lt;&lt;\"The result is :\"; cout&lt;&lt;result&lt;&lt;endl; return 0;&#125; 这里注意的是递归式和自底向上方法不一样 $ if(breakpoint(L,cost,start,part,cut)+breakpoint(L,cost,part+1,end,cut)+(end-start+1)&lt;=totalcost)$ 算法实现结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"译码算法","slug":"20170416","date":"2017-04-16T07:20:00.000Z","updated":"2018-03-02T18:15:54.000Z","comments":true,"path":"2017/04/16/20170416/","link":"","permalink":"http://www.fogsail.net/2017/04/16/20170416/","excerpt":"我们可以通过在有向图$G=(V,E)$中使用动态规划的算法来实现语音识别功能。对每条边$(u,v) \\in E$打上一个声音标签$\\sigma (u,v)$，该声音来自于有限声音集$\\sum$ 。图中从特定的顶点$v_0 \\in V$开始的每条路径都对应模型产生一个可能的声音序列。对于一条有向路径，我们定义标签为路径中边的标签的简单连结。","text":"我们可以通过在有向图$G=(V,E)$中使用动态规划的算法来实现语音识别功能。对每条边$(u,v) \\in E$打上一个声音标签$\\sigma (u,v)$，该声音来自于有限声音集$\\sum$ 。图中从特定的顶点$v_0 \\in V$开始的每条路径都对应模型产生一个可能的声音序列。对于一条有向路径，我们定义标签为路径中边的标签的简单连结。 寻找特定的声音序列对给定的带标签的图$G$，特定顶点$v_0$以及$\\sum$上的声音序列$\\sigma=&lt;\\sigma _1,\\sigma _2,\\sigma_3, \\cdots, \\sigma_k&gt;$返回从$G$中从$V_0$开始的一条路径，$s$为该路径的标签（如果存在这样的路径）。否则，返回NO-SUCH-PATH viterbi_graph.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include \"stdlib.h\"#include &lt;string.h&gt;using namespace std;#define MAXVEX 100enum color&#123;WHITE,GRAY,BLACK&#125;;enum which_edge&#123;NONE,TREE,BACK,FORWARD,CROSS&#125;;typedef int status;typedef string VertexType;typedef int EdgeType;typedef struct EdgeNode&#123; int Edgestart; int Edgeend; //邻接点域，储存该顶点对应的下标 EdgeType weight; //用于存储权值 int type; struct EdgeNode *next; //下一个邻接点&#125;EdgeNode;typedef struct VertexNode //顶点表结点&#123; VertexType data; //顶点域，存储顶点信息 int color; int touch,finish; //访问开始时间和结束时间 EdgeNode* FirstEdge; //边表头指针 int parent; //指向遍历的父结点&#125;VertexNode,AdjList[MAXVEX];typedef struct&#123; AdjList adjList; //图的顶点表 int numNodes,numEdges;&#125;GraphAdjList;void CreateALGraph(GraphAdjList *G)&#123; EdgeNode *e; cout&lt;&lt;\"Input the number of vertexes and edges: \"&lt;&lt;endl; cin&gt;&gt;G-&gt;numNodes&gt;&gt;G-&gt;numEdges; //输入顶点表的信息 for(int i=0;i&lt;G-&gt;numNodes;i++) &#123; cout&lt;&lt;\"Input the data (information) of vertexes \"&lt;&lt;i+1&lt;&lt;endl; cin&gt;&gt;G-&gt;adjList[i].data; G-&gt;adjList[i].FirstEdge=NULL; G-&gt;adjList[i].parent=-1; G-&gt;adjList[i].color=WHITE; G-&gt;adjList[i].touch=G-&gt;adjList[i].finish=-1; &#125; int beg,end; for(int k=0;k&lt;G-&gt;numEdges;k++) &#123; cout&lt;&lt;\"Input the serial number of edges (Vi,Vj) \"&lt;&lt;endl; cout&lt;&lt;\"Input the vertex of beginning: \"; cin&gt;&gt;beg; cout&lt;&lt;\"Input the vertex of endding: \"; cin&gt;&gt;end; e=(EdgeNode *)malloc(sizeof(EdgeNode)); e-&gt;Edgeend=end; e-&gt;Edgestart=beg; e-&gt;weight=0; e-&gt;type=NONE; e-&gt;next=G-&gt;adjList[beg].FirstEdge; G-&gt;adjList[beg].FirstEdge=e; &#125;&#125; graph_algorithm.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include \"viterbi_graph.h\"int path_time=0;int path_exist=0;int path_print_signal=0;void print_graph(GraphAdjList *G)&#123; EdgeNode *cur_edge; for(int i=0;i&lt;G-&gt;numNodes;i++) &#123; cout&lt;&lt;\"The start is \"&lt;&lt;G-&gt;adjList[i].data&lt;&lt;endl; cout&lt;&lt;G-&gt;adjList[i].data; if(G-&gt;adjList[i].FirstEdge) cout&lt;&lt;\" adjust end is: \"; for(cur_edge=G-&gt;adjList[i].FirstEdge;cur_edge;cur_edge=cur_edge-&gt;next) &#123; cout&lt;&lt;cur_edge-&gt;Edgeend&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125;&#125;void DFS_visit(GraphAdjList *G,int start,int end)&#123; G-&gt;adjList[start].color=GRAY; path_time++; G-&gt;adjList[start].touch=path_time; for(EdgeNode *cur_e=G-&gt;adjList[start].FirstEdge;cur_e;cur_e=cur_e-&gt;next) &#123; if(cur_e-&gt;Edgeend==end) &#123; path_exist=1; &#125; if(path_exist==1) return; int cur_end=cur_e-&gt;Edgeend; if(G-&gt;adjList[cur_end].color==WHITE) &#123; G-&gt;adjList-&gt;parent=start; DFS_visit(G,cur_end,end); cur_e-&gt;type=TREE; &#125; else if(G-&gt;adjList[cur_end].color==GRAY) &#123; cur_e-&gt;type=BACK; &#125; else if(G-&gt;adjList[cur_end].color==BLACK) &#123; if(G-&gt;adjList[start].touch&lt;G-&gt;adjList[end].touch) cur_e-&gt;type=FORWARD; else cur_e-&gt;type=CROSS; &#125; &#125; //G-&gt;adjList[start] has finished G-&gt;adjList[start].color=BLACK; path_time++; G-&gt;adjList[start].finish=path_time;&#125;void DFS(GraphAdjList *G,int start,int end)&#123; for(int u=0;u&lt;G-&gt;numNodes;u++) &#123; G-&gt;adjList[u].color=WHITE; G-&gt;adjList[u].parent=-1; &#125; path_time=0; if(G-&gt;adjList[start].color==WHITE) DFS_visit(G,start,end);&#125;void path_print(GraphAdjList *G,int start,int end)&#123; if(path_exist==1) &#123; cout&lt;&lt;\" \"&lt;&lt;start; for(EdgeNode *e_ptr=G-&gt;adjList[start].FirstEdge;e_ptr;e_ptr=e_ptr-&gt;next) &#123; if(e_ptr-&gt;Edgeend==end) &#123; cout&lt;&lt;\" \"&lt;&lt;end; path_print_signal=1; return; &#125; &#125; if(path_print_signal==0) &#123; for(EdgeNode *e_ptr=G-&gt;adjList[start].FirstEdge;e_ptr;e_ptr=e_ptr-&gt;next) &#123; if(e_ptr-&gt;type==TREE) path_print(G,e_ptr-&gt;Edgeend,end); &#125; &#125; &#125; else &#123; cout&lt;&lt;\"The path is not exist\"&lt;&lt;endl; &#125;&#125; viterbi_algorithm.cpp1234567891011121314151617181920212223242526#include \"graph_algorithm.h\"int main()&#123; GraphAdjList G; CreateALGraph(&amp;G); print_graph(&amp;G); int start,end; cout&lt;&lt;\"Input the start of the edge : \"&lt;&lt;endl; cin&gt;&gt;start; cout&lt;&lt;\"Input the end of the edge : \"&lt;&lt;endl; cin&gt;&gt;end; DFS(&amp;G,start,end); cout&lt;&lt;endl; cout&lt;&lt;path_exist&lt;&lt;endl; cout&lt;&lt;G.adjList[start].color&lt;&lt;\" \"&lt;&lt;G.adjList[start].touch&lt;&lt;\" \"&lt;&lt;G.adjList[start].finish&lt;&lt;\" \"&lt;&lt;endl; cout&lt;&lt;G.adjList[end].color&lt;&lt;\" \"&lt;&lt;G.adjList[end].touch&lt;&lt;\" \"&lt;&lt;G.adjList[end].finish&lt;&lt;\" \"&lt;&lt;endl; cout&lt;&lt;\"The path is :\"&lt;&lt;endl; path_print(&amp;G,start,end); return 0;&#125; 算法运行结果 随机游动假定每条边$(u,v) /in E$都关联一个非负概率$p(u,v)$，它表示从顶点$u$开始，经过边$(u,v)$，产生对应的声音的概率。任何一个顶点射出的概率之和均为1。 一条路径上的概率定义为路径上所有边的概率之积。 状态转移函数 可以看出：从$v_1$到$v_4$，最大的概率值为$0.8 \\times 1=0.8$ 动态规划能够实现的状态转移函数如下： 1234567answer=e-&gt;probability*DFS_compute(G,e-&gt;e_end,end);//计算从G-&gt;adjlist[beg]出发的每一条边，找出最大值if(answer&gt;G-&gt;adjlist[beg].res)&#123; G-&gt;adjlist[beg].res=answer; G-&gt;adjlist[beg].direction=e-&gt;e_end;&#125; probability_graph.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;string.h&gt;#include \"stdlib.h\"using namespace std;#define MAXVEX 100typedef int status;typedef string VertexType;typedef double EdgeType;typedef struct Edge&#123; int e_start; int e_end; //邻接点域 EdgeType probability; //用于存储权值，即边的概率 struct Edge *next;&#125;Edge;typedef struct Vertex&#123; VertexType data; Edge* head; //边表头指针 int direction; //用于指明节点下一步该往哪里走 double res; //用于储存最后的结果，初始化为-1 //direction和res要联动&#125;Vertex,adjvertex[MAXVEX];typedef struct&#123; adjvertex adjlist; //图的顶点表 int numNodes,numEdges;&#125;GraphAdj;void CreateGraph(GraphAdj *G)&#123; Edge *e; cout&lt;&lt;\"Input the number of vertexes and edges: \"&lt;&lt;endl; cin&gt;&gt;G-&gt;numNodes&gt;&gt;G-&gt;numEdges; //输入顶点表信息 for(int i=0;i&lt;G-&gt;numNodes;i++) &#123; cout&lt;&lt;\"Input the data (information) of vertexes \"&lt;&lt;i+1&lt;&lt;endl; cin&gt;&gt;G-&gt;adjlist[i].data; G-&gt;adjlist[i].head=NULL; G-&gt;adjlist[i].direction=-1; G-&gt;adjlist[i].res=-1; &#125; int beg,end; double prob; for(int k=0;k&lt;G-&gt;numEdges;k++) &#123; cout&lt;&lt;\"Input the serial number of Edges (Vi,Vj) \"&lt;&lt;endl; cout&lt;&lt;\"Input the vertex of beginning: \"; cin&gt;&gt;beg; cout&lt;&lt;\"Input the vertex of endding: \"; cin&gt;&gt;end; cout&lt;&lt;\"Input the probability of edge: \"; cin&gt;&gt;prob; e=(Edge *)malloc(sizeof(Edge)); e-&gt;e_start=beg; e-&gt;e_end=end; e-&gt;probability=prob; e-&gt;next=G-&gt;adjlist[beg].head; G-&gt;adjlist[beg].head=e; &#125;&#125; viterbi_probability.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include \"probability_graph.h\"double answer=1;double maxpath=0;int path_exist=0;int path_print_signal=0;int has_founded[MAXVEX];double DFS_compute(GraphAdj *G,int beg,int end);double max(double a,double b)&#123; return a&gt;b?a:b;&#125;double DFSTraverse(GraphAdj *G,int beg,int end)&#123; for(int i=0;i&lt;G-&gt;numNodes;i++) has_founded[i]=0; maxpath=DFS_compute(G,beg,end); return maxpath;&#125;double DFS_compute(GraphAdj *G,int beg,int end)&#123; if(beg==end) &#123; answer=1; return 1; &#125; for(Edge *e=G-&gt;adjlist[beg].head;e;e=e-&gt;next) &#123; if(has_founded[beg]==1) &#123; answer=G-&gt;adjlist[e-&gt;e_start].res; return G-&gt;adjlist[e-&gt;e_start].res; &#125; if(has_founded[beg]==0) &#123; if(e-&gt;e_end==end) &#123; path_exist=1; answer=e-&gt;probability; if(answer&gt;G-&gt;adjlist[e-&gt;e_start].res) &#123; G-&gt;adjlist[e-&gt;e_start].res=answer; G-&gt;adjlist[e-&gt;e_start].direction=e-&gt;e_end; &#125; return G-&gt;adjlist[e-&gt;e_start].res; &#125; answer=e-&gt;probability*DFS_compute(G,e-&gt;e_end,end); //计算从G-&gt;adjlist[beg]出发的每一条边，找出最大值 if(answer&gt;G-&gt;adjlist[beg].res) &#123; G-&gt;adjlist[beg].res=answer; G-&gt;adjlist[beg].direction=e-&gt;e_end; &#125; &#125; &#125; //beg开始的answer已经全部计算完了 has_founded[beg]=1; return G-&gt;adjlist[beg].res;&#125;void print_graph(GraphAdj *G)&#123; Edge *cur_edge; for(int i=0;i&lt;G-&gt;numNodes;i++) &#123; cout&lt;&lt;\"The start is \"&lt;&lt;G-&gt;adjlist[i].data&lt;&lt;endl; cout&lt;&lt;G-&gt;adjlist[i].data; if(G-&gt;adjlist[i].head) cout&lt;&lt;\" adjust end is: \"; for(cur_edge=G-&gt;adjlist[i].head;cur_edge;cur_edge=cur_edge-&gt;next) &#123; cout&lt;&lt;cur_edge-&gt;e_end&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125;&#125; viterbi_probability.cpp1234567891011121314151617181920212223242526272829303132333435#include \"viterbi_probability.h\"int main()&#123; GraphAdj G; CreateGraph(&amp;G); print_graph(&amp;G); int start,end; cout&lt;&lt;\"Input the start of the edge : \"&lt;&lt;endl; cin&gt;&gt;start; cout&lt;&lt;\"Input the end of the edge : \"&lt;&lt;endl; cin&gt;&gt;end; double result=DFSTraverse(&amp;G,start,end); cout&lt;&lt;endl; cout&lt;&lt;path_exist&lt;&lt;endl; cout&lt;&lt;result&lt;&lt;endl; cout&lt;&lt;\"The max path is : \"&lt;&lt;endl; cout&lt;&lt;start&lt;&lt;\" \"; if(path_exist==1) &#123; int pathID=G.adjlist[start].direction; while(pathID!=end) &#123; cout&lt;&lt;pathID&lt;&lt;\" \"; pathID=G.adjlist[pathID].direction; &#125; cout&lt;&lt;end; &#125; return 0;&#125; 算法运行结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"有向无环图的最长简单路径","slug":"20170405","date":"2017-04-05T05:05:00.000Z","updated":"2018-03-02T18:07:28.000Z","comments":true,"path":"2017/04/05/20170405/","link":"","permalink":"http://www.fogsail.net/2017/04/05/20170405/","excerpt":"给定一个有向无环图$G=(V,E)$，边权重为实数，给定图中的两个顶点$k,t$，设计动态规划算法，求从k到t的最长简单路径，子问题图是怎样的？算法的效率如何？","text":"给定一个有向无环图$G=(V,E)$，边权重为实数，给定图中的两个顶点$k,t$，设计动态规划算法，求从k到t的最长简单路径，子问题图是怎样的？算法的效率如何？ 算法分析：该问题不能够用贪心求解，假设从k出发，每一步取得weight最大的边，按这样的路径，并不能够保证能走到终点t。所以考虑动态规划算法。该问题满足动态规划算法的两个特征：一、最优子结构：从k出发到t的最优路径，一定是$max(best \\, path \\, A_1 \\, to \\,\\, t+weight[A_0][A_1])$，其中$A0—&gt;A1—&gt;\\cdots t$和$B0—&gt;B1—&gt;\\cdots t$等等的诸多方案中的最优方案，构成了最优解。符合“剪贴”性质。 二、重叠子结构 有上面的公式可知，子问题：$A0—&gt;A1—&gt;\\cdots t$会被反复求解。 状态转移函数： 1234567int q=weight[k][t];for(int i=k+1;i&lt;=t &amp;&amp; weight[k][i];i++)&#123; q=max(q,weight[k][i]+Find_longest_path(weight,numVertexes,i,t,r));&#125;r[k]=q;return q; 算法实现Graphic_longest_path.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;#define INITWEIGHT 0//用矩阵实现图class graph&#123; private: bool isWeighted; //是否带权？ bool isDirected; //是否有向？ int numV; //顶点数 int numE; //边数 int **matrix; //邻接矩阵 public: graph(int numV,bool isWeighted=false,bool isDirected=false); void createGraph(); ~graph(); int getVerNums() &#123; return numV; &#125; int getEdgeNums() &#123; return numE; &#125; int **getWeight() &#123; return matrix; &#125; void setEdgeWeight(int beg,int end,int weight); void printAdjacentMatrix(); //检查输入 bool check(int i,int j,int w=1);&#125;;//类的实现graph::graph(int numV,bool isWeighted,bool isDirected)&#123; while(numV&lt;=0) &#123; cout&lt;&lt;\"Vertex is wrong! Please enter again! \"&lt;&lt;endl; cin&gt;&gt;numV; &#125; this-&gt;numV=numV; this-&gt;isWeighted=isWeighted; this-&gt;isDirected=isDirected; //private之后的成员可以被类的成员函数访问，但是不能够被使用该类的代码访问 matrix=new int *[numV]; for(int i=0;i&lt;numV;i++) matrix[i]=new int [numV]; //对图进行初始化 if(!isWeighted) //无权图 &#123; //对所有的权值初始化为0 for(int i=0;i&lt;numV;i++) for(int j=0;j&lt;numV;j++) matrix[i][j]=0; &#125; else //有权图 &#123; for(int i=0;i&lt;numV;i++) for(int j=0;j&lt;numV;j++) matrix[i][j]=INITWEIGHT; &#125;&#125;//建图void graph::createGraph()&#123; cout&lt;&lt;\"input edges: \"&lt;&lt;endl; while(cin&gt;&gt;numE &amp;&amp; numE&lt;0) cout&lt;&lt;\"wrong input! \"&lt;&lt;endl; int i,j,w; if(!isWeighted) //无权图 &#123; if(!isDirected) //无向图 &#123; cout&lt;&lt;\"Input begin and end \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j; while(!check(i,j)) &#123; cout&lt;&lt;\"wrong edges, input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j; &#125; matrix[i][j]=matrix[j][i]=1; &#125; &#125; else &#123; cout&lt;&lt;\"enter begin and end \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j; while(!check(i,j)) &#123; cout&lt;&lt;\"wrong edges, input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j; &#125; matrix[i][j]=1; &#125; &#125; &#125; else //有权图 &#123; if(!isDirected) //无向图 &#123; cout&lt;&lt;\"enter begin, end, and weight: \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; while(!check(i,j,w)) &#123; cout&lt;&lt;\"wrong edges,input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; &#125; matrix[i][j]=matrix[j][i]=w; &#125; &#125; else &#123; cout&lt;&lt;\"begin, end, and weight: \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; while(!check(i,j,w)) &#123; cout&lt;&lt;\"wrong edges, input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; &#125; matrix[i][j]=w; &#125; &#125; &#125;&#125;graph::~graph() //析构函数&#123; for(int i=0;i&lt;numV;i++) delete[] matrix[i]; delete[] matrix;&#125;//设置指定边权值：void graph::setEdgeWeight(int beg,int end,int weight)&#123; if(isWeighted) &#123; while(!check(beg,end,weight)) &#123; cout&lt;&lt;\"wrong input, input again:\"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end&gt;&gt;weight; &#125; if(isDirected) matrix[beg][end]=weight; else matrix[beg][end]=matrix[end][beg]=weight; &#125; else &#123; while(!check(beg,end,1)) &#123; cout&lt;&lt;\"wrong input, input again: \"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end; &#125; if(isDirected) //对邻接矩阵的值进行反转，重置，1变成0，0变成1 matrix[beg][end]=1-matrix[beg][end]; else matrix[beg][end]=matrix[end][beg]=1-matrix[beg][end]; &#125;&#125;//输入检查bool graph::check(int i,int j,int w)&#123; if(i&gt;=0 &amp;&amp; i&lt;numV &amp;&amp; j&gt;=0 &amp;&amp; j&lt;numV &amp;&amp; w&gt;0) return true; else return false;&#125;void graph::printAdjacentMatrix()&#123; cout.setf(ios::left); cout&lt;&lt;setw(4)&lt;&lt;\" \"; for(int i=0;i&lt;numV;i++) cout&lt;&lt;setw(4)&lt;&lt;i; cout&lt;&lt;endl; for(int i=0;i&lt;numV;i++) &#123; cout&lt;&lt;setw(4)&lt;&lt;i; for(int j=0;j&lt;numV;j++) cout&lt;&lt;setw(4)&lt;&lt;matrix[i][j]; cout&lt;&lt;endl; &#125;&#125; dynamic_longest_path.h123456789101112131415161718192021222324252627282930313233343536373839404142434445#include \"Graphic_longest_path.h\"#include &lt;iostream&gt;#include &lt;vector&gt;#define INFINITY 0x7fffffffint max(int a,int b)&#123; return a&gt;b?a:b;&#125;int Find_longest_path(int **weight,int numVertexes,int k,int t,vector&lt;int&gt; &amp;r) //寻找k到t的最短路径&#123; if(r[k]&gt;=0) return r[k]; if(k==t) &#123; int q=0; r[k]=q; return q; &#125; else &#123; int q=weight[k][t]; for(int i=k+1;i&lt;=t &amp;&amp; weight[k][i];i++) &#123; q=max(q,weight[k][i]+Find_longest_path(weight,numVertexes,i,t,r)); &#125; r[k]=q; return q; &#125;&#125;int dynamic_longest_path(int **weight,int numVertexes,int k,int t)&#123; vector&lt;int&gt; r; r.resize(numVertexes); for(int i=0;i&lt;numVertexes;i++) r[i]=-INFINITY; return Find_longest_path(weight,numVertexes,k,t,r);&#125; Graphic_longest_path.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include \"dynamic_longest_path.h\"#include &lt;iostream&gt;int main()&#123; cout&lt;&lt;\"AdjacentMatrix Graphic: \"&lt;&lt;endl; bool isDirected, isWeighted; int numV; cout&lt;&lt;\"Create Graphics: \"&lt;&lt;endl; cout&lt;&lt;\"input Vertexes: \"; cin&gt;&gt;numV; cout&lt;&lt;\"Is weighted? 0(no), 1(yes) : \"; cin&gt;&gt;isWeighted; cout&lt;&lt;\"IS directed? 0(no), 1(yes) : \"; cin&gt;&gt;isDirected; graph graph(numV,isWeighted,isDirected); cout&lt;&lt;\"This is a \"; isDirected ? cout&lt;&lt;\"Directed \" : cout&lt;&lt;\"Undirected: \"; isWeighted ? cout&lt;&lt;\"Weighted \" &lt;&lt;endl : cout&lt;&lt;\"Unweighted \"&lt;&lt;endl; graph.createGraph(); cout&lt;&lt;\"print AdjacentMatrix: \"&lt;&lt;endl; graph.printAdjacentMatrix(); cout&lt;&lt;endl; int k,t; cout&lt;&lt;\"input k, t :\"&lt;&lt;endl; cin&gt;&gt;k&gt;&gt;t; int numVertex=graph.getVerNums(); int **weight_dynamic=graph.getWeight(); cout&lt;&lt;\"test: \"; cout&lt;&lt;weight_dynamic[k][t]&lt;&lt;endl; int result=dynamic_longest_path(weight_dynamic,numVertex,k,t); cout&lt;&lt;\"The result is :\"&lt;&lt;endl; cout&lt;&lt;result&lt;&lt;endl; int beg, end, weight; bool flag; cout&lt;&lt;\"Adjust the weight, no(0), yes(1): \"&lt;&lt;endl; cin&gt;&gt;flag; if(flag) &#123; if(isWeighted) &#123; cout&lt;&lt;\"Enter edges--begin, end, and weight: \"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end&gt;&gt;weight; graph.setEdgeWeight(beg,end,weight); &#125; else &#123; cout&lt;&lt;\"Enter edges--begin, end: \"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end; graph.setEdgeWeight(beg,end,1); &#125; cout&lt;&lt;\"Successed!\"&lt;&lt;endl; cout&lt;&lt;\"Print AdjacentMatrix: \"&lt;&lt;endl; graph.printAdjacentMatrix(); &#125; return 0;&#125; 重构解为了能够输出最短路径的方案，可以对解进行重构： Graphic_longest_path.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;#define INITWEIGHT 0//用矩阵实现图class graph&#123; private: bool isWeighted; //是否带权？ bool isDirected; //是否有向？ int numV; //顶点数 int numE; //边数 int **matrix; //邻接矩阵 public: graph(int numV,bool isWeighted=false,bool isDirected=false); void createGraph(); ~graph(); int getVerNums() &#123; return numV; &#125; int getEdgeNums() &#123; return numE; &#125; int **getWeight() &#123; return matrix; &#125; void setEdgeWeight(int beg,int end,int weight); void printAdjacentMatrix(); //检查输入 bool check(int i,int j,int w=1);&#125;;//类的实现graph::graph(int numV,bool isWeighted,bool isDirected)&#123; while(numV&lt;=0) &#123; cout&lt;&lt;\"Vertex is wrong! Please enter again! \"&lt;&lt;endl; cin&gt;&gt;numV; &#125; this-&gt;numV=numV; this-&gt;isWeighted=isWeighted; this-&gt;isDirected=isDirected; //private之后的成员可以被类的成员函数访问，但是不能够被使用该类的代码访问 matrix=new int *[numV]; for(int i=0;i&lt;numV;i++) matrix[i]=new int [numV]; //对图进行初始化 if(!isWeighted) //无权图 &#123; //对所有的权值初始化为0 for(int i=0;i&lt;numV;i++) for(int j=0;j&lt;numV;j++) matrix[i][j]=0; &#125; else //有权图 &#123; for(int i=0;i&lt;numV;i++) for(int j=0;j&lt;numV;j++) matrix[i][j]=INITWEIGHT; &#125;&#125;//建图void graph::createGraph()&#123; cout&lt;&lt;\"input edges: \"&lt;&lt;endl; while(cin&gt;&gt;numE &amp;&amp; numE&lt;0) cout&lt;&lt;\"wrong input! \"&lt;&lt;endl; int i,j,w; if(!isWeighted) //无权图 &#123; if(!isDirected) //无向图 &#123; cout&lt;&lt;\"Input begin and end \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j; while(!check(i,j)) &#123; cout&lt;&lt;\"wrong edges, input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j; &#125; matrix[i][j]=matrix[j][i]=1; &#125; &#125; else &#123; cout&lt;&lt;\"enter begin and end \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j; while(!check(i,j)) &#123; cout&lt;&lt;\"wrong edges, input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j; &#125; matrix[i][j]=1; &#125; &#125; &#125; else //有权图 &#123; if(!isDirected) //无向图 &#123; cout&lt;&lt;\"enter begin, end, and weight: \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; while(!check(i,j,w)) &#123; cout&lt;&lt;\"wrong edges,input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; &#125; matrix[i][j]=matrix[j][i]=w; &#125; &#125; else &#123; cout&lt;&lt;\"begin, end, and weight: \"&lt;&lt;endl; for(int k=0;k&lt;numE;k++) &#123; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; while(!check(i,j,w)) &#123; cout&lt;&lt;\"wrong edges, input again: \"&lt;&lt;endl; cin&gt;&gt;i&gt;&gt;j&gt;&gt;w; &#125; matrix[i][j]=w; &#125; &#125; &#125;&#125;graph::~graph() //析构函数&#123; for(int i=0;i&lt;numV;i++) delete[] matrix[i]; delete[] matrix;&#125;//设置指定边权值：void graph::setEdgeWeight(int beg,int end,int weight)&#123; if(isWeighted) &#123; while(!check(beg,end,weight)) &#123; cout&lt;&lt;\"wrong input, input again:\"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end&gt;&gt;weight; &#125; if(isDirected) matrix[beg][end]=weight; else matrix[beg][end]=matrix[end][beg]=weight; &#125; else &#123; while(!check(beg,end,1)) &#123; cout&lt;&lt;\"wrong input, input again: \"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end; &#125; if(isDirected) //对邻接矩阵的值进行反转，重置，1变成0，0变成1 matrix[beg][end]=1-matrix[beg][end]; else matrix[beg][end]=matrix[end][beg]=1-matrix[beg][end]; &#125;&#125;//输入检查bool graph::check(int i,int j,int w)&#123; if(i&gt;=0 &amp;&amp; i&lt;numV &amp;&amp; j&gt;=0 &amp;&amp; j&lt;numV &amp;&amp; w&gt;0) return true; else return false;&#125;void graph::printAdjacentMatrix()&#123; cout.setf(ios::left); cout&lt;&lt;setw(4)&lt;&lt;\" \"; for(int i=0;i&lt;numV;i++) cout&lt;&lt;setw(4)&lt;&lt;i; cout&lt;&lt;endl; for(int i=0;i&lt;numV;i++) &#123; cout&lt;&lt;setw(4)&lt;&lt;i; for(int j=0;j&lt;numV;j++) cout&lt;&lt;setw(4)&lt;&lt;matrix[i][j]; cout&lt;&lt;endl; &#125;&#125; longest_path_constitute.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include \"Graphic_longest_path.h\"#include &lt;iostream&gt;#include &lt;vector&gt;#define INFINITY 0x7fffffffint max(int a,int b)&#123; return a&gt;b?a:b;&#125;int Find_longest_path(int **weight,int numVertexes,int k,int t,vector&lt;int&gt; &amp;r,int *solution) //寻找k到t的最短路径&#123; if(r[k]&gt;=0) return r[k]; if(k==t) &#123; int q=0; r[k]=q; solution[k]=t; return q; &#125; else &#123; int q=weight[k][t]; if(weight[k][t]) solution[k]=t; for(int i=k+1;i&lt;=t &amp;&amp; weight[k][i];i++) &#123; int tmp=max(q,weight[k][i]+Find_longest_path(weight,numVertexes,i,t,r,solution)); if(tmp&gt;q) &#123; q=tmp; solution[k]=i; &#125; &#125; r[k]=q; return q; &#125;&#125;int dynamic_longest_path(int **weight,int numVertexes,int k,int t,int *solution)&#123; vector&lt;int&gt; r; r.resize(numVertexes); for(int i=0;i&lt;numVertexes;i++) &#123; r[i]=-INFINITY; &#125; //完成初始化 return Find_longest_path(weight,numVertexes,k,t,r,solution);&#125;void print_solution(int *solution,int k,int t)&#123; if(solution[k]==-1) cout&lt;&lt;\"The path is not exist! \"&lt;&lt;endl; else &#123; cout&lt;&lt;\"The result is : \"&lt;&lt;endl; cout&lt;&lt;\" \"&lt;&lt;k&lt;&lt;\" --&gt; \"; while(k!=t) &#123; cout&lt;&lt;solution[k]; if(solution[k]!=t) &#123; cout&lt;&lt;\" --&gt; \"; &#125; k=solution[k]; &#125; cout&lt;&lt;endl; &#125;&#125; Graphic_longest_path.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include \"longest_path_constitute.h\"#include &lt;iostream&gt;int main()&#123; cout&lt;&lt;\"AdjacentMatrix Graphic: \"&lt;&lt;endl; bool isDirected, isWeighted; int numV; cout&lt;&lt;\"Create Graphics: \"&lt;&lt;endl; cout&lt;&lt;\"input Vertexes: \"; cin&gt;&gt;numV; cout&lt;&lt;\"Is weighted? 0(no), 1(yes) : \"; cin&gt;&gt;isWeighted; cout&lt;&lt;\"IS directed? 0(no), 1(yes) : \"; cin&gt;&gt;isDirected; graph graph(numV,isWeighted,isDirected); cout&lt;&lt;\"This is a \"; isDirected ? cout&lt;&lt;\"Directed \" : cout&lt;&lt;\"Undirected: \"; isWeighted ? cout&lt;&lt;\"Weighted \" &lt;&lt;endl : cout&lt;&lt;\"Unweighted \"&lt;&lt;endl; graph.createGraph(); cout&lt;&lt;\"print AdjacentMatrix: \"&lt;&lt;endl; graph.printAdjacentMatrix(); cout&lt;&lt;endl; int k,t; cout&lt;&lt;\"input k, t :\"&lt;&lt;endl; cin&gt;&gt;k&gt;&gt;t; int numVertex=graph.getVerNums(); int **weight_dynamic=graph.getWeight(); cout&lt;&lt;\"test: \"; cout&lt;&lt;weight_dynamic[k][t]&lt;&lt;endl; //初始化solution： int *solution=new int[numVertex+1]; for(int i=0;i&lt;numVertex;i++) solution[i]=-1; //返回最优解： int result=dynamic_longest_path(weight_dynamic,numVertex,k,t,solution); cout&lt;&lt;\"The result is :\"&lt;&lt;endl; cout&lt;&lt;result&lt;&lt;endl; //返回solution的解，注意delete[] cout&lt;&lt;\"The solution is \"&lt;&lt;endl; print_solution(solution,k,t); int beg, end, weight; bool flag; cout&lt;&lt;\"Adjust the weight, no(0), yes(1): \"&lt;&lt;endl; cin&gt;&gt;flag; if(flag) &#123; if(isWeighted) &#123; cout&lt;&lt;\"Enter edges--begin, end, and weight: \"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end&gt;&gt;weight; graph.setEdgeWeight(beg,end,weight); &#125; else &#123; cout&lt;&lt;\"Enter edges--begin, end: \"&lt;&lt;endl; cin&gt;&gt;beg&gt;&gt;end; graph.setEdgeWeight(beg,end,1); &#125; cout&lt;&lt;\"Successed!\"&lt;&lt;endl; cout&lt;&lt;\"Print AdjacentMatrix: \"&lt;&lt;endl; graph.printAdjacentMatrix(); &#125; return 0;&#125; 输出结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"公司聚会计划","slug":"20170312","date":"2017-03-12T10:00:00.000Z","updated":"2018-03-02T20:53:28.000Z","comments":true,"path":"2017/03/12/20170312/","link":"","permalink":"http://www.fogsail.net/2017/03/12/20170312/","excerpt":"公司内部结构关系是层次化的，即员工按主管—下属关系构成一棵树，根节点为公司主席。人事部按“宴会交际能力”给每个员工打分，分值为实数。Stewart教授是一家公司总裁的顾问，这家公司正在计划一个公司的聚会。这个公司有一个层次式的结构；也就是，管理关系形成一颗以总裁为根的树。人事部门按每个员工喜欢聚会的程度来排名，排名是一个实数。为了使每个参加聚会者都喜欢这个聚会，总裁不希望一个雇员和她的直接上司同时参加。 Stewart教授面对一颗描述公司结构的树，使用了左孩子右兄弟描述法。树中每个节点除了包含指针，还包含雇员的名字以及雇员喜欢聚会的排名。描述一个算法，它生成一张客人列表，使得客人喜欢聚会的程度的总和最大。分析你的算法的执行时间。 最大喜欢程度和？","text":"公司内部结构关系是层次化的，即员工按主管—下属关系构成一棵树，根节点为公司主席。人事部按“宴会交际能力”给每个员工打分，分值为实数。Stewart教授是一家公司总裁的顾问，这家公司正在计划一个公司的聚会。这个公司有一个层次式的结构；也就是，管理关系形成一颗以总裁为根的树。人事部门按每个员工喜欢聚会的程度来排名，排名是一个实数。为了使每个参加聚会者都喜欢这个聚会，总裁不希望一个雇员和她的直接上司同时参加。 Stewart教授面对一颗描述公司结构的树，使用了左孩子右兄弟描述法。树中每个节点除了包含指针，还包含雇员的名字以及雇员喜欢聚会的排名。描述一个算法，它生成一张客人列表，使得客人喜欢聚会的程度的总和最大。分析你的算法的执行时间。 最大喜欢程度和？ 动态规划原理：1、重叠子问题：该问题会对某个领导的下属反复求解。 2、最优子结构公司聚会有最佳方案，构成最优子结构 状态转移函数： $people(0)=\\sum max(confirm(i,0),confirm(i,1))$$people(1)=likevalue+\\sum confirm(i,0)$$result=max(confirm(root,0),confirm(root,1))$ 邻接矩阵求解company_party_array.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#define MAXNUM 20//使用有向图的邻接矩阵来表示bool party_graph[MAXNUM][MAXNUM];int solution[MAXNUM][2]; //用来存储解决方案，solution[i][0]表示不被选中 //solution[i][1]表示被选中int likevalue[MAXNUM]; //表示对party的热衷程度int how_many_member;int id;int how_many_branch,branch_id;int max(int a,int b)&#123; return a&gt;b?a:b;&#125;int confirm(int id,int status) //递归求解方案&#123; int result; if(solution[id][status]!=-1) return solution[id][status]; if(status==0) &#123; result=0; //表示这个id不参加聚会 for(int i=0;i&lt;how_many_member;i++) //遍历这个id的边，即邻接链表 &#123; if(party_graph[id][i]) result+=max(confirm(i,0),confirm(i,1)); &#125; solution[id][status]=result; return result; &#125; else &#123; result=likevalue[id]; for(int i=0;i&lt;how_many_member;i++) &#123; if(party_graph[id][i]) result+=confirm(i,0); &#125; solution[id][status]=result; return result; &#125;&#125; company_party_array.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344#include \"company_party_array.h\"#include &lt;string.h&gt;using namespace std;int main()&#123; //Initialize:对数组的值进行初始化 for(int i=0;i&lt;MAXNUM;i++) &#123; for(int j=0;j&lt;2;j++) solution[i][j]=-1; &#125; cout&lt;&lt;\"Input the number of members who join the party: \"&lt;&lt;endl; cin&gt;&gt;how_many_member; cout&lt;&lt;\"Input the like value of members: \"&lt;&lt;endl; for(int i=0;i&lt;how_many_member;i++) cin&gt;&gt;likevalue[i]; for(int i=0;i&lt;how_many_member;i++) &#123; cout&lt;&lt;\"Input member id and how many branch it has: \"&lt;&lt;endl; cin&gt;&gt;id&gt;&gt;how_many_branch; //输入每个人的编号和下属的个数 cout&lt;&lt;\"branch id: \"&lt;&lt;endl; for(int j=0;j&lt;how_many_branch;j++) &#123; cin&gt;&gt;branch_id; //输入下属员工的id party_graph[id][branch_id]=true; &#125; &#125; //初始化完成 int root=0; int result=confirm(root,0); memset(solution,-1,sizeof(solution)); //注意使用这种方法，对数组中的值进行赋值 result=max(result,confirm(root,1)); cout&lt;&lt;result&lt;&lt;endl; return 0;&#125; 左孩子右兄弟树求解用辅助队列完成特别说明：用辅助队列，使用标准库比较安全 1queue&lt;CSTree&gt; helpqueue; 用g++编译的时候，在最新的版本中，用malloc分配内存会出现错误 1CSTree child_node=temp-&gt;firstChild=new CSNode; 使用new来分配内存 CSTree.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#define Wrong 'W'using namespace std;typedef struct CSNode&#123; int data; int status; struct CSNode *firstChild; struct CSNode *nextsibling; struct CSNode *parent;&#125;CSNode,*CSTree;int InitTree(CSTree &amp;T)&#123; T=NULL; return true;&#125;int CreateTree(CSTree &amp;T)&#123; queue&lt;CSTree&gt; helpqueue; int buffchild[10]=&#123;0&#125;; int child_num; cout&lt;&lt;\"Input root of the tree: if empty, enter -1: \"&lt;&lt;endl; cin&gt;&gt;buffchild[0]; if(buffchild[0]!=-1) &#123; T=new CSNode; T-&gt;status=-1; T-&gt;data=buffchild[0]; T-&gt;nextsibling=NULL; helpqueue.push(T); //根结点入队，只存储根节点 while(!helpqueue.empty()) &#123; CSTree temp=helpqueue.front(); helpqueue.pop(); cout&lt;&lt;\"Input the child number of \"&lt;&lt;temp-&gt;data&lt;&lt;\" if child number is 0, please enter '0'\"&lt;&lt;endl; cin&gt;&gt;child_num; cout&lt;&lt;\"Input the child data of \"&lt;&lt;temp-&gt;data&lt;&lt;\" ,if it has no child , enter -1\"&lt;&lt;endl; for(int i=0;i&lt;child_num;i++) cin&gt;&gt;buffchild[i]; if(child_num!=0) &#123; CSTree child_node=temp-&gt;firstChild=new CSNode; child_node-&gt;status=-1; child_node-&gt;data=buffchild[0]; helpqueue.push(child_node); //第一个孩子入队列 for(int i=1;i&lt;child_num;i++) &#123; child_node-&gt;nextsibling=new CSNode; child_node-&gt;nextsibling-&gt;data=buffchild[i]; helpqueue.push(child_node-&gt;nextsibling); child_node=child_node-&gt;nextsibling; //指向刚刚入队的孩子 &#125; child_node-&gt;nextsibling=NULL; &#125; else temp-&gt;firstChild=NULL; &#125; &#125; else T=NULL; return true;&#125;void DestroyTree(CSTree &amp;T)&#123; if(T) &#123; if(T-&gt;firstChild) DestroyTree(T-&gt;firstChild); if(T-&gt;nextsibling) DestroyTree(T-&gt;nextsibling); free(T); T=NULL; &#125;&#125;void ClearTree(CSTree &amp;T)&#123; DestroyTree(T);&#125;bool TreeEmpty(CSTree &amp;T)&#123; if(T) return true; else return false;&#125;int TreeDepth(CSTree &amp;T)&#123; if(!T) return 0; if(!T-&gt;firstChild) return 1; CSTree child_ptr; int depth, max=0; for(child_ptr=T-&gt;firstChild;child_ptr;child_ptr=child_ptr-&gt;nextsibling) &#123; depth=TreeDepth(child_ptr); if(depth&gt;max) max=depth; &#125; return max+1;&#125;int Root(CSTree &amp;T,int cur_node)&#123; if(T) return T-&gt;data; return 0;&#125;CSNode *FindNode(CSTree &amp;T,int cur_node)&#123; queue&lt;CSTree&gt; Q; if(T) &#123; Q.push(T); while(!Q.empty()) &#123; CSTree tmp_node=Q.front(); Q.pop(); if(tmp_node-&gt;data==cur_node) return tmp_node; if(tmp_node-&gt;firstChild) Q.push(tmp_node-&gt;firstChild); if(tmp_node-&gt;nextsibling) Q.push(tmp_node-&gt;nextsibling); &#125; &#125; return NULL;&#125;bool Assign(CSTree &amp;T,int cur_node,int value) //进行赋值操作&#123; if(!T) return false; CSNode *find_cur_node=FindNode(T,cur_node); if(!find_cur_node) return false; find_cur_node-&gt;data=value; return true;&#125;CSNode *parent(CSTree &amp;T,int cur_value)&#123; queue&lt;CSTree&gt; Q; if(T) &#123; if(T-&gt;data==cur_value) return NULL; Q.push(T); while(!Q.empty()) &#123; CSTree cur_node=Q.front(); Q.pop(); CSTree parent_ptr=cur_node; if(cur_node-&gt;firstChild) &#123; if(cur_node-&gt;firstChild-&gt;data==cur_value) return parent_ptr; Q.push(cur_node-&gt;firstChild); CSTree brotherptr=cur_node-&gt;firstChild-&gt;nextsibling; while(brotherptr) &#123; if(brotherptr-&gt;data==cur_value) return parent_ptr; Q.push(brotherptr); brotherptr=brotherptr-&gt;nextsibling; &#125; &#125; &#125; &#125; return NULL;&#125;int leftchild(CSTree &amp;T,int cur_node)&#123; CSNode *node=FindNode(T,cur_node); if(node) &#123; if(node-&gt;firstChild) return node-&gt;firstChild-&gt;data; &#125; return Wrong;&#125;int rightsibling(CSTree &amp;T,int cur_node)&#123; CSNode *node=FindNode(T,cur_node); if(node) &#123; if(node-&gt;nextsibling) return node-&gt;nextsibling-&gt;data; &#125; return Wrong;&#125;bool LevelOrderTraverse(CSTree T)&#123; queue&lt;CSTree&gt; Q; if(T) &#123; cout&lt;&lt;T-&gt;data&lt;&lt;\" \"; Q.push(T); while(!Q.empty()) &#123; CSTree cur_node,child_node; cur_node=Q.front(); Q.pop(); child_node=cur_node-&gt;firstChild; while(child_node) &#123; cout&lt;&lt;child_node-&gt;data&lt;&lt;\" \"; Q.push(child_node); child_node=child_node-&gt;nextsibling; &#125; &#125; return true; &#125; return false;&#125;void recurse_Traverse(CSTree T)&#123; if(T) &#123; T-&gt;status=-1; cout&lt;&lt;T-&gt;data&lt;&lt;\" \"&lt;&lt;T-&gt;status&lt;&lt;\" \"; recurse_Traverse(T-&gt;firstChild); recurse_Traverse(T-&gt;nextsibling); &#125;&#125;void refresh_tree(CSTree &amp;T)&#123; if(T) &#123; T-&gt;status=-1; refresh_tree(T-&gt;firstChild); refresh_tree(T-&gt;nextsibling); &#125;&#125;void recurse_createtree(CSTree T)&#123; int child_number; cout&lt;&lt;\"Input the child number of \"&lt;&lt;T-&gt;data&lt;&lt;\" if it has no child, input 0 \"&lt;&lt;endl; cin&gt;&gt;child_number; if(child_number==0) &#123; T-&gt;firstChild=NULL; &#125; else &#123; CSTree child,ptr; int child_data; child=new CSNode; child-&gt;status=-1; cout&lt;&lt;\"Input the data of the child node : \"&lt;&lt;endl; cin&gt;&gt;child_data; child-&gt;data=child_data; T-&gt;firstChild=child; ptr=child; for(int i=1;i&lt;child_number;i++) &#123; CSTree brother=new CSNode; brother-&gt;status=-1; int brother_data; cout&lt;&lt;\"Input the data of the child node: \"&lt;&lt;endl; cin&gt;&gt;brother_data; brother-&gt;data=brother_data; ptr-&gt;nextsibling=brother; ptr=ptr-&gt;nextsibling; &#125; ptr-&gt;nextsibling=NULL; for(CSTree p=T-&gt;firstChild;p;p=p-&gt;nextsibling) recurse_createtree(p); &#125;&#125;void depth_traverse(CSTree &amp;T)&#123; if(T) &#123; T-&gt;status=-1; cout&lt;&lt;T-&gt;data&lt;&lt;\" \"&lt;&lt;T-&gt;status&lt;&lt;\" \"; for(CSTree p=T-&gt;firstChild;p;p=p-&gt;nextsibling) depth_traverse(p); &#125;&#125; company_party.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include \"CSTree.h\"int max(int a,int b)&#123; return a&gt;b?a:b;&#125;int confirm(CSTree &amp;T,int flag)&#123; int result; if(T-&gt;status!=-1) return T-&gt;status; if(flag==1) &#123; result=T-&gt;data; for(CSTree p=T-&gt;firstChild;p!=NULL;p=p-&gt;nextsibling) &#123; result+=confirm(p,0); &#125; T-&gt;status=result; return result; &#125; else &#123; result=0; int maxnum; for(CSTree p=T-&gt;firstChild;p;p=p-&gt;nextsibling) &#123; maxnum=confirm(p,0); refresh_tree(p); //注意在求max的时候，洗刷status的值 maxnum=max(maxnum,confirm(p,1)); result+=maxnum; &#125; T-&gt;status=result; return result; &#125;&#125;int main()&#123; CSTree T; CreateTree(T); cout&lt;&lt;\"Level order Traverse: \"&lt;&lt;endl; LevelOrderTraverse(T); cout&lt;&lt;endl; recurse_Traverse(T); cout&lt;&lt;endl; int result=confirm(T,1); cout&lt;&lt;result&lt;&lt;endl; refresh_tree(T); cout&lt;&lt;endl; result=max(result,confirm(T,0)); cout&lt;&lt;result; cout&lt;&lt;endl; cout&lt;&lt;\"recurse mathod:\"&lt;&lt;endl; CSTree Recur_T; int root_data; Recur_T=new CSNode; Recur_T-&gt;status=-1; cout&lt;&lt;\"Input the data of root : \"&lt;&lt;endl; cin&gt;&gt;root_data; Recur_T-&gt;data=root_data; recurse_createtree(Recur_T); cout&lt;&lt;\"Level order Traverse: \"&lt;&lt;endl; LevelOrderTraverse(Recur_T); cout&lt;&lt;endl; depth_traverse(Recur_T); cout&lt;&lt;endl;&#125; 递归建立左孩子右兄弟树的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546void recurse_createtree(CSTree T)&#123; int child_number; cout&lt;&lt;\"Input the child number of \"&lt;&lt;T-&gt;data&lt;&lt;\" if it has no child, input 0 \"&lt;&lt;endl; cin&gt;&gt;child_number; if(child_number==0) &#123; T-&gt;firstChild=NULL; &#125; else &#123; CSTree child,ptr; int child_data; child=new CSNode; child-&gt;status=-1; cout&lt;&lt;\"Input the data of the child node : \"&lt;&lt;endl; cin&gt;&gt;child_data; child-&gt;data=child_data; T-&gt;firstChild=child; ptr=child; for(int i=1;i&lt;child_number;i++) &#123; CSTree brother=new CSNode; brother-&gt;status=-1; int brother_data; cout&lt;&lt;\"Input the data of the child node: \"&lt;&lt;endl; cin&gt;&gt;brother_data; brother-&gt;data=brother_data; ptr-&gt;nextsibling=brother; ptr=ptr-&gt;nextsibling; &#125; ptr-&gt;nextsibling=NULL; for(CSTree p=T-&gt;firstChild;p;p=p-&gt;nextsibling) recurse_createtree(p); &#125;&#125; 实现结果非递归建树（使用辅助队列）： 递归建树的过程：仅用于测试： 特别注意：在用树实现递归的时候，算完一次confirm()之后，要使用refresh_tree把树刷新一遍，去掉第一次计算的痕迹","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"整齐打印与编辑距离问题","slug":"20170307","date":"2017-03-06T06:00:00.000Z","updated":"2018-03-02T17:45:52.000Z","comments":true,"path":"2017/03/06/20170307/","link":"","permalink":"http://www.fogsail.net/2017/03/06/20170307/","excerpt":"整齐打印使用等宽字符打印一段文本。输入文本为n个单词的序列，单词长度为$l_1,l_2, \\cdots l_n$个字符，将其打印在若干行上，每一行最多$Maxnum$个字符。如果某行包含第$i$到第$j(i \\leq j)$个单词，行尾额外空格符的数量是$M-j+i-\\sum_{k=i}^jl_k$，这个值必须是非负的。","text":"整齐打印使用等宽字符打印一段文本。输入文本为n个单词的序列，单词长度为$l_1,l_2, \\cdots l_n$个字符，将其打印在若干行上，每一行最多$Maxnum$个字符。如果某行包含第$i$到第$j(i \\leq j)$个单词，行尾额外空格符的数量是$M-j+i-\\sum_{k=i}^jl_k$，这个值必须是非负的。 算法分析： 实现过程： .h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;string.h&gt;#define infinity 0x7fffffffusing namespace std;int get_lines(int solution[],int j,string number[]);void (int length[],string number[],int n,int Maxnum)&#123; int i,j; //保存空格数 int **space; space=new int *[n+1]; for(int i=0;i&lt;=n;i++) &#123; space[i]=new int [n+1]; &#125; //保存立方值 int **cube; cube=new int *[n+1]; for(int i=0;i&lt;=n;i++) &#123; cube[i]=new int [n+1]; &#125; //用于保存解决方案 int *solution=new int [n+1]; //初始化获取space[][]的值 for(int i=1;i&lt;=n;i++) &#123; space[i][i]=Maxnum-length[i-1]; //这里space[i][]表示第几个数？length[i-1]对应的是下标 for(int j=i+1;j&lt;=n;j++) space[i][j]=space[i][j-1]-length[j-1]-1; &#125; //获取cube的值，整齐打印是依据cube的值来确定打印距离 for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=n;j++) &#123; if(space[i][j]&lt;0) cube[i][j]=infinity; else if(j==n &amp;&amp; space[i][j]&gt;=0) cube[i][j]=0; else cube[i][j]=space[i][j]*space[i][j]*space[i][j]; &#125; &#125; //动态规划过程，将结果存储在res数组中 int *res=new int [n+1]; res[0]=0; for(int j=1;j&lt;=n;j++) &#123; res[j]=infinity; for(int i=1;i&lt;=j;i++) &#123; if(res[i-1]!=infinity &amp;&amp; cube[i][j]!=infinity &amp;&amp; (res[i-1]+cube[i][j]&lt;res[j])) &#123; res[j]=res[i-1]+cube[i][j]; solution[j]=i; //i为当前行的第一个元素 &#125; &#125; &#125; get_lines(solution,n,number); //释放内存 delete[] res; delete[] solution; for(int i=0;i&lt;=n;i++) delete[] cube[i]; delete[] cube; for(int i=0;i&lt;=n;i++) delete[] space[i]; delete[] space;&#125;int get_lines(int solution[],int j,string number[]) //j为当前行的最后一个元素下标&#123; int k; int i=solution[j]; if(i==1) //表示第一个元素 k=1; else k=get_lines(solution,i-1,number)+1; //递归 cout&lt;&lt;\"current line number is : \"&lt;&lt;k&lt;&lt;\" \"; for(int l=i;l&lt;=j;l++) cout&lt;&lt;number[l-1]&lt;&lt;\" \"; //当前行的第l个元素，str下标为l-1 cout&lt;&lt;endl; return k;&#125; .cpp12345678910111213141516#include \".h\"int main()&#123; int n=10; //10个单词 int Maxnum=8; //一行可以容纳最多8个字符 string number[n]=&#123;\"abc\",\"def\",\"gh\",\"polq\",\"cs\",\"opaqe\",\"klfgh\",\"t\",\"asd\",\"th\"&#125;; int length[n]=&#123;0&#125;; for(int i=0;i&lt;n;i++) &#123; length[i]=number[i].size(); &#125; (length,number,n,Maxnum); return 0;&#125; 编辑距离算法分析 状态转移函数res[i,j]=min \\begin{cases} res[i-1,j-1]+copy& \\text{x[i]==y[j]}\\\\ res[i-1,j-1]+replace& \\text{x[i]!=y[j]}\\\\ res[i-2,j-2]+twiddle& \\text{i,j>=2 x[i]==y[j-1] && x[i-1]==y[j]}\\\\ res[i-1,j]+delete& \\text{other}\\\\ res[i,j-1]+insert& \\text{other}\\\\ \\mathop{\\min}_{0 \\leq i \\leq m} {res[i,n]}+kill& \\text{i==m && j==n} \\end{cases}分析方法与“最长公共子序列”问题分析的方法类似。 count_distance.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;using namespace std;#define infinity 0x7fffffffenum &#123;COPY,REPLACE,DELETE,INSERT,TWIDDLE,KILL,TYPE_NUM&#125;;struct TABLE&#123; int **cnt,**res; TABLE(int m,int n) //res[m][n] 分别表示图中x_max和y_max &#123; cnt=new int *[m+1]; for(int i=0;i&lt;=m;i++) cnt[i]=new int [n+1]; res=new int *[m+1]; for(int i=0;i&lt;=m;i++) res[i]=new int [n+1]; &#125;&#125;;void PRINT_SOLUTION(TABLE dis,int i,int j);TABLE count_distance(char x[],char y[],int m,int n)&#123; TABLE dis(m,n); int cost[TYPE_NUM]=&#123;-1,1,2,2,-2,1&#125;; //初始化 dis.cnt[0][0]=0; for(int i=0;i&lt;=m;i++) &#123; dis.cnt[i][0]=i*cost[DELETE]; //这里不操作y，等于把x中的元素全部删除 //删除的代价就是 第几个元素×cost dis.res[i][0]=DELETE; &#125; for(int j=0;j&lt;=n;j++) &#123; //这里相当于x中没有元素，y[]的值等于插入每一个新的元素 dis.cnt[0][j]=j*cost[INSERT]; dis.res[0][j]=INSERT; &#125; //计算最优代价 for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; dis.cnt[i][j]=0x7fffffff; if(x[i]==y[j] &amp;&amp; dis.cnt[i-1][j-1]+cost[COPY]&lt;dis.cnt[i][j]) &#123; dis.cnt[i][j]=dis.cnt[i-1][j-1]+cost[COPY]; dis.res[i][j]=COPY; &#125; if(x[i]!=y[j] &amp;&amp; dis.cnt[i-1][j-1]+cost[REPLACE]&lt;dis.cnt[i][j]) &#123; dis.cnt[i][j]=dis.cnt[i-1][j-1]+cost[REPLACE]; dis.res[i][j]=REPLACE; &#125; if(i&gt;=2&amp;&amp;j&gt;=2&amp;&amp; x[i]==y[j-1] &amp;&amp; x[i-1]==y[j] &amp;&amp; dis.cnt[i-2][j-2]+cost[TWIDDLE]&lt;dis.cnt[i][j]) &#123; dis.cnt[i][j]=dis.cnt[i-2][j-2]+cost[TWIDDLE]; dis.res[i][j]=TWIDDLE; &#125; if(dis.cnt[i-1][j]+cost[DELETE]&lt;dis.cnt[i][j]) &#123; dis.cnt[i][j]=dis.cnt[i-1][j]+cost[DELETE]; dis.res[i][j]=DELETE; &#125; if(dis.res[i][j-1]+cost[INSERT]&lt;dis.cnt[i][j]) &#123; dis.cnt[i][j]=dis.cnt[i][j-1]+cost[INSERT]; dis.res[i][j]=INSERT; &#125; &#125; &#125; //此时序列y[n]的值已经完成，这个时候截取从0&lt;=i&lt;=m-1中最小的kill值 //把m以后的值全部截取掉 for(int i=0;i&lt;=m-1;i++) &#123; if(dis.cnt[i][n]+cost[KILL]&lt;dis.cnt[m][n]) //相当于调整res[m][n]的值 //判断从哪里开始截断？ &#123; dis.cnt[m][n]=dis.cnt[i][n]+cost[KILL]; dis.res[m][n]=i; //从i开始截断，distance.solution[][]提供回溯的点，回溯到哪个点？ &#125; &#125; cout&lt;&lt;\"distance[m][n]=\"&lt;&lt;dis.cnt[m][n]&lt;&lt;\" \"&lt;&lt;endl; //输出： for(int i=0;i&lt;=m;i++) &#123; for(int j=0;j&lt;=n;j++) cout&lt;&lt;dis.cnt[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; for(int i=0;i&lt;=m;i++) &#123; for(int j=0;j&lt;=n;j++) PRINT_SOLUTION(dis,i,j); cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; return dis;&#125;void PRINT_sequence(TABLE dis,int i,int j)&#123; int I,J; if(i==0 &amp;&amp; j==0) return; if(dis.res[i][j]==COPY || dis.res[i][j]==REPLACE) &#123; I=i-1; J=j-1; &#125; else if(dis.res[i][j]==TWIDDLE) &#123; I=i-2; J=j-2; &#125; else if(dis.res[i][j]==DELETE) &#123; I=i-1; J=j; &#125; else if(dis.res[i][j]==INSERT) &#123; I=i; J=j-1; &#125; else &#123; I=dis.res[i][j]; J=j; dis.res[i][j]=KILL; &#125; PRINT_sequence(dis,I,J); PRINT_SOLUTION(dis,i,j);&#125;void PRINT_SOLUTION(TABLE dis,int i,int j)&#123; if(dis.res[i][j]==COPY) cout&lt;&lt;\"COPY\"&lt;&lt;\" \"; else if(dis.res[i][j]==REPLACE) cout&lt;&lt;\"REPLACE\"&lt;&lt;\" \"; else if(dis.res[i][j]==INSERT) cout&lt;&lt;\"INSERT\"&lt;&lt;\" \"; else if(dis.res[i][j]==TWIDDLE) cout&lt;&lt;\"TWIDDLE\"&lt;&lt;\" \"; else cout&lt;&lt;\"KILL\"&lt;&lt;\" \";&#125; count_distance.cpp1234567891011#include \"count_distance.h\"#include &lt;string.h&gt;using namespace std;int main()&#123; char x[]=\"algorithm\"; char y[]=\"altruistic\"; int x_len=strlen(x),y_len=strlen(y); TABLE distance=count_distance(x,y,x_len,y_len); PRINT_sequence(distance,x_len,y_len);&#125; 算法实现结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"回文子序列与欧几里德旅行商","slug":"20170305","date":"2017-03-04T23:27:00.000Z","updated":"2018-03-02T17:25:26.000Z","comments":true,"path":"2017/03/05/20170305/","link":"","permalink":"http://www.fogsail.net/2017/03/05/20170305/","excerpt":"回文子序列最长回文子序列是正序与逆序相同的非空字符串。例如，所有长度为1的字符串，civic，racecar，aibobphobia都是回文。设计算法，求给定输入字符串的最长回文子序列。例如，给定输入character，算法应该返回carac。算法的运行时间是怎么样的？","text":"回文子序列最长回文子序列是正序与逆序相同的非空字符串。例如，所有长度为1的字符串，civic，racecar，aibobphobia都是回文。设计算法，求给定输入字符串的最长回文子序列。例如，给定输入character，算法应该返回carac。算法的运行时间是怎么样的？ 算法设计与分析： 注意这里是回文子序列，而不是回文子串。求子串和子序列有一些不同，这里的方法用于求子序列。字串的意义是：aaabbb，需要连续的字符相同。 而子序列，是字母按照一定的排列顺序，保持回文的一致性就可以。 实现过程：将原字符串反转，然后用LCS_length(),Print_LCS()计算出最长公共子序列即可。 palidrome_longest.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;locale&gt;using namespace std;#define N 9 //输入您要判断的字符串的字符数wchar_t b[N+1][N+1]=&#123;'S'&#125;; //表示起点startint c[N+1][N+1]=&#123;0&#125;;wchar_t northwest=L'\\\\', up=L'|', leftway=L'-';void LCS_length(char *x,char *y)&#123; for(int i1=0;i1&lt;N;i1++) b[i1][0]='S'; for(int j1=0;j1&lt;N;j1++) b[0][j1]='S'; for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;N;j++) &#123; if(x[i]==y[j]) &#123; c[i+1][j+1]=c[i][j]+1; b[i+1][j+1]=northwest; //Northwest往左上 &#125; else &#123; if(c[i][j+1]&gt;=c[i+1][j]) //c[i-1][j-1] 过渡到 c[i][j]，需要将c[i-1][j]和c[i][j-1]比较大小 //取较大的那一个值 &#123; c[i+1][j+1]=c[i][j+1]; b[i+1][j+1]=up; //Up往上 &#125; else &#123; c[i+1][j+1]=c[i+1][j]; b[i+1][j+1]=leftway; //Left往左 &#125; &#125; &#125; &#125;&#125;void Print_lcs(char *x,int i,int j)&#123; if(i==0||j==0) return; if(b[i][j]==northwest) &#123; Print_lcs(x,i-1,j-1); cout&lt;&lt;x[i-1]&lt;&lt;\" \"; //当然，按y[j]输出也没有问题，因为是公共序列嘛！ &#125; //这里的下标是从i=0开始的，所以输出x[i-1] else &#123; if(b[i][j]==up) Print_lcs(x,i-1,j); else Print_lcs(x,i,j-1); &#125;&#125;char *strReverse(char *str)&#123; for(int i=0;i&lt;N/2;i++) &#123; swap(str[i],str[N-1-i]); &#125; return str;&#125; palidrome_longest.cpp1234567891011121314151617181920212223#include \"palidrome_longest.h\"int main()&#123; char x[N+1]=&#123;0&#125;; char y[N+1]=&#123;0&#125;; char c; cout&lt;&lt;\"get the string you need to judge: \"&lt;&lt;endl; int i; for(i=1;i&lt;=N;i++) //默认的字符串是从下标1开始的，这里我们可以让它从0开始 &#123; cin&gt;&gt;c; y[i]=x[i]=c; &#125; x[i]='\\0';y[i]='\\0'; cout&lt;&lt;y&lt;&lt;endl; cout&lt;&lt;\"x=\"&lt;&lt;y&lt;&lt;endl; strReverse(y); //反转字符串 cout&lt;&lt;\"y=\"&lt;&lt;y&lt;&lt;endl; LCS_length(x,y); Print_lcs(x,N,N); return 0;&#125; 实现结果 欧几里德旅行商问题算法分析图 Eucilid_travel.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#define N 7 //确定有几个点？struct travelnode&#123; double x; double y;&#125;T[N];//计算两个点之间的直线距离double distance(travelnode T[],int i,int j) //T[]的下标，第几个数？1,2....N&#123; return sqrt((T[i].x-T[j].x)*(T[i].x-T[j].x)+(T[i].y-T[j].y)*(T[i].y-T[j].y));&#125;double Bitonic_Eucilid(travelnode T[])&#123; double b[N+1][N+1]=&#123;0&#125;; //初始化b[1][2]，注意初始下标从1开始，1,2.....N b[1][2]=distance(T,1,2); for(int j=3;j&lt;=N;j++) &#123; for(int i=1;i&lt;j-1;i++) //注意1&lt;=i&lt;=j-2 &#123; b[i][j]=b[i][j-1]+distance(T,j-1,j); //巡路系统的初始化，递归求解 //length((start-&gt;j-1)+(start-&gt;i)+length(j-1,j)) //即b[i][j]=b[i][j-1]+distance(T,j-1,j) 这里distance(T,j-1,j)封闭了路径 &#125; //注意：这里递归求解所得到的路径，b[i][j]不一定就是最短的欧几里德旅行商 //必须用min()维护旅行商信息 //用min()维护每一条线段[j-1,j]，保证从length(start-&gt;j-1)+length(start-&gt;k)+length(k,j)均是最小的 //如图所示：对每一个线段[j-1,j]的两端进行维护，保证最短的Eucilid巡回，即维护b[j-1][j] //在维护的过程中b[j-1][j]=min(b[k][j-1]+distance(k,j))，封闭了[k,j]就获取了最佳路径 //因为j是在最远端，1&lt;=k&lt;=j-1&lt;j，j-1和k一定在回路的不同方向。由递归求解，已知b[k][j-1] //最后封闭[k,j]即可年少有你 //这一步确定了从start-&gt;i+start-&gt;j的路径，但是巡路并不是封闭的 //最后确定b[j-1][j]，即确定线段[j-1,j]，完成巡路封闭。 //这里b[j-1][j]要保证遍历1&lt;=k&lt;j-1中的最小路径，如图中所示 b[j-1][j]=INFINITY; //对每一条线段[j-1,j]两端维护Eucilid巡回路径性质 for(int k=1;k&lt;j-1;k++) &#123; double q=b[k][j-1]+distance(T,k,j); //最后封闭的线段长度[j-1,j]是固定的 //(start-&gt;j-1)+(start-&gt;k)+length(k,j) //由于1&lt;=k&lt;j-1，k和j-1一定是分居在Eucilid旅行图的线段[j-1,j]的两侧 if(q&lt;b[j-1][j]) b[j-1][j]=q; &#125; &#125; b[N][N]=b[N-1][N]+distance(T,N-1,N); return b[N][N];&#125; Eucilid_travel.cpp12345678910111213#include \"Eucilid_travel.h\"int main()&#123; travelnode T[N+1]=&#123;0&#125;; cout&lt;&lt;\"Input the numbers in order : \"&lt;&lt;endl; for(int i=1;i&lt;=N;i++) &#123; cin&gt;&gt;T[i].x&gt;&gt;T[i].y; &#125; cout&lt;&lt;Bitonic_Eucilid(T)&lt;&lt;endl;&#125; 旅行商的重构解Print函数的递归分析 特别注意： 12if(s&lt;k) print_eucilid(solution,s,val); 或者是：12if(s&gt;k) print_eucilid(solution,val,k); 如图中绿色线条所示：递归的过程，无论是$s-&gt;val$还是$val-&gt;s$，均是由较大坐标的点转向较小坐标的点。二者的区别在于：s&lt;k的时候直接取得val=solution[s][k]的值，先输出val，再递归； 而s&gt;k的时候，则先递归输出顺时针方向其余的点，再输出val=solution[k][s]的值。注意这里是solution[k][s] 当然递归和$val$的输出的先后顺序，取决于你是按顺时针还是逆时针输出。 Eucilid_travel_constitute.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#define N 7 //确定有几个点？struct travelnode&#123; double x; double y;&#125;T[N];//计算两个点之间的直线距离double distance(travelnode T[],int i,int j) //T[]的下标，第几个数？1,2....N&#123; return sqrt((T[i].x-T[j].x)*(T[i].x-T[j].x)+(T[i].y-T[j].y)*(T[i].y-T[j].y));&#125;double Bitonic_Eucilid(travelnode T[],int solution[][N+1])&#123; double b[N+1][N+1]=&#123;0&#125;; //初始化b[1][2]，注意初始下标从1开始，1,2.....N b[1][2]=distance(T,1,2); for(int j=3;j&lt;=N;j++) &#123; for(int i=1;i&lt;j-1;i++) //注意1&lt;=i&lt;=j-2 &#123; b[i][j]=b[i][j-1]+distance(T,j-1,j); //巡路系统的初始化，递归求解 //length((start-&gt;j-1)+(start-&gt;i)+length(j-1,j)) //即b[i][j]=b[i][j-1]+distance(T,j-1,j) 这里distance(T,j-1,j)封闭了路径 solution[i][j]=j-1; &#125; //注意：这里递归求解所得到的路径，b[i][j]不一定就是最短的欧几里德旅行商 //必须用min()维护旅行商信息 //用min()维护每一条线段[j-1,j]，保证从length(start-&gt;j-1)+length(start-&gt;k)+length(k,j)均是最小的 //如图所示：对每一个线段[j-1,j]的两端进行维护，保证最短的Eucilid巡回，即维护b[j-1][j] //在维护的过程中b[j-1][j]=min(b[k][j-1]+distance(k,j))，封闭了[k,j]就获取了最佳路径 //因为j是在最远端，1&lt;=k&lt;=j-1&lt;j，j-1和k一定在回路的不同方向。由递归求解，已知b[k][j-1] //最后封闭[k,j]即可 //这一步确定了从start-&gt;i+start-&gt;j的路径，但是巡路并不是封闭的 //最后确定b[j-1][j]，即确定线段[j-1,j]，完成巡路封闭。 //这里b[j-1][j]要保证遍历1&lt;=k&lt;j-1中的最小路径，如图中所示 b[j-1][j]=INFINITY; //对每一条线段[j-1,j]两端维护Eucilid巡回路径性质 for(int k=1;k&lt;j-1;k++) &#123; double q=b[k][j-1]+distance(T,k,j); //最后封闭的线段长度[j-1,j]是固定的 //(start-&gt;j-1)+(start-&gt;k)+length(k,j) //由于1&lt;=k&lt;j-1，k和j-1一定是分居在Eucilid旅行图的线段[j-1,j]的两侧 if(q&lt;b[j-1][j]) &#123; b[j-1][j]=q; solution[j-1][j]=k; &#125; &#125; &#125; b[N][N]=b[N-1][N]+distance(T,N-1,N); solution[N][N]=N-1; return b[N][N];&#125;void print_eucilid(int solution[][N+1],int s,int k)&#123; if(s&lt;k) &#123; int val=solution[s][k]; cout&lt;&lt;val&lt;&lt;\" \"; if(val&gt;1) print_eucilid(solution,s,val); &#125; else &#123; int val=solution[k][s]; if(val&gt;1) &#123; print_eucilid(solution,val,k); &#125; cout&lt;&lt;val&lt;&lt;\" \"; &#125;&#125; Eucilid_travel_constitute.cpp12345678910111213141516171819202122#include \"Eucilid_travel_constitute.h\"int main()&#123; travelnode T[N+1]=&#123;0&#125;; int solution[N+1][N+1]=&#123;0&#125;; cout&lt;&lt;\"Input the numbers in order : \"&lt;&lt;endl; for(int i=1;i&lt;=N;i++) &#123; cin&gt;&gt;T[i].x&gt;&gt;T[i].y; &#125; cout&lt;&lt;Bitonic_Eucilid(T,solution)&lt;&lt;endl; cout&lt;&lt;\"The Eucilid travel is :\"&lt;&lt;endl; cout&lt;&lt;N&lt;&lt;\" \"; print_eucilid(solution,N-1,N); cout&lt;&lt;N-1&lt;&lt;\" \";&#125; 算法运行结果","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"最长公共子序列","slug":"20170218","date":"2017-02-18T05:05:00.000Z","updated":"2018-03-02T17:38:14.000Z","comments":true,"path":"2017/02/18/20170218/","link":"","permalink":"http://www.fogsail.net/2017/02/18/20170218/","excerpt":"Biological applications often need to compare the DNA of two (or more) different organisms. A strand of DNA consists of a string of molecules called bases, where the possible bases are adenine, guanine, cytosine, and thymine. Representing each of these bases by its initial letter, we can express a strand of DNA as a string over the ﬁnite set {A,C,G,T}. 这是生物学应用中最为常见的“最长公共子序列问题”。","text":"Biological applications often need to compare the DNA of two (or more) different organisms. A strand of DNA consists of a string of molecules called bases, where the possible bases are adenine, guanine, cytosine, and thymine. Representing each of these bases by its initial letter, we can express a strand of DNA as a string over the ﬁnite set {A,C,G,T}. 这是生物学应用中最为常见的“最长公共子序列问题”。 动态规划原理能够用动态规划解决的问题，通常具有两种属性：第一，存在最优子结构，即可以用“剪切，粘帖”的方法来证明；第二，具有重叠子问题。 递归和穷举算法分析在矩阵链乘法的问题中，可以使用递归和穷举两种方法来解决最优的括号化方案。其中，对每一种方案计算乘法运算次数。 用穷举法的时候，表中的每一个节点都必须访问，记访问一个节点的时间为$b_k$则有递推式：$b_n= \\sum_{k=0}^{n-1}b_kb_{n-1-k}$ 该递推式符合卡特兰数，可以推出通项公式为：$b(n)=\\frac{4^n}{\\sqrt{\\pi}n^{3/2}}(1+O(1/n))$阶是关于n的指数函数。 用Recursive-Matrix-Chain递归求解，递推式符合$T(n)\\geq1+\\sum_{k=1}^{n-1}(T(k)+T(n-k)+1) \\qquad n&gt;1$可以求得递推公式为：$T(n)\\geq2^{n-1}$ 可见朴素递归算法比穷举好一些。 动态规划问题和分治法区别在merge-sort过程中，可以发现，问题不具有重叠字问题的性质，如下图所示，所有的子问题均不重叠。 最大化矩阵括号方案最大化矩阵括号化方案，问题仍然具有最优子结构性质。因为“剪切，粘帖”的处理方式没有变。 假设最大括号化方案能够使结果最优，则其中的划分为：$A_1A_2\\dots \\dots A_kA_{k+1}\\dots A_j$如果该方案不是最优的，总可以找到另外一种方案如下：$A_1A_2\\dots A_iA_{i+1}\\dots \\dots A_j$来替代该方案，使得结果最优。 贪心和动态规划的区别贪心算法的原理是：我们不必计算原问题的最优解，总是可以在求解子问题的时候划分出$A_iA_{i+1}\\dots A_j$，选定的k使得$p_{i-1}p_{k}p_{j}$最小。这样的贪心算法并不能够得到最优解。原因如下： 虽然我们求出来的最优解如红色的图，但很有可能$p_{u-1}p_wp_v&lt;p_{u-1}p_xp_v$ 原因如下：最优解的函数表达式与贪心中的$p_k$函数表达式不同，所以贪心算法并不能够用于最优解问题。 编程验证： 贪心策略如下： 12345678910111213141516171819202122232425262728//下面这是用错误的贪心算法求解的问题：Matrix_Chain Matrix_Chain_Order_greedy(int p[])&#123; int N=n-1; Matrix_Chain T_greedy; for(int i=0;i&lt;N;i++) T_greedy.m[i][i]=0; for(int l=2;l&lt;=N;l++) &#123; for(int i=1;i&lt;=N-l+1;i++) &#123; int j=i+l-1; T_greedy.m[i-1][j-1]=INFINITY; int q_min=INFINITY; for(int k=i;k&lt;=j-1;k++) &#123; int q=T_greedy.m[i-1][k-1]+T_greedy.m[k][j-1]+p[i-1]*p[k]*p[j]; if(q_min&gt;p[i-1]*p[k]*p[j]) &#123; q_min=p[i-1]*p[k]*p[j]; T_greedy.m[i-1][j-1]=q; T_greedy.s[i-1][j-1]=k-1; &#125; &#125; &#125; &#125; return T_greedy;&#125; 结果如图： 很显然地看出，greedy_result得到了不同的括号化结果。 钢条切割问题的限制 如果我们限制，在r=4的时候，只能够切割成两段长度为1的钢条，则r=4的时候，最优切割方案1+1+1+1无法成立。 外币兑换问题该问题可以看成是一种矩阵链乘法的变形，当佣金$C_k$为任意值的时候，并不符合最优子结构的性质。 具体的描述见下图： 合并问题的代价，可以描述为$C_k$ 解决每个问题所需要的代价为$R_k$ 总代价的递推式为：$R_k+C_k$$R_{k2}+C_{k_2}$ 如果$C_k$不为常数，假设它可以用一个$f(k)$描述，则问题的代价可以描述为： $R_k+f(k)$ 动态规划算法只能保证$R_k$的最优解，并不能保证$f(k)$的最优解。 最长公共子序列最长公共子序列的求解，如下图所示： 可以看到，最长公共子序列的依赖关系如上图所示，[i,j]的值取决于{[i-1,j-1],[i,j-1],[i-1,j]} 实现方法如下： LCS_len.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;locale&gt;#define M 6#define N 7wchar_t b[N+1][M+1]=&#123;'S'&#125;; //表示起点startint c[N+1][M+1]=&#123;0&#125;;wchar_t northwest=L'\\\\', up=L'|', leftway=L'-';void LCS_length(char *x,char *y)&#123; for(int i1=0;i1&lt;=N;i1++) b[i1][0]='S'; for(int j1=0;j1&lt;=M;j1++) b[0][j1]='S'; for(int i=1;i&lt;=N;i++) &#123; for(int j=1;j&lt;=M;j++) &#123; if(x[i]==y[j]) &#123; c[i][j]=c[i-1][j-1]+1; b[i][j]=northwest; //Northwest往左上 &#125; else &#123; if(c[i-1][j]&gt;=c[i][j-1]) //c[i-1][j-1] 过渡到 c[i][j]，需要将c[i-1][j]和c[i][j-1]比较大小 //取较大的那一个值 &#123; c[i][j]=c[i-1][j]; b[i][j]=up; //Up往上 &#125; else &#123; c[i][j]=c[i][j-1]; b[i][j]=leftway; //Left往左 &#125; &#125; &#125; &#125;&#125;void Print_lcs(char *x,int i,int j)&#123; if(i==0||j==0) return; if(b[i][j]==northwest) &#123; Print_lcs(x,i-1,j-1); std::cout&lt;&lt;x[i]&lt;&lt;\" \"; //当然，按y[j]输出也没有问题，因为是公共序列嘛！ &#125; else &#123; if(b[i][j]==up) Print_lcs(x,i-1,j); else Print_lcs(x,i,j-1); &#125;&#125; 主函数LCS.cpp 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;locale&gt;#include \"LCS_len.h\"int main()&#123; setlocale(LC_ALL,\"chs\"); char x[N+1]=&#123;'\\0','A','B','C','B','D','A','B'&#125;; char y[M+1]=&#123;'\\0','B','D','C','A','B','A'&#125;; LCS_length(x,y); Print_lcs(x,N,M); std::cout&lt;&lt;std::endl; std::cout&lt;&lt;\"Gene Distance:\"&lt;&lt;std::endl; for(int i=0;i&lt;=N;i++) &#123; for(int j=0;j&lt;=M;j++) &#123; std::wcout&lt;&lt;b[i][j]&lt;&lt;\"\\t\"; &#125; std::cout&lt;&lt;std::endl; for(int j=0;j&lt;=M;j++) &#123; std::cout&lt;&lt;c[i][j]&lt;&lt;\"\\t\"; &#125; std::cout&lt;&lt;std::endl; &#125; system(\"pause\"); return 0;&#125; 实现结果输出 问题解答运行上述代码，可以知道和的一个LCS为： 不使用表b重构LCSlcs_len2.h 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#define M 6#define N 7void lcs_len_withouthelp(char *x, char *y,int c[][M+1])&#123; for(int i=1;i&lt;=N;i++) &#123; for(int j=1;j&lt;=M;j++) &#123; if(x[i]==y[j]) c[i][j]=c[i-1][j-1]+1; else &#123; if(c[i-1][j]&gt;=c[i][j-1]) c[i][j]=c[i-1][j]; else c[i][j]=c[i][j-1]; &#125; &#125; &#125;&#125;void print_LCS_withouthelp(int c[][M+1],char *x,int i,int j)&#123; if(i==0||j==0) return; if(c[i][j]==c[i-1][j-1]+1) &#123; print_LCS_withouthelp(c,x,i-1,j-1); std::cout&lt;&lt;x[i]&lt;&lt;\" \"; &#125; else &#123; if(c[i-1][j]&gt;=c[i][j-1]) print_LCS_withouthelp(c,x,i-1,j); else print_LCS_withouthelp(c,x,i,j-1); &#125;&#125; LCS2.CPP 1234567891011#include &lt;iostream&gt;#include \"lcs_len2.h\"int main()&#123; char x[N+1]=&#123;'\\0','A','B','C','B','D','A','B'&#125;; char y[M+1]=&#123;'\\0','B','D','C','A','B','A'&#125;; int c[N+1][M+1]=&#123;0&#125;; lcs_len_withouthelp(x,y,c); print_LCS_withouthelp(c,x,N,M);&#125; 带备忘的LCS-Length基本思路： 一、初始化1Initialize(c)=&#123;0&#125;; 二、带备忘的值，执行判断1234if(i==0||j==0) c[i][j]=0;else if(c[i][j]&gt;0) return c[i][j]; //带备忘的return,执行输出 实现过程 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;#define M 6#define N 7int Max(int a,int b)&#123; return a&gt;b?a:b;&#125;//数组初始化为0的方法：//只要定义第一个元素为0，后面就劝为0了//int c[N+1][M+1]=&#123;0&#125;int lcs_length(char *x,char *y,int c[][M+1],int i,int j) //这里，i,j指下标，就是第几个数//在递归的时候，从最后一个数，就是第N，M个数算起&#123; if(i==0||j==0) c[i][j]=0; else if(c[i][j]&gt;0) return c[i][j]; else &#123; if(x[i]==y[j]) c[i][j]=lcs_length(x,y,c,i-1,j-1)+1; else c[i][j]=Max(lcs_length(x,y,c,i-1,j),lcs_length(x,y,c,i,j-1)); &#125; return c[i][j];&#125;int main()&#123; char x[N+1] = &#123;'\\0','A','B','C','B','D','A','B'&#125;; char y[M+1] = &#123;'\\0','B','D','C','A','B','A'&#125;; int c[N+1][M+1]=&#123;0&#125;; cout&lt;&lt;lcs_length(x,y,c,N,M);&#125; 2×min(m,n)计算LCS长度实际上，根据c[i][j],c[i-1][j-1],c[i][j-1],c[i-1][j]的依赖关系，可以知道：LCS的值仅仅依赖于两行关系，如下图所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;#define M 8#define N 9//仅有的二维数组：/*用第0行作为上一行，第1行作为当前行，一次循环后，把旧的第1行(当前行)的所有数据转移给新的上一行，而新的当前行用来存储新的当前行数据，这样不断循环，最终得到LCS长度*/void copy(int res[][M+1])&#123; for(int i=0;i&lt;=M;i++) res[0][i]=res[1][i];&#125;void LCS_length_2mn(char *x,char *y)&#123; int res[2][M+1]=&#123;0&#125;; for(int i=1;i&lt;=N;i++) &#123; for(int j=1;j&lt;=M;j++) &#123; if(x[i]==y[j]) res[1][j]=res[0][j-1]+1; else &#123; if(res[0][j]&gt;=res[1][j-1]) res[1][j]=res[0][j]; else res[1][j]=res[1][j-1]; &#125; &#125; copy(res); &#125; cout&lt;&lt;\"first line: \"&lt;&lt;res[0][M]&lt;&lt;endl; cout&lt;&lt;\"second line: \"&lt;&lt;res[1][M]&lt;&lt;endl;&#125;int main() &#123; //char x[N+1] = &#123;'\\0','A','B','C','B','D','A','B'&#125;; //char y[M+1] = &#123;'\\0','B','D','C','A','B','A'&#125;; char x[M+1] = &#123;'\\0','1','0','0','1','0','1','0','1'&#125;; char y[N+1] = &#123;'\\0','0','1','0','1','1','0','1','1','0'&#125;; LCS_length_2mn(x,y); return 0; &#125; 最后输出结果为6，公共子序列为{1，0，1，0，1，1} 最长公共单调递增子序列具体实现方法：1、利用快速排序先将原序列排序。2、然后再计算原序列和已排序序列两者公共子序列。3、打印公共子序列。 LCS_quicksort.h123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;using namespace std;int PARTITION(int A[],int p,int r)&#123; int x=A[r]; int i=p-1; for(int j=p;j&lt;=r-1;j++) &#123; if(A[j]&lt;=x) &#123; i++; swap(A[i],A[j]); &#125; &#125; swap(A[i+1],A[r]); return i+1;&#125;void QUICKSORT(int A[],int p,int r)&#123; if(p&lt;r) &#123; int q=PARTITION(A,p,r); QUICKSORT(A,p,q-1); QUICKSORT(A,q+1,r); &#125;&#125; LCS_len.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;locale&gt;#define M 11#define N 11wchar_t b[N+1][M+1]=&#123;'S'&#125;; //表示起点startint c[N+1][M+1]=&#123;0&#125;;wchar_t northwest=L'\\\\', up=L'|', leftway=L'-';void LCS_length(int *x,int *y)&#123; for(int i1=0;i1&lt;=N;i1++) b[i1][0]='S'; for(int j1=0;j1&lt;=M;j1++) b[0][j1]='S'; for(int i=1;i&lt;=N;i++) &#123; for(int j=1;j&lt;=M;j++) &#123; if(x[i]==y[j]) &#123; c[i][j]=c[i-1][j-1]+1; b[i][j]=northwest; //Northwest往左上 &#125; else &#123; if(c[i-1][j]&gt;=c[i][j-1]) //c[i-1][j-1] 过渡到 c[i][j]，需要将c[i-1][j]和c[i][j-1]比较大小 //取较大的那一个值 &#123; c[i][j]=c[i-1][j]; b[i][j]=up; //Up往上 &#125; else &#123; c[i][j]=c[i][j-1]; b[i][j]=leftway; //Left往左 &#125; &#125; &#125; &#125;&#125;void Print_lcs(int *x,int i,int j)&#123; if(i==0||j==0) return; if(b[i][j]==northwest) &#123; Print_lcs(x,i-1,j-1); std::cout&lt;&lt;x[i]&lt;&lt;\" \"; //当然，按y[j]输出也没有问题，因为是公共序列嘛！ &#125; else &#123; if(b[i][j]==up) Print_lcs(x,i-1,j); else Print_lcs(x,i,j-1); &#125;&#125; LCS_increase.cpp123456789101112131415161718192021222324252627282930313233343536373839#include \"LCS_quicksort.h\"#include \"LCS_len.h\"#include &lt;iostream&gt;#include &lt;locale&gt;#include &lt;cstdlib&gt;int main()&#123; setlocale(LC_ALL,\"chs\"); srand((unsigned)time(NULL)); int x[N+1]=&#123;0&#125;; int y[N+1]=&#123;0&#125;; //一般，第一个位置放0，第二个位置放1 //i的循环，从i=1 to N for(int i=1;i&lt;=N;i++) &#123; y[i]=x[i]=rand()%10+1; std::cout&lt;&lt;x[i]&lt;&lt;\" \"; &#125; std::cout&lt;&lt;std::endl; QUICKSORT(y,0,N); LCS_length(x,y); Print_lcs(x,N,N); std::cout&lt;&lt;std::endl; std::cout&lt;&lt;\"15-8\"&lt;&lt;std::endl; for(int i=0;i&lt;=N;i++) &#123; for(int j=0;j&lt;=N;j++) std::wcout&lt;&lt;b[i][j]&lt;&lt;\"\\t\"; std::cout&lt;&lt;std::endl; for(int j=0;j&lt;=N;j++) std::cout&lt;&lt;c[i][j]&lt;&lt;\"\\t\"; std::cout&lt;&lt;std::endl; &#125; system(\"pause\"); return 0;&#125; 输出结果： 最长公共单调递增子序列的改进可以把算法的运行时间缩短到$O(nlgn)$ 具体的实现方法如下图： 可能常见的错误： bisearch.h1234567891011121314151617181920212223#include &lt;iostream&gt;//使用二分查找寻找合适的位置//要插入的位置，是比该数大的第一个数值int bisearch(int *b,int len,int w)&#123; int left=0,right=len-1; int mid; while(left&lt;=right) &#123; mid=left+(right-mid)/2; if(b[mid]&gt;w) right=mid-1; else if(b[mid]&lt;w) left=mid+1; else return mid; &#125; return left;&#125;//二分查找最后返回的值，是b[mid+1]//当然，如果找不到该值，最后返回的是b[0+1]，或者是b[len+1] LIS.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stdlib.h&gt;#include \"bisearch.h\"#define N 9int B[N];int len; //用来标注数组B中元素的个数struct node&#123; int data; int prev; //存放上一个prev的下标&#125;;int LIS(int *array,node *result,int n)&#123; int len=1; //B[]数组的长度 B[0]=array[0]; int i,pos=0; result[0].data=B[0]; result[0].prev=-1; for(int i=1;i&lt;n;i++) //为什么下标从1开始？ //[i]要和[i-1]比较，然后执行替换，原来array[0]作为初始值 &#123; if(array[i]&gt;B[len-1]) &#123; B[len]=array[i]; result[len].data=array[i]; result[len].prev=len-1; len++; &#125; else &#123; int pos=bisearch(B,len,array[i]); B[pos]=array[i]; result[pos+1].prev=pos; &#125; &#125; return len;&#125;//这里，result提供用于回溯的另一组数值 LCS_increase_imple.cpp123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include \"LIS.h\"using namespace std;#define N 9int main()&#123; int array[N]=&#123;2,1,6,3,5,4,8,7,9&#125;; node *result=new node[N+1]; int cur_len=LIS(array,result,N); cout&lt;&lt;cur_len&lt;&lt;endl; for(int i=0;i&lt;cur_len;i++) &#123; cout&lt;&lt;B[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; cout&lt;&lt;\"wrong answer:\"&lt;&lt;endl; int temp[cur_len]=&#123;0&#125;; int id=cur_len-1; for(int i=cur_len-1;i&gt;=0;i--) &#123; temp[i]=result[id].data; id=result[id].prev; &#125; cout&lt;&lt;temp[0]&lt;&lt;\" \"; for(int i=0;i&lt;cur_len;i++) &#123; if(i&gt;0 &amp;&amp; temp[i]&gt;=temp[i-1]) cout&lt;&lt;temp[i]&lt;&lt;\" \"; &#125; delete[] result; return 0;&#125; 最优二叉搜索树最优二叉搜索树的动态规划由最优二叉搜索树期望搜索代价的递推公式： 因此，若$k_r$为包含关键字$k_i \\cdots k_j$的最优二叉搜索树的根节点，我们的递推公式可以这样理解：$e$作为期望代价，当选定一个新的根节点$k_r$的时候，左右子树的深度均$+1$。 而$w(i,j)=\\sum_{l=i}^{j}p_l+\\sum_{l=i-1}^{j}q_l$ 根据期望的公式可以这么理解：$e[i,j]$为期望代价，指定新的节点作为根节点的时候，所有的节点都必须重新排列。由$(15.11)$公式可知，左右子树节点的深度都$+1$的时候，$E[search \\, cost \\, in \\, T]$增加的值为$w(i,j)=\\sum_{l=i}^{j}p_l+\\sum_{l=i-1}^{j}q_l$。 同时，还要加上根节点的期望$p_r$。 $e[i,j]=p_r+(e[i,r-1]+w(i,r-1))+(e[r+1,j]+w(r+1,j))$$w(i,j)=w(i,r-1)+p_r+w(r+1,j)$ 因此$e[i,j]$可以重写为$e[i,j]=e[i,r-1]+e[r+1,j]+w(i,j)$如果选取期望搜索代价最低的为根节点，可以有递推公式： e[i,j]= \\begin{cases} q_{i-1}& \\text{j=i-1}\\\\ \\min \\limits_{i \\leq r \\leq j} (e[i,r-1]+e[r+1,j]+w(i,j))& \\text{i","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"动态规划概论","slug":"20170202","date":"2017-02-01T17:00:00.000Z","updated":"2018-03-02T17:14:12.000Z","comments":true,"path":"2017/02/02/20170202/","link":"","permalink":"http://www.fogsail.net/2017/02/02/20170202/","excerpt":"动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。","text":"动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。 钢条切割问题算法运行时间分析如果采用最平凡的递推算法，由$r_n= \\underset{1 \\leq i \\leq n}{\\max} (p_i+r_{n-i})$令$T(n)$表示算法第二个参数值为n的时候CUT-ROD的调用次数，可以推出：$T(n)=1+ \\sum_{j=0}^{n-1}T(j)$ $T(n)=1+T(1)+T(2)+\\cdots+T(n-1)$$T(n-1)=1+T(1)+T(2)+\\cdots+T(n-2)$ 即$T(n)=2+2T(1)+\\cdots+2T(n-2)=2T(n-1)$ $\\frac{T(n)}{T(n-1)}=2$ 由等比数列的递推公式，$T(n)=2^n$所以，平凡的递归算法反复求解相同的子问题，耗费了大量的时间。 使用动态规划 求解子问题的两种方法：使用memorized_cut_rod方法的时候，memorized_cut_rod_aux(p,n,r)的递归，最多递归到r[]的下标为n-1，因为在循环中执行的是for(int i=0;i&lt;n;i++) 使用自底向上递归求解。 由上图所示，在递归过程中：1234567891011121314151617r[0]=0;for(int j=0;j&lt;n;j++)&#123; int result=-INFINITY; for(int i=0;i&lt;=j;i++) &#123; //获取scale=j时候的max值，即最大收益result //随着j++，我们获取最大收益的时候要返回r[j+1]的值，这样 //scale=scale+1时候的最大收益，即r[j+1]，即为上一步求出的 //result值，即r[j+1]=result result=max(result,p[i]+r[j-1]); &#125; r[j+1]=result;&#125;return r[n];//返回的r[n]这里的n指问题的规模 算法实现过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#define INFINITY 0x7fffffffusing namespace std;int max(int a,int b)&#123; return a&gt;b?a:b;&#125;int memorized_cut_rod_aux(int p[],int n,int r) //n表示问题的规模&#123; //注意，这里p[i]的意义和r[i]的意义不一样 //p[i]表示对应的数组元素，i表示下标 //r[i]表示问题的规模为i所对应的解 //p[i]对应的问题是第i个，其规模为i+1，剩余的问题规模是n-(i+1) //从另一个角度，0&lt;=i&lt;=n-1 0&lt;=r&lt;=n-1，所以递归的时候是(p,n-1-i,r) int result; if(r[n]&gt;=0) return r[n]; //表示问题已经被求解完毕了，返回该值 if(n==0) result=0; //表示没有切割 else &#123; result=-INFINITY; for(int i=0;i&lt;n;i++) &#123; result=max(result,p[i]+memorized_cut_rod_aux(p,n-1-i,r)); &#125; &#125; //表示规模为n的问题求解完毕 r[n]=result; return result;&#125;int memorized_cut_rod(int p[],int n)&#123; int *r=new int[n]; for(int i=0;i&lt;n;i++) &#123; r[i]=-INFINITY; &#125; return memorized_cut_rod_aux(p,n,r); //这里(p,n,r) //r[]的递归标最多为n-1&#125;int BOTTOM_UP_CUT_ROD(int p[],int n)&#123; int *r=new int [n]; r[0]=0; for(int j=0;j&lt;n;j++) &#123; int result=-INFINITY; for(int i=0;i&lt;=j;i++) &#123; //获取scale=j时候的max值，即最大收益result //随着j++，我们获取最大收益的时候要返回r[j+1]的值，这样 //scale=scale+1时候的最大收益，即r[j+1]，即为上一步求出的 //result值，即r[j+1]=result result=max(result,p[i]+r[j-1]); &#125; r[j+1]=result; &#125; return r[n]; //返回的r[n]这里的n指问题的规模&#125; 主函数：1234567int main()&#123; const int n=10; int p[10]=&#123;1,5,8,9,10,17,17,20,24,30&#125;; cout&lt;&lt;memorized_cut_rod(p,9)&lt;&lt;endl; cout&lt;&lt;BOTTOM_UP_CUT_ROD(p,9)&lt;&lt;endl;&#125; 子问题图与重构解这里特别说明一种表示方式1array *EXTENDED_BOTTOM_UP_CUT_ROD(int p[],int n) 这里p[]表示指向数组第一个元素的指针，注意区分以下两种表示方法：当表示第n个元素的时候12*(p+n)-&gt;elementp[n].element 这两种表示方式不同，一种是指针，一种是结构体表示。 具体的说明见下图： 动态规划解决钢条切割问题，问题的输出：注意让规模逐渐减小。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;#define INFINITY 0x7fffffffstruct rod&#123; int result; //代表最大收益 int solution; //代表切割方案&#125;;rod *EXTENDED_BOTTOM_UP_CUT_ROD(int p[], int n)&#123; rod *res=new rod[n]; res[0].result=0; //初始化，钢条规模为0，收益为0 int q; for(int j=0;j&lt;n;j++) &#123; q=-INFINITY; for(int i=0;i&lt;=j;i++) &#123; if(q&lt;p[i]+res[j-i].result) &#123; q=p[i]+res[j-i].result; res[j+1].solution=i+1; //保存切割方式 &#125; //这里的i表示切割下来的片段，规模有多大？ &#125; //此时已经完成了从1---j的循环 res[j+1].result=q; &#125; return res+n; //注意：这里res表示指向第一个元素的指针&#125;//res+n表示指针移动n位，新的指针指向n之后的那个位置//rod *res=new rod[n] res[i].result (res+i)-&gt;result//两种用法注意区分//特别注意：这里res[0].result=0 最后res[j+1].result//res[j+1].solution，意味这res[]的存储范围如下：//res[1]，res[2],......,res[n]//res初始指针位置为res[0]，res末指针的位置为res[n]void PRINT_CUT_ROD_SOLUTION(int p[], int n)&#123; rod *res=EXTENDED_BOTTOM_UP_CUT_ROD(p,n); //注意这里函数的返回值为res+n，即最后一个数组元素的地址 while(n&gt;0) &#123; cout&lt;&lt;(*res).solution&lt;&lt;\" \"; n=n-(*res).solution; //注意返回的res指的是res[n]的位置 //返回的是规模为n时候的切割方法,从最大规模往最小规模输出 //这里从大规模往小规模输出，指针也要调整 //从规模为n的位置逐渐减小到i，再逐渐减小到1，0 res=res-(*res).solution; &#125;&#125;void main()&#123; const int n=10; int p[10]=&#123;1,5,8,9,10,17,17,20,24,30&#125;; cout&lt;&lt;(*EXTENDED_BOTTOM_UP_CUT_ROD(p,4)).result&lt;&lt;endl; PRINT_CUT_ROD_SOLUTION(p,4);&#125; 其他问题15.1-2 反例如下图： 15.1-3 钢条切割的时候考虑固定成本为c 特别注意，这里的固定成本为c，在执行循环的时候，存在表达式的不同！ 1234567891011121314151617181920212223242526272829303132333435//当j==i的时候有不同！for(int j=0;j&lt;n;j++)&#123; //省略的code for(int i=0;i&lt;j;i++) &#123; //i&lt;j时候表示钢条一定会进行切割！ if(q&lt;=p[i]+res[j-i].result-c) &#123; q=p[i]+res[j-i].result-c; res[j+1].solution=i+1; cut_or_not=true; //表示进行切割了 &#125; &#125; //当i==j时候的情况不一样了！ //此时已经保存的最大收益是q //很有可能 //p[i]+res[j-i].result-c&lt;q&lt;=p[i]+res[j-i].result //这个时候j==i可能没有发生切割，没有发生切割和发生切割 //收益的表达式不同，一个减去成本，一个没有 if(j==i) &#123; if(q&lt;=p[i]+res[j-i].result &amp;&amp; cut_or_not==false) &#123; res[j+1].solution=i+1; &#125; &#125; //j求解完毕 res[j+1].result=q;&#125;return res+n; 具体实现的过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;#define INFINITY -0x7fffffff#define cost 2int max(int a, int b)&#123; return a&gt;b?a:b;&#125;struct rod_cost&#123; int result; int solution; bool cut_or_not;&#125;;rod_cost *EXTENDED_BOTTOM_UP_CUT_ROD(int p[], int n)&#123; rod_cost *res=new rod_cost[n]; res[0].result=0; int q; for(int j=0;j&lt;n;j++) &#123; q=-INFINITY; bool cut_or_not=false; for(int i=0;i&lt;j;i++) &#123; if(q&lt;=p[i]+res[j-i].result-cost) &#123; q=p[i]+res[j-i].result-cost; res[j+1].solution=i+1; cut_or_not=true; &#125; &#125; //每一次循环，j=0----j=n-1，表示问题的规模从1---n //每一个规模，cut_or_not都初始化为false，最后看是否切割？ //如果发生了切割，在i的循环中，也就是j的子问题中 //让cut_or_not=true，最后判断是否切割？ if(j==i) &#123; if(q&lt;=p[i]+res[j-i].result &amp;&amp; cut_or_not==false) &#123; res[j+1].solution=i+1; &#125; &#125; //求解完毕 res[j+1].result=q; &#125; return res+n;&#125;void PRINT_CUT_ROD_SOLUTION(int p[], int n)&#123; rod_cost *res=EXTENDED_BOTTOM_UP_CUT_ROD(p,n); while(n) &#123; cout&lt;&lt;(*res).solution&lt;&lt;\" \"； n=n-(*res).solution; res=res-(*res).solution; &#125;&#125;void main()&#123; const int n=10; int p[10]=&#123;1,5,8,9,10,17,17,20,24,30&#125;; cout&lt;&lt;(*EXTENDED_BOTTOM_UP_CUT_ROD(p,10)).result&lt;&lt;endl; PRINT_CUT_ROD_SOLUTION(p,10);&#125; 15.1-4修改memorized_cut_rod，使之返回最优收益值和切割方案 实现函数如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;using namespace std;#define INFINITY 0x7fffffffstruct rod&#123; int result; int solution;&#125;;int max(int a, int b)&#123; return a&gt;b?a:b;&#125;rod *memorized_cut_rod_aux(int p[], int n, rod res[])&#123; int q; if(res[n].result&gt;=0) return res+n; if(n==0) q=0; //规模为0的时候，自然收益为0 else &#123; q=-INFINITY; for(int i=0;i&lt;n;i++) &#123; //会犯错误的地方： //这里不能够直接写 //q=max(q,p[i]+(memorized_cut_rod(p,n-1-i,res))-&gt;solution) //因为还要进行储存切割方案，在子问题规模为i+1的时候，有可能进行切割，也有可能不切割 int tmp=p[i]+memorized_cut_rod_aux(p,n-1-i,res)-&gt;solution; //在p[i]处的最优方案是tmp，tmp和q进行比较判断后，推出在i+1处的最优方案 //这里把n分解成更小的子问题，怎么解决？通过递归解决 //memorized_cut_rod_aux(p,n-1-i,res)把n-1的子问题转化为n-1-i if(q&lt;tmp) &#123; q=tmp; res[n].solution=i+1; //我们这里返回的就是问题规模为n时候的切割方案，这里的切割方案是： //切割一次or无切割！ //i&lt;n-1时候，q=tmp表示切割 //i==n-1的时候，tmp=p[n-1]+memorized_cut_rod(p,0,res)-&gt;solution //如果此时还满足q&lt;tmp，res[n].solution=n-1+1=n，表示无切割 //这一步的目的在于保存每一个循环过程中i的最优方案 &#125; &#125; &#125; res[n].result=q; return res+n;&#125;rod *memorized_cut_rod(int p[], int n)&#123; rod *res=new rod[n]; for(int i=0;i&lt;=n;i++) &#123; res[i].result=-INFINITY; &#125; return memorized_cut_rod_aux(p,n,res);&#125;void PRINT_CUT_ROD_SOLUTION(int p[], int n)&#123; rod *res=memorized_cut_rod(p,n); cout&lt;&lt;\"max result\"&lt;&lt;res-&gt;result&lt;&lt;endl; cout&lt;&lt;\"solution: \"&lt;&lt;endl; while(n) &#123; cout&lt;&lt;(*res).solution&lt;&lt;\" \"; n=n-(*res).solution; res=res-(*res).solution; &#125;&#125;//重点：在于区分数组下标和子问题的规模，数组下标为i-1，子问题的规模为ivoid main()&#123; const int n=10; int p[10]=&#123;1,5,8,9,10,17,17,20,24,30&#125;; PRINT_CUT_ROD_SOLUTION(p,10); cout&lt;&lt;endl;&#125; 15.1-5斐波那契数列 子问题图： 实现方法： 12345678910111213141516#include &lt;iostream&gt;using namespace std;int fibonacci(int array[],int n)&#123; if(n&gt;=0) array[0]=0; if(n&gt;=1) array[1]=1; for(int i=2;i&lt;n;i++) &#123; array[i]=array[i-1]+array[i-2]; &#125; return array[n];&#125; 特别说明： 1234567891011for(int j=0;j&lt;n;j++)&#123; //code for(int i=0;i&lt;=j;i++) &#123; q=max(q,p[i]+r[j-i]); &#125; r[j]=q; //这样写也是可\\ \\;\\;以的&#125;return r[n-1]; //只是返回值会不一样 矩阵链乘法矩阵规模序列 $A1 \\qquad\\ \\;\\;|A2 \\qquad\\ \\;\\;|A3 \\qquad\\ \\;\\;|$$\\underline{10}\\times100\\;\\;|100\\times5\\;\\;\\;|\\underline{5\\times50}\\quad\\;\\;\\,|$ $A1A2 \\qquad\\times A3=10\\times5\\times50$ 由此可以推出：$A_{i \\ldots k} \\qquad \\qquad \\times \\qquad \\qquad A_{k+1 \\ldots j}$$=\\underline{p_{i-1}} \\times p_i \\times p_{i+1} \\times \\qquad\\quad \\underline{p_k} \\times p_{k+1}\\times\\underline{p_j}$$=p_{i-1} \\times p_k \\times p_j$ 由矩阵规模序列推出矩阵链乘法，如上图所示，相乘的代价是：把有下划线的项相乘的值。可以得到递推式如下： m[i,j]= \\begin{cases} 0& \\text{i=j}\\\\ min(m[i,k]+m[k+1,j]+p_{i-1}p_kp_j)& \\text{i","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://www.fogsail.net/tags/algorithm/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"http://www.fogsail.net/tags/dynamic-programming/"}]},{"title":"约瑟夫环","slug":"20170130","date":"2017-01-29T21:27:00.000Z","updated":"2018-03-02T17:06:28.000Z","comments":true,"path":"2017/01/30/20170130/","link":"","permalink":"http://www.fogsail.net/2017/01/30/20170130/","excerpt":"Josephus问题的定义如下：假设n个人排成环形，且有以正整数m&lt;=n。从某个制定的人开始，沿环报数，每遇到第m个人就让其出列，且报数进行下去。这个过程一直进行到所有人都出列为止。每个人出列的次序定义了整数1，2，…，n的(n, m)-Josephus排列。例如，(7,3)-Josephus排列为。 a)假设m为整数。请描述一个O(n)时间的算法，使之对给定的整数n，输出(n, m)-Josephus排列。b)假设m不是个常数。请描述一个O(nlgn)时间的算法，使给定的整数n和m，输出(n, m)-Josephus排列。","text":"Josephus问题的定义如下：假设n个人排成环形，且有以正整数m&lt;=n。从某个制定的人开始，沿环报数，每遇到第m个人就让其出列，且报数进行下去。这个过程一直进行到所有人都出列为止。每个人出列的次序定义了整数1，2，…，n的(n, m)-Josephus排列。例如，(7,3)-Josephus排列为。 a)假设m为整数。请描述一个O(n)时间的算法，使之对给定的整数n，输出(n, m)-Josephus排列。b)假设m不是个常数。请描述一个O(nlgn)时间的算法，使给定的整数n和m，输出(n, m)-Josephus排列。 递归求解约瑟夫环约瑟夫序列从0,1,2…..,N-1中报数为M-1的出列，从M开始又重新从1开始报数，这可以用典型的递归来求解，递归的具体过程如下图所示： 不妨用$f(i)$表示问题规模$size=i$的时候，数的下标的排列，值得注意的是，从$size=i$问题规模递减为$size=i-1$的时候，同一个数的下标发生变化，其实是对应函数的映射，不妨用$f(i)$表示这种映射。 如上图所示，在Josephus排列中，满足$f(i)=(f(i-1)+k)\\ mod\\ i$ 根据这种算法，可以使用递归求解： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; int N; int M; cin&gt;&gt;N; cin&gt;&gt;M; int result=0; for(int i=2; i&lt;=N;i++) result=(result+M)%i; //值得注意的是，这里的i表示规模，递推关系 //表示从i递推到i-1，问题规模数组大小 //最小就为1，所以i的初值为2 std::cout &lt;&lt; \"最后输出的元素是\" &lt;&lt;result+1&lt;&lt;endl; return 0;&#125; 递归算法的局限性：用这样的递归算法，无法获得一个Josephus的(n,m)排列，我们只知道最后一个出队的人，在初始时候的下标，并不知道所有的人，分别什么时候出队。 使用循环链表输出不删除结点的时候，我们需要给每一个节点加上status属性，判断这个结点是否已经处理过？或者就采用最普通的删除结点的方式来处理。每当完成报数的时候，删除节点让报数的人退出Josephus环。 这里给出两种实现函数，XXX_stus用status属性判断是否出队，但不删除节点，不带_stus的函数每隔m删除一个人。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;iostream&gt;using namespace std;#define n 30#define m 3#define LEN sizeof(struct circular_list)#define LEN_status sizeof(struct circular_list_status)struct circular_list&#123; int key; //存储数据 circular_list *next;&#125;;struct circular_list_status&#123; int key; bool status; //用来存储该节点的状态，出队没有？ circular_list_status *next; circular_list(int k,circular_list *init):key(k),status(TRUE),next(init)&#123;&#125;&#125;;struct circular_list *tail=NULL;struct circular_list_status *tail_status=NULL;circular_list *insert(circular_list *head, int k)&#123; circular_list *z=new circular_list[LEN]; z-&gt;key=k; if(head==NULL) &#123; head=tail=z; head-&gt;next=tail; //自循环 &#125; else &#123; //插入表尾 tail-&gt;next=z; z-&gt;next=head; tail=z; &#125; return head;&#125;circular_list_status *insert_stus(circular_list_status *head,int k)&#123; circular_list_status *z=new circular_list_status[LEN_status]; z-&gt;key=k; z-&gt;status=TRUE; if(head==NULL) &#123; head=tail=z; head-&gt;next=tail; //自循环 &#125; else &#123; //插入表尾 tail-&gt;next=z; z-&gt;next=head; tail=z; &#125; return head;&#125;circular_list *delete(circular_list *head, circular_list *z)&#123; circular_list *p=head; //先是要寻找到z这个结点的位置 while(p-&gt;next!=z) //要删除的是p-&gt;next这个节点 p=p-&gt;next; if(head==tail) p-&gt;next=NULL; else &#123; if(p-&gt;next==head) head=p-&gt;next-&gt;next; else if(p-&gt;next==tail) tail=p; p-&gt;next=p-&gt;next-&gt;next; &#125; return p-&gt;next;&#125;circular_list_status *delete_stus(circular_list_status *head, circular_list_status *z)&#123; circular_list_status *p=head; while(p-&gt;next!=z) //要删除的是p-&gt;next这个节点 p=p-&gt;next; if(head==tail) p-&gt;next=NULL; else &#123; if(p-&gt;next==head) head=p-&gt;next-&gt;next; else if(p-&gt;next==tail) tail=p; p-&gt;next=p-&gt;next-&gt;next; &#125; return p-&gt;next; //返回的值，是更新后的p-&gt;next&#125;void Josephus_n_m(circular_list_status *head, int n,int m)&#123; struct circular_list_status *p=head; //p作为遍历指针 int count=0; while(p &amp;&amp; count&lt;=n) &#123; int i=0; while(i!=m-1) &#123; if(p-&gt;status==TRUE) &#123; p=p-&gt;next; i++; &#125; else p=p-&gt;next; &#125; //循环到最后，i报数报M-1 p-&gt;status=false; count++; p=p-&gt;next; &#125;&#125;void Josephus_link_imple(circular_list *head,int m)&#123; circular_list *p=head; while(p) &#123; int i=0; while(i!=m-1) &#123; p=p-&gt;next; i++; &#125; circular_list *z=p; cout&lt;&lt;z-&gt;key&lt;&lt;\" \"; p=delete(head,z); &#125;&#125;int main()&#123; int a[n]=&#123;0&#125; for(int i=0;i&lt;n;i++) a[i]=i+1; int j=0; circular_list *head=NULL; while(j!=n) &#123; head=insert(head,a[j]); j++; &#125; circular_list *p=head; do &#123; cout&lt;&lt;p-&gt;key; p=p-&gt;next; /* code */ &#125; while(p!=head); cout&lt;&lt;endl; Josephus_link_imple(head,m);&#125; 算法分析：时间复杂度是$O(mn)=O(n)$ 是两个循环的嵌套，在m值不大的情况下可以使用该算法实现。 使用顺序统计树实现假设m不是一个常数，用$O(nlgn)$的算法实现 这里采用顺序统计树来存储Josephus环中的点，通过映射关系查找每次需要删除的节点的坐标并执行删除。映射关系如下图所示： 相关的递推表示为： t=1k=(t+m-1)\\ mod\\ it=k主要的实现函数12345678910111213141516171819202122232425void Josephus_imple(os_tree *T, int m, int n)&#123; os_node *x=T-&gt;root; int k=0, i=n; int t=1; while(T-&gt;root!=NULL &amp;&amp; i&gt;0) &#123; k=(t+m-1)%i; //k就是我们需要删除的点，注意到我们对一个点执行删除之后 //这个点原来的下标是k，删除了之后k+1就自动补到k的位置上 //这样新的k重新编号的话就是1，相当于原来的t=1 if(k==0) k=i; os_node *del=os_select(T,k); //这里del表示要删除的结点 cout&lt;&lt;del-&gt;key&lt;&lt;\" \"; //输出节点 RB_delete(del); t=k; i--; &#125;&#125; 这里采用的数据结构是一种顺序统计量，能够计算出rank值。但值得注意的是，在顺序统计量中，计算一个节点的rank值的函数的写法： 1234567891011121314151617int Interative_os_rank(os_tree *T,os_node *x)//确定x这个节点的顺序统计树的rank&#123; int r=x-&gt;left-&gt;size+1; os_node *y=x; //沿左脊柱上升，r=x-&gt;left-&gt;size+1 while(y!=T-&gt;root) //如果是沿着右脊柱上升？y-&gt;size=y-&gt;left-&gt;size+1+sum&#123;y-&gt;parent-&gt;size&#125; &#123; //沿左脊柱上升，r保持不变；一旦拐弯到了右脊柱，要关注y-&gt;parent-&gt;left-&gt;size+1 if(y==y-&gt;parent-&gt;right) r=r+y-&gt;parent-&gt;left-&gt;size+1; y=y-&gt;parent; //不管是左脊柱还是右脊柱，都要沿树上升 &#125; return r;&#125; 特别说明，当函数沿左脊柱上升的时候，r的值是r=x-&gt;left-&gt;size+1,但是，沿右脊柱，情形就变成了r=r+y-&gt;parent-&gt;left-&gt;size+1，具体的说明请看下图： ** $O(lgn)$算法的实现os_tree.h123456789101112131415161718192021222324252627282930#define RED 0#define BLACK 1#define NIL -1#define LEN sizeof(struct os_node)#define LENTREE sizeof(struct os_tree)struct os_node&#123; os_node *left; os_node *right; os_node *parent; int key; int color; int size; //用于顺序统计量 os_node(os_node *init,int num) :left(init),right(init),parent(init),key(num),color(RED),size(0)&#123;&#125;&#125;;struct os_tree&#123; os_node *root; os_node *nil; os_tree() &#123; nil=new os_node(NULL,NIL); root=nil; &#125;&#125;; rotate.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include \"os_tree.h\"void left_rotate(os_tree *T,os_node *x)&#123; os_node *y=x-&gt;right; //左孩子结点 x-&gt;right=y-&gt;left; //这一部处理的是加在x，y之间的“内结点”，y-&gt;left原先 //夹在x-&gt;left和y-&gt;right之间，旋转之后子树的相对顺序不变，最外边的结点是 //x-&gt;left和y-&gt;right，注意是围绕x和y进行的旋转，所以子树的相对位置保持不变 if(y!=T-&gt;nil &amp;&amp; y-&gt;left!=T-&gt;nil) y-&gt;left-&gt;parent=x; //旋转之后需要重新更新parent结点信息 y-&gt;parent=x-&gt;parent; //这个时候y作为子树的根了，y要连到祖先中！ if(x-&gt;parent==T-&gt;nil) T-&gt;root=y; else if(x-&gt;parent-&gt;left==x) x-&gt;parent-&gt;left=y; else x-&gt;parent-&gt;right=y; //保证x与祖先结点相连接 //最后处理x和y的关系 y-&gt;left=x; x-&gt;parent=y; //顺序统计树新增部分 y-&gt;size=x-&gt;size; //旋转之后，y代替原来x的位置，而x的位置在树的高处 //直接将原来x的size值赋值给y就可以了 x-&gt;size=x-&gt;left-&gt;size+x-&gt;right-&gt;size+1;&#125;//右旋，对称的代码void right_rotate(os_tree *T,os_node *x)&#123; //只需要把上述代码的相对位置，right和left互换就可以了 os_node *y=x-&gt;left; x-&gt;left=y-&gt;right; if(y!=T-&gt;nil &amp;&amp; y-&gt;right!=T-&gt;nil) y-&gt;right-&gt;parent=x; //旋转之后需要重新更新parent结点信息 y-&gt;parent=x-&gt;parent; if(x-&gt;parent==T-&gt;nil) T-&gt;root=y; else if(x-&gt;parent-&gt;left==x) x-&gt;parent-&gt;left=y; else x-&gt;parent-&gt;right=y; //保证x与祖先结点相连接 //最后处理x和y的关系 y-&gt;right=x; x-&gt;parent=y; y-&gt;size=x-&gt;size; x-&gt;size=x&gt;left-&gt;size+x-&gt;right-&gt;size;&#125; delete.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include \"os_tree.h\"#include \"rotate.h\"#include \"succ_and_other.h\"//删除调整，这个时候x有两重黑色void RB_delete_fixup(os_tree *T, os_node *x)&#123; os_node *w=T-&gt;nil; while (x!=T-&gt;root &amp;&amp; x-&gt;color==BLACK) &#123; if(x==x-&gt;parent-&gt;left) &#123; w=x-&gt;parent-&gt;right; //w为x的兄弟结点 if(w-&gt;color==RED) &#123; w-&gt;color=BLACK; //将这种情况划归为下面一种情况 w-&gt;parent-&gt;color=RED; left_rotate(T,x-&gt;parent); w=x-&gt;parent-&gt;right; &#125; if(w-&gt;left-&gt;color==BLACK &amp;&amp; w-&gt;right-&gt;color==BLACK) &#123; w-&gt;color=RED; x=x-&gt;parent; //x和w的黑色沿树上升，注意到x有双重黑色，所以x的颜色不变 &#125; //变得是w，x-&gt;parent的颜色 else &#123; if(w-&gt;right-&gt;color==BLACK) &#123; w-&gt;left-&gt;color=BLACK; w-&gt;color=RED; //同样，内节点变为外节点 right_rotate(T,w); w=x-&gt;parent-&gt;right; &#125; w-&gt;color=x-&gt;parent-&gt;color; //这里x-&gt;parent的颜色不确定，但是w的颜色是黑色 //x有双重黑色，通过改变颜色加上旋转，可以将双重黑色表现在图中，这样完成了红黑树的局部平衡 x-&gt;parent-&gt;color=BLACK; w-&gt;right-&gt;color=BLACK; left_rotate(T,x-&gt;parent); //红黑树局部平衡了 x=T-&gt;root; &#125; &#125; else &#123; w=x-&gt;parent-&gt;left; if(w-&gt;color==RED) &#123; w-&gt;color=BLACK; x-&gt;parent-&gt;color=RED; right_rotate(T,x-&gt;parent); w=x-&gt;parent-&gt;left; &#125; &#125; if(w-&gt;left-&gt;color==BLACK &amp;&amp; w-&gt;right-&gt;color==BLACK) &#123; w-&gt;color=RED; x=x-&gt;parent; &#125; else &#123; if(w-&gt;left-&gt;color==BLACK) &#123; w-&gt;right-&gt;color=BLACK; w-&gt;color=RED; left_rotate(T,w); w=x-&gt;parent-&gt;left; &#125; w-&gt;color=x-&gt;parent-&gt;color; x-&gt;parent-&gt;color=BLACK; w-&gt;left-&gt;color=BLACK; right_rotate(T,x-&gt;parent); x=T-&gt;root; &#125; &#125; x-&gt;color=BLACK;&#125;void transplant(os_tree *T, os_node *u, os_node *v)&#123; if(u-&gt;parent==T-&gt;nil) T-&gt;root=v; else if(u==u-&gt;parent-&gt;left) u-&gt;parent-&gt;left=v; else u-&gt;parent-&gt;right=v; if(v!=T-&gt;nil) v-&gt;parent=u-&gt;parent;&#125;void RB_delete(os_tree *T, os_node *z)&#123; os_node *y=z, *x; int y_original_color=y-&gt;color; os_node *par=z-&gt;parent; //par作为被删除节点的双亲 if(z-&gt;left==T-&gt;nil) &#123; //删除一个节点的时候，size会发生变化 while(par!=T-&gt;nil) &#123; //删除节点后，z的双亲的size值会减小 par-&gt;size--; par=par-&gt;parent; //自底向上遍历，所有的节点的size都减小 &#125; x=z-&gt;right; transplant(T,z,z-&gt;right); &#125; else if(z-&gt;right==T-&gt;nil) &#123; while(par!=T-&gt;nil) &#123; //删除节点后，z的双亲的size值会减小 par-&gt;size--; par=par-&gt;parent; //自底向上遍历，所有的节点的size都减小 &#125; x=z-&gt;left; transplant(T,z,z-&gt;left); &#125; else &#123; y=tree_minimum(T,z-&gt;right); //这里是查找z的后继，为y，用y来代替z的位置 y_original_color=y-&gt;color; os_node *par=y-&gt;parent; //这里用y嫁接到z处，原先y位置往上所有的节点相当于 //少了一个y结点，所以par往上遍历的过程中所有的size都为size-- //特别地，当用y来代替z的时候，并不是y-&gt;size=z-&gt;size //因为子树中少了一个y，所以size-1 //特别注意，实际上，从y结点到z节点之间的节点，少了一个y //从z节点往上，少了一个z，由于size结点是不包括当前节点的 //所以y-&gt;size=z-&gt;size-1 /*y-&gt;size=z-&gt;size-1; while(par!=T-&gt;nil) &#123; //删除节点后，z的双亲的size值会减小 par-&gt;size--; par=par-&gt;parent; //自底向上遍历，所有的节点的size都减小 &#125;*/ //还有一种方法：完成transplant之后自底向上调整！ x=y-&gt;right; if(y-&gt;parent==z) &#123; x-&gt;parent=y; &#125; else &#123; transplant(T,y,y-&gt;right); y-&gt;right=z-&gt;right; y-&gt;right-&gt;parent=y; &#125; transplant(T,z,y); y-&gt;left=z-&gt;left; y-&gt;left-&gt;parent=y; y-&gt;color=z-&gt;color; //这里进行size属性的维护 while(par!=T-&gt;nil) &#123; //删除节点后，z的双亲的size值会减小 par-&gt;size--; par=par-&gt;parent; //自底向上遍历，所有的节点的size都减小 &#125; &#125; if(y_original_color==BLACK) RB_delete_fixup(T,x); //x为y的孩子结点，y的删除会影响x的相关性质&#125; insert.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include \"os_tree.h\"#include \"rotate.h\"void RB_insert_fixup(os_tree *T, os_node *z);void RB_insert(os_tree *T, os_node *z)&#123; os_node *y=T-&gt;nil; //y作为遍历指针的双亲 RB_node *x=T-&gt;root; while(x!=T-&gt;nil) &#123; y=x; if(z-&gt;key&lt;x-&gt;key) x-&gt;x-&gt;left; else x=x-&gt;right; &#125; z-&gt;parent=y; //y作为遍历指针x的母结点，x遍历寻找合适的插入位置 if(y==T-&gt;nil) T-&gt;root=z; else if(z-&gt;key&lt;y-&gt;key) y-&gt;left=z; else y-&gt;right=z; z-&gt;left=T-&gt;nil; z-&gt;right=T-&gt;nil; z-&gt;parent=RED; //新插入节点的信息 z-&gt;size=1; z-&gt;left-&gt;size=0; z-&gt;right-&gt;size=0; RB_insert_fixup(T,z); //最后插入的结点是红色的，与此同时进行红黑树性质的调整&#125;void RB_insert_fixup(os_tree *T,os_node *z)&#123; while(z-&gt;parent-&gt;color==RED) &#123; if(z-&gt;parent==z-&gt;parent-&gt;parent-&gt;left) &#123; os_node *y=z-&gt;parent-&gt;parent-&gt;right; //设置叔结点 if(y-&gt;color==RED) &#123; z-&gt;parent-&gt;color=BLACK; //父节点的黑色可以下放给两个结点 y-&gt;color=BLACK; z-&gt;parent-&gt;parent-&gt;color=RED; z=z-&gt;parent-&gt;parent; //z沿树上升 &#125; else &#123; if(z==z-&gt;parent-&gt;right) //内结点先旋转成外节点 &#123; z=z-&gt;parent; left_rotate(T,z); &#125; z-&gt;parent-&gt;color=BLACK; //改变颜色之后，z的兄弟结点和z颜色相同 z-&gt;parent-&gt;parent-&gt;color=RED; //红黑树局部恢复平衡 right_rotate(T,z-&gt;parent-&gt;parent); //这个技巧是：改变颜色之后，然后旋转，这样不破坏红黑树性质 &#125; //与此同时，结点沿树上升 &#125; else &#123; os_node *y=z-&gt;parent-&gt;parent-&gt;left; if(y-&gt;color==RED) &#123; z-&gt;parent-&gt;color=BLACK; y-&gt;color=BLACK; z-&gt;parent-&gt;parent-&gt;color=RED; z=z-&gt;parent-&gt;parent; &#125; else &#123; if(z==z-&gt;parent-&gt;left) &#123; z=z-&gt;parent; right_rotate(T,z); &#125; z-&gt;parent-&gt;color=BLACK; z-&gt;parent-&gt;parent-&gt;color=RED; left_rotate(T,z-&gt;parent-&gt;parent); &#125; &#125; &#125; T-&gt;root-&gt;color=BLACK;&#125; succ_and_other.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include \"os_tree.h\"os_node *tree_maxinum(os_tree *T, os_node *x)&#123; while(x!=T-&gt;nil &amp;&amp; x-&gt;right!=T-&gt;nil) x=x-&gt;right; return x;&#125;os_node *tree_minimum(os_tree *T,os_node *x)&#123; while (x-&gt;left!=T-&gt;nil) &#123; x=x-&gt;left; &#125; return x;&#125;os_node *tree_successor(os_tree *T, os_node *x)&#123; if(x-&gt;right!=T-&gt;nil) &#123; return tree_minimum(x-&gt;right); &#125; os_node *y=x-&gt;parent; //后继在根节点处 while(y!=T-&gt;nil &amp;&amp; x==y-&gt;right) &#123; x=y; y=y-&gt;parent; &#125; return y;&#125;os_node *tree_predecessor(os_tree *T, os_node *x)&#123; if(x-&gt;left!=T-&gt;nil) &#123; return tree_maxinum(x-&gt;left); &#125; os_node *y=x-&gt;parent; while(y!=T-&gt;nil &amp;&amp; x==y-&gt;left) &#123; x=y; y=y-&gt;parent; &#125; return y;&#125;os_node *Iterative_tree_search(os_tree *T,os_node *x, int k)&#123; while(x!=T-&gt;nil &amp;&amp; k!=x-&gt;key) &#123; if(k&lt;x-&gt;key) x=x-&gt;left; else x=x-&gt;right; &#125; return x;&#125;void in_order_traverse(os_tree *T, os_node *p)&#123; if(p!=T-&gt;nil) &#123; in_order_traverse(p-&gt;left); cout&lt;&lt;p-&gt;key&lt;&lt;\" \"&lt;&lt;p-&gt;color&lt;&lt;\" \"&lt;&lt;p-&gt;size&lt;&lt;endl; in_order_traverse(p-&gt;right); &#125;&#125;os_node *os_select_rank(os_tree *T, os_node *x, int i)&#123; int r=x-&gt;left-&gt;size+1; if(i==r) return x; else if(i&lt;r) return os_select_rank(T,x-&gt;left,i); else return os_select_rank(T,x-&gt;right,i-r);&#125;int Interative_os_rank(os_tree *T,os_node *x)//确定x这个节点的顺序统计树的rank&#123; int r=x-&gt;left-&gt;size+1; os_node *y=x; //沿左脊柱上升，r=x-&gt;left-&gt;size+1 while(y!=T-&gt;root) //如果是沿着右脊柱上升？y-&gt;size=y-&gt;left-&gt;size+1+sum&#123;y-&gt;parent-&gt;size&#125; &#123; //沿左脊柱上升，r保持不变；一旦拐弯到了右脊柱，要关注y-&gt;parent-&gt;left-&gt;size+1 if(y==y-&gt;parent-&gt;right) r=r+y-&gt;parent-&gt;left-&gt;size+1; y=y-&gt;parent; //不管是左脊柱还是右脊柱，都要沿树上升 &#125; return r;&#125; Josephus_circle.h12345678910111213141516171819202122232425262728#include \"delete.h\"#include \"succ_and_other.h\"void Josephus_imple(os_tree *T, int m, int n)&#123; os_node *x=T-&gt;root; int k=0, i=n; int t=1; while(T-&gt;root!=NULL &amp;&amp; i&gt;0) &#123; k=(t+m-1)%i; //k就是我们需要删除的点，注意到我们对一个点执行删除之后 //这个点原来的下标是k，删除了之后k+1就自动补到k的位置上 //这样新的k重新编号的话就是1，相当于原来的t=1 if(k==0) k=i; os_node *del=os_select(T,k); //这里del表示要删除的结点 cout&lt;&lt;del-&gt;key&lt;&lt;\" \"; //输出节点 RB_delete(del); t=k; i--; &#125;&#125; 主函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include \"Josephus_circle.h\"#include &lt;iostream&gt;#include \"time.h\"#include \"os_tree.h\"#include \"delete.h\"#include \"insert.h\"using namespace std;int main()&#123; srand((unsigned)time(NULL)); int m=0,n=0; cout&lt;&lt;\"输入Josephus排列的m和n值\"&lt;&lt;endl; cout&lt;&lt;\"m=\"; cin&gt;&gt;m; cout&lt;&lt;\"n=\"; cin&gt;&gt;n; int *array_jose=new int [n]; //对数组进行赋值和初始化 for(int j=0;j&lt;n;j++) &#123; array_jose[j]=j+1; cout&lt;&lt;array_jose[j]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; os_node *nilnode=new os_node [LEN]; os_tree *T=new os_tree [LENTREE]; os_node *newroot=new os_node [LEN]; nilnode-&gt;key=-1; nilnode-&gt;color=BLACK; T-&gt;nil=nilnode; int i=0; newroot-&gt;key=array_jose[i++]; RB_insert(T,newroot); T-&gt;root=newroot; while(i!=n) &#123; os_node *z=new os_node[LEN]; z-&gt;key=array_jose[i]; RB_insert(T,z); i++; &#125; in_order_traverse(T,T-&gt;root); cout&lt;&lt;\"Josephus排列\"&lt;&lt;\" \"; Josephus_imple(T,m,n);&#125;","categories":[{"name":"data_structure","slug":"data-structure","permalink":"http://www.fogsail.net/categories/data-structure/"}],"tags":[{"name":"data_structure","slug":"data-structure","permalink":"http://www.fogsail.net/tags/data-structure/"}]},{"title":"聊聊红黑树","slug":"20170129","date":"2017-01-29T15:00:00.000Z","updated":"2018-03-02T16:55:28.000Z","comments":true,"path":"2017/01/29/20170129/","link":"","permalink":"http://www.fogsail.net/2017/01/29/20170129/","excerpt":"第一部分：红黑树表示与旋转红黑树是一种平衡二叉树，其性质不再赘述。红黑树的数据结构如下：","text":"第一部分：红黑树表示与旋转红黑树是一种平衡二叉树，其性质不再赘述。红黑树的数据结构如下： 123456789101112131415161718192021222324#define RED 0#define BLACK 1#define INFINITY 345879790struct RB_node&#123; RB_node *left; //左孩子 RB_node *right; //右孩子 RB_node *parent; //父节点 int color; //结点的颜色 int key; RB_node(RB_node* init,int c_init,int num):left(init),right(init),parent(init),color(c_init),key(num)&#123;&#125;&#125;;struct RB_tree&#123; RB_tree *root; RB_tree *nil; RB_tree() &#123; nil=new RB_node(NULL,BLACK,INFINITY); //树的哨兵必然为黑色 root=nil; &#125;&#125;; 值得特别说明的是，这里的T-&gt;nil表示的是哨兵结点，是为了方便之后的运算。 红黑树的旋转过程，如下图所示： 注意旋转的前后，从左到右，子树依次是y-&gt;left y-&gt;right x-&gt;right，但是y-&gt;right的parent变成了x了！ 红黑树旋转的过程如下给出：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include \"RB_tree.h\"void left_rotate(RB_tree *T,RB_node *x)&#123; RB_node *y=x-&gt;right; //左孩子结点 x-&gt;right=y-&gt;left; //这一部处理的是加在x，y之间的“内结点”，y-&gt;left原先 //夹在x-&gt;left和y-&gt;right之间，旋转之后子树的相对顺序不变，最外边的结点是 //x-&gt;left和y-&gt;right，注意是围绕x和y进行的旋转，所以子树的相对位置保持不变 if(y!=NULL &amp;&amp; y-&gt;left!=NULL) y-&gt;left-&gt;parent=x; //旋转之后需要重新更新parent结点信息 y-&gt;parent=x-&gt;parent; //这个时候y作为子树的根了，y要连到祖先中！ if(x-&gt;parent==NULL) T-&gt;root=y; else if(x-&gt;parent-&gt;left==x) x-&gt;parent-&gt;left=y; else x-&gt;parent-&gt;right=y; //保证x与祖先结点相连接 //最后处理x和y的关系 y-&gt;left=x; x-&gt;parent=y;&#125;//右旋，对称的代码void right_rotate(RB_tree *T,RB_node *x)&#123; //只需要把上述代码的相对位置，right和left互换就可以了 RB_node *y=x-&gt;left; x-&gt;left=y-&gt;right; if(y!=NULL &amp;&amp; y-&gt;right!=NULL) y-&gt;right-&gt;parent=x; //旋转之后需要重新更新parent结点信息 y-&gt;parent=x-&gt;parent; if(x-&gt;parent==NULL) T-&gt;root=y; else if(x-&gt;parent-&gt;left==x) x-&gt;parent-&gt;left=y; else x-&gt;parent-&gt;right=y; //保证x与祖先结点相连接 //最后处理x和y的关系 y-&gt;right=x; x-&gt;parent=y;&#125; 红黑树的旋转左旋和右旋是对称的。 第二部分：红黑树的插入和性质的维护具体程序：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include \"RB_tree.h\"void RB_insert_fixup(RB_tree *T, RB_node *z);void RB_insert(RB_tree *T, RB_node *z)&#123; RB_node *y=NULL; //y作为遍历指针的双亲 RB_node *x=T-&gt;root; while(x!=NULL) &#123; y=x; if(z-&gt;key&lt;x-&gt;key) x-&gt;x-&gt;left; else x=x-&gt;right; &#125; z-&gt;parent=y; //y作为遍历指针x的母结点，x遍历寻找合适的插入位置 if(y==NULL) T-&gt;root=z; else if(z-&gt;key&lt;y-&gt;key) y-&gt;left=z; else y-&gt;right=z; z-&gt;left=NULL; z-&gt;right=NULL; z-&gt;parent=RED; RB_insert_fixup(T,z); //最后插入的结点是红色的，与此同时进行红黑树性质的调整&#125;void RB_insert_fixup(RB_tree *T,RB_node *z)&#123; while(z-&gt;parent-&gt;color==RED) &#123; if(z-&gt;parent==z-&gt;parent-&gt;parent-&gt;left) &#123; RB_node *y=z-&gt;parent-&gt;parent-&gt;right; //设置叔结点 if(y-&gt;color==RED) &#123; z-&gt;parent-&gt;color=BLACK; //父节点的黑色可以下放给两个结点 y-&gt;color=BLACK; z-&gt;parent-&gt;parent-&gt;color=RED; z=z-&gt;parent-&gt;parent; //z沿树上升 &#125; else &#123; if(z==z-&gt;parent-&gt;right) //内结点先旋转成外节点 &#123; z=z-&gt;parent; left_rotate(T,z); &#125; z-&gt;parent-&gt;color=BLACK; //改变颜色之后，z的兄弟结点和z颜色相同 z-&gt;parent-&gt;parent-&gt;color=RED; //红黑树局部恢复平衡 right_rotate(T,z-&gt;parent-&gt;parent); //这个技巧是：改变颜色之后，然后旋转，这样不破坏红黑树性质 &#125; //与此同时，结点沿树上升 &#125; else &#123; RB_node *y=z-&gt;parent-&gt;parent-&gt;left; if(y-&gt;color==RED) &#123; z-&gt;parent-&gt;color=BLACK; y-&gt;color=BLACK; z-&gt;parent-&gt;parent-&gt;color=RED; z=z-&gt;parent-&gt;parent; &#125; else &#123; if(z==z-&gt;parent-&gt;left) &#123; z=z-&gt;parent; right_rotate(T,z); &#125; z-&gt;parent-&gt;color=BLACK; z-&gt;parent-&gt;parent-&gt;color=RED; left_rotate(T,z-&gt;parent-&gt;parent); &#125; &#125; &#125; T-&gt;root-&gt;color=BLACK;&#125; 实现过程说明：红黑树的插入是比较容易理解的，下面着重来讨论红黑树插入的调整： 情形一：这个时候只要把根部A这个点的黑色，下放给两个孩子结点，这样红黑树的性质得到保持，这个时候刚插入的节点沿树上升就可以了。 情形二：如果z是内节点，要首先旋转成外结点，因为外节点的相对位置是不变的，内节点在旋转的过程中还会更换parent！所以用外节点处理方便，值得注意的是，在旋转过程中，z的相对高度要保持不变，所以要执行z=z-&gt;parent，然后再旋转！这样沿树上升的时候，保证所有的结点都得到处理！ 最后一步改变颜色，做到了红黑树的局部平衡，这个时候改变颜色之后再执行旋转，不破坏红黑树的平衡性，与此同时，z结点沿树上升，这样局部平衡得到保持。最后只要树根置为black就可以了。 第三部分：红黑树的删除红黑树删除的代码和普通二叉树的删除没有多少区别，主要是要关注：删除一个结点之后，记得寻找这个结点的后继，后继不一定是right，而是min(x-&gt;right) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include \"RB_tree.h\"//删除调整，这个时候x有两重黑色void RB_delete_fixup(RB_tree *T, RB_node *x)&#123; RB_node *w=NULL; while (x!=T-&gt;root &amp;&amp; x-&gt;color==BLACK) &#123; if(x==x-&gt;parent-&gt;left) &#123; w=x-&gt;parent-&gt;right; //w为x的兄弟结点 if(w-&gt;color==RED) &#123; w-&gt;color=BLACK; //将这种情况划归为下面一种情况 w-&gt;parent-&gt;color=RED; left_rotate(T,x-&gt;parent); w=x-&gt;parent-&gt;right; &#125; if(w-&gt;left-&gt;color==BLACK &amp;&amp; w-&gt;right-&gt;color==BLACK) &#123; W-&gt;color=RED; x=x-&gt;parent; //x和w的黑色沿树上升，注意到x有双重黑色，所以x的颜色不变 &#125; //变得是w，x-&gt;parent的颜色 else &#123; if(w-&gt;right-&gt;color==BLACK) &#123; w-&gt;left-&gt;color=BLACK; w-&gt;color=RED; //同样，内节点变为外节点 right_rotate(T,w); w=x-&gt;parent-?right; &#125; w-&gt;color=x-&gt;parent-&gt;color; //这里x-&gt;parent的颜色不确定，但是w的颜色是黑色 //x有双重黑色，通过改变颜色加上旋转，可以将双重黑色表现在图中，这样完成了红黑树的局部平衡 x-&gt;parent-&gt;color=BLACK; w-&gt;right-&gt;color=BLACK; left_rotate(T,x-&gt;parent); //红黑树局部平衡了 x=T-&gt;root; &#125; &#125; else &#123; w=x-&gt;parent-&gt;left; if(w-&gt;color==RED) &#123; w-&gt;color=BLACK; x-&gt;parent-&gt;color=RED; right_rotate(T,x-&gt;parent); w=x-&gt;parent-&gt;left; &#125; &#125; if(w-&gt;left-&gt;color==BLACK &amp;&amp; w-&gt;right-&gt;color==BLACK) &#123; w-&gt;color=RED; x=x-&gt;parent; &#125; else &#123; if(w-&gt;left-&gt;color==BLACK) &#123; w-&gt;right-&gt;color=BLACK; W-&gt;color=RED; left_rotate(T,w); w=x-&gt;parent-&gt;left; &#125; w-&gt;color=x-&gt;parent-&gt;color; x-&gt;parent-&gt;color=BLACK; w-&gt;left-&gt;color=BLACK; right_rotate(T,x-&gt;parent); x=T-&gt;root; &#125; &#125; x-&gt;color=BLACK;&#125;void transplant(RB_tree *T, RB_node *u, RB_node *v)&#123; if(u-&gt;parent==T-&gt;nil) T-&gt;root=v; else if(u==u-&gt;parent-&gt;left) u-&gt;parent-&gt;left=v; else u-&gt;parent-&gt;right=v; if(v!=NULL) v-&gt;parent=u-&gt;parent;&#125;RB_node *tree_minimum(RB_tree *T,RB_node *x)&#123; while (x-&gt;left!=NULL) &#123; x=x-&gt;left; &#125; return x;&#125;void RB_delete(RB_tree *T, RB_node *z)&#123; RB_node *y=z, *x; int y_original_color=y-&gt;color; if(z-&gt;left==NULL) &#123; x=z-&gt;right; transplant(T,z,z-&gt;right); &#125; else if(z-&gt;right==NULL) &#123; x=z-&gt;left; transplant(T,z,z-&gt;left); &#125; else &#123; y=tree_minimum(T,z-&gt;right); //这里是查找z的后继，为y，用y来代替z的位置 y_original_color=y-&gt;color; x=y-&gt;right; if(y-&gt;parent==z) &#123; x-&gt;parent=y; &#125; else &#123; transplant(T,y,y-&gt;right); y-&gt;right=z-&gt;right; y-&gt;right-&gt;parent=y; &#125; transplant(T,z,y); y-&gt;left=z-&gt;left; y-&gt;left-&gt;parent=y; y-&gt;color=z-&gt;color; &#125; if(y_original_color==BLACK) RB_delete_fixup(T,x); //x为y的孩子结点，y的删除会影响x的相关性质&#125; 具体来看红黑树删除的调整： 情形一这个时候x的兄弟节点w是red，一个红节点必然跟着两个黑节点，这个时候改变颜色，并且执行旋转，可以将这种情况划归为第二种情况，就是x和w都是黑色。为什么要这么做？主要的原因是x有双重黑色，我们需要让x的黑色沿树上升，w的黑色也沿树上升，w为白色，要想办法让它变成黑色。改变颜色+旋转是常用的方法。 情形二 这个时候需要让x和w的黑色都沿树上升。注意到这个时候x有双重黑色，所以x的黑色不改变。 情形三 这个时候和插入调整一样，内节点要转化成外节点。值得注意的是，这个时候w-&gt;left的颜色一定是red，因为不是的话就变成了第二种情况啦！这个时候红色的结点是内结点，要将它旋转成外节点处理，理由在插入调整的过程中已经说了很清楚了。 情形四 这个时候要注意的是：x-&gt;parent的颜色没有确定下来，但是w的颜色一定是black。交换颜色的代码是：123w-&gt;color=x-&gt;parent-&gt;color;x-&gt;parent-&gt;color=BLACK;w-&gt;right-&gt;color=BLACK; 如图所示，改变颜色+完成旋转之后，x的双重黑色已经体现出来了。这个时候红黑树达到了局部平衡。所以将x置为根节点，确定颜色就可以了。 第四部分：算法导论课后习题解答13.1红黑树的性质13.1-1 13.1-21、不行，违反性质42、不行，违反性质5 13.1-3是，我们在调整过程中就是利用松弛红黑树的性质，最后将T-&gt;root-color置为black。 13.1-4红黑树的黑高为从该点开始，所含有的黑节点的个数，所以红黑树的黑高保持不变。可能的度为：2 这个时候它的两个子节点原来都是黑色3 这个时候一个子节点为红色，另一个为黑色，红色子节点又跟随两个黑色子节点，度为34 两个子节点都是红色 13.1-5 $rh(x) \\leq bh(x)$$h(x) = rh(x)+bh(x) \\leq 2bh(x)$其中，rh(x)表示红高，bh(x)表示黑高 所以最长的一条最多是最短一条的两倍 13.1-6 黑高为k，内部节点最少为：$2^k-1$最多为：由13.1-5的结论，最长路径$ \\leq 2k+1$最多节点为： $2^ {2k+1} -1$ 13.1-7 比值最小为0，结点全部为黑色。比值最大为2：1参见13.1-1图，一个black两个结点都是红的，每个红节点又有两个黑节点，红节点和黑节点的比值为：4：2=2（内部节点，不算根节点） 13.2旋转13.2-1已写出 13.2-2 n个节点有n-1条边，所以可能有n-1种旋转 13.2-3 可以发现b的深度不变，a的深度增加，c的深度减少 13.2-4 最坏的情况，仅有左子树，假设左子树有n个节点，可以看出左子树旋转成右子树需要n-1次。这样左子树变成一条右侧伸展的链。 从左侧伸展的链旋转成为右侧伸展的链，最坏需要n-1的时间，其余任何一种情况，所需时间均少于n-1 13.2-5 T1可以右转成T2，可知若有i个结点，需要旋转i-1条边 $\\sum_{i=1}^n i = O(n^2)$ 13.3插入13.3-1 如果将z染色成黑色，很显然违反红黑树性质5，违反红黑树性质5，做调整的时候是针对高度来调整。这个时候红黑树还必须满足一种高度平衡：就是任意路径，从root到nil，红黑树的黑高差恒等于0在调整的时候比较麻烦。实际上这是属于类AVL树了。 高度平衡的二叉树，是AVL树，这是另外一种平衡二叉树。 13.3-2 13.3-3 13.3-4 z为叶子节点，则z-&gt;parent为根节点。根节点的颜色肯定恒为黑色，这个时候退出循环while(z-&gt;parent-&gt;color==RED)那么也就遍历不到z-&gt;parent-&gt;parent了。 13.3-5 插入的n-1个节点都为black，当插入第n个节点的时候，新插入的节点为红色，满足红黑树性质。 13.3-6 123456789101112131415161718192021222324252627RB_node *tree_search(RB_tree *T, RB_node *x, int k, RB_node *par, RB_node *p_par)&#123; //人为定义一个tree_search函数，从根节点遍历，寻找x的parent和parent-&gt;parent while(x!=T-&gt;nil &amp;&amp; k!=x-&gt;key) &#123; par=x; if(k&lt;x-&gt;key) x=x-&gt;left; else x=x-&gt;right; if(k!=x-&gt;key) //如果没有找到待查找的值，此时x=x-&gt;child &#123; //记录下遍历前的x=p_par，遍历后的x=par，返回x，此时用par和p_par表示 p_par=par; par=x; &#125; &#125; return x；&#125;void RB_insert_fixup(RB_tree *T, RB_node *z)&#123; //相关代码 RB_node *par=T-&gt;nil, *p_par=T-&gt;nil; tree_search(T,T-&gt;root,z-&gt;key,par,p_par); //将原来的z-&gt;parent用par代替，z-&gt;parent-&gt;parent用p_par代替&#125; 13.4删除13.4-1在执行RB_delete_fixup之后，可以发现，x=root, x-&gt;color=BLACK，所以树根一定是黑色的 13.4-2 此时不进入循环，x-&gt;color=BLACK，恢复性质4 13.4-3 13.4-4 1) 1、4、5行检查哨兵，因为被删除的节点没有孩子，所以检查T-&gt;nil的情况2) 左旋，右旋的时候，w的兄弟没有孩子，此时检查哨兵 13.4-5检查在稿纸上进行 13.4-6 情况一，w的颜色为红色，所以x-&gt;parent的颜色一定是黑色 13.4-7 不一样如下图 其中，灰色的节点代表刚刚插入又删除的节点。","categories":[{"name":"data_structure","slug":"data-structure","permalink":"http://www.fogsail.net/categories/data-structure/"}],"tags":[{"name":"data_structure","slug":"data-structure","permalink":"http://www.fogsail.net/tags/data-structure/"}]}]}